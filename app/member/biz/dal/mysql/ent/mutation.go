// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"member/biz/dal/mysql/ent/member"
	"member/biz/dal/mysql/ent/memberdetails"
	"member/biz/dal/mysql/ent/membernote"
	"member/biz/dal/mysql/ent/predicate"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMember        = "Member"
	TypeMemberDetails = "MemberDetails"
	TypeMemberNote    = "MemberNote"
)

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	status                *int64
	addstatus             *int64
	password              *string
	name                  *string
	nickname              *string
	mobile                *string
	avatar                *string
	condition             *int64
	addcondition          *int64
	clearedFields         map[string]struct{}
	member_details        map[int64]struct{}
	removedmember_details map[int64]struct{}
	clearedmember_details bool
	member_notes          map[int64]struct{}
	removedmember_notes   map[int64]struct{}
	clearedmember_notes   bool
	done                  bool
	oldValue              func(context.Context) (*Member, error)
	predicates            []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int64) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[member.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[member.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, member.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *MemberMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[member.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *MemberMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[member.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, member.FieldPassword)
}

// SetName sets the "name" field.
func (m *MemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberMutation) ClearName() {
	m.name = nil
	m.clearedFields[member.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberMutation) NameCleared() bool {
	_, ok := m.clearedFields[member.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, member.FieldName)
}

// SetNickname sets the "nickname" field.
func (m *MemberMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *MemberMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *MemberMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[member.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *MemberMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[member.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *MemberMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, member.FieldNickname)
}

// SetMobile sets the "mobile" field.
func (m *MemberMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *MemberMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *MemberMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[member.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *MemberMutation) MobileCleared() bool {
	_, ok := m.clearedFields[member.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *MemberMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, member.FieldMobile)
}

// SetAvatar sets the "avatar" field.
func (m *MemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *MemberMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[member.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *MemberMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[member.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, member.FieldAvatar)
}

// SetCondition sets the "condition" field.
func (m *MemberMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *MemberMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *MemberMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *MemberMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *MemberMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[member.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *MemberMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[member.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *MemberMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, member.FieldCondition)
}

// AddMemberDetailIDs adds the "member_details" edge to the MemberDetails entity by ids.
func (m *MemberMutation) AddMemberDetailIDs(ids ...int64) {
	if m.member_details == nil {
		m.member_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_details[ids[i]] = struct{}{}
	}
}

// ClearMemberDetails clears the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) ClearMemberDetails() {
	m.clearedmember_details = true
}

// MemberDetailsCleared reports if the "member_details" edge to the MemberDetails entity was cleared.
func (m *MemberMutation) MemberDetailsCleared() bool {
	return m.clearedmember_details
}

// RemoveMemberDetailIDs removes the "member_details" edge to the MemberDetails entity by IDs.
func (m *MemberMutation) RemoveMemberDetailIDs(ids ...int64) {
	if m.removedmember_details == nil {
		m.removedmember_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_details, ids[i])
		m.removedmember_details[ids[i]] = struct{}{}
	}
}

// RemovedMemberDetails returns the removed IDs of the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) RemovedMemberDetailsIDs() (ids []int64) {
	for id := range m.removedmember_details {
		ids = append(ids, id)
	}
	return
}

// MemberDetailsIDs returns the "member_details" edge IDs in the mutation.
func (m *MemberMutation) MemberDetailsIDs() (ids []int64) {
	for id := range m.member_details {
		ids = append(ids, id)
	}
	return
}

// ResetMemberDetails resets all changes to the "member_details" edge.
func (m *MemberMutation) ResetMemberDetails() {
	m.member_details = nil
	m.clearedmember_details = false
	m.removedmember_details = nil
}

// AddMemberNoteIDs adds the "member_notes" edge to the MemberNote entity by ids.
func (m *MemberMutation) AddMemberNoteIDs(ids ...int64) {
	if m.member_notes == nil {
		m.member_notes = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_notes[ids[i]] = struct{}{}
	}
}

// ClearMemberNotes clears the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) ClearMemberNotes() {
	m.clearedmember_notes = true
}

// MemberNotesCleared reports if the "member_notes" edge to the MemberNote entity was cleared.
func (m *MemberMutation) MemberNotesCleared() bool {
	return m.clearedmember_notes
}

// RemoveMemberNoteIDs removes the "member_notes" edge to the MemberNote entity by IDs.
func (m *MemberMutation) RemoveMemberNoteIDs(ids ...int64) {
	if m.removedmember_notes == nil {
		m.removedmember_notes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_notes, ids[i])
		m.removedmember_notes[ids[i]] = struct{}{}
	}
}

// RemovedMemberNotes returns the removed IDs of the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) RemovedMemberNotesIDs() (ids []int64) {
	for id := range m.removedmember_notes {
		ids = append(ids, id)
	}
	return
}

// MemberNotesIDs returns the "member_notes" edge IDs in the mutation.
func (m *MemberMutation) MemberNotesIDs() (ids []int64) {
	for id := range m.member_notes {
		ids = append(ids, id)
	}
	return
}

// ResetMemberNotes resets all changes to the "member_notes" edge.
func (m *MemberMutation) ResetMemberNotes() {
	m.member_notes = nil
	m.clearedmember_notes = false
	m.removedmember_notes = nil
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, member.FieldName)
	}
	if m.nickname != nil {
		fields = append(fields, member.FieldNickname)
	}
	if m.mobile != nil {
		fields = append(fields, member.FieldMobile)
	}
	if m.avatar != nil {
		fields = append(fields, member.FieldAvatar)
	}
	if m.condition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldStatus:
		return m.Status()
	case member.FieldPassword:
		return m.Password()
	case member.FieldName:
		return m.Name()
	case member.FieldNickname:
		return m.Nickname()
	case member.FieldMobile:
		return m.Mobile()
	case member.FieldAvatar:
		return m.Avatar()
	case member.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldStatus:
		return m.OldStatus(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldName:
		return m.OldName(ctx)
	case member.FieldNickname:
		return m.OldNickname(ctx)
	case member.FieldMobile:
		return m.OldMobile(ctx)
	case member.FieldAvatar:
		return m.OldAvatar(ctx)
	case member.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case member.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case member.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case member.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.addcondition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldStatus:
		return m.AddedStatus()
	case member.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldStatus) {
		fields = append(fields, member.FieldStatus)
	}
	if m.FieldCleared(member.FieldPassword) {
		fields = append(fields, member.FieldPassword)
	}
	if m.FieldCleared(member.FieldName) {
		fields = append(fields, member.FieldName)
	}
	if m.FieldCleared(member.FieldNickname) {
		fields = append(fields, member.FieldNickname)
	}
	if m.FieldCleared(member.FieldMobile) {
		fields = append(fields, member.FieldMobile)
	}
	if m.FieldCleared(member.FieldAvatar) {
		fields = append(fields, member.FieldAvatar)
	}
	if m.FieldCleared(member.FieldCondition) {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldStatus:
		m.ClearStatus()
		return nil
	case member.FieldPassword:
		m.ClearPassword()
		return nil
	case member.FieldName:
		m.ClearName()
		return nil
	case member.FieldNickname:
		m.ClearNickname()
		return nil
	case member.FieldMobile:
		m.ClearMobile()
		return nil
	case member.FieldAvatar:
		m.ClearAvatar()
		return nil
	case member.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldStatus:
		m.ResetStatus()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldName:
		m.ResetName()
		return nil
	case member.FieldNickname:
		m.ResetNickname()
		return nil
	case member.FieldMobile:
		m.ResetMobile()
		return nil
	case member.FieldAvatar:
		m.ResetAvatar()
		return nil
	case member.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.member_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.member_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.member_details))
		for id := range m.member_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.member_notes))
		for id := range m.member_notes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmember_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.removedmember_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.removedmember_details))
		for id := range m.removedmember_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.removedmember_notes))
		for id := range m.removedmember_notes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmember_details {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.clearedmember_notes {
		edges = append(edges, member.EdgeMemberNotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeMemberDetails:
		return m.clearedmember_details
	case member.EdgeMemberNotes:
		return m.clearedmember_notes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberDetails:
		m.ResetMemberDetails()
		return nil
	case member.EdgeMemberNotes:
		m.ResetMemberNotes()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// MemberDetailsMutation represents an operation that mutates the MemberDetails nodes in the graph.
type MemberDetailsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	email               *string
	wecom               *string
	gender              *int64
	addgender           *int64
	birthday            *time.Time
	money_sum           *float64
	addmoney_sum        *float64
	product_id          *int64
	addproduct_id       *int64
	product_name        *string
	product_venue       *int64
	addproduct_venue    *int64
	product_venue_name  *string
	entry_sum           *int64
	addentry_sum        *int64
	entry_last_time     *time.Time
	entry_deadline_time *time.Time
	class_last_time     *time.Time
	relation_uid        *int64
	addrelation_uid     *int64
	relation_uname      *string
	relation_mid        *int64
	addrelation_mid     *int64
	relation_mame       *string
	create_id           *int64
	addcreate_id        *int64
	create_name         *string
	clearedFields       map[string]struct{}
	info                *int64
	clearedinfo         bool
	done                bool
	oldValue            func(context.Context) (*MemberDetails, error)
	predicates          []predicate.MemberDetails
}

var _ ent.Mutation = (*MemberDetailsMutation)(nil)

// memberdetailsOption allows management of the mutation configuration using functional options.
type memberdetailsOption func(*MemberDetailsMutation)

// newMemberDetailsMutation creates new mutation for the MemberDetails entity.
func newMemberDetailsMutation(c config, op Op, opts ...memberdetailsOption) *MemberDetailsMutation {
	m := &MemberDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberDetailsID sets the ID field of the mutation.
func withMemberDetailsID(id int64) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberDetails
		)
		m.oldValue = func(ctx context.Context) (*MemberDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberDetails sets the old MemberDetails of the mutation.
func withMemberDetails(node *MemberDetails) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		m.oldValue = func(context.Context) (*MemberDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberDetails entities.
func (m *MemberDetailsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberDetailsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberDetailsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberDetailsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberDetailsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberDetailsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberDetailsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberDetailsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberDetailsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMemberID sets the "member_id" field.
func (m *MemberDetailsMutation) SetMemberID(i int64) {
	m.info = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberDetailsMutation) MemberID() (r int64, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberDetailsMutation) ClearMemberID() {
	m.info = nil
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberDetailsMutation) ResetMemberID() {
	m.info = nil
	delete(m.clearedFields, memberdetails.FieldMemberID)
}

// SetEmail sets the "email" field.
func (m *MemberDetailsMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberDetailsMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MemberDetailsMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[memberdetails.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MemberDetailsMutation) EmailCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberDetailsMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, memberdetails.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *MemberDetailsMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *MemberDetailsMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *MemberDetailsMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[memberdetails.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *MemberDetailsMutation) WecomCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *MemberDetailsMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, memberdetails.FieldWecom)
}

// SetGender sets the "gender" field.
func (m *MemberDetailsMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *MemberDetailsMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *MemberDetailsMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *MemberDetailsMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *MemberDetailsMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[memberdetails.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *MemberDetailsMutation) GenderCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *MemberDetailsMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, memberdetails.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *MemberDetailsMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *MemberDetailsMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *MemberDetailsMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[memberdetails.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *MemberDetailsMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *MemberDetailsMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, memberdetails.FieldBirthday)
}

// SetMoneySum sets the "money_sum" field.
func (m *MemberDetailsMutation) SetMoneySum(f float64) {
	m.money_sum = &f
	m.addmoney_sum = nil
}

// MoneySum returns the value of the "money_sum" field in the mutation.
func (m *MemberDetailsMutation) MoneySum() (r float64, exists bool) {
	v := m.money_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldMoneySum returns the old "money_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMoneySum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoneySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoneySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoneySum: %w", err)
	}
	return oldValue.MoneySum, nil
}

// AddMoneySum adds f to the "money_sum" field.
func (m *MemberDetailsMutation) AddMoneySum(f float64) {
	if m.addmoney_sum != nil {
		*m.addmoney_sum += f
	} else {
		m.addmoney_sum = &f
	}
}

// AddedMoneySum returns the value that was added to the "money_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedMoneySum() (r float64, exists bool) {
	v := m.addmoney_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearMoneySum clears the value of the "money_sum" field.
func (m *MemberDetailsMutation) ClearMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	m.clearedFields[memberdetails.FieldMoneySum] = struct{}{}
}

// MoneySumCleared returns if the "money_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) MoneySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMoneySum]
	return ok
}

// ResetMoneySum resets all changes to the "money_sum" field.
func (m *MemberDetailsMutation) ResetMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	delete(m.clearedFields, memberdetails.FieldMoneySum)
}

// SetProductID sets the "product_id" field.
func (m *MemberDetailsMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MemberDetailsMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *MemberDetailsMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *MemberDetailsMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *MemberDetailsMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[memberdetails.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MemberDetailsMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, memberdetails.FieldProductID)
}

// SetProductName sets the "product_name" field.
func (m *MemberDetailsMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *MemberDetailsMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *MemberDetailsMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[memberdetails.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *MemberDetailsMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, memberdetails.FieldProductName)
}

// SetProductVenue sets the "product_venue" field.
func (m *MemberDetailsMutation) SetProductVenue(i int64) {
	m.product_venue = &i
	m.addproduct_venue = nil
}

// ProductVenue returns the value of the "product_venue" field in the mutation.
func (m *MemberDetailsMutation) ProductVenue() (r int64, exists bool) {
	v := m.product_venue
	if v == nil {
		return
	}
	return *v, true
}

// OldProductVenue returns the old "product_venue" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductVenue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductVenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductVenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductVenue: %w", err)
	}
	return oldValue.ProductVenue, nil
}

// AddProductVenue adds i to the "product_venue" field.
func (m *MemberDetailsMutation) AddProductVenue(i int64) {
	if m.addproduct_venue != nil {
		*m.addproduct_venue += i
	} else {
		m.addproduct_venue = &i
	}
}

// AddedProductVenue returns the value that was added to the "product_venue" field in this mutation.
func (m *MemberDetailsMutation) AddedProductVenue() (r int64, exists bool) {
	v := m.addproduct_venue
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductVenue clears the value of the "product_venue" field.
func (m *MemberDetailsMutation) ClearProductVenue() {
	m.product_venue = nil
	m.addproduct_venue = nil
	m.clearedFields[memberdetails.FieldProductVenue] = struct{}{}
}

// ProductVenueCleared returns if the "product_venue" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductVenueCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductVenue]
	return ok
}

// ResetProductVenue resets all changes to the "product_venue" field.
func (m *MemberDetailsMutation) ResetProductVenue() {
	m.product_venue = nil
	m.addproduct_venue = nil
	delete(m.clearedFields, memberdetails.FieldProductVenue)
}

// SetProductVenueName sets the "product_venue_name" field.
func (m *MemberDetailsMutation) SetProductVenueName(s string) {
	m.product_venue_name = &s
}

// ProductVenueName returns the value of the "product_venue_name" field in the mutation.
func (m *MemberDetailsMutation) ProductVenueName() (r string, exists bool) {
	v := m.product_venue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductVenueName returns the old "product_venue_name" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductVenueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductVenueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductVenueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductVenueName: %w", err)
	}
	return oldValue.ProductVenueName, nil
}

// ClearProductVenueName clears the value of the "product_venue_name" field.
func (m *MemberDetailsMutation) ClearProductVenueName() {
	m.product_venue_name = nil
	m.clearedFields[memberdetails.FieldProductVenueName] = struct{}{}
}

// ProductVenueNameCleared returns if the "product_venue_name" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductVenueNameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductVenueName]
	return ok
}

// ResetProductVenueName resets all changes to the "product_venue_name" field.
func (m *MemberDetailsMutation) ResetProductVenueName() {
	m.product_venue_name = nil
	delete(m.clearedFields, memberdetails.FieldProductVenueName)
}

// SetEntrySum sets the "entry_sum" field.
func (m *MemberDetailsMutation) SetEntrySum(i int64) {
	m.entry_sum = &i
	m.addentry_sum = nil
}

// EntrySum returns the value of the "entry_sum" field in the mutation.
func (m *MemberDetailsMutation) EntrySum() (r int64, exists bool) {
	v := m.entry_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldEntrySum returns the old "entry_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntrySum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntrySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntrySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntrySum: %w", err)
	}
	return oldValue.EntrySum, nil
}

// AddEntrySum adds i to the "entry_sum" field.
func (m *MemberDetailsMutation) AddEntrySum(i int64) {
	if m.addentry_sum != nil {
		*m.addentry_sum += i
	} else {
		m.addentry_sum = &i
	}
}

// AddedEntrySum returns the value that was added to the "entry_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedEntrySum() (r int64, exists bool) {
	v := m.addentry_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearEntrySum clears the value of the "entry_sum" field.
func (m *MemberDetailsMutation) ClearEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	m.clearedFields[memberdetails.FieldEntrySum] = struct{}{}
}

// EntrySumCleared returns if the "entry_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntrySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntrySum]
	return ok
}

// ResetEntrySum resets all changes to the "entry_sum" field.
func (m *MemberDetailsMutation) ResetEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	delete(m.clearedFields, memberdetails.FieldEntrySum)
}

// SetEntryLastTime sets the "entry_last_time" field.
func (m *MemberDetailsMutation) SetEntryLastTime(t time.Time) {
	m.entry_last_time = &t
}

// EntryLastTime returns the value of the "entry_last_time" field in the mutation.
func (m *MemberDetailsMutation) EntryLastTime() (r time.Time, exists bool) {
	v := m.entry_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryLastTime returns the old "entry_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryLastTime: %w", err)
	}
	return oldValue.EntryLastTime, nil
}

// ClearEntryLastTime clears the value of the "entry_last_time" field.
func (m *MemberDetailsMutation) ClearEntryLastTime() {
	m.entry_last_time = nil
	m.clearedFields[memberdetails.FieldEntryLastTime] = struct{}{}
}

// EntryLastTimeCleared returns if the "entry_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryLastTime]
	return ok
}

// ResetEntryLastTime resets all changes to the "entry_last_time" field.
func (m *MemberDetailsMutation) ResetEntryLastTime() {
	m.entry_last_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryLastTime)
}

// SetEntryDeadlineTime sets the "entry_deadline_time" field.
func (m *MemberDetailsMutation) SetEntryDeadlineTime(t time.Time) {
	m.entry_deadline_time = &t
}

// EntryDeadlineTime returns the value of the "entry_deadline_time" field in the mutation.
func (m *MemberDetailsMutation) EntryDeadlineTime() (r time.Time, exists bool) {
	v := m.entry_deadline_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryDeadlineTime returns the old "entry_deadline_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryDeadlineTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryDeadlineTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryDeadlineTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryDeadlineTime: %w", err)
	}
	return oldValue.EntryDeadlineTime, nil
}

// ClearEntryDeadlineTime clears the value of the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ClearEntryDeadlineTime() {
	m.entry_deadline_time = nil
	m.clearedFields[memberdetails.FieldEntryDeadlineTime] = struct{}{}
}

// EntryDeadlineTimeCleared returns if the "entry_deadline_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryDeadlineTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryDeadlineTime]
	return ok
}

// ResetEntryDeadlineTime resets all changes to the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ResetEntryDeadlineTime() {
	m.entry_deadline_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryDeadlineTime)
}

// SetClassLastTime sets the "class_last_time" field.
func (m *MemberDetailsMutation) SetClassLastTime(t time.Time) {
	m.class_last_time = &t
}

// ClassLastTime returns the value of the "class_last_time" field in the mutation.
func (m *MemberDetailsMutation) ClassLastTime() (r time.Time, exists bool) {
	v := m.class_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClassLastTime returns the old "class_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldClassLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassLastTime: %w", err)
	}
	return oldValue.ClassLastTime, nil
}

// ClearClassLastTime clears the value of the "class_last_time" field.
func (m *MemberDetailsMutation) ClearClassLastTime() {
	m.class_last_time = nil
	m.clearedFields[memberdetails.FieldClassLastTime] = struct{}{}
}

// ClassLastTimeCleared returns if the "class_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) ClassLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldClassLastTime]
	return ok
}

// ResetClassLastTime resets all changes to the "class_last_time" field.
func (m *MemberDetailsMutation) ResetClassLastTime() {
	m.class_last_time = nil
	delete(m.clearedFields, memberdetails.FieldClassLastTime)
}

// SetRelationUID sets the "relation_uid" field.
func (m *MemberDetailsMutation) SetRelationUID(i int64) {
	m.relation_uid = &i
	m.addrelation_uid = nil
}

// RelationUID returns the value of the "relation_uid" field in the mutation.
func (m *MemberDetailsMutation) RelationUID() (r int64, exists bool) {
	v := m.relation_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationUID returns the old "relation_uid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationUID: %w", err)
	}
	return oldValue.RelationUID, nil
}

// AddRelationUID adds i to the "relation_uid" field.
func (m *MemberDetailsMutation) AddRelationUID(i int64) {
	if m.addrelation_uid != nil {
		*m.addrelation_uid += i
	} else {
		m.addrelation_uid = &i
	}
}

// AddedRelationUID returns the value that was added to the "relation_uid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationUID() (r int64, exists bool) {
	v := m.addrelation_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationUID clears the value of the "relation_uid" field.
func (m *MemberDetailsMutation) ClearRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	m.clearedFields[memberdetails.FieldRelationUID] = struct{}{}
}

// RelationUIDCleared returns if the "relation_uid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationUIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationUID]
	return ok
}

// ResetRelationUID resets all changes to the "relation_uid" field.
func (m *MemberDetailsMutation) ResetRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	delete(m.clearedFields, memberdetails.FieldRelationUID)
}

// SetRelationUname sets the "relation_uname" field.
func (m *MemberDetailsMutation) SetRelationUname(s string) {
	m.relation_uname = &s
}

// RelationUname returns the value of the "relation_uname" field in the mutation.
func (m *MemberDetailsMutation) RelationUname() (r string, exists bool) {
	v := m.relation_uname
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationUname returns the old "relation_uname" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationUname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationUname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationUname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationUname: %w", err)
	}
	return oldValue.RelationUname, nil
}

// ClearRelationUname clears the value of the "relation_uname" field.
func (m *MemberDetailsMutation) ClearRelationUname() {
	m.relation_uname = nil
	m.clearedFields[memberdetails.FieldRelationUname] = struct{}{}
}

// RelationUnameCleared returns if the "relation_uname" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationUnameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationUname]
	return ok
}

// ResetRelationUname resets all changes to the "relation_uname" field.
func (m *MemberDetailsMutation) ResetRelationUname() {
	m.relation_uname = nil
	delete(m.clearedFields, memberdetails.FieldRelationUname)
}

// SetRelationMid sets the "relation_mid" field.
func (m *MemberDetailsMutation) SetRelationMid(i int64) {
	m.relation_mid = &i
	m.addrelation_mid = nil
}

// RelationMid returns the value of the "relation_mid" field in the mutation.
func (m *MemberDetailsMutation) RelationMid() (r int64, exists bool) {
	v := m.relation_mid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMid returns the old "relation_mid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationMid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMid: %w", err)
	}
	return oldValue.RelationMid, nil
}

// AddRelationMid adds i to the "relation_mid" field.
func (m *MemberDetailsMutation) AddRelationMid(i int64) {
	if m.addrelation_mid != nil {
		*m.addrelation_mid += i
	} else {
		m.addrelation_mid = &i
	}
}

// AddedRelationMid returns the value that was added to the "relation_mid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationMid() (r int64, exists bool) {
	v := m.addrelation_mid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationMid clears the value of the "relation_mid" field.
func (m *MemberDetailsMutation) ClearRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	m.clearedFields[memberdetails.FieldRelationMid] = struct{}{}
}

// RelationMidCleared returns if the "relation_mid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationMidCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationMid]
	return ok
}

// ResetRelationMid resets all changes to the "relation_mid" field.
func (m *MemberDetailsMutation) ResetRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	delete(m.clearedFields, memberdetails.FieldRelationMid)
}

// SetRelationMame sets the "relation_mame" field.
func (m *MemberDetailsMutation) SetRelationMame(s string) {
	m.relation_mame = &s
}

// RelationMame returns the value of the "relation_mame" field in the mutation.
func (m *MemberDetailsMutation) RelationMame() (r string, exists bool) {
	v := m.relation_mame
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMame returns the old "relation_mame" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationMame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMame: %w", err)
	}
	return oldValue.RelationMame, nil
}

// ClearRelationMame clears the value of the "relation_mame" field.
func (m *MemberDetailsMutation) ClearRelationMame() {
	m.relation_mame = nil
	m.clearedFields[memberdetails.FieldRelationMame] = struct{}{}
}

// RelationMameCleared returns if the "relation_mame" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationMameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationMame]
	return ok
}

// ResetRelationMame resets all changes to the "relation_mame" field.
func (m *MemberDetailsMutation) ResetRelationMame() {
	m.relation_mame = nil
	delete(m.clearedFields, memberdetails.FieldRelationMame)
}

// SetCreateID sets the "create_id" field.
func (m *MemberDetailsMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *MemberDetailsMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *MemberDetailsMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *MemberDetailsMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *MemberDetailsMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[memberdetails.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *MemberDetailsMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, memberdetails.FieldCreateID)
}

// SetCreateName sets the "create_name" field.
func (m *MemberDetailsMutation) SetCreateName(s string) {
	m.create_name = &s
}

// CreateName returns the value of the "create_name" field in the mutation.
func (m *MemberDetailsMutation) CreateName() (r string, exists bool) {
	v := m.create_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateName returns the old "create_name" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateName: %w", err)
	}
	return oldValue.CreateName, nil
}

// ClearCreateName clears the value of the "create_name" field.
func (m *MemberDetailsMutation) ClearCreateName() {
	m.create_name = nil
	m.clearedFields[memberdetails.FieldCreateName] = struct{}{}
}

// CreateNameCleared returns if the "create_name" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreateNameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreateName]
	return ok
}

// ResetCreateName resets all changes to the "create_name" field.
func (m *MemberDetailsMutation) ResetCreateName() {
	m.create_name = nil
	delete(m.clearedFields, memberdetails.FieldCreateName)
}

// SetInfoID sets the "info" edge to the Member entity by id.
func (m *MemberDetailsMutation) SetInfoID(id int64) {
	m.info = &id
}

// ClearInfo clears the "info" edge to the Member entity.
func (m *MemberDetailsMutation) ClearInfo() {
	m.clearedinfo = true
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// InfoCleared reports if the "info" edge to the Member entity was cleared.
func (m *MemberDetailsMutation) InfoCleared() bool {
	return m.MemberIDCleared() || m.clearedinfo
}

// InfoID returns the "info" edge ID in the mutation.
func (m *MemberDetailsMutation) InfoID() (id int64, exists bool) {
	if m.info != nil {
		return *m.info, true
	}
	return
}

// InfoIDs returns the "info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InfoID instead. It exists only for internal usage by the builders.
func (m *MemberDetailsMutation) InfoIDs() (ids []int64) {
	if id := m.info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInfo resets all changes to the "info" edge.
func (m *MemberDetailsMutation) ResetInfo() {
	m.info = nil
	m.clearedinfo = false
}

// Where appends a list predicates to the MemberDetailsMutation builder.
func (m *MemberDetailsMutation) Where(ps ...predicate.MemberDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberDetails).
func (m *MemberDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberDetailsMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, memberdetails.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberdetails.FieldUpdatedAt)
	}
	if m.info != nil {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.email != nil {
		fields = append(fields, memberdetails.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, memberdetails.FieldWecom)
	}
	if m.gender != nil {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, memberdetails.FieldBirthday)
	}
	if m.money_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.product_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, memberdetails.FieldProductName)
	}
	if m.product_venue != nil {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.product_venue_name != nil {
		fields = append(fields, memberdetails.FieldProductVenueName)
	}
	if m.entry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.entry_last_time != nil {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.entry_deadline_time != nil {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.class_last_time != nil {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.relation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.relation_uname != nil {
		fields = append(fields, memberdetails.FieldRelationUname)
	}
	if m.relation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.relation_mame != nil {
		fields = append(fields, memberdetails.FieldRelationMame)
	}
	if m.create_id != nil {
		fields = append(fields, memberdetails.FieldCreateID)
	}
	if m.create_name != nil {
		fields = append(fields, memberdetails.FieldCreateName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.CreatedAt()
	case memberdetails.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberdetails.FieldMemberID:
		return m.MemberID()
	case memberdetails.FieldEmail:
		return m.Email()
	case memberdetails.FieldWecom:
		return m.Wecom()
	case memberdetails.FieldGender:
		return m.Gender()
	case memberdetails.FieldBirthday:
		return m.Birthday()
	case memberdetails.FieldMoneySum:
		return m.MoneySum()
	case memberdetails.FieldProductID:
		return m.ProductID()
	case memberdetails.FieldProductName:
		return m.ProductName()
	case memberdetails.FieldProductVenue:
		return m.ProductVenue()
	case memberdetails.FieldProductVenueName:
		return m.ProductVenueName()
	case memberdetails.FieldEntrySum:
		return m.EntrySum()
	case memberdetails.FieldEntryLastTime:
		return m.EntryLastTime()
	case memberdetails.FieldEntryDeadlineTime:
		return m.EntryDeadlineTime()
	case memberdetails.FieldClassLastTime:
		return m.ClassLastTime()
	case memberdetails.FieldRelationUID:
		return m.RelationUID()
	case memberdetails.FieldRelationUname:
		return m.RelationUname()
	case memberdetails.FieldRelationMid:
		return m.RelationMid()
	case memberdetails.FieldRelationMame:
		return m.RelationMame()
	case memberdetails.FieldCreateID:
		return m.CreateID()
	case memberdetails.FieldCreateName:
		return m.CreateName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberdetails.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberdetails.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberdetails.FieldEmail:
		return m.OldEmail(ctx)
	case memberdetails.FieldWecom:
		return m.OldWecom(ctx)
	case memberdetails.FieldGender:
		return m.OldGender(ctx)
	case memberdetails.FieldBirthday:
		return m.OldBirthday(ctx)
	case memberdetails.FieldMoneySum:
		return m.OldMoneySum(ctx)
	case memberdetails.FieldProductID:
		return m.OldProductID(ctx)
	case memberdetails.FieldProductName:
		return m.OldProductName(ctx)
	case memberdetails.FieldProductVenue:
		return m.OldProductVenue(ctx)
	case memberdetails.FieldProductVenueName:
		return m.OldProductVenueName(ctx)
	case memberdetails.FieldEntrySum:
		return m.OldEntrySum(ctx)
	case memberdetails.FieldEntryLastTime:
		return m.OldEntryLastTime(ctx)
	case memberdetails.FieldEntryDeadlineTime:
		return m.OldEntryDeadlineTime(ctx)
	case memberdetails.FieldClassLastTime:
		return m.OldClassLastTime(ctx)
	case memberdetails.FieldRelationUID:
		return m.OldRelationUID(ctx)
	case memberdetails.FieldRelationUname:
		return m.OldRelationUname(ctx)
	case memberdetails.FieldRelationMid:
		return m.OldRelationMid(ctx)
	case memberdetails.FieldRelationMame:
		return m.OldRelationMame(ctx)
	case memberdetails.FieldCreateID:
		return m.OldCreateID(ctx)
	case memberdetails.FieldCreateName:
		return m.OldCreateName(ctx)
	}
	return nil, fmt.Errorf("unknown MemberDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberdetails.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberdetails.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberdetails.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case memberdetails.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case memberdetails.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case memberdetails.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case memberdetails.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case memberdetails.FieldProductVenue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductVenue(v)
		return nil
	case memberdetails.FieldProductVenueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductVenueName(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntrySum(v)
		return nil
	case memberdetails.FieldEntryLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryLastTime(v)
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryDeadlineTime(v)
		return nil
	case memberdetails.FieldClassLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassLastTime(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationUID(v)
		return nil
	case memberdetails.FieldRelationUname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationUname(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMid(v)
		return nil
	case memberdetails.FieldRelationMame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMame(v)
		return nil
	case memberdetails.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	case memberdetails.FieldCreateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateName(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberDetailsMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.addmoney_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.addproduct_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.addproduct_venue != nil {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.addentry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.addrelation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.addrelation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.addcreate_id != nil {
		fields = append(fields, memberdetails.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldGender:
		return m.AddedGender()
	case memberdetails.FieldMoneySum:
		return m.AddedMoneySum()
	case memberdetails.FieldProductID:
		return m.AddedProductID()
	case memberdetails.FieldProductVenue:
		return m.AddedProductVenue()
	case memberdetails.FieldEntrySum:
		return m.AddedEntrySum()
	case memberdetails.FieldRelationUID:
		return m.AddedRelationUID()
	case memberdetails.FieldRelationMid:
		return m.AddedRelationMid()
	case memberdetails.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case memberdetails.FieldProductVenue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductVenue(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntrySum(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationUID(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationMid(v)
		return nil
	case memberdetails.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberdetails.FieldMemberID) {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.FieldCleared(memberdetails.FieldEmail) {
		fields = append(fields, memberdetails.FieldEmail)
	}
	if m.FieldCleared(memberdetails.FieldWecom) {
		fields = append(fields, memberdetails.FieldWecom)
	}
	if m.FieldCleared(memberdetails.FieldGender) {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.FieldCleared(memberdetails.FieldBirthday) {
		fields = append(fields, memberdetails.FieldBirthday)
	}
	if m.FieldCleared(memberdetails.FieldMoneySum) {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.FieldCleared(memberdetails.FieldProductID) {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.FieldCleared(memberdetails.FieldProductName) {
		fields = append(fields, memberdetails.FieldProductName)
	}
	if m.FieldCleared(memberdetails.FieldProductVenue) {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.FieldCleared(memberdetails.FieldProductVenueName) {
		fields = append(fields, memberdetails.FieldProductVenueName)
	}
	if m.FieldCleared(memberdetails.FieldEntrySum) {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.FieldCleared(memberdetails.FieldEntryLastTime) {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.FieldCleared(memberdetails.FieldEntryDeadlineTime) {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.FieldCleared(memberdetails.FieldClassLastTime) {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.FieldCleared(memberdetails.FieldRelationUID) {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.FieldCleared(memberdetails.FieldRelationUname) {
		fields = append(fields, memberdetails.FieldRelationUname)
	}
	if m.FieldCleared(memberdetails.FieldRelationMid) {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.FieldCleared(memberdetails.FieldRelationMame) {
		fields = append(fields, memberdetails.FieldRelationMame)
	}
	if m.FieldCleared(memberdetails.FieldCreateID) {
		fields = append(fields, memberdetails.FieldCreateID)
	}
	if m.FieldCleared(memberdetails.FieldCreateName) {
		fields = append(fields, memberdetails.FieldCreateName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ClearField(name string) error {
	switch name {
	case memberdetails.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberdetails.FieldEmail:
		m.ClearEmail()
		return nil
	case memberdetails.FieldWecom:
		m.ClearWecom()
		return nil
	case memberdetails.FieldGender:
		m.ClearGender()
		return nil
	case memberdetails.FieldBirthday:
		m.ClearBirthday()
		return nil
	case memberdetails.FieldMoneySum:
		m.ClearMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ClearProductID()
		return nil
	case memberdetails.FieldProductName:
		m.ClearProductName()
		return nil
	case memberdetails.FieldProductVenue:
		m.ClearProductVenue()
		return nil
	case memberdetails.FieldProductVenueName:
		m.ClearProductVenueName()
		return nil
	case memberdetails.FieldEntrySum:
		m.ClearEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ClearEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ClearEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ClearClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ClearRelationUID()
		return nil
	case memberdetails.FieldRelationUname:
		m.ClearRelationUname()
		return nil
	case memberdetails.FieldRelationMid:
		m.ClearRelationMid()
		return nil
	case memberdetails.FieldRelationMame:
		m.ClearRelationMame()
		return nil
	case memberdetails.FieldCreateID:
		m.ClearCreateID()
		return nil
	case memberdetails.FieldCreateName:
		m.ClearCreateName()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ResetField(name string) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberdetails.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberdetails.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberdetails.FieldEmail:
		m.ResetEmail()
		return nil
	case memberdetails.FieldWecom:
		m.ResetWecom()
		return nil
	case memberdetails.FieldGender:
		m.ResetGender()
		return nil
	case memberdetails.FieldBirthday:
		m.ResetBirthday()
		return nil
	case memberdetails.FieldMoneySum:
		m.ResetMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ResetProductID()
		return nil
	case memberdetails.FieldProductName:
		m.ResetProductName()
		return nil
	case memberdetails.FieldProductVenue:
		m.ResetProductVenue()
		return nil
	case memberdetails.FieldProductVenueName:
		m.ResetProductVenueName()
		return nil
	case memberdetails.FieldEntrySum:
		m.ResetEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ResetEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ResetEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ResetClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ResetRelationUID()
		return nil
	case memberdetails.FieldRelationUname:
		m.ResetRelationUname()
		return nil
	case memberdetails.FieldRelationMid:
		m.ResetRelationMid()
		return nil
	case memberdetails.FieldRelationMame:
		m.ResetRelationMame()
		return nil
	case memberdetails.FieldCreateID:
		m.ResetCreateID()
		return nil
	case memberdetails.FieldCreateName:
		m.ResetCreateName()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.info != nil {
		edges = append(edges, memberdetails.EdgeInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberdetails.EdgeInfo:
		if id := m.info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinfo {
		edges = append(edges, memberdetails.EdgeInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case memberdetails.EdgeInfo:
		return m.clearedinfo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberDetailsMutation) ClearEdge(name string) error {
	switch name {
	case memberdetails.EdgeInfo:
		m.ClearInfo()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberDetailsMutation) ResetEdge(name string) error {
	switch name {
	case memberdetails.EdgeInfo:
		m.ResetInfo()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails edge %s", name)
}

// MemberNoteMutation represents an operation that mutates the MemberNote nodes in the graph.
type MemberNoteMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int64
	addstatus     *int64
	note          *string
	clearedFields map[string]struct{}
	notes         *int64
	clearednotes  bool
	done          bool
	oldValue      func(context.Context) (*MemberNote, error)
	predicates    []predicate.MemberNote
}

var _ ent.Mutation = (*MemberNoteMutation)(nil)

// membernoteOption allows management of the mutation configuration using functional options.
type membernoteOption func(*MemberNoteMutation)

// newMemberNoteMutation creates new mutation for the MemberNote entity.
func newMemberNoteMutation(c config, op Op, opts ...membernoteOption) *MemberNoteMutation {
	m := &MemberNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberNoteID sets the ID field of the mutation.
func withMemberNoteID(id int64) membernoteOption {
	return func(m *MemberNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberNote
		)
		m.oldValue = func(ctx context.Context) (*MemberNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberNote sets the old MemberNote of the mutation.
func withMemberNote(node *MemberNote) membernoteOption {
	return func(m *MemberNoteMutation) {
		m.oldValue = func(context.Context) (*MemberNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberNote entities.
func (m *MemberNoteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberNoteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberNoteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberNoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberNoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberNoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberNoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberNoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberNoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberNoteMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberNoteMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberNoteMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberNoteMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberNoteMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membernote.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberNoteMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membernote.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberNoteMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membernote.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberNoteMutation) SetMemberID(i int64) {
	m.notes = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberNoteMutation) MemberID() (r int64, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberNoteMutation) ClearMemberID() {
	m.notes = nil
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberNoteMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberNoteMutation) ResetMemberID() {
	m.notes = nil
	delete(m.clearedFields, membernote.FieldMemberID)
}

// SetNote sets the "note" field.
func (m *MemberNoteMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MemberNoteMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *MemberNoteMutation) ClearNote() {
	m.note = nil
	m.clearedFields[membernote.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *MemberNoteMutation) NoteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *MemberNoteMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, membernote.FieldNote)
}

// SetNotesID sets the "notes" edge to the Member entity by id.
func (m *MemberNoteMutation) SetNotesID(id int64) {
	m.notes = &id
}

// ClearNotes clears the "notes" edge to the Member entity.
func (m *MemberNoteMutation) ClearNotes() {
	m.clearednotes = true
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// NotesCleared reports if the "notes" edge to the Member entity was cleared.
func (m *MemberNoteMutation) NotesCleared() bool {
	return m.MemberIDCleared() || m.clearednotes
}

// NotesID returns the "notes" edge ID in the mutation.
func (m *MemberNoteMutation) NotesID() (id int64, exists bool) {
	if m.notes != nil {
		return *m.notes, true
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotesID instead. It exists only for internal usage by the builders.
func (m *MemberNoteMutation) NotesIDs() (ids []int64) {
	if id := m.notes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *MemberNoteMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
}

// Where appends a list predicates to the MemberNoteMutation builder.
func (m *MemberNoteMutation) Where(ps ...predicate.MemberNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberNote).
func (m *MemberNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberNoteMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.note != nil {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.CreatedAt()
	case membernote.FieldUpdatedAt:
		return m.UpdatedAt()
	case membernote.FieldStatus:
		return m.Status()
	case membernote.FieldMemberID:
		return m.MemberID()
	case membernote.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membernote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membernote.FieldStatus:
		return m.OldStatus(ctx)
	case membernote.FieldMemberID:
		return m.OldMemberID(ctx)
	case membernote.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown MemberNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membernote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membernote.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membernote.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberNoteMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberNoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberNoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membernote.FieldStatus) {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.FieldCleared(membernote.FieldMemberID) {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.FieldCleared(membernote.FieldNote) {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberNoteMutation) ClearField(name string) error {
	switch name {
	case membernote.FieldStatus:
		m.ClearStatus()
		return nil
	case membernote.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membernote.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberNoteMutation) ResetField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membernote.FieldStatus:
		m.ResetStatus()
		return nil
	case membernote.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membernote.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.notes != nil {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membernote.EdgeNotes:
		if id := m.notes; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednotes {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case membernote.EdgeNotes:
		return m.clearednotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberNoteMutation) ClearEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberNoteMutation) ResetEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote edge %s", name)
}
