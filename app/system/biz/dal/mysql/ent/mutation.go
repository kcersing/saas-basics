// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"system/biz/dal/mysql/ent/api"
	"system/biz/dal/mysql/ent/dictionary"
	"system/biz/dal/mysql/ent/dictionarydetail"
	"system/biz/dal/mysql/ent/logs"
	"system/biz/dal/mysql/ent/menu"
	"system/biz/dal/mysql/ent/menuparam"
	"system/biz/dal/mysql/ent/messages"
	"system/biz/dal/mysql/ent/predicate"
	"system/biz/dal/mysql/ent/role"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI              = "API"
	TypeDictionary       = "Dictionary"
	TypeDictionaryDetail = "DictionaryDetail"
	TypeLogs             = "Logs"
	TypeMenu             = "Menu"
	TypeMenuParam        = "MenuParam"
	TypeMessages         = "Messages"
	TypeRole             = "Role"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_path         *string
	title         *string
	description   *string
	api_group     *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetTitle sets the "title" field.
func (m *APIMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *APIMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *APIMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.title != nil {
		fields = append(fields, api.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldPath:
		return m.Path()
	case api.FieldTitle:
		return m.Title()
	case api.FieldDescription:
		return m.Description()
	case api.FieldAPIGroup:
		return m.APIGroup()
	case api.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldTitle:
		return m.OldTitle(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldTitle:
		m.ResetTitle()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	created_at                *time.Time
	updated_at                *time.Time
	status                    *int64
	addstatus                 *int64
	title                     *string
	name                      *string
	description               *string
	clearedFields             map[string]struct{}
	dictionary_details        map[int64]struct{}
	removeddictionary_details map[int64]struct{}
	cleareddictionary_details bool
	done                      bool
	oldValue                  func(context.Context) (*Dictionary, error)
	predicates                []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id int64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DictionaryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictionaryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DictionaryMutation) ResetDescription() {
	m.description = nil
}

// AddDictionaryDetailIDs adds the "dictionary_details" edge to the DictionaryDetail entity by ids.
func (m *DictionaryMutation) AddDictionaryDetailIDs(ids ...int64) {
	if m.dictionary_details == nil {
		m.dictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.dictionary_details[ids[i]] = struct{}{}
	}
}

// ClearDictionaryDetails clears the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) ClearDictionaryDetails() {
	m.cleareddictionary_details = true
}

// DictionaryDetailsCleared reports if the "dictionary_details" edge to the DictionaryDetail entity was cleared.
func (m *DictionaryMutation) DictionaryDetailsCleared() bool {
	return m.cleareddictionary_details
}

// RemoveDictionaryDetailIDs removes the "dictionary_details" edge to the DictionaryDetail entity by IDs.
func (m *DictionaryMutation) RemoveDictionaryDetailIDs(ids ...int64) {
	if m.removeddictionary_details == nil {
		m.removeddictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.dictionary_details, ids[i])
		m.removeddictionary_details[ids[i]] = struct{}{}
	}
}

// RemovedDictionaryDetails returns the removed IDs of the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) RemovedDictionaryDetailsIDs() (ids []int64) {
	for id := range m.removeddictionary_details {
		ids = append(ids, id)
	}
	return
}

// DictionaryDetailsIDs returns the "dictionary_details" edge IDs in the mutation.
func (m *DictionaryMutation) DictionaryDetailsIDs() (ids []int64) {
	for id := range m.dictionary_details {
		ids = append(ids, id)
	}
	return
}

// ResetDictionaryDetails resets all changes to the "dictionary_details" edge.
func (m *DictionaryMutation) ResetDictionaryDetails() {
	m.dictionary_details = nil
	m.cleareddictionary_details = false
	m.removeddictionary_details = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionary.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dictionary.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldTitle:
		return m.Title()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldTitle:
		return m.OldTitle(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.dictionary_details))
		for id := range m.dictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.removeddictionary_details))
		for id := range m.removeddictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary_details {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		return m.cleareddictionary_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		m.ResetDictionaryDetails()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryDetailMutation represents an operation that mutates the DictionaryDetail nodes in the graph.
type DictionaryDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	status            *int64
	addstatus         *int64
	title             *string
	key               *string
	value             *string
	clearedFields     map[string]struct{}
	dictionary        *int64
	cleareddictionary bool
	done              bool
	oldValue          func(context.Context) (*DictionaryDetail, error)
	predicates        []predicate.DictionaryDetail
}

var _ ent.Mutation = (*DictionaryDetailMutation)(nil)

// dictionarydetailOption allows management of the mutation configuration using functional options.
type dictionarydetailOption func(*DictionaryDetailMutation)

// newDictionaryDetailMutation creates new mutation for the DictionaryDetail entity.
func newDictionaryDetailMutation(c config, op Op, opts ...dictionarydetailOption) *DictionaryDetailMutation {
	m := &DictionaryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryDetailID sets the ID field of the mutation.
func withDictionaryDetailID(id int64) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DictionaryDetail
		)
		m.oldValue = func(ctx context.Context) (*DictionaryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictionaryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionaryDetail sets the old DictionaryDetail of the mutation.
func withDictionaryDetail(node *DictionaryDetail) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		m.oldValue = func(context.Context) (*DictionaryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictionaryDetail entities.
func (m *DictionaryDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictionaryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryDetailMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryDetailMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryDetailMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryDetailMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryDetailMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionarydetail.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryDetailMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionarydetail.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetKey sets the "key" field.
func (m *DictionaryDetailMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DictionaryDetailMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DictionaryDetailMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DictionaryDetailMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryDetailMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryDetailMutation) ResetValue() {
	m.value = nil
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryDetailMutation) SetDictionaryID(i int64) {
	m.dictionary = &i
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryDetailMutation) DictionaryID() (r int64, exists bool) {
	v := m.dictionary
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDictionaryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ClearDictionaryID clears the value of the "dictionary_id" field.
func (m *DictionaryDetailMutation) ClearDictionaryID() {
	m.dictionary = nil
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryIDCleared returns if the "dictionary_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DictionaryIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDictionaryID]
	return ok
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryDetailMutation) ResetDictionaryID() {
	m.dictionary = nil
	delete(m.clearedFields, dictionarydetail.FieldDictionaryID)
}

// ClearDictionary clears the "dictionary" edge to the Dictionary entity.
func (m *DictionaryDetailMutation) ClearDictionary() {
	m.cleareddictionary = true
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryCleared reports if the "dictionary" edge to the Dictionary entity was cleared.
func (m *DictionaryDetailMutation) DictionaryCleared() bool {
	return m.DictionaryIDCleared() || m.cleareddictionary
}

// DictionaryIDs returns the "dictionary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionaryID instead. It exists only for internal usage by the builders.
func (m *DictionaryDetailMutation) DictionaryIDs() (ids []int64) {
	if id := m.dictionary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionary resets all changes to the "dictionary" edge.
func (m *DictionaryDetailMutation) ResetDictionary() {
	m.dictionary = nil
	m.cleareddictionary = false
}

// Where appends a list predicates to the DictionaryDetailMutation builder.
func (m *DictionaryDetailMutation) Where(ps ...predicate.DictionaryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictionaryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictionaryDetail).
func (m *DictionaryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryDetailMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionarydetail.FieldTitle)
	}
	if m.key != nil {
		fields = append(fields, dictionarydetail.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dictionarydetail.FieldValue)
	}
	if m.dictionary != nil {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case dictionarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionarydetail.FieldStatus:
		return m.Status()
	case dictionarydetail.FieldTitle:
		return m.Title()
	case dictionarydetail.FieldKey:
		return m.Key()
	case dictionarydetail.FieldValue:
		return m.Value()
	case dictionarydetail.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionarydetail.FieldStatus:
		return m.OldStatus(ctx)
	case dictionarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case dictionarydetail.FieldKey:
		return m.OldKey(ctx)
	case dictionarydetail.FieldValue:
		return m.OldValue(ctx)
	case dictionarydetail.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionarydetail.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dictionarydetail.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionarydetail.FieldDictionaryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryDetailMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionarydetail.FieldStatus) {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.FieldCleared(dictionarydetail.FieldDictionaryID) {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ClearField(name string) error {
	switch name {
	case dictionarydetail.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ClearDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ResetField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionarydetail.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionarydetail.FieldKey:
		m.ResetKey()
		return nil
	case dictionarydetail.FieldValue:
		m.ResetValue()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary != nil {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeDictionary:
		if id := m.dictionary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionarydetail.EdgeDictionary:
		return m.cleareddictionary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryDetailMutation) ClearEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ClearDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryDetailMutation) ResetEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ResetDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	method        *string
	api           *string
	success       *bool
	req_content   *string
	resp_content  *string
	ip            *string
	user_agent    *string
	operator      *string
	time          *int64
	addtime       *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int64) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *LogsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LogsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LogsMutation) ResetType() {
	m._type = nil
}

// SetMethod sets the "method" field.
func (m *LogsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *LogsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *LogsMutation) ResetMethod() {
	m.method = nil
}

// SetAPI sets the "api" field.
func (m *LogsMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *LogsMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *LogsMutation) ResetAPI() {
	m.api = nil
}

// SetSuccess sets the "success" field.
func (m *LogsMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LogsMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LogsMutation) ResetSuccess() {
	m.success = nil
}

// SetReqContent sets the "req_content" field.
func (m *LogsMutation) SetReqContent(s string) {
	m.req_content = &s
}

// ReqContent returns the value of the "req_content" field in the mutation.
func (m *LogsMutation) ReqContent() (r string, exists bool) {
	v := m.req_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReqContent returns the old "req_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldReqContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqContent: %w", err)
	}
	return oldValue.ReqContent, nil
}

// ClearReqContent clears the value of the "req_content" field.
func (m *LogsMutation) ClearReqContent() {
	m.req_content = nil
	m.clearedFields[logs.FieldReqContent] = struct{}{}
}

// ReqContentCleared returns if the "req_content" field was cleared in this mutation.
func (m *LogsMutation) ReqContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldReqContent]
	return ok
}

// ResetReqContent resets all changes to the "req_content" field.
func (m *LogsMutation) ResetReqContent() {
	m.req_content = nil
	delete(m.clearedFields, logs.FieldReqContent)
}

// SetRespContent sets the "resp_content" field.
func (m *LogsMutation) SetRespContent(s string) {
	m.resp_content = &s
}

// RespContent returns the value of the "resp_content" field in the mutation.
func (m *LogsMutation) RespContent() (r string, exists bool) {
	v := m.resp_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRespContent returns the old "resp_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRespContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespContent: %w", err)
	}
	return oldValue.RespContent, nil
}

// ClearRespContent clears the value of the "resp_content" field.
func (m *LogsMutation) ClearRespContent() {
	m.resp_content = nil
	m.clearedFields[logs.FieldRespContent] = struct{}{}
}

// RespContentCleared returns if the "resp_content" field was cleared in this mutation.
func (m *LogsMutation) RespContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldRespContent]
	return ok
}

// ResetRespContent resets all changes to the "resp_content" field.
func (m *LogsMutation) ResetRespContent() {
	m.resp_content = nil
	delete(m.clearedFields, logs.FieldRespContent)
}

// SetIP sets the "ip" field.
func (m *LogsMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *LogsMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[logs.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *LogsMutation) IPCleared() bool {
	_, ok := m.clearedFields[logs.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *LogsMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, logs.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LogsMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LogsMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LogsMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[logs.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LogsMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LogsMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, logs.FieldUserAgent)
}

// SetOperator sets the "operator" field.
func (m *LogsMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the value of the "operator" field in the mutation.
func (m *LogsMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldOperator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ClearOperator clears the value of the "operator" field.
func (m *LogsMutation) ClearOperator() {
	m.operator = nil
	m.clearedFields[logs.FieldOperator] = struct{}{}
}

// OperatorCleared returns if the "operator" field was cleared in this mutation.
func (m *LogsMutation) OperatorCleared() bool {
	_, ok := m.clearedFields[logs.FieldOperator]
	return ok
}

// ResetOperator resets all changes to the "operator" field.
func (m *LogsMutation) ResetOperator() {
	m.operator = nil
	delete(m.clearedFields, logs.FieldOperator)
}

// SetTime sets the "time" field.
func (m *LogsMutation) SetTime(i int64) {
	m.time = &i
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *LogsMutation) Time() (r int64, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to the "time" field.
func (m *LogsMutation) AddTime(i int64) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *LogsMutation) AddedTime() (r int64, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *LogsMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[logs.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *LogsMutation) TimeCleared() bool {
	_, ok := m.clearedFields[logs.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *LogsMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, logs.FieldTime)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, logs.FieldType)
	}
	if m.method != nil {
		fields = append(fields, logs.FieldMethod)
	}
	if m.api != nil {
		fields = append(fields, logs.FieldAPI)
	}
	if m.success != nil {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.req_content != nil {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.resp_content != nil {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.ip != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.operator != nil {
		fields = append(fields, logs.FieldOperator)
	}
	if m.time != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldType:
		return m.GetType()
	case logs.FieldMethod:
		return m.Method()
	case logs.FieldAPI:
		return m.API()
	case logs.FieldSuccess:
		return m.Success()
	case logs.FieldReqContent:
		return m.ReqContent()
	case logs.FieldRespContent:
		return m.RespContent()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldUserAgent:
		return m.UserAgent()
	case logs.FieldOperator:
		return m.Operator()
	case logs.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldType:
		return m.OldType(ctx)
	case logs.FieldMethod:
		return m.OldMethod(ctx)
	case logs.FieldAPI:
		return m.OldAPI(ctx)
	case logs.FieldSuccess:
		return m.OldSuccess(ctx)
	case logs.FieldReqContent:
		return m.OldReqContent(ctx)
	case logs.FieldRespContent:
		return m.OldRespContent(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case logs.FieldOperator:
		return m.OldOperator(ctx)
	case logs.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case logs.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case logs.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case logs.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case logs.FieldReqContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqContent(v)
		return nil
	case logs.FieldRespContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespContent(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case logs.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.addtime != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldReqContent) {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.FieldCleared(logs.FieldRespContent) {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.FieldCleared(logs.FieldIP) {
		fields = append(fields, logs.FieldIP)
	}
	if m.FieldCleared(logs.FieldUserAgent) {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.FieldCleared(logs.FieldOperator) {
		fields = append(fields, logs.FieldOperator)
	}
	if m.FieldCleared(logs.FieldTime) {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldReqContent:
		m.ClearReqContent()
		return nil
	case logs.FieldRespContent:
		m.ClearRespContent()
		return nil
	case logs.FieldIP:
		m.ClearIP()
		return nil
	case logs.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case logs.FieldOperator:
		m.ClearOperator()
		return nil
	case logs.FieldTime:
		m.ClearTime()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldType:
		m.ResetType()
		return nil
	case logs.FieldMethod:
		m.ResetMethod()
		return nil
	case logs.FieldAPI:
		m.ResetAPI()
		return nil
	case logs.FieldSuccess:
		m.ResetSuccess()
		return nil
	case logs.FieldReqContent:
		m.ResetReqContent()
		return nil
	case logs.FieldRespContent:
		m.ResetRespContent()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case logs.FieldOperator:
		m.ResetOperator()
		return nil
	case logs.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	_path           *string
	name            *string
	order_no        *int64
	addorder_no     *int64
	disabled        *int64
	adddisabled     *int64
	ignore          *bool
	clearedFields   map[string]struct{}
	roles           map[int64]struct{}
	removedroles    map[int64]struct{}
	clearedroles    bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	params          map[int64]struct{}
	removedparams   map[int64]struct{}
	clearedparams   bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetOrderNo sets the "order_no" field.
func (m *MenuMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *MenuMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *MenuMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *MenuMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *MenuMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetDisabled sets the "disabled" field.
func (m *MenuMutation) SetDisabled(i int64) {
	m.disabled = &i
	m.adddisabled = nil
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *MenuMutation) Disabled() (r int64, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDisabled(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// AddDisabled adds i to the "disabled" field.
func (m *MenuMutation) AddDisabled(i int64) {
	if m.adddisabled != nil {
		*m.adddisabled += i
	} else {
		m.adddisabled = &i
	}
}

// AddedDisabled returns the value that was added to the "disabled" field in this mutation.
func (m *MenuMutation) AddedDisabled() (r int64, exists bool) {
	v := m.adddisabled
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabled clears the value of the "disabled" field.
func (m *MenuMutation) ClearDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	m.clearedFields[menu.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *MenuMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[menu.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *MenuMutation) ResetDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	delete(m.clearedFields, menu.FieldDisabled)
}

// SetIgnore sets the "ignore" field.
func (m *MenuMutation) SetIgnore(b bool) {
	m.ignore = &b
}

// Ignore returns the value of the "ignore" field in the mutation.
func (m *MenuMutation) Ignore() (r bool, exists bool) {
	v := m.ignore
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnore returns the old "ignore" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIgnore(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnore: %w", err)
	}
	return oldValue.Ignore, nil
}

// ClearIgnore clears the value of the "ignore" field.
func (m *MenuMutation) ClearIgnore() {
	m.ignore = nil
	m.clearedFields[menu.FieldIgnore] = struct{}{}
}

// IgnoreCleared returns if the "ignore" field was cleared in this mutation.
func (m *MenuMutation) IgnoreCleared() bool {
	_, ok := m.clearedFields[menu.FieldIgnore]
	return ok
}

// ResetIgnore resets all changes to the "ignore" field.
func (m *MenuMutation) ResetIgnore() {
	m.ignore = nil
	delete(m.clearedFields, menu.FieldIgnore)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddParamIDs adds the "params" edge to the MenuParam entity by ids.
func (m *MenuMutation) AddParamIDs(ids ...int64) {
	if m.params == nil {
		m.params = make(map[int64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the MenuParam entity.
func (m *MenuMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the MenuParam entity was cleared.
func (m *MenuMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the MenuParam entity by IDs.
func (m *MenuMutation) RemoveParamIDs(ids ...int64) {
	if m.removedparams == nil {
		m.removedparams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the MenuParam entity.
func (m *MenuMutation) RemovedParamsIDs() (ids []int64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *MenuMutation) ParamsIDs() (ids []int64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *MenuMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.order_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.disabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.ignore != nil {
		fields = append(fields, menu.FieldIgnore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldOrderNo:
		return m.OrderNo()
	case menu.FieldDisabled:
		return m.Disabled()
	case menu.FieldIgnore:
		return m.Ignore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case menu.FieldDisabled:
		return m.OldDisabled(ctx)
	case menu.FieldIgnore:
		return m.OldIgnore(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case menu.FieldIgnore:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnore(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addorder_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.adddisabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldOrderNo:
		return m.AddedOrderNo()
	case menu.FieldDisabled:
		return m.AddedDisabled()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldDisabled) {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.FieldCleared(menu.FieldIgnore) {
		fields = append(fields, menu.FieldIgnore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldDisabled:
		m.ClearDisabled()
		return nil
	case menu.FieldIgnore:
		m.ClearIgnore()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case menu.FieldDisabled:
		m.ResetDisabled()
		return nil
	case menu.FieldIgnore:
		m.ResetIgnore()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.params != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedparams != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedparams {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeParams:
		return m.clearedparams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuParamMutation represents an operation that mutates the MenuParam nodes in the graph.
type MenuParamMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	key           *string
	value         *string
	clearedFields map[string]struct{}
	menus         *int64
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*MenuParam, error)
	predicates    []predicate.MenuParam
}

var _ ent.Mutation = (*MenuParamMutation)(nil)

// menuparamOption allows management of the mutation configuration using functional options.
type menuparamOption func(*MenuParamMutation)

// newMenuParamMutation creates new mutation for the MenuParam entity.
func newMenuParamMutation(c config, op Op, opts ...menuparamOption) *MenuParamMutation {
	m := &MenuParamMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuParamID sets the ID field of the mutation.
func withMenuParamID(id int64) menuparamOption {
	return func(m *MenuParamMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuParam
		)
		m.oldValue = func(ctx context.Context) (*MenuParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuParam sets the old MenuParam of the mutation.
func withMenuParam(node *MenuParam) menuparamOption {
	return func(m *MenuParamMutation) {
		m.oldValue = func(context.Context) (*MenuParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuParam entities.
func (m *MenuParamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuParamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuParamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuParamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *MenuParamMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuParamMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MenuParamMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *MenuParamMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *MenuParamMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *MenuParamMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *MenuParamMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MenuParamMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MenuParamMutation) ResetValue() {
	m.value = nil
}

// SetMenusID sets the "menus" edge to the Menu entity by id.
func (m *MenuParamMutation) SetMenusID(id int64) {
	m.menus = &id
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *MenuParamMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *MenuParamMutation) MenusCleared() bool {
	return m.clearedmenus
}

// MenusID returns the "menus" edge ID in the mutation.
func (m *MenuParamMutation) MenusID() (id int64, exists bool) {
	if m.menus != nil {
		return *m.menus, true
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenusID instead. It exists only for internal usage by the builders.
func (m *MenuParamMutation) MenusIDs() (ids []int64) {
	if id := m.menus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *MenuParamMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
}

// Where appends a list predicates to the MenuParamMutation builder.
func (m *MenuParamMutation) Where(ps ...predicate.MenuParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuParam).
func (m *MenuParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuParamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, menuparam.FieldType)
	}
	if m.key != nil {
		fields = append(fields, menuparam.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, menuparam.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.CreatedAt()
	case menuparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuparam.FieldType:
		return m.GetType()
	case menuparam.FieldKey:
		return m.Key()
	case menuparam.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuparam.FieldType:
		return m.OldType(ctx)
	case menuparam.FieldKey:
		return m.OldKey(ctx)
	case menuparam.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown MenuParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuparam.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menuparam.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case menuparam.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuParamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuParamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MenuParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuParamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuParamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MenuParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuParamMutation) ResetField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuparam.FieldType:
		m.ResetType()
		return nil
	case menuparam.FieldKey:
		m.ResetKey()
		return nil
	case menuparam.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuparam.EdgeMenus:
		if id := m.menus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuParamMutation) EdgeCleared(name string) bool {
	switch name {
	case menuparam.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuParamMutation) ClearEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ClearMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuParamMutation) ResetEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam edge %s", name)
}

// MessagesMutation represents an operation that mutates the Messages nodes in the graph.
type MessagesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	to_user_id    *string
	from_user_id  *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Messages, error)
	predicates    []predicate.Messages
}

var _ ent.Mutation = (*MessagesMutation)(nil)

// messagesOption allows management of the mutation configuration using functional options.
type messagesOption func(*MessagesMutation)

// newMessagesMutation creates new mutation for the Messages entity.
func newMessagesMutation(c config, op Op, opts ...messagesOption) *MessagesMutation {
	m := &MessagesMutation{
		config:        c,
		op:            op,
		typ:           TypeMessages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesID sets the ID field of the mutation.
func withMessagesID(id int64) messagesOption {
	return func(m *MessagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Messages
		)
		m.oldValue = func(ctx context.Context) (*Messages, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Messages.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessages sets the old Messages of the mutation.
func withMessages(node *Messages) messagesOption {
	return func(m *MessagesMutation) {
		m.oldValue = func(context.Context) (*Messages, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Messages entities.
func (m *MessagesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Messages.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *MessagesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessagesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessagesMutation) ResetType() {
	m._type = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *MessagesMutation) SetToUserID(s string) {
	m.to_user_id = &s
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *MessagesMutation) ToUserID() (r string, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldToUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *MessagesMutation) ResetToUserID() {
	m.to_user_id = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *MessagesMutation) SetFromUserID(s string) {
	m.from_user_id = &s
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *MessagesMutation) FromUserID() (r string, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldFromUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *MessagesMutation) ResetFromUserID() {
	m.from_user_id = nil
}

// SetContent sets the "content" field.
func (m *MessagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessagesMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the MessagesMutation builder.
func (m *MessagesMutation) Where(ps ...predicate.Messages) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Messages, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Messages).
func (m *MessagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, messages.FieldType)
	}
	if m.to_user_id != nil {
		fields = append(fields, messages.FieldToUserID)
	}
	if m.from_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.content != nil {
		fields = append(fields, messages.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldCreatedAt:
		return m.CreatedAt()
	case messages.FieldUpdatedAt:
		return m.UpdatedAt()
	case messages.FieldType:
		return m.GetType()
	case messages.FieldToUserID:
		return m.ToUserID()
	case messages.FieldFromUserID:
		return m.FromUserID()
	case messages.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messages.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messages.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messages.FieldType:
		return m.OldType(ctx)
	case messages.FieldToUserID:
		return m.OldToUserID(ctx)
	case messages.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case messages.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Messages field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messages.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messages.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messages.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case messages.FieldToUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case messages.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Messages numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Messages nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesMutation) ResetField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messages.FieldType:
		m.ResetType()
		return nil
	case messages.FieldToUserID:
		m.ResetToUserID()
		return nil
	case messages.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case messages.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Messages unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Messages edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	status         *int64
	addstatus      *int64
	name           *string
	value          *string
	default_router *string
	remark         *string
	order_no       *int64
	addorder_no    *int64
	apis           *[]int
	appendapis     []int
	clearedFields  map[string]struct{}
	menus          map[int64]struct{}
	removedmenus   map[int64]struct{}
	clearedmenus   bool
	done           bool
	oldValue       func(context.Context) (*Role, error)
	predicates     []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RoleMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RoleMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RoleMutation) ResetValue() {
	m.value = nil
}

// SetDefaultRouter sets the "default_router" field.
func (m *RoleMutation) SetDefaultRouter(s string) {
	m.default_router = &s
}

// DefaultRouter returns the value of the "default_router" field in the mutation.
func (m *RoleMutation) DefaultRouter() (r string, exists bool) {
	v := m.default_router
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRouter returns the old "default_router" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDefaultRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRouter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRouter: %w", err)
	}
	return oldValue.DefaultRouter, nil
}

// ResetDefaultRouter resets all changes to the "default_router" field.
func (m *RoleMutation) ResetDefaultRouter() {
	m.default_router = nil
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
}

// SetOrderNo sets the "order_no" field.
func (m *RoleMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RoleMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *RoleMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *RoleMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RoleMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetApis sets the "apis" field.
func (m *RoleMutation) SetApis(i []int) {
	m.apis = &i
	m.appendapis = nil
}

// Apis returns the value of the "apis" field in the mutation.
func (m *RoleMutation) Apis() (r []int, exists bool) {
	v := m.apis
	if v == nil {
		return
	}
	return *v, true
}

// OldApis returns the old "apis" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApis(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApis: %w", err)
	}
	return oldValue.Apis, nil
}

// AppendApis adds i to the "apis" field.
func (m *RoleMutation) AppendApis(i []int) {
	m.appendapis = append(m.appendapis, i...)
}

// AppendedApis returns the list of values that were appended to the "apis" field in this mutation.
func (m *RoleMutation) AppendedApis() ([]int, bool) {
	if len(m.appendapis) == 0 {
		return nil, false
	}
	return m.appendapis, true
}

// ResetApis resets all changes to the "apis" field.
func (m *RoleMutation) ResetApis() {
	m.apis = nil
	m.appendapis = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.value != nil {
		fields = append(fields, role.FieldValue)
	}
	if m.default_router != nil {
		fields = append(fields, role.FieldDefaultRouter)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.order_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.apis != nil {
		fields = append(fields, role.FieldApis)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldValue:
		return m.Value()
	case role.FieldDefaultRouter:
		return m.DefaultRouter()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldOrderNo:
		return m.OrderNo()
	case role.FieldApis:
		return m.Apis()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldValue:
		return m.OldValue(ctx)
	case role.FieldDefaultRouter:
		return m.OldDefaultRouter(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case role.FieldApis:
		return m.OldApis(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case role.FieldDefaultRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRouter(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case role.FieldApis:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApis(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldOrderNo:
		return m.AddedOrderNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldValue:
		m.ResetValue()
		return nil
	case role.FieldDefaultRouter:
		m.ResetDefaultRouter()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case role.FieldApis:
		m.ResetApis()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}
