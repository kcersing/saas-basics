// Code generated by ent, DO NOT EDIT.

package ent

import (
	"company/biz/dal/mysql/ent/contract"
	"company/biz/dal/mysql/ent/entrylogs"
	"company/biz/dal/mysql/ent/face"
	"company/biz/dal/mysql/ent/member"
	"company/biz/dal/mysql/ent/messages"
	"company/biz/dal/mysql/ent/predicate"
	"company/biz/dal/mysql/ent/user"
	"company/biz/dal/mysql/ent/venue"
	"company/biz/dal/mysql/ent/venueplace"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeContract   = "Contract"
	TypeEntryLogs  = "EntryLogs"
	TypeFace       = "Face"
	TypeMember     = "Member"
	TypeMessages   = "Messages"
	TypeUser       = "User"
	TypeVenue      = "Venue"
	TypeVenuePlace = "VenuePlace"
)

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int64
	addstatus     *int64
	name          *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Contract, error)
	predicates    []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id int64) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contract entities.
func (m *ContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contract.FieldStatus)
}

// SetName sets the "name" field.
func (m *ContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[contract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[contract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contract.FieldName)
}

// SetContent sets the "content" field.
func (m *ContractMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ContractMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ContractMutation) ClearContent() {
	m.content = nil
	m.clearedFields[contract.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ContractMutation) ContentCleared() bool {
	_, ok := m.clearedFields[contract.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ContractMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, contract.FieldContent)
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, contract.FieldName)
	}
	if m.content != nil {
		fields = append(fields, contract.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldStatus:
		return m.Status()
	case contract.FieldName:
		return m.Name()
	case contract.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldStatus:
		return m.OldStatus(ctx)
	case contract.FieldName:
		return m.OldName(ctx)
	case contract.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contract.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, contract.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldStatus) {
		fields = append(fields, contract.FieldStatus)
	}
	if m.FieldCleared(contract.FieldName) {
		fields = append(fields, contract.FieldName)
	}
	if m.FieldCleared(contract.FieldContent) {
		fields = append(fields, contract.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldStatus:
		m.ClearStatus()
		return nil
	case contract.FieldName:
		m.ClearName()
		return nil
	case contract.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldStatus:
		m.ResetStatus()
		return nil
	case contract.FieldName:
		m.ResetName()
		return nil
	case contract.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Contract edge %s", name)
}

// EntryLogsMutation represents an operation that mutates the EntryLogs nodes in the graph.
type EntryLogsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	user_id               *int64
	adduser_id            *int64
	member_id             *int64
	addmember_id          *int64
	member_product_id     *int64
	addmember_product_id  *int64
	member_property_id    *int64
	addmember_property_id *int64
	entry_time            *time.Time
	leaving_time          *time.Time
	clearedFields         map[string]struct{}
	venues                *int64
	clearedvenues         bool
	done                  bool
	oldValue              func(context.Context) (*EntryLogs, error)
	predicates            []predicate.EntryLogs
}

var _ ent.Mutation = (*EntryLogsMutation)(nil)

// entrylogsOption allows management of the mutation configuration using functional options.
type entrylogsOption func(*EntryLogsMutation)

// newEntryLogsMutation creates new mutation for the EntryLogs entity.
func newEntryLogsMutation(c config, op Op, opts ...entrylogsOption) *EntryLogsMutation {
	m := &EntryLogsMutation{
		config:        c,
		op:            op,
		typ:           TypeEntryLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryLogsID sets the ID field of the mutation.
func withEntryLogsID(id int64) entrylogsOption {
	return func(m *EntryLogsMutation) {
		var (
			err   error
			once  sync.Once
			value *EntryLogs
		)
		m.oldValue = func(ctx context.Context) (*EntryLogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntryLogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntryLogs sets the old EntryLogs of the mutation.
func withEntryLogs(node *EntryLogs) entrylogsOption {
	return func(m *EntryLogsMutation) {
		m.oldValue = func(context.Context) (*EntryLogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryLogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryLogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntryLogs entities.
func (m *EntryLogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntryLogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntryLogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntryLogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntryLogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntryLogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntryLogsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntryLogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntryLogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntryLogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVenueID sets the "venue_id" field.
func (m *EntryLogsMutation) SetVenueID(i int64) {
	m.venues = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *EntryLogsMutation) VenueID() (r int64, exists bool) {
	v := m.venues
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *EntryLogsMutation) ClearVenueID() {
	m.venues = nil
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *EntryLogsMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *EntryLogsMutation) ResetVenueID() {
	m.venues = nil
	delete(m.clearedFields, entrylogs.FieldVenueID)
}

// SetUserID sets the "user_id" field.
func (m *EntryLogsMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EntryLogsMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *EntryLogsMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *EntryLogsMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *EntryLogsMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[entrylogs.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *EntryLogsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EntryLogsMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, entrylogs.FieldUserID)
}

// SetMemberID sets the "member_id" field.
func (m *EntryLogsMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *EntryLogsMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *EntryLogsMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *EntryLogsMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *EntryLogsMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[entrylogs.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *EntryLogsMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, entrylogs.FieldMemberID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *EntryLogsMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *EntryLogsMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *EntryLogsMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *EntryLogsMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *EntryLogsMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[entrylogs.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *EntryLogsMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, entrylogs.FieldMemberProductID)
}

// SetMemberPropertyID sets the "member_property_id" field.
func (m *EntryLogsMutation) SetMemberPropertyID(i int64) {
	m.member_property_id = &i
	m.addmember_property_id = nil
}

// MemberPropertyID returns the value of the "member_property_id" field in the mutation.
func (m *EntryLogsMutation) MemberPropertyID() (r int64, exists bool) {
	v := m.member_property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberPropertyID returns the old "member_property_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberPropertyID: %w", err)
	}
	return oldValue.MemberPropertyID, nil
}

// AddMemberPropertyID adds i to the "member_property_id" field.
func (m *EntryLogsMutation) AddMemberPropertyID(i int64) {
	if m.addmember_property_id != nil {
		*m.addmember_property_id += i
	} else {
		m.addmember_property_id = &i
	}
}

// AddedMemberPropertyID returns the value that was added to the "member_property_id" field in this mutation.
func (m *EntryLogsMutation) AddedMemberPropertyID() (r int64, exists bool) {
	v := m.addmember_property_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberPropertyID clears the value of the "member_property_id" field.
func (m *EntryLogsMutation) ClearMemberPropertyID() {
	m.member_property_id = nil
	m.addmember_property_id = nil
	m.clearedFields[entrylogs.FieldMemberPropertyID] = struct{}{}
}

// MemberPropertyIDCleared returns if the "member_property_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberPropertyIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberPropertyID]
	return ok
}

// ResetMemberPropertyID resets all changes to the "member_property_id" field.
func (m *EntryLogsMutation) ResetMemberPropertyID() {
	m.member_property_id = nil
	m.addmember_property_id = nil
	delete(m.clearedFields, entrylogs.FieldMemberPropertyID)
}

// SetEntryTime sets the "entry_time" field.
func (m *EntryLogsMutation) SetEntryTime(t time.Time) {
	m.entry_time = &t
}

// EntryTime returns the value of the "entry_time" field in the mutation.
func (m *EntryLogsMutation) EntryTime() (r time.Time, exists bool) {
	v := m.entry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryTime returns the old "entry_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldEntryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryTime: %w", err)
	}
	return oldValue.EntryTime, nil
}

// ClearEntryTime clears the value of the "entry_time" field.
func (m *EntryLogsMutation) ClearEntryTime() {
	m.entry_time = nil
	m.clearedFields[entrylogs.FieldEntryTime] = struct{}{}
}

// EntryTimeCleared returns if the "entry_time" field was cleared in this mutation.
func (m *EntryLogsMutation) EntryTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldEntryTime]
	return ok
}

// ResetEntryTime resets all changes to the "entry_time" field.
func (m *EntryLogsMutation) ResetEntryTime() {
	m.entry_time = nil
	delete(m.clearedFields, entrylogs.FieldEntryTime)
}

// SetLeavingTime sets the "leaving_time" field.
func (m *EntryLogsMutation) SetLeavingTime(t time.Time) {
	m.leaving_time = &t
}

// LeavingTime returns the value of the "leaving_time" field in the mutation.
func (m *EntryLogsMutation) LeavingTime() (r time.Time, exists bool) {
	v := m.leaving_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLeavingTime returns the old "leaving_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldLeavingTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeavingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeavingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeavingTime: %w", err)
	}
	return oldValue.LeavingTime, nil
}

// ClearLeavingTime clears the value of the "leaving_time" field.
func (m *EntryLogsMutation) ClearLeavingTime() {
	m.leaving_time = nil
	m.clearedFields[entrylogs.FieldLeavingTime] = struct{}{}
}

// LeavingTimeCleared returns if the "leaving_time" field was cleared in this mutation.
func (m *EntryLogsMutation) LeavingTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldLeavingTime]
	return ok
}

// ResetLeavingTime resets all changes to the "leaving_time" field.
func (m *EntryLogsMutation) ResetLeavingTime() {
	m.leaving_time = nil
	delete(m.clearedFields, entrylogs.FieldLeavingTime)
}

// SetVenuesID sets the "venues" edge to the Venue entity by id.
func (m *EntryLogsMutation) SetVenuesID(id int64) {
	m.venues = &id
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *EntryLogsMutation) ClearVenues() {
	m.clearedvenues = true
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *EntryLogsMutation) VenuesCleared() bool {
	return m.VenueIDCleared() || m.clearedvenues
}

// VenuesID returns the "venues" edge ID in the mutation.
func (m *EntryLogsMutation) VenuesID() (id int64, exists bool) {
	if m.venues != nil {
		return *m.venues, true
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenuesID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) VenuesIDs() (ids []int64) {
	if id := m.venues; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *EntryLogsMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
}

// Where appends a list predicates to the EntryLogsMutation builder.
func (m *EntryLogsMutation) Where(ps ...predicate.EntryLogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntryLogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntryLogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntryLogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntryLogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntryLogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntryLogs).
func (m *EntryLogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryLogsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, entrylogs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entrylogs.FieldUpdatedAt)
	}
	if m.venues != nil {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.user_id != nil {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.member_id != nil {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.member_product_id != nil {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.member_property_id != nil {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	if m.entry_time != nil {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.leaving_time != nil {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryLogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.CreatedAt()
	case entrylogs.FieldUpdatedAt:
		return m.UpdatedAt()
	case entrylogs.FieldVenueID:
		return m.VenueID()
	case entrylogs.FieldUserID:
		return m.UserID()
	case entrylogs.FieldMemberID:
		return m.MemberID()
	case entrylogs.FieldMemberProductID:
		return m.MemberProductID()
	case entrylogs.FieldMemberPropertyID:
		return m.MemberPropertyID()
	case entrylogs.FieldEntryTime:
		return m.EntryTime()
	case entrylogs.FieldLeavingTime:
		return m.LeavingTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryLogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entrylogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entrylogs.FieldVenueID:
		return m.OldVenueID(ctx)
	case entrylogs.FieldUserID:
		return m.OldUserID(ctx)
	case entrylogs.FieldMemberID:
		return m.OldMemberID(ctx)
	case entrylogs.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case entrylogs.FieldMemberPropertyID:
		return m.OldMemberPropertyID(ctx)
	case entrylogs.FieldEntryTime:
		return m.OldEntryTime(ctx)
	case entrylogs.FieldLeavingTime:
		return m.OldLeavingTime(ctx)
	}
	return nil, fmt.Errorf("unknown EntryLogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entrylogs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entrylogs.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case entrylogs.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case entrylogs.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case entrylogs.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case entrylogs.FieldMemberPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberPropertyID(v)
		return nil
	case entrylogs.FieldEntryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryTime(v)
		return nil
	case entrylogs.FieldLeavingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeavingTime(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryLogsMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.addmember_id != nil {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.addmember_product_id != nil {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.addmember_property_id != nil {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryLogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldUserID:
		return m.AddedUserID()
	case entrylogs.FieldMemberID:
		return m.AddedMemberID()
	case entrylogs.FieldMemberProductID:
		return m.AddedMemberProductID()
	case entrylogs.FieldMemberPropertyID:
		return m.AddedMemberPropertyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case entrylogs.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case entrylogs.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	case entrylogs.FieldMemberPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberPropertyID(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryLogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entrylogs.FieldVenueID) {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.FieldCleared(entrylogs.FieldUserID) {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.FieldCleared(entrylogs.FieldMemberID) {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.FieldCleared(entrylogs.FieldMemberProductID) {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.FieldCleared(entrylogs.FieldMemberPropertyID) {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	if m.FieldCleared(entrylogs.FieldEntryTime) {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.FieldCleared(entrylogs.FieldLeavingTime) {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryLogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryLogsMutation) ClearField(name string) error {
	switch name {
	case entrylogs.FieldVenueID:
		m.ClearVenueID()
		return nil
	case entrylogs.FieldUserID:
		m.ClearUserID()
		return nil
	case entrylogs.FieldMemberID:
		m.ClearMemberID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case entrylogs.FieldMemberPropertyID:
		m.ClearMemberPropertyID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ClearEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ClearLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryLogsMutation) ResetField(name string) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entrylogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entrylogs.FieldVenueID:
		m.ResetVenueID()
		return nil
	case entrylogs.FieldUserID:
		m.ResetUserID()
		return nil
	case entrylogs.FieldMemberID:
		m.ResetMemberID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case entrylogs.FieldMemberPropertyID:
		m.ResetMemberPropertyID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ResetEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ResetLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryLogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.venues != nil {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryLogsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entrylogs.EdgeVenues:
		if id := m.venues; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryLogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryLogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryLogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvenues {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryLogsMutation) EdgeCleared(name string) bool {
	switch name {
	case entrylogs.EdgeVenues:
		return m.clearedvenues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryLogsMutation) ClearEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ClearVenues()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryLogsMutation) ResetEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ResetVenues()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs edge %s", name)
}

// FaceMutation represents an operation that mutates the Face nodes in the graph.
type FaceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	identity_card         *string
	face_identity_card    *string
	back_identity_card    *string
	face_pic              *string
	face_eigenvalue       *string
	face_pic_updated_time *time.Time
	clearedFields         map[string]struct{}
	member_faces          *int64
	clearedmember_faces   bool
	user_faces            *int64
	cleareduser_faces     bool
	done                  bool
	oldValue              func(context.Context) (*Face, error)
	predicates            []predicate.Face
}

var _ ent.Mutation = (*FaceMutation)(nil)

// faceOption allows management of the mutation configuration using functional options.
type faceOption func(*FaceMutation)

// newFaceMutation creates new mutation for the Face entity.
func newFaceMutation(c config, op Op, opts ...faceOption) *FaceMutation {
	m := &FaceMutation{
		config:        c,
		op:            op,
		typ:           TypeFace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFaceID sets the ID field of the mutation.
func withFaceID(id int64) faceOption {
	return func(m *FaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Face
		)
		m.oldValue = func(ctx context.Context) (*Face, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Face.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFace sets the old Face of the mutation.
func withFace(node *Face) faceOption {
	return func(m *FaceMutation) {
		m.oldValue = func(context.Context) (*Face, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Face entities.
func (m *FaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Face.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMemberID sets the "member_id" field.
func (m *FaceMutation) SetMemberID(i int64) {
	m.member_faces = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *FaceMutation) MemberID() (r int64, exists bool) {
	v := m.member_faces
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *FaceMutation) ClearMemberID() {
	m.member_faces = nil
	m.clearedFields[face.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *FaceMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[face.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *FaceMutation) ResetMemberID() {
	m.member_faces = nil
	delete(m.clearedFields, face.FieldMemberID)
}

// SetUserID sets the "user_id" field.
func (m *FaceMutation) SetUserID(i int64) {
	m.user_faces = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FaceMutation) UserID() (r int64, exists bool) {
	v := m.user_faces
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *FaceMutation) ClearUserID() {
	m.user_faces = nil
	m.clearedFields[face.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *FaceMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[face.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FaceMutation) ResetUserID() {
	m.user_faces = nil
	delete(m.clearedFields, face.FieldUserID)
}

// SetIdentityCard sets the "identity_card" field.
func (m *FaceMutation) SetIdentityCard(s string) {
	m.identity_card = &s
}

// IdentityCard returns the value of the "identity_card" field in the mutation.
func (m *FaceMutation) IdentityCard() (r string, exists bool) {
	v := m.identity_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityCard returns the old "identity_card" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldIdentityCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityCard: %w", err)
	}
	return oldValue.IdentityCard, nil
}

// ClearIdentityCard clears the value of the "identity_card" field.
func (m *FaceMutation) ClearIdentityCard() {
	m.identity_card = nil
	m.clearedFields[face.FieldIdentityCard] = struct{}{}
}

// IdentityCardCleared returns if the "identity_card" field was cleared in this mutation.
func (m *FaceMutation) IdentityCardCleared() bool {
	_, ok := m.clearedFields[face.FieldIdentityCard]
	return ok
}

// ResetIdentityCard resets all changes to the "identity_card" field.
func (m *FaceMutation) ResetIdentityCard() {
	m.identity_card = nil
	delete(m.clearedFields, face.FieldIdentityCard)
}

// SetFaceIdentityCard sets the "face_identity_card" field.
func (m *FaceMutation) SetFaceIdentityCard(s string) {
	m.face_identity_card = &s
}

// FaceIdentityCard returns the value of the "face_identity_card" field in the mutation.
func (m *FaceMutation) FaceIdentityCard() (r string, exists bool) {
	v := m.face_identity_card
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceIdentityCard returns the old "face_identity_card" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldFaceIdentityCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceIdentityCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceIdentityCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceIdentityCard: %w", err)
	}
	return oldValue.FaceIdentityCard, nil
}

// ClearFaceIdentityCard clears the value of the "face_identity_card" field.
func (m *FaceMutation) ClearFaceIdentityCard() {
	m.face_identity_card = nil
	m.clearedFields[face.FieldFaceIdentityCard] = struct{}{}
}

// FaceIdentityCardCleared returns if the "face_identity_card" field was cleared in this mutation.
func (m *FaceMutation) FaceIdentityCardCleared() bool {
	_, ok := m.clearedFields[face.FieldFaceIdentityCard]
	return ok
}

// ResetFaceIdentityCard resets all changes to the "face_identity_card" field.
func (m *FaceMutation) ResetFaceIdentityCard() {
	m.face_identity_card = nil
	delete(m.clearedFields, face.FieldFaceIdentityCard)
}

// SetBackIdentityCard sets the "back_identity_card" field.
func (m *FaceMutation) SetBackIdentityCard(s string) {
	m.back_identity_card = &s
}

// BackIdentityCard returns the value of the "back_identity_card" field in the mutation.
func (m *FaceMutation) BackIdentityCard() (r string, exists bool) {
	v := m.back_identity_card
	if v == nil {
		return
	}
	return *v, true
}

// OldBackIdentityCard returns the old "back_identity_card" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldBackIdentityCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackIdentityCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackIdentityCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackIdentityCard: %w", err)
	}
	return oldValue.BackIdentityCard, nil
}

// ClearBackIdentityCard clears the value of the "back_identity_card" field.
func (m *FaceMutation) ClearBackIdentityCard() {
	m.back_identity_card = nil
	m.clearedFields[face.FieldBackIdentityCard] = struct{}{}
}

// BackIdentityCardCleared returns if the "back_identity_card" field was cleared in this mutation.
func (m *FaceMutation) BackIdentityCardCleared() bool {
	_, ok := m.clearedFields[face.FieldBackIdentityCard]
	return ok
}

// ResetBackIdentityCard resets all changes to the "back_identity_card" field.
func (m *FaceMutation) ResetBackIdentityCard() {
	m.back_identity_card = nil
	delete(m.clearedFields, face.FieldBackIdentityCard)
}

// SetFacePic sets the "face_pic" field.
func (m *FaceMutation) SetFacePic(s string) {
	m.face_pic = &s
}

// FacePic returns the value of the "face_pic" field in the mutation.
func (m *FaceMutation) FacePic() (r string, exists bool) {
	v := m.face_pic
	if v == nil {
		return
	}
	return *v, true
}

// OldFacePic returns the old "face_pic" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldFacePic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacePic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacePic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacePic: %w", err)
	}
	return oldValue.FacePic, nil
}

// ClearFacePic clears the value of the "face_pic" field.
func (m *FaceMutation) ClearFacePic() {
	m.face_pic = nil
	m.clearedFields[face.FieldFacePic] = struct{}{}
}

// FacePicCleared returns if the "face_pic" field was cleared in this mutation.
func (m *FaceMutation) FacePicCleared() bool {
	_, ok := m.clearedFields[face.FieldFacePic]
	return ok
}

// ResetFacePic resets all changes to the "face_pic" field.
func (m *FaceMutation) ResetFacePic() {
	m.face_pic = nil
	delete(m.clearedFields, face.FieldFacePic)
}

// SetFaceEigenvalue sets the "face_eigenvalue" field.
func (m *FaceMutation) SetFaceEigenvalue(s string) {
	m.face_eigenvalue = &s
}

// FaceEigenvalue returns the value of the "face_eigenvalue" field in the mutation.
func (m *FaceMutation) FaceEigenvalue() (r string, exists bool) {
	v := m.face_eigenvalue
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceEigenvalue returns the old "face_eigenvalue" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldFaceEigenvalue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceEigenvalue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceEigenvalue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceEigenvalue: %w", err)
	}
	return oldValue.FaceEigenvalue, nil
}

// ClearFaceEigenvalue clears the value of the "face_eigenvalue" field.
func (m *FaceMutation) ClearFaceEigenvalue() {
	m.face_eigenvalue = nil
	m.clearedFields[face.FieldFaceEigenvalue] = struct{}{}
}

// FaceEigenvalueCleared returns if the "face_eigenvalue" field was cleared in this mutation.
func (m *FaceMutation) FaceEigenvalueCleared() bool {
	_, ok := m.clearedFields[face.FieldFaceEigenvalue]
	return ok
}

// ResetFaceEigenvalue resets all changes to the "face_eigenvalue" field.
func (m *FaceMutation) ResetFaceEigenvalue() {
	m.face_eigenvalue = nil
	delete(m.clearedFields, face.FieldFaceEigenvalue)
}

// SetFacePicUpdatedTime sets the "face_pic_updated_time" field.
func (m *FaceMutation) SetFacePicUpdatedTime(t time.Time) {
	m.face_pic_updated_time = &t
}

// FacePicUpdatedTime returns the value of the "face_pic_updated_time" field in the mutation.
func (m *FaceMutation) FacePicUpdatedTime() (r time.Time, exists bool) {
	v := m.face_pic_updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFacePicUpdatedTime returns the old "face_pic_updated_time" field's value of the Face entity.
// If the Face object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaceMutation) OldFacePicUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacePicUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacePicUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacePicUpdatedTime: %w", err)
	}
	return oldValue.FacePicUpdatedTime, nil
}

// ClearFacePicUpdatedTime clears the value of the "face_pic_updated_time" field.
func (m *FaceMutation) ClearFacePicUpdatedTime() {
	m.face_pic_updated_time = nil
	m.clearedFields[face.FieldFacePicUpdatedTime] = struct{}{}
}

// FacePicUpdatedTimeCleared returns if the "face_pic_updated_time" field was cleared in this mutation.
func (m *FaceMutation) FacePicUpdatedTimeCleared() bool {
	_, ok := m.clearedFields[face.FieldFacePicUpdatedTime]
	return ok
}

// ResetFacePicUpdatedTime resets all changes to the "face_pic_updated_time" field.
func (m *FaceMutation) ResetFacePicUpdatedTime() {
	m.face_pic_updated_time = nil
	delete(m.clearedFields, face.FieldFacePicUpdatedTime)
}

// SetMemberFacesID sets the "member_faces" edge to the Member entity by id.
func (m *FaceMutation) SetMemberFacesID(id int64) {
	m.member_faces = &id
}

// ClearMemberFaces clears the "member_faces" edge to the Member entity.
func (m *FaceMutation) ClearMemberFaces() {
	m.clearedmember_faces = true
	m.clearedFields[face.FieldMemberID] = struct{}{}
}

// MemberFacesCleared reports if the "member_faces" edge to the Member entity was cleared.
func (m *FaceMutation) MemberFacesCleared() bool {
	return m.MemberIDCleared() || m.clearedmember_faces
}

// MemberFacesID returns the "member_faces" edge ID in the mutation.
func (m *FaceMutation) MemberFacesID() (id int64, exists bool) {
	if m.member_faces != nil {
		return *m.member_faces, true
	}
	return
}

// MemberFacesIDs returns the "member_faces" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberFacesID instead. It exists only for internal usage by the builders.
func (m *FaceMutation) MemberFacesIDs() (ids []int64) {
	if id := m.member_faces; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemberFaces resets all changes to the "member_faces" edge.
func (m *FaceMutation) ResetMemberFaces() {
	m.member_faces = nil
	m.clearedmember_faces = false
}

// SetUserFacesID sets the "user_faces" edge to the User entity by id.
func (m *FaceMutation) SetUserFacesID(id int64) {
	m.user_faces = &id
}

// ClearUserFaces clears the "user_faces" edge to the User entity.
func (m *FaceMutation) ClearUserFaces() {
	m.cleareduser_faces = true
	m.clearedFields[face.FieldUserID] = struct{}{}
}

// UserFacesCleared reports if the "user_faces" edge to the User entity was cleared.
func (m *FaceMutation) UserFacesCleared() bool {
	return m.UserIDCleared() || m.cleareduser_faces
}

// UserFacesID returns the "user_faces" edge ID in the mutation.
func (m *FaceMutation) UserFacesID() (id int64, exists bool) {
	if m.user_faces != nil {
		return *m.user_faces, true
	}
	return
}

// UserFacesIDs returns the "user_faces" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserFacesID instead. It exists only for internal usage by the builders.
func (m *FaceMutation) UserFacesIDs() (ids []int64) {
	if id := m.user_faces; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserFaces resets all changes to the "user_faces" edge.
func (m *FaceMutation) ResetUserFaces() {
	m.user_faces = nil
	m.cleareduser_faces = false
}

// Where appends a list predicates to the FaceMutation builder.
func (m *FaceMutation) Where(ps ...predicate.Face) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Face, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Face).
func (m *FaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FaceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, face.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, face.FieldUpdatedAt)
	}
	if m.member_faces != nil {
		fields = append(fields, face.FieldMemberID)
	}
	if m.user_faces != nil {
		fields = append(fields, face.FieldUserID)
	}
	if m.identity_card != nil {
		fields = append(fields, face.FieldIdentityCard)
	}
	if m.face_identity_card != nil {
		fields = append(fields, face.FieldFaceIdentityCard)
	}
	if m.back_identity_card != nil {
		fields = append(fields, face.FieldBackIdentityCard)
	}
	if m.face_pic != nil {
		fields = append(fields, face.FieldFacePic)
	}
	if m.face_eigenvalue != nil {
		fields = append(fields, face.FieldFaceEigenvalue)
	}
	if m.face_pic_updated_time != nil {
		fields = append(fields, face.FieldFacePicUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case face.FieldCreatedAt:
		return m.CreatedAt()
	case face.FieldUpdatedAt:
		return m.UpdatedAt()
	case face.FieldMemberID:
		return m.MemberID()
	case face.FieldUserID:
		return m.UserID()
	case face.FieldIdentityCard:
		return m.IdentityCard()
	case face.FieldFaceIdentityCard:
		return m.FaceIdentityCard()
	case face.FieldBackIdentityCard:
		return m.BackIdentityCard()
	case face.FieldFacePic:
		return m.FacePic()
	case face.FieldFaceEigenvalue:
		return m.FaceEigenvalue()
	case face.FieldFacePicUpdatedTime:
		return m.FacePicUpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case face.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case face.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case face.FieldMemberID:
		return m.OldMemberID(ctx)
	case face.FieldUserID:
		return m.OldUserID(ctx)
	case face.FieldIdentityCard:
		return m.OldIdentityCard(ctx)
	case face.FieldFaceIdentityCard:
		return m.OldFaceIdentityCard(ctx)
	case face.FieldBackIdentityCard:
		return m.OldBackIdentityCard(ctx)
	case face.FieldFacePic:
		return m.OldFacePic(ctx)
	case face.FieldFaceEigenvalue:
		return m.OldFaceEigenvalue(ctx)
	case face.FieldFacePicUpdatedTime:
		return m.OldFacePicUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Face field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case face.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case face.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case face.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case face.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case face.FieldIdentityCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityCard(v)
		return nil
	case face.FieldFaceIdentityCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceIdentityCard(v)
		return nil
	case face.FieldBackIdentityCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackIdentityCard(v)
		return nil
	case face.FieldFacePic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacePic(v)
		return nil
	case face.FieldFaceEigenvalue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceEigenvalue(v)
		return nil
	case face.FieldFacePicUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacePicUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Face field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Face numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(face.FieldMemberID) {
		fields = append(fields, face.FieldMemberID)
	}
	if m.FieldCleared(face.FieldUserID) {
		fields = append(fields, face.FieldUserID)
	}
	if m.FieldCleared(face.FieldIdentityCard) {
		fields = append(fields, face.FieldIdentityCard)
	}
	if m.FieldCleared(face.FieldFaceIdentityCard) {
		fields = append(fields, face.FieldFaceIdentityCard)
	}
	if m.FieldCleared(face.FieldBackIdentityCard) {
		fields = append(fields, face.FieldBackIdentityCard)
	}
	if m.FieldCleared(face.FieldFacePic) {
		fields = append(fields, face.FieldFacePic)
	}
	if m.FieldCleared(face.FieldFaceEigenvalue) {
		fields = append(fields, face.FieldFaceEigenvalue)
	}
	if m.FieldCleared(face.FieldFacePicUpdatedTime) {
		fields = append(fields, face.FieldFacePicUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FaceMutation) ClearField(name string) error {
	switch name {
	case face.FieldMemberID:
		m.ClearMemberID()
		return nil
	case face.FieldUserID:
		m.ClearUserID()
		return nil
	case face.FieldIdentityCard:
		m.ClearIdentityCard()
		return nil
	case face.FieldFaceIdentityCard:
		m.ClearFaceIdentityCard()
		return nil
	case face.FieldBackIdentityCard:
		m.ClearBackIdentityCard()
		return nil
	case face.FieldFacePic:
		m.ClearFacePic()
		return nil
	case face.FieldFaceEigenvalue:
		m.ClearFaceEigenvalue()
		return nil
	case face.FieldFacePicUpdatedTime:
		m.ClearFacePicUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Face nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FaceMutation) ResetField(name string) error {
	switch name {
	case face.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case face.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case face.FieldMemberID:
		m.ResetMemberID()
		return nil
	case face.FieldUserID:
		m.ResetUserID()
		return nil
	case face.FieldIdentityCard:
		m.ResetIdentityCard()
		return nil
	case face.FieldFaceIdentityCard:
		m.ResetFaceIdentityCard()
		return nil
	case face.FieldBackIdentityCard:
		m.ResetBackIdentityCard()
		return nil
	case face.FieldFacePic:
		m.ResetFacePic()
		return nil
	case face.FieldFaceEigenvalue:
		m.ResetFaceEigenvalue()
		return nil
	case face.FieldFacePicUpdatedTime:
		m.ResetFacePicUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Face field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.member_faces != nil {
		edges = append(edges, face.EdgeMemberFaces)
	}
	if m.user_faces != nil {
		edges = append(edges, face.EdgeUserFaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case face.EdgeMemberFaces:
		if id := m.member_faces; id != nil {
			return []ent.Value{*id}
		}
	case face.EdgeUserFaces:
		if id := m.user_faces; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmember_faces {
		edges = append(edges, face.EdgeMemberFaces)
	}
	if m.cleareduser_faces {
		edges = append(edges, face.EdgeUserFaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FaceMutation) EdgeCleared(name string) bool {
	switch name {
	case face.EdgeMemberFaces:
		return m.clearedmember_faces
	case face.EdgeUserFaces:
		return m.cleareduser_faces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FaceMutation) ClearEdge(name string) error {
	switch name {
	case face.EdgeMemberFaces:
		m.ClearMemberFaces()
		return nil
	case face.EdgeUserFaces:
		m.ClearUserFaces()
		return nil
	}
	return fmt.Errorf("unknown Face unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FaceMutation) ResetEdge(name string) error {
	switch name {
	case face.EdgeMemberFaces:
		m.ResetMemberFaces()
		return nil
	case face.EdgeUserFaces:
		m.ResetUserFaces()
		return nil
	}
	return fmt.Errorf("unknown Face edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	status              *int64
	addstatus           *int64
	password            *string
	name                *string
	nickname            *string
	mobile              *string
	avatar              *string
	condition           *int64
	addcondition        *int64
	clearedFields       map[string]struct{}
	member_entry        map[int64]struct{}
	removedmember_entry map[int64]struct{}
	clearedmember_entry bool
	member_face         map[int64]struct{}
	removedmember_face  map[int64]struct{}
	clearedmember_face  bool
	done                bool
	oldValue            func(context.Context) (*Member, error)
	predicates          []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int64) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[member.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[member.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, member.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *MemberMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[member.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *MemberMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[member.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, member.FieldPassword)
}

// SetName sets the "name" field.
func (m *MemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberMutation) ClearName() {
	m.name = nil
	m.clearedFields[member.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberMutation) NameCleared() bool {
	_, ok := m.clearedFields[member.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, member.FieldName)
}

// SetNickname sets the "nickname" field.
func (m *MemberMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *MemberMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *MemberMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[member.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *MemberMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[member.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *MemberMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, member.FieldNickname)
}

// SetMobile sets the "mobile" field.
func (m *MemberMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *MemberMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *MemberMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[member.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *MemberMutation) MobileCleared() bool {
	_, ok := m.clearedFields[member.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *MemberMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, member.FieldMobile)
}

// SetAvatar sets the "avatar" field.
func (m *MemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *MemberMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[member.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *MemberMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[member.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, member.FieldAvatar)
}

// SetCondition sets the "condition" field.
func (m *MemberMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *MemberMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *MemberMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *MemberMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *MemberMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[member.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *MemberMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[member.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *MemberMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, member.FieldCondition)
}

// AddMemberEntryIDs adds the "member_entry" edge to the EntryLogs entity by ids.
func (m *MemberMutation) AddMemberEntryIDs(ids ...int64) {
	if m.member_entry == nil {
		m.member_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_entry[ids[i]] = struct{}{}
	}
}

// ClearMemberEntry clears the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) ClearMemberEntry() {
	m.clearedmember_entry = true
}

// MemberEntryCleared reports if the "member_entry" edge to the EntryLogs entity was cleared.
func (m *MemberMutation) MemberEntryCleared() bool {
	return m.clearedmember_entry
}

// RemoveMemberEntryIDs removes the "member_entry" edge to the EntryLogs entity by IDs.
func (m *MemberMutation) RemoveMemberEntryIDs(ids ...int64) {
	if m.removedmember_entry == nil {
		m.removedmember_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_entry, ids[i])
		m.removedmember_entry[ids[i]] = struct{}{}
	}
}

// RemovedMemberEntry returns the removed IDs of the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) RemovedMemberEntryIDs() (ids []int64) {
	for id := range m.removedmember_entry {
		ids = append(ids, id)
	}
	return
}

// MemberEntryIDs returns the "member_entry" edge IDs in the mutation.
func (m *MemberMutation) MemberEntryIDs() (ids []int64) {
	for id := range m.member_entry {
		ids = append(ids, id)
	}
	return
}

// ResetMemberEntry resets all changes to the "member_entry" edge.
func (m *MemberMutation) ResetMemberEntry() {
	m.member_entry = nil
	m.clearedmember_entry = false
	m.removedmember_entry = nil
}

// AddMemberFaceIDs adds the "member_face" edge to the Face entity by ids.
func (m *MemberMutation) AddMemberFaceIDs(ids ...int64) {
	if m.member_face == nil {
		m.member_face = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_face[ids[i]] = struct{}{}
	}
}

// ClearMemberFace clears the "member_face" edge to the Face entity.
func (m *MemberMutation) ClearMemberFace() {
	m.clearedmember_face = true
}

// MemberFaceCleared reports if the "member_face" edge to the Face entity was cleared.
func (m *MemberMutation) MemberFaceCleared() bool {
	return m.clearedmember_face
}

// RemoveMemberFaceIDs removes the "member_face" edge to the Face entity by IDs.
func (m *MemberMutation) RemoveMemberFaceIDs(ids ...int64) {
	if m.removedmember_face == nil {
		m.removedmember_face = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_face, ids[i])
		m.removedmember_face[ids[i]] = struct{}{}
	}
}

// RemovedMemberFace returns the removed IDs of the "member_face" edge to the Face entity.
func (m *MemberMutation) RemovedMemberFaceIDs() (ids []int64) {
	for id := range m.removedmember_face {
		ids = append(ids, id)
	}
	return
}

// MemberFaceIDs returns the "member_face" edge IDs in the mutation.
func (m *MemberMutation) MemberFaceIDs() (ids []int64) {
	for id := range m.member_face {
		ids = append(ids, id)
	}
	return
}

// ResetMemberFace resets all changes to the "member_face" edge.
func (m *MemberMutation) ResetMemberFace() {
	m.member_face = nil
	m.clearedmember_face = false
	m.removedmember_face = nil
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, member.FieldName)
	}
	if m.nickname != nil {
		fields = append(fields, member.FieldNickname)
	}
	if m.mobile != nil {
		fields = append(fields, member.FieldMobile)
	}
	if m.avatar != nil {
		fields = append(fields, member.FieldAvatar)
	}
	if m.condition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldStatus:
		return m.Status()
	case member.FieldPassword:
		return m.Password()
	case member.FieldName:
		return m.Name()
	case member.FieldNickname:
		return m.Nickname()
	case member.FieldMobile:
		return m.Mobile()
	case member.FieldAvatar:
		return m.Avatar()
	case member.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldStatus:
		return m.OldStatus(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldName:
		return m.OldName(ctx)
	case member.FieldNickname:
		return m.OldNickname(ctx)
	case member.FieldMobile:
		return m.OldMobile(ctx)
	case member.FieldAvatar:
		return m.OldAvatar(ctx)
	case member.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case member.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case member.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case member.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.addcondition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldStatus:
		return m.AddedStatus()
	case member.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldStatus) {
		fields = append(fields, member.FieldStatus)
	}
	if m.FieldCleared(member.FieldPassword) {
		fields = append(fields, member.FieldPassword)
	}
	if m.FieldCleared(member.FieldName) {
		fields = append(fields, member.FieldName)
	}
	if m.FieldCleared(member.FieldNickname) {
		fields = append(fields, member.FieldNickname)
	}
	if m.FieldCleared(member.FieldMobile) {
		fields = append(fields, member.FieldMobile)
	}
	if m.FieldCleared(member.FieldAvatar) {
		fields = append(fields, member.FieldAvatar)
	}
	if m.FieldCleared(member.FieldCondition) {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldStatus:
		m.ClearStatus()
		return nil
	case member.FieldPassword:
		m.ClearPassword()
		return nil
	case member.FieldName:
		m.ClearName()
		return nil
	case member.FieldNickname:
		m.ClearNickname()
		return nil
	case member.FieldMobile:
		m.ClearMobile()
		return nil
	case member.FieldAvatar:
		m.ClearAvatar()
		return nil
	case member.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldStatus:
		m.ResetStatus()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldName:
		m.ResetName()
		return nil
	case member.FieldNickname:
		m.ResetNickname()
		return nil
	case member.FieldMobile:
		m.ResetMobile()
		return nil
	case member.FieldAvatar:
		m.ResetAvatar()
		return nil
	case member.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.member_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.member_face != nil {
		edges = append(edges, member.EdgeMemberFace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.member_entry))
		for id := range m.member_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberFace:
		ids := make([]ent.Value, 0, len(m.member_face))
		for id := range m.member_face {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmember_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.removedmember_face != nil {
		edges = append(edges, member.EdgeMemberFace)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.removedmember_entry))
		for id := range m.removedmember_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberFace:
		ids := make([]ent.Value, 0, len(m.removedmember_face))
		for id := range m.removedmember_face {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmember_entry {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.clearedmember_face {
		edges = append(edges, member.EdgeMemberFace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeMemberEntry:
		return m.clearedmember_entry
	case member.EdgeMemberFace:
		return m.clearedmember_face
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberEntry:
		m.ResetMemberEntry()
		return nil
	case member.EdgeMemberFace:
		m.ResetMemberFace()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// MessagesMutation represents an operation that mutates the Messages nodes in the graph.
type MessagesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	to_user_id    *string
	from_user_id  *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Messages, error)
	predicates    []predicate.Messages
}

var _ ent.Mutation = (*MessagesMutation)(nil)

// messagesOption allows management of the mutation configuration using functional options.
type messagesOption func(*MessagesMutation)

// newMessagesMutation creates new mutation for the Messages entity.
func newMessagesMutation(c config, op Op, opts ...messagesOption) *MessagesMutation {
	m := &MessagesMutation{
		config:        c,
		op:            op,
		typ:           TypeMessages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesID sets the ID field of the mutation.
func withMessagesID(id int64) messagesOption {
	return func(m *MessagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Messages
		)
		m.oldValue = func(ctx context.Context) (*Messages, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Messages.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessages sets the old Messages of the mutation.
func withMessages(node *Messages) messagesOption {
	return func(m *MessagesMutation) {
		m.oldValue = func(context.Context) (*Messages, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Messages entities.
func (m *MessagesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Messages.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *MessagesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessagesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessagesMutation) ResetType() {
	m._type = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *MessagesMutation) SetToUserID(s string) {
	m.to_user_id = &s
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *MessagesMutation) ToUserID() (r string, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldToUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *MessagesMutation) ResetToUserID() {
	m.to_user_id = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *MessagesMutation) SetFromUserID(s string) {
	m.from_user_id = &s
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *MessagesMutation) FromUserID() (r string, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldFromUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *MessagesMutation) ResetFromUserID() {
	m.from_user_id = nil
}

// SetContent sets the "content" field.
func (m *MessagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessagesMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the MessagesMutation builder.
func (m *MessagesMutation) Where(ps ...predicate.Messages) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Messages, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Messages).
func (m *MessagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, messages.FieldType)
	}
	if m.to_user_id != nil {
		fields = append(fields, messages.FieldToUserID)
	}
	if m.from_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.content != nil {
		fields = append(fields, messages.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldCreatedAt:
		return m.CreatedAt()
	case messages.FieldUpdatedAt:
		return m.UpdatedAt()
	case messages.FieldType:
		return m.GetType()
	case messages.FieldToUserID:
		return m.ToUserID()
	case messages.FieldFromUserID:
		return m.FromUserID()
	case messages.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messages.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messages.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messages.FieldType:
		return m.OldType(ctx)
	case messages.FieldToUserID:
		return m.OldToUserID(ctx)
	case messages.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case messages.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Messages field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messages.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messages.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messages.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case messages.FieldToUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case messages.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Messages numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Messages nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesMutation) ResetField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messages.FieldType:
		m.ResetType()
		return nil
	case messages.FieldToUserID:
		m.ResetToUserID()
		return nil
	case messages.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case messages.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Messages unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Messages edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	status              *int64
	addstatus           *int64
	username            *string
	password            *string
	nickname            *string
	side_mode           *string
	base_color          *string
	active_color        *string
	role_id             *int64
	addrole_id          *int64
	mobile              *string
	email               *string
	wecom               *string
	job                 *string
	organization        *string
	default_venue_id    *int64
	adddefault_venue_id *int64
	avatar              *string
	gender              *int64
	addgender           *int64
	birthday            *time.Time
	clearedFields       map[string]struct{}
	user_entry          map[int64]struct{}
	removeduser_entry   map[int64]struct{}
	cleareduser_entry   bool
	user_face           map[int64]struct{}
	removeduser_face    map[int64]struct{}
	cleareduser_face    bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetSideMode sets the "side_mode" field.
func (m *UserMutation) SetSideMode(s string) {
	m.side_mode = &s
}

// SideMode returns the value of the "side_mode" field in the mutation.
func (m *UserMutation) SideMode() (r string, exists bool) {
	v := m.side_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSideMode returns the old "side_mode" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSideMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSideMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSideMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSideMode: %w", err)
	}
	return oldValue.SideMode, nil
}

// ClearSideMode clears the value of the "side_mode" field.
func (m *UserMutation) ClearSideMode() {
	m.side_mode = nil
	m.clearedFields[user.FieldSideMode] = struct{}{}
}

// SideModeCleared returns if the "side_mode" field was cleared in this mutation.
func (m *UserMutation) SideModeCleared() bool {
	_, ok := m.clearedFields[user.FieldSideMode]
	return ok
}

// ResetSideMode resets all changes to the "side_mode" field.
func (m *UserMutation) ResetSideMode() {
	m.side_mode = nil
	delete(m.clearedFields, user.FieldSideMode)
}

// SetBaseColor sets the "base_color" field.
func (m *UserMutation) SetBaseColor(s string) {
	m.base_color = &s
}

// BaseColor returns the value of the "base_color" field in the mutation.
func (m *UserMutation) BaseColor() (r string, exists bool) {
	v := m.base_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseColor returns the old "base_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBaseColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseColor: %w", err)
	}
	return oldValue.BaseColor, nil
}

// ClearBaseColor clears the value of the "base_color" field.
func (m *UserMutation) ClearBaseColor() {
	m.base_color = nil
	m.clearedFields[user.FieldBaseColor] = struct{}{}
}

// BaseColorCleared returns if the "base_color" field was cleared in this mutation.
func (m *UserMutation) BaseColorCleared() bool {
	_, ok := m.clearedFields[user.FieldBaseColor]
	return ok
}

// ResetBaseColor resets all changes to the "base_color" field.
func (m *UserMutation) ResetBaseColor() {
	m.base_color = nil
	delete(m.clearedFields, user.FieldBaseColor)
}

// SetActiveColor sets the "active_color" field.
func (m *UserMutation) SetActiveColor(s string) {
	m.active_color = &s
}

// ActiveColor returns the value of the "active_color" field in the mutation.
func (m *UserMutation) ActiveColor() (r string, exists bool) {
	v := m.active_color
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveColor returns the old "active_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActiveColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveColor: %w", err)
	}
	return oldValue.ActiveColor, nil
}

// ClearActiveColor clears the value of the "active_color" field.
func (m *UserMutation) ClearActiveColor() {
	m.active_color = nil
	m.clearedFields[user.FieldActiveColor] = struct{}{}
}

// ActiveColorCleared returns if the "active_color" field was cleared in this mutation.
func (m *UserMutation) ActiveColorCleared() bool {
	_, ok := m.clearedFields[user.FieldActiveColor]
	return ok
}

// ResetActiveColor resets all changes to the "active_color" field.
func (m *UserMutation) ResetActiveColor() {
	m.active_color = nil
	delete(m.clearedFields, user.FieldActiveColor)
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(i int64) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r int64, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *UserMutation) AddRoleID(i int64) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *UserMutation) AddedRoleID() (r int64, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, user.FieldRoleID)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *UserMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *UserMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *UserMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[user.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *UserMutation) WecomCleared() bool {
	_, ok := m.clearedFields[user.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *UserMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, user.FieldWecom)
}

// SetJob sets the "job" field.
func (m *UserMutation) SetJob(s string) {
	m.job = &s
}

// Job returns the value of the "job" field in the mutation.
func (m *UserMutation) Job() (r string, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJob returns the old "job" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJob(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJob: %w", err)
	}
	return oldValue.Job, nil
}

// ClearJob clears the value of the "job" field.
func (m *UserMutation) ClearJob() {
	m.job = nil
	m.clearedFields[user.FieldJob] = struct{}{}
}

// JobCleared returns if the "job" field was cleared in this mutation.
func (m *UserMutation) JobCleared() bool {
	_, ok := m.clearedFields[user.FieldJob]
	return ok
}

// ResetJob resets all changes to the "job" field.
func (m *UserMutation) ResetJob() {
	m.job = nil
	delete(m.clearedFields, user.FieldJob)
}

// SetOrganization sets the "organization" field.
func (m *UserMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *UserMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *UserMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[user.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *UserMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[user.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, user.FieldOrganization)
}

// SetDefaultVenueID sets the "default_venue_id" field.
func (m *UserMutation) SetDefaultVenueID(i int64) {
	m.default_venue_id = &i
	m.adddefault_venue_id = nil
}

// DefaultVenueID returns the value of the "default_venue_id" field in the mutation.
func (m *UserMutation) DefaultVenueID() (r int64, exists bool) {
	v := m.default_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultVenueID returns the old "default_venue_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDefaultVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultVenueID: %w", err)
	}
	return oldValue.DefaultVenueID, nil
}

// AddDefaultVenueID adds i to the "default_venue_id" field.
func (m *UserMutation) AddDefaultVenueID(i int64) {
	if m.adddefault_venue_id != nil {
		*m.adddefault_venue_id += i
	} else {
		m.adddefault_venue_id = &i
	}
}

// AddedDefaultVenueID returns the value that was added to the "default_venue_id" field in this mutation.
func (m *UserMutation) AddedDefaultVenueID() (r int64, exists bool) {
	v := m.adddefault_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultVenueID clears the value of the "default_venue_id" field.
func (m *UserMutation) ClearDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	m.clearedFields[user.FieldDefaultVenueID] = struct{}{}
}

// DefaultVenueIDCleared returns if the "default_venue_id" field was cleared in this mutation.
func (m *UserMutation) DefaultVenueIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDefaultVenueID]
	return ok
}

// ResetDefaultVenueID resets all changes to the "default_venue_id" field.
func (m *UserMutation) ResetDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	delete(m.clearedFields, user.FieldDefaultVenueID)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *UserMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *UserMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *UserMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *UserMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *UserMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[user.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *UserMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, user.FieldBirthday)
}

// AddUserEntryIDs adds the "user_entry" edge to the EntryLogs entity by ids.
func (m *UserMutation) AddUserEntryIDs(ids ...int64) {
	if m.user_entry == nil {
		m.user_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_entry[ids[i]] = struct{}{}
	}
}

// ClearUserEntry clears the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) ClearUserEntry() {
	m.cleareduser_entry = true
}

// UserEntryCleared reports if the "user_entry" edge to the EntryLogs entity was cleared.
func (m *UserMutation) UserEntryCleared() bool {
	return m.cleareduser_entry
}

// RemoveUserEntryIDs removes the "user_entry" edge to the EntryLogs entity by IDs.
func (m *UserMutation) RemoveUserEntryIDs(ids ...int64) {
	if m.removeduser_entry == nil {
		m.removeduser_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_entry, ids[i])
		m.removeduser_entry[ids[i]] = struct{}{}
	}
}

// RemovedUserEntry returns the removed IDs of the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) RemovedUserEntryIDs() (ids []int64) {
	for id := range m.removeduser_entry {
		ids = append(ids, id)
	}
	return
}

// UserEntryIDs returns the "user_entry" edge IDs in the mutation.
func (m *UserMutation) UserEntryIDs() (ids []int64) {
	for id := range m.user_entry {
		ids = append(ids, id)
	}
	return
}

// ResetUserEntry resets all changes to the "user_entry" edge.
func (m *UserMutation) ResetUserEntry() {
	m.user_entry = nil
	m.cleareduser_entry = false
	m.removeduser_entry = nil
}

// AddUserFaceIDs adds the "user_face" edge to the Face entity by ids.
func (m *UserMutation) AddUserFaceIDs(ids ...int64) {
	if m.user_face == nil {
		m.user_face = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_face[ids[i]] = struct{}{}
	}
}

// ClearUserFace clears the "user_face" edge to the Face entity.
func (m *UserMutation) ClearUserFace() {
	m.cleareduser_face = true
}

// UserFaceCleared reports if the "user_face" edge to the Face entity was cleared.
func (m *UserMutation) UserFaceCleared() bool {
	return m.cleareduser_face
}

// RemoveUserFaceIDs removes the "user_face" edge to the Face entity by IDs.
func (m *UserMutation) RemoveUserFaceIDs(ids ...int64) {
	if m.removeduser_face == nil {
		m.removeduser_face = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_face, ids[i])
		m.removeduser_face[ids[i]] = struct{}{}
	}
}

// RemovedUserFace returns the removed IDs of the "user_face" edge to the Face entity.
func (m *UserMutation) RemovedUserFaceIDs() (ids []int64) {
	for id := range m.removeduser_face {
		ids = append(ids, id)
	}
	return
}

// UserFaceIDs returns the "user_face" edge IDs in the mutation.
func (m *UserMutation) UserFaceIDs() (ids []int64) {
	for id := range m.user_face {
		ids = append(ids, id)
	}
	return
}

// ResetUserFace resets all changes to the "user_face" edge.
func (m *UserMutation) ResetUserFace() {
	m.user_face = nil
	m.cleareduser_face = false
	m.removeduser_face = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.side_mode != nil {
		fields = append(fields, user.FieldSideMode)
	}
	if m.base_color != nil {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.active_color != nil {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.role_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, user.FieldWecom)
	}
	if m.job != nil {
		fields = append(fields, user.FieldJob)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganization)
	}
	if m.default_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldSideMode:
		return m.SideMode()
	case user.FieldBaseColor:
		return m.BaseColor()
	case user.FieldActiveColor:
		return m.ActiveColor()
	case user.FieldRoleID:
		return m.RoleID()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldEmail:
		return m.Email()
	case user.FieldWecom:
		return m.Wecom()
	case user.FieldJob:
		return m.Job()
	case user.FieldOrganization:
		return m.Organization()
	case user.FieldDefaultVenueID:
		return m.DefaultVenueID()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldGender:
		return m.Gender()
	case user.FieldBirthday:
		return m.Birthday()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldSideMode:
		return m.OldSideMode(ctx)
	case user.FieldBaseColor:
		return m.OldBaseColor(ctx)
	case user.FieldActiveColor:
		return m.OldActiveColor(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldWecom:
		return m.OldWecom(ctx)
	case user.FieldJob:
		return m.OldJob(ctx)
	case user.FieldOrganization:
		return m.OldOrganization(ctx)
	case user.FieldDefaultVenueID:
		return m.OldDefaultVenueID(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldSideMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSideMode(v)
		return nil
	case user.FieldBaseColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseColor(v)
		return nil
	case user.FieldActiveColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveColor(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case user.FieldJob:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJob(v)
		return nil
	case user.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultVenueID(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addrole_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.adddefault_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldRoleID:
		return m.AddedRoleID()
	case user.FieldDefaultVenueID:
		return m.AddedDefaultVenueID()
	case user.FieldGender:
		return m.AddedGender()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultVenueID(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldSideMode) {
		fields = append(fields, user.FieldSideMode)
	}
	if m.FieldCleared(user.FieldBaseColor) {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.FieldCleared(user.FieldActiveColor) {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.FieldCleared(user.FieldRoleID) {
		fields = append(fields, user.FieldRoleID)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldWecom) {
		fields = append(fields, user.FieldWecom)
	}
	if m.FieldCleared(user.FieldJob) {
		fields = append(fields, user.FieldJob)
	}
	if m.FieldCleared(user.FieldOrganization) {
		fields = append(fields, user.FieldOrganization)
	}
	if m.FieldCleared(user.FieldDefaultVenueID) {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldBirthday) {
		fields = append(fields, user.FieldBirthday)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldSideMode:
		m.ClearSideMode()
		return nil
	case user.FieldBaseColor:
		m.ClearBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ClearActiveColor()
		return nil
	case user.FieldRoleID:
		m.ClearRoleID()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldWecom:
		m.ClearWecom()
		return nil
	case user.FieldJob:
		m.ClearJob()
		return nil
	case user.FieldOrganization:
		m.ClearOrganization()
		return nil
	case user.FieldDefaultVenueID:
		m.ClearDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldBirthday:
		m.ClearBirthday()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldSideMode:
		m.ResetSideMode()
		return nil
	case user.FieldBaseColor:
		m.ResetBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ResetActiveColor()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldWecom:
		m.ResetWecom()
		return nil
	case user.FieldJob:
		m.ResetJob()
		return nil
	case user.FieldOrganization:
		m.ResetOrganization()
		return nil
	case user.FieldDefaultVenueID:
		m.ResetDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	if m.user_face != nil {
		edges = append(edges, user.EdgeUserFace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.user_entry))
		for id := range m.user_entry {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserFace:
		ids := make([]ent.Value, 0, len(m.user_face))
		for id := range m.user_face {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	if m.removeduser_face != nil {
		edges = append(edges, user.EdgeUserFace)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.removeduser_entry))
		for id := range m.removeduser_entry {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserFace:
		ids := make([]ent.Value, 0, len(m.removeduser_face))
		for id := range m.removeduser_face {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_entry {
		edges = append(edges, user.EdgeUserEntry)
	}
	if m.cleareduser_face {
		edges = append(edges, user.EdgeUserFace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserEntry:
		return m.cleareduser_entry
	case user.EdgeUserFace:
		return m.cleareduser_face
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserEntry:
		m.ResetUserEntry()
		return nil
	case user.EdgeUserFace:
		m.ResetUserFace()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VenueMutation represents an operation that mutates the Venue nodes in the graph.
type VenueMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_at         *time.Time
	updated_at         *time.Time
	status             *int64
	addstatus          *int64
	name               *string
	address            *string
	address_detail     *string
	latitude           *string
	longitude          *string
	mobile             *string
	pic                *string
	information        *string
	clearedFields      map[string]struct{}
	places             map[int64]struct{}
	removedplaces      map[int64]struct{}
	clearedplaces      bool
	venue_entry        map[int64]struct{}
	removedvenue_entry map[int64]struct{}
	clearedvenue_entry bool
	done               bool
	oldValue           func(context.Context) (*Venue, error)
	predicates         []predicate.Venue
}

var _ ent.Mutation = (*VenueMutation)(nil)

// venueOption allows management of the mutation configuration using functional options.
type venueOption func(*VenueMutation)

// newVenueMutation creates new mutation for the Venue entity.
func newVenueMutation(c config, op Op, opts ...venueOption) *VenueMutation {
	m := &VenueMutation{
		config:        c,
		op:            op,
		typ:           TypeVenue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueID sets the ID field of the mutation.
func withVenueID(id int64) venueOption {
	return func(m *VenueMutation) {
		var (
			err   error
			once  sync.Once
			value *Venue
		)
		m.oldValue = func(ctx context.Context) (*Venue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Venue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenue sets the old Venue of the mutation.
func withVenue(node *Venue) venueOption {
	return func(m *VenueMutation) {
		m.oldValue = func(context.Context) (*Venue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Venue entities.
func (m *VenueMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Venue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *VenueMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenueMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenueMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenueMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenueMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venue.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenueMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venue.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenueMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venue.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenueMutation) ClearName() {
	m.name = nil
	m.clearedFields[venue.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenueMutation) NameCleared() bool {
	_, ok := m.clearedFields[venue.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenueMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venue.FieldName)
}

// SetAddress sets the "address" field.
func (m *VenueMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VenueMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VenueMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[venue.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VenueMutation) AddressCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VenueMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, venue.FieldAddress)
}

// SetAddressDetail sets the "address_detail" field.
func (m *VenueMutation) SetAddressDetail(s string) {
	m.address_detail = &s
}

// AddressDetail returns the value of the "address_detail" field in the mutation.
func (m *VenueMutation) AddressDetail() (r string, exists bool) {
	v := m.address_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "address_detail" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddressDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "address_detail" field.
func (m *VenueMutation) ClearAddressDetail() {
	m.address_detail = nil
	m.clearedFields[venue.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "address_detail" field was cleared in this mutation.
func (m *VenueMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "address_detail" field.
func (m *VenueMutation) ResetAddressDetail() {
	m.address_detail = nil
	delete(m.clearedFields, venue.FieldAddressDetail)
}

// SetLatitude sets the "latitude" field.
func (m *VenueMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *VenueMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *VenueMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[venue.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *VenueMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *VenueMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, venue.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *VenueMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *VenueMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *VenueMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[venue.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *VenueMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *VenueMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, venue.FieldLongitude)
}

// SetMobile sets the "mobile" field.
func (m *VenueMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *VenueMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *VenueMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[venue.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *VenueMutation) MobileCleared() bool {
	_, ok := m.clearedFields[venue.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *VenueMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, venue.FieldMobile)
}

// SetPic sets the "pic" field.
func (m *VenueMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenueMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenueMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venue.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenueMutation) PicCleared() bool {
	_, ok := m.clearedFields[venue.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenueMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venue.FieldPic)
}

// SetInformation sets the "information" field.
func (m *VenueMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the value of the "information" field in the mutation.
func (m *VenueMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old "information" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ClearInformation clears the value of the "information" field.
func (m *VenueMutation) ClearInformation() {
	m.information = nil
	m.clearedFields[venue.FieldInformation] = struct{}{}
}

// InformationCleared returns if the "information" field was cleared in this mutation.
func (m *VenueMutation) InformationCleared() bool {
	_, ok := m.clearedFields[venue.FieldInformation]
	return ok
}

// ResetInformation resets all changes to the "information" field.
func (m *VenueMutation) ResetInformation() {
	m.information = nil
	delete(m.clearedFields, venue.FieldInformation)
}

// AddPlaceIDs adds the "places" edge to the VenuePlace entity by ids.
func (m *VenueMutation) AddPlaceIDs(ids ...int64) {
	if m.places == nil {
		m.places = make(map[int64]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the VenuePlace entity.
func (m *VenueMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the VenuePlace entity was cleared.
func (m *VenueMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the VenuePlace entity by IDs.
func (m *VenueMutation) RemovePlaceIDs(ids ...int64) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the VenuePlace entity.
func (m *VenueMutation) RemovedPlacesIDs() (ids []int64) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *VenueMutation) PlacesIDs() (ids []int64) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *VenueMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddVenueEntryIDs adds the "venue_entry" edge to the EntryLogs entity by ids.
func (m *VenueMutation) AddVenueEntryIDs(ids ...int64) {
	if m.venue_entry == nil {
		m.venue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.venue_entry[ids[i]] = struct{}{}
	}
}

// ClearVenueEntry clears the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) ClearVenueEntry() {
	m.clearedvenue_entry = true
}

// VenueEntryCleared reports if the "venue_entry" edge to the EntryLogs entity was cleared.
func (m *VenueMutation) VenueEntryCleared() bool {
	return m.clearedvenue_entry
}

// RemoveVenueEntryIDs removes the "venue_entry" edge to the EntryLogs entity by IDs.
func (m *VenueMutation) RemoveVenueEntryIDs(ids ...int64) {
	if m.removedvenue_entry == nil {
		m.removedvenue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venue_entry, ids[i])
		m.removedvenue_entry[ids[i]] = struct{}{}
	}
}

// RemovedVenueEntry returns the removed IDs of the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) RemovedVenueEntryIDs() (ids []int64) {
	for id := range m.removedvenue_entry {
		ids = append(ids, id)
	}
	return
}

// VenueEntryIDs returns the "venue_entry" edge IDs in the mutation.
func (m *VenueMutation) VenueEntryIDs() (ids []int64) {
	for id := range m.venue_entry {
		ids = append(ids, id)
	}
	return
}

// ResetVenueEntry resets all changes to the "venue_entry" edge.
func (m *VenueMutation) ResetVenueEntry() {
	m.venue_entry = nil
	m.clearedvenue_entry = false
	m.removedvenue_entry = nil
}

// Where appends a list predicates to the VenueMutation builder.
func (m *VenueMutation) Where(ps ...predicate.Venue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Venue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Venue).
func (m *VenueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, venue.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venue.FieldName)
	}
	if m.address != nil {
		fields = append(fields, venue.FieldAddress)
	}
	if m.address_detail != nil {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.latitude != nil {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.mobile != nil {
		fields = append(fields, venue.FieldMobile)
	}
	if m.pic != nil {
		fields = append(fields, venue.FieldPic)
	}
	if m.information != nil {
		fields = append(fields, venue.FieldInformation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldCreatedAt:
		return m.CreatedAt()
	case venue.FieldUpdatedAt:
		return m.UpdatedAt()
	case venue.FieldStatus:
		return m.Status()
	case venue.FieldName:
		return m.Name()
	case venue.FieldAddress:
		return m.Address()
	case venue.FieldAddressDetail:
		return m.AddressDetail()
	case venue.FieldLatitude:
		return m.Latitude()
	case venue.FieldLongitude:
		return m.Longitude()
	case venue.FieldMobile:
		return m.Mobile()
	case venue.FieldPic:
		return m.Pic()
	case venue.FieldInformation:
		return m.Information()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venue.FieldStatus:
		return m.OldStatus(ctx)
	case venue.FieldName:
		return m.OldName(ctx)
	case venue.FieldAddress:
		return m.OldAddress(ctx)
	case venue.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case venue.FieldLatitude:
		return m.OldLatitude(ctx)
	case venue.FieldLongitude:
		return m.OldLongitude(ctx)
	case venue.FieldMobile:
		return m.OldMobile(ctx)
	case venue.FieldPic:
		return m.OldPic(ctx)
	case venue.FieldInformation:
		return m.OldInformation(ctx)
	}
	return nil, fmt.Errorf("unknown Venue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venue.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case venue.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case venue.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case venue.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case venue.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case venue.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venue.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, venue.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Venue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venue.FieldStatus) {
		fields = append(fields, venue.FieldStatus)
	}
	if m.FieldCleared(venue.FieldName) {
		fields = append(fields, venue.FieldName)
	}
	if m.FieldCleared(venue.FieldAddress) {
		fields = append(fields, venue.FieldAddress)
	}
	if m.FieldCleared(venue.FieldAddressDetail) {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.FieldCleared(venue.FieldLatitude) {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.FieldCleared(venue.FieldLongitude) {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.FieldCleared(venue.FieldMobile) {
		fields = append(fields, venue.FieldMobile)
	}
	if m.FieldCleared(venue.FieldPic) {
		fields = append(fields, venue.FieldPic)
	}
	if m.FieldCleared(venue.FieldInformation) {
		fields = append(fields, venue.FieldInformation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueMutation) ClearField(name string) error {
	switch name {
	case venue.FieldStatus:
		m.ClearStatus()
		return nil
	case venue.FieldName:
		m.ClearName()
		return nil
	case venue.FieldAddress:
		m.ClearAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ClearLatitude()
		return nil
	case venue.FieldLongitude:
		m.ClearLongitude()
		return nil
	case venue.FieldMobile:
		m.ClearMobile()
		return nil
	case venue.FieldPic:
		m.ClearPic()
		return nil
	case venue.FieldInformation:
		m.ClearInformation()
		return nil
	}
	return fmt.Errorf("unknown Venue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueMutation) ResetField(name string) error {
	switch name {
	case venue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venue.FieldStatus:
		m.ResetStatus()
		return nil
	case venue.FieldName:
		m.ResetName()
		return nil
	case venue.FieldAddress:
		m.ResetAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ResetLatitude()
		return nil
	case venue.FieldLongitude:
		m.ResetLongitude()
		return nil
	case venue.FieldMobile:
		m.ResetMobile()
		return nil
	case venue.FieldPic:
		m.ResetPic()
		return nil
	case venue.FieldInformation:
		m.ResetInformation()
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.places != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.venue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.venue_entry))
		for id := range m.venue_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedplaces != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.removedvenue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.removedvenue_entry))
		for id := range m.removedvenue_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplaces {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.clearedvenue_entry {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueMutation) EdgeCleared(name string) bool {
	switch name {
	case venue.EdgePlaces:
		return m.clearedplaces
	case venue.EdgeVenueEntry:
		return m.clearedvenue_entry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Venue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueMutation) ResetEdge(name string) error {
	switch name {
	case venue.EdgePlaces:
		m.ResetPlaces()
		return nil
	case venue.EdgeVenueEntry:
		m.ResetVenueEntry()
		return nil
	}
	return fmt.Errorf("unknown Venue edge %s", name)
}

// VenuePlaceMutation represents an operation that mutates the VenuePlace nodes in the graph.
type VenuePlaceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int64
	addstatus     *int64
	name          *string
	pic           *string
	clearedFields map[string]struct{}
	venue         *int64
	clearedvenue  bool
	done          bool
	oldValue      func(context.Context) (*VenuePlace, error)
	predicates    []predicate.VenuePlace
}

var _ ent.Mutation = (*VenuePlaceMutation)(nil)

// venueplaceOption allows management of the mutation configuration using functional options.
type venueplaceOption func(*VenuePlaceMutation)

// newVenuePlaceMutation creates new mutation for the VenuePlace entity.
func newVenuePlaceMutation(c config, op Op, opts ...venueplaceOption) *VenuePlaceMutation {
	m := &VenuePlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeVenuePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenuePlaceID sets the ID field of the mutation.
func withVenuePlaceID(id int64) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *VenuePlace
		)
		m.oldValue = func(ctx context.Context) (*VenuePlace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VenuePlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenuePlace sets the old VenuePlace of the mutation.
func withVenuePlace(node *VenuePlace) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		m.oldValue = func(context.Context) (*VenuePlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenuePlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenuePlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VenuePlace entities.
func (m *VenuePlaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenuePlaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenuePlaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VenuePlace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenuePlaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenuePlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenuePlaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenuePlaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenuePlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenuePlaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *VenuePlaceMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenuePlaceMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenuePlaceMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenuePlaceMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenuePlaceMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venueplace.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenuePlaceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenuePlaceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venueplace.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenuePlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenuePlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenuePlaceMutation) ClearName() {
	m.name = nil
	m.clearedFields[venueplace.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenuePlaceMutation) NameCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenuePlaceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venueplace.FieldName)
}

// SetPic sets the "pic" field.
func (m *VenuePlaceMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenuePlaceMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenuePlaceMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venueplace.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenuePlaceMutation) PicCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenuePlaceMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venueplace.FieldPic)
}

// SetVenueID sets the "venue_id" field.
func (m *VenuePlaceMutation) SetVenueID(i int64) {
	m.venue = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenuePlaceMutation) VenueID() (r int64, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *VenuePlaceMutation) ClearVenueID() {
	m.venue = nil
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *VenuePlaceMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenuePlaceMutation) ResetVenueID() {
	m.venue = nil
	delete(m.clearedFields, venueplace.FieldVenueID)
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *VenuePlaceMutation) ClearVenue() {
	m.clearedvenue = true
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *VenuePlaceMutation) VenueCleared() bool {
	return m.VenueIDCleared() || m.clearedvenue
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *VenuePlaceMutation) VenueIDs() (ids []int64) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *VenuePlaceMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// Where appends a list predicates to the VenuePlaceMutation builder.
func (m *VenuePlaceMutation) Where(ps ...predicate.VenuePlace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenuePlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenuePlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VenuePlace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenuePlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenuePlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VenuePlace).
func (m *VenuePlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenuePlaceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, venueplace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venueplace.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venueplace.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.venue != nil {
		fields = append(fields, venueplace.FieldVenueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenuePlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.CreatedAt()
	case venueplace.FieldUpdatedAt:
		return m.UpdatedAt()
	case venueplace.FieldStatus:
		return m.Status()
	case venueplace.FieldName:
		return m.Name()
	case venueplace.FieldPic:
		return m.Pic()
	case venueplace.FieldVenueID:
		return m.VenueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenuePlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venueplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venueplace.FieldStatus:
		return m.OldStatus(ctx)
	case venueplace.FieldName:
		return m.OldName(ctx)
	case venueplace.FieldPic:
		return m.OldPic(ctx)
	case venueplace.FieldVenueID:
		return m.OldVenueID(ctx)
	}
	return nil, fmt.Errorf("unknown VenuePlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venueplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venueplace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venueplace.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venueplace.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenuePlaceMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenuePlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenuePlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venueplace.FieldStatus) {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.FieldCleared(venueplace.FieldName) {
		fields = append(fields, venueplace.FieldName)
	}
	if m.FieldCleared(venueplace.FieldPic) {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.FieldCleared(venueplace.FieldVenueID) {
		fields = append(fields, venueplace.FieldVenueID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenuePlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ClearField(name string) error {
	switch name {
	case venueplace.FieldStatus:
		m.ClearStatus()
		return nil
	case venueplace.FieldName:
		m.ClearName()
		return nil
	case venueplace.FieldPic:
		m.ClearPic()
		return nil
	case venueplace.FieldVenueID:
		m.ClearVenueID()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ResetField(name string) error {
	switch name {
	case venueplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venueplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venueplace.FieldStatus:
		m.ResetStatus()
		return nil
	case venueplace.FieldName:
		m.ResetName()
		return nil
	case venueplace.FieldPic:
		m.ResetPic()
		return nil
	case venueplace.FieldVenueID:
		m.ResetVenueID()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenuePlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.venue != nil {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenuePlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venueplace.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenuePlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenuePlaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenuePlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvenue {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenuePlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case venueplace.EdgeVenue:
		return m.clearedvenue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenuePlaceMutation) ClearEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenuePlaceMutation) ResetEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ResetVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace edge %s", name)
}
