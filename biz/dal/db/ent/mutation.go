// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"saas/biz/dal/db/ent/api"
	"saas/biz/dal/db/ent/banner"
	"saas/biz/dal/db/ent/bootcamp"
	"saas/biz/dal/db/ent/bootcampparticipant"
	"saas/biz/dal/db/ent/community"
	"saas/biz/dal/db/ent/communityparticipant"
	"saas/biz/dal/db/ent/contest"
	"saas/biz/dal/db/ent/contestparticipant"
	"saas/biz/dal/db/ent/contract"
	"saas/biz/dal/db/ent/dictionary"
	"saas/biz/dal/db/ent/dictionarydetail"
	"saas/biz/dal/db/ent/entrylogs"
	"saas/biz/dal/db/ent/logs"
	"saas/biz/dal/db/ent/member"
	"saas/biz/dal/db/ent/membercontract"
	"saas/biz/dal/db/ent/membercontractcontent"
	"saas/biz/dal/db/ent/memberdetails"
	"saas/biz/dal/db/ent/membernote"
	"saas/biz/dal/db/ent/memberproduct"
	"saas/biz/dal/db/ent/memberproductcourses"
	"saas/biz/dal/db/ent/memberprofile"
	"saas/biz/dal/db/ent/menu"
	"saas/biz/dal/db/ent/menuparam"
	"saas/biz/dal/db/ent/messages"
	"saas/biz/dal/db/ent/order"
	"saas/biz/dal/db/ent/orderamount"
	"saas/biz/dal/db/ent/orderitem"
	"saas/biz/dal/db/ent/orderpay"
	"saas/biz/dal/db/ent/ordersales"
	"saas/biz/dal/db/ent/predicate"
	"saas/biz/dal/db/ent/product"
	"saas/biz/dal/db/ent/productcourses"
	"saas/biz/dal/db/ent/role"
	"saas/biz/dal/db/ent/schedule"
	"saas/biz/dal/db/ent/schedulecoach"
	"saas/biz/dal/db/ent/schedulemember"
	"saas/biz/dal/db/ent/token"
	"saas/biz/dal/db/ent/user"
	"saas/biz/dal/db/ent/usertimeperiod"
	"saas/biz/dal/db/ent/venue"
	"saas/biz/dal/db/ent/venueplace"
	"saas/biz/dal/db/ent/venuesms"
	"saas/biz/dal/db/ent/venuesmslog"
	"saas/idl_gen/model/base"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI                   = "API"
	TypeBanner                = "Banner"
	TypeBootcamp              = "Bootcamp"
	TypeBootcampParticipant   = "BootcampParticipant"
	TypeCommunity             = "Community"
	TypeCommunityParticipant  = "CommunityParticipant"
	TypeContest               = "Contest"
	TypeContestParticipant    = "ContestParticipant"
	TypeContract              = "Contract"
	TypeDictionary            = "Dictionary"
	TypeDictionaryDetail      = "DictionaryDetail"
	TypeEntryLogs             = "EntryLogs"
	TypeLogs                  = "Logs"
	TypeMember                = "Member"
	TypeMemberContract        = "MemberContract"
	TypeMemberContractContent = "MemberContractContent"
	TypeMemberDetails         = "MemberDetails"
	TypeMemberNote            = "MemberNote"
	TypeMemberProduct         = "MemberProduct"
	TypeMemberProductCourses  = "MemberProductCourses"
	TypeMemberProfile         = "MemberProfile"
	TypeMenu                  = "Menu"
	TypeMenuParam             = "MenuParam"
	TypeMessages              = "Messages"
	TypeOrder                 = "Order"
	TypeOrderAmount           = "OrderAmount"
	TypeOrderItem             = "OrderItem"
	TypeOrderPay              = "OrderPay"
	TypeOrderSales            = "OrderSales"
	TypeProduct               = "Product"
	TypeProductCourses        = "ProductCourses"
	TypeRole                  = "Role"
	TypeSchedule              = "Schedule"
	TypeScheduleCoach         = "ScheduleCoach"
	TypeScheduleMember        = "ScheduleMember"
	TypeToken                 = "Token"
	TypeUser                  = "User"
	TypeUserTimePeriod        = "UserTimePeriod"
	TypeVenue                 = "Venue"
	TypeVenuePlace            = "VenuePlace"
	TypeVenueSms              = "VenueSms"
	TypeVenueSmsLog           = "VenueSmsLog"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_path         *string
	title         *string
	description   *string
	api_group     *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *APIMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[api.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *APIMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, api.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *APIMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[api.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *APIMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, api.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *APIMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *APIMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *APIMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *APIMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *APIMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[api.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *APIMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[api.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *APIMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, api.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *APIMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *APIMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *APIMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *APIMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *APIMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[api.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *APIMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *APIMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, api.FieldCreatedID)
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetTitle sets the "title" field.
func (m *APIMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *APIMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *APIMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.title != nil {
		fields = append(fields, api.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldDelete:
		return m.Delete()
	case api.FieldCreatedID:
		return m.CreatedID()
	case api.FieldPath:
		return m.Path()
	case api.FieldTitle:
		return m.Title()
	case api.FieldDescription:
		return m.Description()
	case api.FieldAPIGroup:
		return m.APIGroup()
	case api.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldDelete:
		return m.OldDelete(ctx)
	case api.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldTitle:
		return m.OldTitle(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldDelete:
		return m.AddedDelete()
	case api.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldCreatedAt) {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.FieldCleared(api.FieldUpdatedAt) {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.FieldCleared(api.FieldDelete) {
		fields = append(fields, api.FieldDelete)
	}
	if m.FieldCleared(api.FieldCreatedID) {
		fields = append(fields, api.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ClearDelete()
		return nil
	case api.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ResetDelete()
		return nil
	case api.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldTitle:
		m.ResetTitle()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	name          *string
	pic           *string
	link          *string
	is_show       *int64
	addis_show    *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Banner, error)
	predicates    []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id int64) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Banner entities.
func (m *BannerMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Banner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BannerMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[banner.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BannerMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[banner.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, banner.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BannerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[banner.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BannerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[banner.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, banner.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *BannerMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *BannerMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *BannerMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *BannerMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *BannerMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[banner.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *BannerMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[banner.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *BannerMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, banner.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *BannerMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *BannerMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *BannerMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *BannerMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *BannerMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[banner.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *BannerMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[banner.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *BannerMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, banner.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *BannerMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BannerMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BannerMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BannerMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BannerMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[banner.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BannerMutation) StatusCleared() bool {
	_, ok := m.clearedFields[banner.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BannerMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, banner.FieldStatus)
}

// SetName sets the "name" field.
func (m *BannerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerMutation) ResetName() {
	m.name = nil
}

// SetPic sets the "pic" field.
func (m *BannerMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *BannerMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ResetPic resets all changes to the "pic" field.
func (m *BannerMutation) ResetPic() {
	m.pic = nil
}

// SetLink sets the "link" field.
func (m *BannerMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *BannerMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *BannerMutation) ResetLink() {
	m.link = nil
}

// SetIsShow sets the "is_show" field.
func (m *BannerMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *BannerMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *BannerMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *BannerMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *BannerMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[banner.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *BannerMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[banner.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *BannerMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, banner.FieldIsShow)
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Banner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, banner.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, banner.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, banner.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, banner.FieldPic)
	}
	if m.link != nil {
		fields = append(fields, banner.FieldLink)
	}
	if m.is_show != nil {
		fields = append(fields, banner.FieldIsShow)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldCreatedAt:
		return m.CreatedAt()
	case banner.FieldUpdatedAt:
		return m.UpdatedAt()
	case banner.FieldDelete:
		return m.Delete()
	case banner.FieldCreatedID:
		return m.CreatedID()
	case banner.FieldStatus:
		return m.Status()
	case banner.FieldName:
		return m.Name()
	case banner.FieldPic:
		return m.Pic()
	case banner.FieldLink:
		return m.Link()
	case banner.FieldIsShow:
		return m.IsShow()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banner.FieldDelete:
		return m.OldDelete(ctx)
	case banner.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case banner.FieldStatus:
		return m.OldStatus(ctx)
	case banner.FieldName:
		return m.OldName(ctx)
	case banner.FieldPic:
		return m.OldPic(ctx)
	case banner.FieldLink:
		return m.OldLink(ctx)
	case banner.FieldIsShow:
		return m.OldIsShow(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banner.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case banner.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case banner.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case banner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case banner.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case banner.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case banner.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, banner.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, banner.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.addis_show != nil {
		fields = append(fields, banner.FieldIsShow)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldDelete:
		return m.AddedDelete()
	case banner.FieldCreatedID:
		return m.AddedCreatedID()
	case banner.FieldStatus:
		return m.AddedStatus()
	case banner.FieldIsShow:
		return m.AddedIsShow()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banner.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case banner.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case banner.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case banner.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banner.FieldCreatedAt) {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.FieldCleared(banner.FieldUpdatedAt) {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	if m.FieldCleared(banner.FieldDelete) {
		fields = append(fields, banner.FieldDelete)
	}
	if m.FieldCleared(banner.FieldCreatedID) {
		fields = append(fields, banner.FieldCreatedID)
	}
	if m.FieldCleared(banner.FieldStatus) {
		fields = append(fields, banner.FieldStatus)
	}
	if m.FieldCleared(banner.FieldIsShow) {
		fields = append(fields, banner.FieldIsShow)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	switch name {
	case banner.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case banner.FieldDelete:
		m.ClearDelete()
		return nil
	case banner.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case banner.FieldStatus:
		m.ClearStatus()
		return nil
	case banner.FieldIsShow:
		m.ClearIsShow()
		return nil
	}
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banner.FieldDelete:
		m.ResetDelete()
		return nil
	case banner.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case banner.FieldStatus:
		m.ResetStatus()
		return nil
	case banner.FieldName:
		m.ResetName()
		return nil
	case banner.FieldPic:
		m.ResetPic()
		return nil
	case banner.FieldLink:
		m.ResetLink()
		return nil
	case banner.FieldIsShow:
		m.ResetIsShow()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Banner edge %s", name)
}

// BootcampMutation represents an operation that mutates the Bootcamp nodes in the graph.
type BootcampMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	delete                       *int64
	adddelete                    *int64
	created_id                   *int64
	addcreated_id                *int64
	status                       *int64
	addstatus                    *int64
	name                         *string
	sign_number                  *int64
	addsign_number               *int64
	sign_start_at                *time.Time
	sign_end_at                  *time.Time
	start_at                     *time.Time
	end_at                       *time.Time
	pic                          *string
	fee                          *float64
	addfee                       *float64
	is_fee                       *int64
	addis_fee                    *int64
	is_show                      *int64
	addis_show                   *int64
	is_cancel                    *int64
	addis_cancel                 *int64
	cancel_time                  *int64
	addcancel_time               *int64
	detail                       *string
	sign_fields                  *string
	condition                    *int64
	addcondition                 *int64
	clearedFields                map[string]struct{}
	bootcamp_participants        map[int64]struct{}
	removedbootcamp_participants map[int64]struct{}
	clearedbootcamp_participants bool
	done                         bool
	oldValue                     func(context.Context) (*Bootcamp, error)
	predicates                   []predicate.Bootcamp
}

var _ ent.Mutation = (*BootcampMutation)(nil)

// bootcampOption allows management of the mutation configuration using functional options.
type bootcampOption func(*BootcampMutation)

// newBootcampMutation creates new mutation for the Bootcamp entity.
func newBootcampMutation(c config, op Op, opts ...bootcampOption) *BootcampMutation {
	m := &BootcampMutation{
		config:        c,
		op:            op,
		typ:           TypeBootcamp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBootcampID sets the ID field of the mutation.
func withBootcampID(id int64) bootcampOption {
	return func(m *BootcampMutation) {
		var (
			err   error
			once  sync.Once
			value *Bootcamp
		)
		m.oldValue = func(ctx context.Context) (*Bootcamp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bootcamp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBootcamp sets the old Bootcamp of the mutation.
func withBootcamp(node *Bootcamp) bootcampOption {
	return func(m *BootcampMutation) {
		m.oldValue = func(context.Context) (*Bootcamp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BootcampMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BootcampMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bootcamp entities.
func (m *BootcampMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BootcampMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BootcampMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bootcamp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BootcampMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BootcampMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BootcampMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[bootcamp.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BootcampMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BootcampMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, bootcamp.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BootcampMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BootcampMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BootcampMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[bootcamp.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BootcampMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BootcampMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, bootcamp.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *BootcampMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *BootcampMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *BootcampMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *BootcampMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *BootcampMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[bootcamp.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *BootcampMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *BootcampMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, bootcamp.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *BootcampMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *BootcampMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *BootcampMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *BootcampMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *BootcampMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[bootcamp.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *BootcampMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *BootcampMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, bootcamp.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *BootcampMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BootcampMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BootcampMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BootcampMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BootcampMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[bootcamp.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BootcampMutation) StatusCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BootcampMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, bootcamp.FieldStatus)
}

// SetName sets the "name" field.
func (m *BootcampMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BootcampMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *BootcampMutation) ClearName() {
	m.name = nil
	m.clearedFields[bootcamp.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *BootcampMutation) NameCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *BootcampMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, bootcamp.FieldName)
}

// SetSignNumber sets the "sign_number" field.
func (m *BootcampMutation) SetSignNumber(i int64) {
	m.sign_number = &i
	m.addsign_number = nil
}

// SignNumber returns the value of the "sign_number" field in the mutation.
func (m *BootcampMutation) SignNumber() (r int64, exists bool) {
	v := m.sign_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSignNumber returns the old "sign_number" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignNumber: %w", err)
	}
	return oldValue.SignNumber, nil
}

// AddSignNumber adds i to the "sign_number" field.
func (m *BootcampMutation) AddSignNumber(i int64) {
	if m.addsign_number != nil {
		*m.addsign_number += i
	} else {
		m.addsign_number = &i
	}
}

// AddedSignNumber returns the value that was added to the "sign_number" field in this mutation.
func (m *BootcampMutation) AddedSignNumber() (r int64, exists bool) {
	v := m.addsign_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearSignNumber clears the value of the "sign_number" field.
func (m *BootcampMutation) ClearSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	m.clearedFields[bootcamp.FieldSignNumber] = struct{}{}
}

// SignNumberCleared returns if the "sign_number" field was cleared in this mutation.
func (m *BootcampMutation) SignNumberCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignNumber]
	return ok
}

// ResetSignNumber resets all changes to the "sign_number" field.
func (m *BootcampMutation) ResetSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	delete(m.clearedFields, bootcamp.FieldSignNumber)
}

// SetSignStartAt sets the "sign_start_at" field.
func (m *BootcampMutation) SetSignStartAt(t time.Time) {
	m.sign_start_at = &t
}

// SignStartAt returns the value of the "sign_start_at" field in the mutation.
func (m *BootcampMutation) SignStartAt() (r time.Time, exists bool) {
	v := m.sign_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartAt returns the old "sign_start_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartAt: %w", err)
	}
	return oldValue.SignStartAt, nil
}

// ClearSignStartAt clears the value of the "sign_start_at" field.
func (m *BootcampMutation) ClearSignStartAt() {
	m.sign_start_at = nil
	m.clearedFields[bootcamp.FieldSignStartAt] = struct{}{}
}

// SignStartAtCleared returns if the "sign_start_at" field was cleared in this mutation.
func (m *BootcampMutation) SignStartAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignStartAt]
	return ok
}

// ResetSignStartAt resets all changes to the "sign_start_at" field.
func (m *BootcampMutation) ResetSignStartAt() {
	m.sign_start_at = nil
	delete(m.clearedFields, bootcamp.FieldSignStartAt)
}

// SetSignEndAt sets the "sign_end_at" field.
func (m *BootcampMutation) SetSignEndAt(t time.Time) {
	m.sign_end_at = &t
}

// SignEndAt returns the value of the "sign_end_at" field in the mutation.
func (m *BootcampMutation) SignEndAt() (r time.Time, exists bool) {
	v := m.sign_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndAt returns the old "sign_end_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndAt: %w", err)
	}
	return oldValue.SignEndAt, nil
}

// ClearSignEndAt clears the value of the "sign_end_at" field.
func (m *BootcampMutation) ClearSignEndAt() {
	m.sign_end_at = nil
	m.clearedFields[bootcamp.FieldSignEndAt] = struct{}{}
}

// SignEndAtCleared returns if the "sign_end_at" field was cleared in this mutation.
func (m *BootcampMutation) SignEndAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignEndAt]
	return ok
}

// ResetSignEndAt resets all changes to the "sign_end_at" field.
func (m *BootcampMutation) ResetSignEndAt() {
	m.sign_end_at = nil
	delete(m.clearedFields, bootcamp.FieldSignEndAt)
}

// SetStartAt sets the "start_at" field.
func (m *BootcampMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *BootcampMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *BootcampMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[bootcamp.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *BootcampMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *BootcampMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, bootcamp.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *BootcampMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *BootcampMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *BootcampMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[bootcamp.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *BootcampMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *BootcampMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, bootcamp.FieldEndAt)
}

// SetPic sets the "pic" field.
func (m *BootcampMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *BootcampMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *BootcampMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[bootcamp.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *BootcampMutation) PicCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *BootcampMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, bootcamp.FieldPic)
}

// SetFee sets the "fee" field.
func (m *BootcampMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *BootcampMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *BootcampMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *BootcampMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *BootcampMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[bootcamp.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *BootcampMutation) FeeCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *BootcampMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, bootcamp.FieldFee)
}

// SetIsFee sets the "is_fee" field.
func (m *BootcampMutation) SetIsFee(i int64) {
	m.is_fee = &i
	m.addis_fee = nil
}

// IsFee returns the value of the "is_fee" field in the mutation.
func (m *BootcampMutation) IsFee() (r int64, exists bool) {
	v := m.is_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFee returns the old "is_fee" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldIsFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFee: %w", err)
	}
	return oldValue.IsFee, nil
}

// AddIsFee adds i to the "is_fee" field.
func (m *BootcampMutation) AddIsFee(i int64) {
	if m.addis_fee != nil {
		*m.addis_fee += i
	} else {
		m.addis_fee = &i
	}
}

// AddedIsFee returns the value that was added to the "is_fee" field in this mutation.
func (m *BootcampMutation) AddedIsFee() (r int64, exists bool) {
	v := m.addis_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsFee clears the value of the "is_fee" field.
func (m *BootcampMutation) ClearIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	m.clearedFields[bootcamp.FieldIsFee] = struct{}{}
}

// IsFeeCleared returns if the "is_fee" field was cleared in this mutation.
func (m *BootcampMutation) IsFeeCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldIsFee]
	return ok
}

// ResetIsFee resets all changes to the "is_fee" field.
func (m *BootcampMutation) ResetIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	delete(m.clearedFields, bootcamp.FieldIsFee)
}

// SetIsShow sets the "is_show" field.
func (m *BootcampMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *BootcampMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *BootcampMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *BootcampMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *BootcampMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[bootcamp.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *BootcampMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *BootcampMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, bootcamp.FieldIsShow)
}

// SetIsCancel sets the "is_cancel" field.
func (m *BootcampMutation) SetIsCancel(i int64) {
	m.is_cancel = &i
	m.addis_cancel = nil
}

// IsCancel returns the value of the "is_cancel" field in the mutation.
func (m *BootcampMutation) IsCancel() (r int64, exists bool) {
	v := m.is_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCancel returns the old "is_cancel" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldIsCancel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCancel: %w", err)
	}
	return oldValue.IsCancel, nil
}

// AddIsCancel adds i to the "is_cancel" field.
func (m *BootcampMutation) AddIsCancel(i int64) {
	if m.addis_cancel != nil {
		*m.addis_cancel += i
	} else {
		m.addis_cancel = &i
	}
}

// AddedIsCancel returns the value that was added to the "is_cancel" field in this mutation.
func (m *BootcampMutation) AddedIsCancel() (r int64, exists bool) {
	v := m.addis_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsCancel clears the value of the "is_cancel" field.
func (m *BootcampMutation) ClearIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	m.clearedFields[bootcamp.FieldIsCancel] = struct{}{}
}

// IsCancelCleared returns if the "is_cancel" field was cleared in this mutation.
func (m *BootcampMutation) IsCancelCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldIsCancel]
	return ok
}

// ResetIsCancel resets all changes to the "is_cancel" field.
func (m *BootcampMutation) ResetIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	delete(m.clearedFields, bootcamp.FieldIsCancel)
}

// SetCancelTime sets the "cancel_time" field.
func (m *BootcampMutation) SetCancelTime(i int64) {
	m.cancel_time = &i
	m.addcancel_time = nil
}

// CancelTime returns the value of the "cancel_time" field in the mutation.
func (m *BootcampMutation) CancelTime() (r int64, exists bool) {
	v := m.cancel_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelTime returns the old "cancel_time" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCancelTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelTime: %w", err)
	}
	return oldValue.CancelTime, nil
}

// AddCancelTime adds i to the "cancel_time" field.
func (m *BootcampMutation) AddCancelTime(i int64) {
	if m.addcancel_time != nil {
		*m.addcancel_time += i
	} else {
		m.addcancel_time = &i
	}
}

// AddedCancelTime returns the value that was added to the "cancel_time" field in this mutation.
func (m *BootcampMutation) AddedCancelTime() (r int64, exists bool) {
	v := m.addcancel_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelTime clears the value of the "cancel_time" field.
func (m *BootcampMutation) ClearCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	m.clearedFields[bootcamp.FieldCancelTime] = struct{}{}
}

// CancelTimeCleared returns if the "cancel_time" field was cleared in this mutation.
func (m *BootcampMutation) CancelTimeCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCancelTime]
	return ok
}

// ResetCancelTime resets all changes to the "cancel_time" field.
func (m *BootcampMutation) ResetCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	delete(m.clearedFields, bootcamp.FieldCancelTime)
}

// SetDetail sets the "detail" field.
func (m *BootcampMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *BootcampMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *BootcampMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[bootcamp.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *BootcampMutation) DetailCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *BootcampMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, bootcamp.FieldDetail)
}

// SetSignFields sets the "sign_fields" field.
func (m *BootcampMutation) SetSignFields(s string) {
	m.sign_fields = &s
}

// SignFields returns the value of the "sign_fields" field in the mutation.
func (m *BootcampMutation) SignFields() (r string, exists bool) {
	v := m.sign_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldSignFields returns the old "sign_fields" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignFields: %w", err)
	}
	return oldValue.SignFields, nil
}

// ClearSignFields clears the value of the "sign_fields" field.
func (m *BootcampMutation) ClearSignFields() {
	m.sign_fields = nil
	m.clearedFields[bootcamp.FieldSignFields] = struct{}{}
}

// SignFieldsCleared returns if the "sign_fields" field was cleared in this mutation.
func (m *BootcampMutation) SignFieldsCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignFields]
	return ok
}

// ResetSignFields resets all changes to the "sign_fields" field.
func (m *BootcampMutation) ResetSignFields() {
	m.sign_fields = nil
	delete(m.clearedFields, bootcamp.FieldSignFields)
}

// SetCondition sets the "condition" field.
func (m *BootcampMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *BootcampMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *BootcampMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *BootcampMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *BootcampMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[bootcamp.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *BootcampMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *BootcampMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, bootcamp.FieldCondition)
}

// AddBootcampParticipantIDs adds the "bootcamp_participants" edge to the BootcampParticipant entity by ids.
func (m *BootcampMutation) AddBootcampParticipantIDs(ids ...int64) {
	if m.bootcamp_participants == nil {
		m.bootcamp_participants = make(map[int64]struct{})
	}
	for i := range ids {
		m.bootcamp_participants[ids[i]] = struct{}{}
	}
}

// ClearBootcampParticipants clears the "bootcamp_participants" edge to the BootcampParticipant entity.
func (m *BootcampMutation) ClearBootcampParticipants() {
	m.clearedbootcamp_participants = true
}

// BootcampParticipantsCleared reports if the "bootcamp_participants" edge to the BootcampParticipant entity was cleared.
func (m *BootcampMutation) BootcampParticipantsCleared() bool {
	return m.clearedbootcamp_participants
}

// RemoveBootcampParticipantIDs removes the "bootcamp_participants" edge to the BootcampParticipant entity by IDs.
func (m *BootcampMutation) RemoveBootcampParticipantIDs(ids ...int64) {
	if m.removedbootcamp_participants == nil {
		m.removedbootcamp_participants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bootcamp_participants, ids[i])
		m.removedbootcamp_participants[ids[i]] = struct{}{}
	}
}

// RemovedBootcampParticipants returns the removed IDs of the "bootcamp_participants" edge to the BootcampParticipant entity.
func (m *BootcampMutation) RemovedBootcampParticipantsIDs() (ids []int64) {
	for id := range m.removedbootcamp_participants {
		ids = append(ids, id)
	}
	return
}

// BootcampParticipantsIDs returns the "bootcamp_participants" edge IDs in the mutation.
func (m *BootcampMutation) BootcampParticipantsIDs() (ids []int64) {
	for id := range m.bootcamp_participants {
		ids = append(ids, id)
	}
	return
}

// ResetBootcampParticipants resets all changes to the "bootcamp_participants" edge.
func (m *BootcampMutation) ResetBootcampParticipants() {
	m.bootcamp_participants = nil
	m.clearedbootcamp_participants = false
	m.removedbootcamp_participants = nil
}

// Where appends a list predicates to the BootcampMutation builder.
func (m *BootcampMutation) Where(ps ...predicate.Bootcamp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BootcampMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BootcampMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bootcamp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BootcampMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BootcampMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bootcamp).
func (m *BootcampMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BootcampMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, bootcamp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bootcamp.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, bootcamp.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, bootcamp.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, bootcamp.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, bootcamp.FieldName)
	}
	if m.sign_number != nil {
		fields = append(fields, bootcamp.FieldSignNumber)
	}
	if m.sign_start_at != nil {
		fields = append(fields, bootcamp.FieldSignStartAt)
	}
	if m.sign_end_at != nil {
		fields = append(fields, bootcamp.FieldSignEndAt)
	}
	if m.start_at != nil {
		fields = append(fields, bootcamp.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, bootcamp.FieldEndAt)
	}
	if m.pic != nil {
		fields = append(fields, bootcamp.FieldPic)
	}
	if m.fee != nil {
		fields = append(fields, bootcamp.FieldFee)
	}
	if m.is_fee != nil {
		fields = append(fields, bootcamp.FieldIsFee)
	}
	if m.is_show != nil {
		fields = append(fields, bootcamp.FieldIsShow)
	}
	if m.is_cancel != nil {
		fields = append(fields, bootcamp.FieldIsCancel)
	}
	if m.cancel_time != nil {
		fields = append(fields, bootcamp.FieldCancelTime)
	}
	if m.detail != nil {
		fields = append(fields, bootcamp.FieldDetail)
	}
	if m.sign_fields != nil {
		fields = append(fields, bootcamp.FieldSignFields)
	}
	if m.condition != nil {
		fields = append(fields, bootcamp.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BootcampMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bootcamp.FieldCreatedAt:
		return m.CreatedAt()
	case bootcamp.FieldUpdatedAt:
		return m.UpdatedAt()
	case bootcamp.FieldDelete:
		return m.Delete()
	case bootcamp.FieldCreatedID:
		return m.CreatedID()
	case bootcamp.FieldStatus:
		return m.Status()
	case bootcamp.FieldName:
		return m.Name()
	case bootcamp.FieldSignNumber:
		return m.SignNumber()
	case bootcamp.FieldSignStartAt:
		return m.SignStartAt()
	case bootcamp.FieldSignEndAt:
		return m.SignEndAt()
	case bootcamp.FieldStartAt:
		return m.StartAt()
	case bootcamp.FieldEndAt:
		return m.EndAt()
	case bootcamp.FieldPic:
		return m.Pic()
	case bootcamp.FieldFee:
		return m.Fee()
	case bootcamp.FieldIsFee:
		return m.IsFee()
	case bootcamp.FieldIsShow:
		return m.IsShow()
	case bootcamp.FieldIsCancel:
		return m.IsCancel()
	case bootcamp.FieldCancelTime:
		return m.CancelTime()
	case bootcamp.FieldDetail:
		return m.Detail()
	case bootcamp.FieldSignFields:
		return m.SignFields()
	case bootcamp.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BootcampMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bootcamp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bootcamp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bootcamp.FieldDelete:
		return m.OldDelete(ctx)
	case bootcamp.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case bootcamp.FieldStatus:
		return m.OldStatus(ctx)
	case bootcamp.FieldName:
		return m.OldName(ctx)
	case bootcamp.FieldSignNumber:
		return m.OldSignNumber(ctx)
	case bootcamp.FieldSignStartAt:
		return m.OldSignStartAt(ctx)
	case bootcamp.FieldSignEndAt:
		return m.OldSignEndAt(ctx)
	case bootcamp.FieldStartAt:
		return m.OldStartAt(ctx)
	case bootcamp.FieldEndAt:
		return m.OldEndAt(ctx)
	case bootcamp.FieldPic:
		return m.OldPic(ctx)
	case bootcamp.FieldFee:
		return m.OldFee(ctx)
	case bootcamp.FieldIsFee:
		return m.OldIsFee(ctx)
	case bootcamp.FieldIsShow:
		return m.OldIsShow(ctx)
	case bootcamp.FieldIsCancel:
		return m.OldIsCancel(ctx)
	case bootcamp.FieldCancelTime:
		return m.OldCancelTime(ctx)
	case bootcamp.FieldDetail:
		return m.OldDetail(ctx)
	case bootcamp.FieldSignFields:
		return m.OldSignFields(ctx)
	case bootcamp.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Bootcamp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bootcamp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bootcamp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bootcamp.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case bootcamp.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case bootcamp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bootcamp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bootcamp.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignNumber(v)
		return nil
	case bootcamp.FieldSignStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartAt(v)
		return nil
	case bootcamp.FieldSignEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndAt(v)
		return nil
	case bootcamp.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case bootcamp.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case bootcamp.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case bootcamp.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case bootcamp.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFee(v)
		return nil
	case bootcamp.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case bootcamp.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCancel(v)
		return nil
	case bootcamp.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelTime(v)
		return nil
	case bootcamp.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case bootcamp.FieldSignFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignFields(v)
		return nil
	case bootcamp.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Bootcamp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BootcampMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, bootcamp.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, bootcamp.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, bootcamp.FieldStatus)
	}
	if m.addsign_number != nil {
		fields = append(fields, bootcamp.FieldSignNumber)
	}
	if m.addfee != nil {
		fields = append(fields, bootcamp.FieldFee)
	}
	if m.addis_fee != nil {
		fields = append(fields, bootcamp.FieldIsFee)
	}
	if m.addis_show != nil {
		fields = append(fields, bootcamp.FieldIsShow)
	}
	if m.addis_cancel != nil {
		fields = append(fields, bootcamp.FieldIsCancel)
	}
	if m.addcancel_time != nil {
		fields = append(fields, bootcamp.FieldCancelTime)
	}
	if m.addcondition != nil {
		fields = append(fields, bootcamp.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BootcampMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bootcamp.FieldDelete:
		return m.AddedDelete()
	case bootcamp.FieldCreatedID:
		return m.AddedCreatedID()
	case bootcamp.FieldStatus:
		return m.AddedStatus()
	case bootcamp.FieldSignNumber:
		return m.AddedSignNumber()
	case bootcamp.FieldFee:
		return m.AddedFee()
	case bootcamp.FieldIsFee:
		return m.AddedIsFee()
	case bootcamp.FieldIsShow:
		return m.AddedIsShow()
	case bootcamp.FieldIsCancel:
		return m.AddedIsCancel()
	case bootcamp.FieldCancelTime:
		return m.AddedCancelTime()
	case bootcamp.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bootcamp.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case bootcamp.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case bootcamp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case bootcamp.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignNumber(v)
		return nil
	case bootcamp.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case bootcamp.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFee(v)
		return nil
	case bootcamp.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	case bootcamp.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCancel(v)
		return nil
	case bootcamp.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelTime(v)
		return nil
	case bootcamp.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Bootcamp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BootcampMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bootcamp.FieldCreatedAt) {
		fields = append(fields, bootcamp.FieldCreatedAt)
	}
	if m.FieldCleared(bootcamp.FieldUpdatedAt) {
		fields = append(fields, bootcamp.FieldUpdatedAt)
	}
	if m.FieldCleared(bootcamp.FieldDelete) {
		fields = append(fields, bootcamp.FieldDelete)
	}
	if m.FieldCleared(bootcamp.FieldCreatedID) {
		fields = append(fields, bootcamp.FieldCreatedID)
	}
	if m.FieldCleared(bootcamp.FieldStatus) {
		fields = append(fields, bootcamp.FieldStatus)
	}
	if m.FieldCleared(bootcamp.FieldName) {
		fields = append(fields, bootcamp.FieldName)
	}
	if m.FieldCleared(bootcamp.FieldSignNumber) {
		fields = append(fields, bootcamp.FieldSignNumber)
	}
	if m.FieldCleared(bootcamp.FieldSignStartAt) {
		fields = append(fields, bootcamp.FieldSignStartAt)
	}
	if m.FieldCleared(bootcamp.FieldSignEndAt) {
		fields = append(fields, bootcamp.FieldSignEndAt)
	}
	if m.FieldCleared(bootcamp.FieldStartAt) {
		fields = append(fields, bootcamp.FieldStartAt)
	}
	if m.FieldCleared(bootcamp.FieldEndAt) {
		fields = append(fields, bootcamp.FieldEndAt)
	}
	if m.FieldCleared(bootcamp.FieldPic) {
		fields = append(fields, bootcamp.FieldPic)
	}
	if m.FieldCleared(bootcamp.FieldFee) {
		fields = append(fields, bootcamp.FieldFee)
	}
	if m.FieldCleared(bootcamp.FieldIsFee) {
		fields = append(fields, bootcamp.FieldIsFee)
	}
	if m.FieldCleared(bootcamp.FieldIsShow) {
		fields = append(fields, bootcamp.FieldIsShow)
	}
	if m.FieldCleared(bootcamp.FieldIsCancel) {
		fields = append(fields, bootcamp.FieldIsCancel)
	}
	if m.FieldCleared(bootcamp.FieldCancelTime) {
		fields = append(fields, bootcamp.FieldCancelTime)
	}
	if m.FieldCleared(bootcamp.FieldDetail) {
		fields = append(fields, bootcamp.FieldDetail)
	}
	if m.FieldCleared(bootcamp.FieldSignFields) {
		fields = append(fields, bootcamp.FieldSignFields)
	}
	if m.FieldCleared(bootcamp.FieldCondition) {
		fields = append(fields, bootcamp.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BootcampMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BootcampMutation) ClearField(name string) error {
	switch name {
	case bootcamp.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case bootcamp.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case bootcamp.FieldDelete:
		m.ClearDelete()
		return nil
	case bootcamp.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case bootcamp.FieldStatus:
		m.ClearStatus()
		return nil
	case bootcamp.FieldName:
		m.ClearName()
		return nil
	case bootcamp.FieldSignNumber:
		m.ClearSignNumber()
		return nil
	case bootcamp.FieldSignStartAt:
		m.ClearSignStartAt()
		return nil
	case bootcamp.FieldSignEndAt:
		m.ClearSignEndAt()
		return nil
	case bootcamp.FieldStartAt:
		m.ClearStartAt()
		return nil
	case bootcamp.FieldEndAt:
		m.ClearEndAt()
		return nil
	case bootcamp.FieldPic:
		m.ClearPic()
		return nil
	case bootcamp.FieldFee:
		m.ClearFee()
		return nil
	case bootcamp.FieldIsFee:
		m.ClearIsFee()
		return nil
	case bootcamp.FieldIsShow:
		m.ClearIsShow()
		return nil
	case bootcamp.FieldIsCancel:
		m.ClearIsCancel()
		return nil
	case bootcamp.FieldCancelTime:
		m.ClearCancelTime()
		return nil
	case bootcamp.FieldDetail:
		m.ClearDetail()
		return nil
	case bootcamp.FieldSignFields:
		m.ClearSignFields()
		return nil
	case bootcamp.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Bootcamp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BootcampMutation) ResetField(name string) error {
	switch name {
	case bootcamp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bootcamp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bootcamp.FieldDelete:
		m.ResetDelete()
		return nil
	case bootcamp.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case bootcamp.FieldStatus:
		m.ResetStatus()
		return nil
	case bootcamp.FieldName:
		m.ResetName()
		return nil
	case bootcamp.FieldSignNumber:
		m.ResetSignNumber()
		return nil
	case bootcamp.FieldSignStartAt:
		m.ResetSignStartAt()
		return nil
	case bootcamp.FieldSignEndAt:
		m.ResetSignEndAt()
		return nil
	case bootcamp.FieldStartAt:
		m.ResetStartAt()
		return nil
	case bootcamp.FieldEndAt:
		m.ResetEndAt()
		return nil
	case bootcamp.FieldPic:
		m.ResetPic()
		return nil
	case bootcamp.FieldFee:
		m.ResetFee()
		return nil
	case bootcamp.FieldIsFee:
		m.ResetIsFee()
		return nil
	case bootcamp.FieldIsShow:
		m.ResetIsShow()
		return nil
	case bootcamp.FieldIsCancel:
		m.ResetIsCancel()
		return nil
	case bootcamp.FieldCancelTime:
		m.ResetCancelTime()
		return nil
	case bootcamp.FieldDetail:
		m.ResetDetail()
		return nil
	case bootcamp.FieldSignFields:
		m.ResetSignFields()
		return nil
	case bootcamp.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Bootcamp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BootcampMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bootcamp_participants != nil {
		edges = append(edges, bootcamp.EdgeBootcampParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BootcampMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		ids := make([]ent.Value, 0, len(m.bootcamp_participants))
		for id := range m.bootcamp_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BootcampMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbootcamp_participants != nil {
		edges = append(edges, bootcamp.EdgeBootcampParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BootcampMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		ids := make([]ent.Value, 0, len(m.removedbootcamp_participants))
		for id := range m.removedbootcamp_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BootcampMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbootcamp_participants {
		edges = append(edges, bootcamp.EdgeBootcampParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BootcampMutation) EdgeCleared(name string) bool {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		return m.clearedbootcamp_participants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BootcampMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bootcamp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BootcampMutation) ResetEdge(name string) error {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		m.ResetBootcampParticipants()
		return nil
	}
	return fmt.Errorf("unknown Bootcamp edge %s", name)
}

// BootcampParticipantMutation represents an operation that mutates the BootcampParticipant nodes in the graph.
type BootcampParticipantMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	delete           *int64
	adddelete        *int64
	created_id       *int64
	addcreated_id    *int64
	status           *int64
	addstatus        *int64
	name             *string
	mobile           *string
	fields           *string
	order_id         *int64
	addorder_id      *int64
	order_sn         *string
	fee              *float64
	addfee           *float64
	member_id        *int64
	addmember_id     *int64
	clearedFields    map[string]struct{}
	bootcamps        *int64
	clearedbootcamps bool
	members          map[int64]struct{}
	removedmembers   map[int64]struct{}
	clearedmembers   bool
	done             bool
	oldValue         func(context.Context) (*BootcampParticipant, error)
	predicates       []predicate.BootcampParticipant
}

var _ ent.Mutation = (*BootcampParticipantMutation)(nil)

// bootcampparticipantOption allows management of the mutation configuration using functional options.
type bootcampparticipantOption func(*BootcampParticipantMutation)

// newBootcampParticipantMutation creates new mutation for the BootcampParticipant entity.
func newBootcampParticipantMutation(c config, op Op, opts ...bootcampparticipantOption) *BootcampParticipantMutation {
	m := &BootcampParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeBootcampParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBootcampParticipantID sets the ID field of the mutation.
func withBootcampParticipantID(id int64) bootcampparticipantOption {
	return func(m *BootcampParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *BootcampParticipant
		)
		m.oldValue = func(ctx context.Context) (*BootcampParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BootcampParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBootcampParticipant sets the old BootcampParticipant of the mutation.
func withBootcampParticipant(node *BootcampParticipant) bootcampparticipantOption {
	return func(m *BootcampParticipantMutation) {
		m.oldValue = func(context.Context) (*BootcampParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BootcampParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BootcampParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BootcampParticipant entities.
func (m *BootcampParticipantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BootcampParticipantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BootcampParticipantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BootcampParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BootcampParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BootcampParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BootcampParticipantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[bootcampparticipant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BootcampParticipantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BootcampParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, bootcampparticipant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BootcampParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BootcampParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BootcampParticipantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[bootcampparticipant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BootcampParticipantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BootcampParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, bootcampparticipant.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *BootcampParticipantMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *BootcampParticipantMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *BootcampParticipantMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *BootcampParticipantMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *BootcampParticipantMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[bootcampparticipant.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *BootcampParticipantMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *BootcampParticipantMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, bootcampparticipant.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *BootcampParticipantMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *BootcampParticipantMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *BootcampParticipantMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *BootcampParticipantMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *BootcampParticipantMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[bootcampparticipant.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *BootcampParticipantMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, bootcampparticipant.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *BootcampParticipantMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BootcampParticipantMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BootcampParticipantMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BootcampParticipantMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BootcampParticipantMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[bootcampparticipant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BootcampParticipantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BootcampParticipantMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, bootcampparticipant.FieldStatus)
}

// SetBootcampID sets the "bootcamp_id" field.
func (m *BootcampParticipantMutation) SetBootcampID(i int64) {
	m.bootcamps = &i
}

// BootcampID returns the value of the "bootcamp_id" field in the mutation.
func (m *BootcampParticipantMutation) BootcampID() (r int64, exists bool) {
	v := m.bootcamps
	if v == nil {
		return
	}
	return *v, true
}

// OldBootcampID returns the old "bootcamp_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldBootcampID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBootcampID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBootcampID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBootcampID: %w", err)
	}
	return oldValue.BootcampID, nil
}

// ClearBootcampID clears the value of the "bootcamp_id" field.
func (m *BootcampParticipantMutation) ClearBootcampID() {
	m.bootcamps = nil
	m.clearedFields[bootcampparticipant.FieldBootcampID] = struct{}{}
}

// BootcampIDCleared returns if the "bootcamp_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) BootcampIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldBootcampID]
	return ok
}

// ResetBootcampID resets all changes to the "bootcamp_id" field.
func (m *BootcampParticipantMutation) ResetBootcampID() {
	m.bootcamps = nil
	delete(m.clearedFields, bootcampparticipant.FieldBootcampID)
}

// SetName sets the "name" field.
func (m *BootcampParticipantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BootcampParticipantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *BootcampParticipantMutation) ClearName() {
	m.name = nil
	m.clearedFields[bootcampparticipant.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *BootcampParticipantMutation) NameCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *BootcampParticipantMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, bootcampparticipant.FieldName)
}

// SetMobile sets the "mobile" field.
func (m *BootcampParticipantMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *BootcampParticipantMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *BootcampParticipantMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[bootcampparticipant.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *BootcampParticipantMutation) MobileCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *BootcampParticipantMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, bootcampparticipant.FieldMobile)
}

// SetFields sets the "fields" field.
func (m *BootcampParticipantMutation) SetFields(s string) {
	m.fields = &s
}

// GetFields returns the value of the "fields" field in the mutation.
func (m *BootcampParticipantMutation) GetFields() (r string, exists bool) {
	v := m.fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFields returns the old "fields" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFields: %w", err)
	}
	return oldValue.Fields, nil
}

// ClearFields clears the value of the "fields" field.
func (m *BootcampParticipantMutation) ClearFields() {
	m.fields = nil
	m.clearedFields[bootcampparticipant.FieldFields] = struct{}{}
}

// FieldsCleared returns if the "fields" field was cleared in this mutation.
func (m *BootcampParticipantMutation) FieldsCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldFields]
	return ok
}

// ResetFields resets all changes to the "fields" field.
func (m *BootcampParticipantMutation) ResetFields() {
	m.fields = nil
	delete(m.clearedFields, bootcampparticipant.FieldFields)
}

// SetOrderID sets the "order_id" field.
func (m *BootcampParticipantMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *BootcampParticipantMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *BootcampParticipantMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *BootcampParticipantMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *BootcampParticipantMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[bootcampparticipant.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *BootcampParticipantMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, bootcampparticipant.FieldOrderID)
}

// SetOrderSn sets the "order_sn" field.
func (m *BootcampParticipantMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *BootcampParticipantMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *BootcampParticipantMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[bootcampparticipant.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *BootcampParticipantMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *BootcampParticipantMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, bootcampparticipant.FieldOrderSn)
}

// SetFee sets the "fee" field.
func (m *BootcampParticipantMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *BootcampParticipantMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *BootcampParticipantMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *BootcampParticipantMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *BootcampParticipantMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[bootcampparticipant.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *BootcampParticipantMutation) FeeCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *BootcampParticipantMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, bootcampparticipant.FieldFee)
}

// SetMemberID sets the "member_id" field.
func (m *BootcampParticipantMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *BootcampParticipantMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *BootcampParticipantMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *BootcampParticipantMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *BootcampParticipantMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[bootcampparticipant.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *BootcampParticipantMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, bootcampparticipant.FieldMemberID)
}

// SetBootcampsID sets the "bootcamps" edge to the Bootcamp entity by id.
func (m *BootcampParticipantMutation) SetBootcampsID(id int64) {
	m.bootcamps = &id
}

// ClearBootcamps clears the "bootcamps" edge to the Bootcamp entity.
func (m *BootcampParticipantMutation) ClearBootcamps() {
	m.clearedbootcamps = true
	m.clearedFields[bootcampparticipant.FieldBootcampID] = struct{}{}
}

// BootcampsCleared reports if the "bootcamps" edge to the Bootcamp entity was cleared.
func (m *BootcampParticipantMutation) BootcampsCleared() bool {
	return m.BootcampIDCleared() || m.clearedbootcamps
}

// BootcampsID returns the "bootcamps" edge ID in the mutation.
func (m *BootcampParticipantMutation) BootcampsID() (id int64, exists bool) {
	if m.bootcamps != nil {
		return *m.bootcamps, true
	}
	return
}

// BootcampsIDs returns the "bootcamps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BootcampsID instead. It exists only for internal usage by the builders.
func (m *BootcampParticipantMutation) BootcampsIDs() (ids []int64) {
	if id := m.bootcamps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBootcamps resets all changes to the "bootcamps" edge.
func (m *BootcampParticipantMutation) ResetBootcamps() {
	m.bootcamps = nil
	m.clearedbootcamps = false
}

// AddMemberIDs adds the "members" edge to the Member entity by ids.
func (m *BootcampParticipantMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *BootcampParticipantMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *BootcampParticipantMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Member entity by IDs.
func (m *BootcampParticipantMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Member entity.
func (m *BootcampParticipantMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *BootcampParticipantMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *BootcampParticipantMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the BootcampParticipantMutation builder.
func (m *BootcampParticipantMutation) Where(ps ...predicate.BootcampParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BootcampParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BootcampParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BootcampParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BootcampParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BootcampParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BootcampParticipant).
func (m *BootcampParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BootcampParticipantMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, bootcampparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bootcampparticipant.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, bootcampparticipant.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, bootcampparticipant.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, bootcampparticipant.FieldStatus)
	}
	if m.bootcamps != nil {
		fields = append(fields, bootcampparticipant.FieldBootcampID)
	}
	if m.name != nil {
		fields = append(fields, bootcampparticipant.FieldName)
	}
	if m.mobile != nil {
		fields = append(fields, bootcampparticipant.FieldMobile)
	}
	if m.fields != nil {
		fields = append(fields, bootcampparticipant.FieldFields)
	}
	if m.order_id != nil {
		fields = append(fields, bootcampparticipant.FieldOrderID)
	}
	if m.order_sn != nil {
		fields = append(fields, bootcampparticipant.FieldOrderSn)
	}
	if m.fee != nil {
		fields = append(fields, bootcampparticipant.FieldFee)
	}
	if m.member_id != nil {
		fields = append(fields, bootcampparticipant.FieldMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BootcampParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case bootcampparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	case bootcampparticipant.FieldDelete:
		return m.Delete()
	case bootcampparticipant.FieldCreatedID:
		return m.CreatedID()
	case bootcampparticipant.FieldStatus:
		return m.Status()
	case bootcampparticipant.FieldBootcampID:
		return m.BootcampID()
	case bootcampparticipant.FieldName:
		return m.Name()
	case bootcampparticipant.FieldMobile:
		return m.Mobile()
	case bootcampparticipant.FieldFields:
		return m.GetFields()
	case bootcampparticipant.FieldOrderID:
		return m.OrderID()
	case bootcampparticipant.FieldOrderSn:
		return m.OrderSn()
	case bootcampparticipant.FieldFee:
		return m.Fee()
	case bootcampparticipant.FieldMemberID:
		return m.MemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BootcampParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bootcampparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bootcampparticipant.FieldDelete:
		return m.OldDelete(ctx)
	case bootcampparticipant.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case bootcampparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case bootcampparticipant.FieldBootcampID:
		return m.OldBootcampID(ctx)
	case bootcampparticipant.FieldName:
		return m.OldName(ctx)
	case bootcampparticipant.FieldMobile:
		return m.OldMobile(ctx)
	case bootcampparticipant.FieldFields:
		return m.OldFields(ctx)
	case bootcampparticipant.FieldOrderID:
		return m.OldOrderID(ctx)
	case bootcampparticipant.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case bootcampparticipant.FieldFee:
		return m.OldFee(ctx)
	case bootcampparticipant.FieldMemberID:
		return m.OldMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown BootcampParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bootcampparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bootcampparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case bootcampparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case bootcampparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bootcampparticipant.FieldBootcampID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBootcampID(v)
		return nil
	case bootcampparticipant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bootcampparticipant.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case bootcampparticipant.FieldFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFields(v)
		return nil
	case bootcampparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case bootcampparticipant.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case bootcampparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case bootcampparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BootcampParticipantMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, bootcampparticipant.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, bootcampparticipant.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, bootcampparticipant.FieldStatus)
	}
	if m.addorder_id != nil {
		fields = append(fields, bootcampparticipant.FieldOrderID)
	}
	if m.addfee != nil {
		fields = append(fields, bootcampparticipant.FieldFee)
	}
	if m.addmember_id != nil {
		fields = append(fields, bootcampparticipant.FieldMemberID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BootcampParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bootcampparticipant.FieldDelete:
		return m.AddedDelete()
	case bootcampparticipant.FieldCreatedID:
		return m.AddedCreatedID()
	case bootcampparticipant.FieldStatus:
		return m.AddedStatus()
	case bootcampparticipant.FieldOrderID:
		return m.AddedOrderID()
	case bootcampparticipant.FieldFee:
		return m.AddedFee()
	case bootcampparticipant.FieldMemberID:
		return m.AddedMemberID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bootcampparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case bootcampparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case bootcampparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case bootcampparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case bootcampparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case bootcampparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BootcampParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bootcampparticipant.FieldCreatedAt) {
		fields = append(fields, bootcampparticipant.FieldCreatedAt)
	}
	if m.FieldCleared(bootcampparticipant.FieldUpdatedAt) {
		fields = append(fields, bootcampparticipant.FieldUpdatedAt)
	}
	if m.FieldCleared(bootcampparticipant.FieldDelete) {
		fields = append(fields, bootcampparticipant.FieldDelete)
	}
	if m.FieldCleared(bootcampparticipant.FieldCreatedID) {
		fields = append(fields, bootcampparticipant.FieldCreatedID)
	}
	if m.FieldCleared(bootcampparticipant.FieldStatus) {
		fields = append(fields, bootcampparticipant.FieldStatus)
	}
	if m.FieldCleared(bootcampparticipant.FieldBootcampID) {
		fields = append(fields, bootcampparticipant.FieldBootcampID)
	}
	if m.FieldCleared(bootcampparticipant.FieldName) {
		fields = append(fields, bootcampparticipant.FieldName)
	}
	if m.FieldCleared(bootcampparticipant.FieldMobile) {
		fields = append(fields, bootcampparticipant.FieldMobile)
	}
	if m.FieldCleared(bootcampparticipant.FieldFields) {
		fields = append(fields, bootcampparticipant.FieldFields)
	}
	if m.FieldCleared(bootcampparticipant.FieldOrderID) {
		fields = append(fields, bootcampparticipant.FieldOrderID)
	}
	if m.FieldCleared(bootcampparticipant.FieldOrderSn) {
		fields = append(fields, bootcampparticipant.FieldOrderSn)
	}
	if m.FieldCleared(bootcampparticipant.FieldFee) {
		fields = append(fields, bootcampparticipant.FieldFee)
	}
	if m.FieldCleared(bootcampparticipant.FieldMemberID) {
		fields = append(fields, bootcampparticipant.FieldMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BootcampParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BootcampParticipantMutation) ClearField(name string) error {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case bootcampparticipant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case bootcampparticipant.FieldDelete:
		m.ClearDelete()
		return nil
	case bootcampparticipant.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case bootcampparticipant.FieldStatus:
		m.ClearStatus()
		return nil
	case bootcampparticipant.FieldBootcampID:
		m.ClearBootcampID()
		return nil
	case bootcampparticipant.FieldName:
		m.ClearName()
		return nil
	case bootcampparticipant.FieldMobile:
		m.ClearMobile()
		return nil
	case bootcampparticipant.FieldFields:
		m.ClearFields()
		return nil
	case bootcampparticipant.FieldOrderID:
		m.ClearOrderID()
		return nil
	case bootcampparticipant.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case bootcampparticipant.FieldFee:
		m.ClearFee()
		return nil
	case bootcampparticipant.FieldMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BootcampParticipantMutation) ResetField(name string) error {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bootcampparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bootcampparticipant.FieldDelete:
		m.ResetDelete()
		return nil
	case bootcampparticipant.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case bootcampparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case bootcampparticipant.FieldBootcampID:
		m.ResetBootcampID()
		return nil
	case bootcampparticipant.FieldName:
		m.ResetName()
		return nil
	case bootcampparticipant.FieldMobile:
		m.ResetMobile()
		return nil
	case bootcampparticipant.FieldFields:
		m.ResetFields()
		return nil
	case bootcampparticipant.FieldOrderID:
		m.ResetOrderID()
		return nil
	case bootcampparticipant.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case bootcampparticipant.FieldFee:
		m.ResetFee()
		return nil
	case bootcampparticipant.FieldMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BootcampParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bootcamps != nil {
		edges = append(edges, bootcampparticipant.EdgeBootcamps)
	}
	if m.members != nil {
		edges = append(edges, bootcampparticipant.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BootcampParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		if id := m.bootcamps; id != nil {
			return []ent.Value{*id}
		}
	case bootcampparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BootcampParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, bootcampparticipant.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BootcampParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bootcampparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BootcampParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbootcamps {
		edges = append(edges, bootcampparticipant.EdgeBootcamps)
	}
	if m.clearedmembers {
		edges = append(edges, bootcampparticipant.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BootcampParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		return m.clearedbootcamps
	case bootcampparticipant.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BootcampParticipantMutation) ClearEdge(name string) error {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		m.ClearBootcamps()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BootcampParticipantMutation) ResetEdge(name string) error {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		m.ResetBootcamps()
		return nil
	case bootcampparticipant.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant edge %s", name)
}

// CommunityMutation represents an operation that mutates the Community nodes in the graph.
type CommunityMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	delete                        *int64
	adddelete                     *int64
	created_id                    *int64
	addcreated_id                 *int64
	status                        *int64
	addstatus                     *int64
	name                          *string
	sign_number                   *int64
	addsign_number                *int64
	sign_start_at                 *time.Time
	sign_end_at                   *time.Time
	number                        *int64
	addnumber                     *int64
	start_at                      *time.Time
	end_at                        *time.Time
	pic                           *string
	sponsor                       *string
	fee                           *float64
	addfee                        *float64
	is_fee                        *int64
	addis_fee                     *int64
	is_show                       *int64
	addis_show                    *int64
	is_cancel                     *int64
	addis_cancel                  *int64
	cancel_time                   *int64
	addcancel_time                *int64
	detail                        *string
	sign_fields                   *string
	condition                     *int64
	addcondition                  *int64
	clearedFields                 map[string]struct{}
	community_participants        map[int64]struct{}
	removedcommunity_participants map[int64]struct{}
	clearedcommunity_participants bool
	done                          bool
	oldValue                      func(context.Context) (*Community, error)
	predicates                    []predicate.Community
}

var _ ent.Mutation = (*CommunityMutation)(nil)

// communityOption allows management of the mutation configuration using functional options.
type communityOption func(*CommunityMutation)

// newCommunityMutation creates new mutation for the Community entity.
func newCommunityMutation(c config, op Op, opts ...communityOption) *CommunityMutation {
	m := &CommunityMutation{
		config:        c,
		op:            op,
		typ:           TypeCommunity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommunityID sets the ID field of the mutation.
func withCommunityID(id int64) communityOption {
	return func(m *CommunityMutation) {
		var (
			err   error
			once  sync.Once
			value *Community
		)
		m.oldValue = func(ctx context.Context) (*Community, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Community.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommunity sets the old Community of the mutation.
func withCommunity(node *Community) communityOption {
	return func(m *CommunityMutation) {
		m.oldValue = func(context.Context) (*Community, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommunityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommunityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Community entities.
func (m *CommunityMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommunityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommunityMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Community.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommunityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommunityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *CommunityMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[community.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *CommunityMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[community.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommunityMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, community.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommunityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommunityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CommunityMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[community.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CommunityMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[community.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommunityMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, community.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *CommunityMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *CommunityMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *CommunityMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *CommunityMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *CommunityMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[community.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *CommunityMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[community.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *CommunityMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, community.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *CommunityMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *CommunityMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *CommunityMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *CommunityMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *CommunityMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[community.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *CommunityMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[community.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *CommunityMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, community.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *CommunityMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommunityMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CommunityMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommunityMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CommunityMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[community.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CommunityMutation) StatusCleared() bool {
	_, ok := m.clearedFields[community.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CommunityMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, community.FieldStatus)
}

// SetName sets the "name" field.
func (m *CommunityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommunityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CommunityMutation) ClearName() {
	m.name = nil
	m.clearedFields[community.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CommunityMutation) NameCleared() bool {
	_, ok := m.clearedFields[community.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CommunityMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, community.FieldName)
}

// SetSignNumber sets the "sign_number" field.
func (m *CommunityMutation) SetSignNumber(i int64) {
	m.sign_number = &i
	m.addsign_number = nil
}

// SignNumber returns the value of the "sign_number" field in the mutation.
func (m *CommunityMutation) SignNumber() (r int64, exists bool) {
	v := m.sign_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSignNumber returns the old "sign_number" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldSignNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignNumber: %w", err)
	}
	return oldValue.SignNumber, nil
}

// AddSignNumber adds i to the "sign_number" field.
func (m *CommunityMutation) AddSignNumber(i int64) {
	if m.addsign_number != nil {
		*m.addsign_number += i
	} else {
		m.addsign_number = &i
	}
}

// AddedSignNumber returns the value that was added to the "sign_number" field in this mutation.
func (m *CommunityMutation) AddedSignNumber() (r int64, exists bool) {
	v := m.addsign_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearSignNumber clears the value of the "sign_number" field.
func (m *CommunityMutation) ClearSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	m.clearedFields[community.FieldSignNumber] = struct{}{}
}

// SignNumberCleared returns if the "sign_number" field was cleared in this mutation.
func (m *CommunityMutation) SignNumberCleared() bool {
	_, ok := m.clearedFields[community.FieldSignNumber]
	return ok
}

// ResetSignNumber resets all changes to the "sign_number" field.
func (m *CommunityMutation) ResetSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	delete(m.clearedFields, community.FieldSignNumber)
}

// SetSignStartAt sets the "sign_start_at" field.
func (m *CommunityMutation) SetSignStartAt(t time.Time) {
	m.sign_start_at = &t
}

// SignStartAt returns the value of the "sign_start_at" field in the mutation.
func (m *CommunityMutation) SignStartAt() (r time.Time, exists bool) {
	v := m.sign_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartAt returns the old "sign_start_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldSignStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartAt: %w", err)
	}
	return oldValue.SignStartAt, nil
}

// ClearSignStartAt clears the value of the "sign_start_at" field.
func (m *CommunityMutation) ClearSignStartAt() {
	m.sign_start_at = nil
	m.clearedFields[community.FieldSignStartAt] = struct{}{}
}

// SignStartAtCleared returns if the "sign_start_at" field was cleared in this mutation.
func (m *CommunityMutation) SignStartAtCleared() bool {
	_, ok := m.clearedFields[community.FieldSignStartAt]
	return ok
}

// ResetSignStartAt resets all changes to the "sign_start_at" field.
func (m *CommunityMutation) ResetSignStartAt() {
	m.sign_start_at = nil
	delete(m.clearedFields, community.FieldSignStartAt)
}

// SetSignEndAt sets the "sign_end_at" field.
func (m *CommunityMutation) SetSignEndAt(t time.Time) {
	m.sign_end_at = &t
}

// SignEndAt returns the value of the "sign_end_at" field in the mutation.
func (m *CommunityMutation) SignEndAt() (r time.Time, exists bool) {
	v := m.sign_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndAt returns the old "sign_end_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldSignEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndAt: %w", err)
	}
	return oldValue.SignEndAt, nil
}

// ClearSignEndAt clears the value of the "sign_end_at" field.
func (m *CommunityMutation) ClearSignEndAt() {
	m.sign_end_at = nil
	m.clearedFields[community.FieldSignEndAt] = struct{}{}
}

// SignEndAtCleared returns if the "sign_end_at" field was cleared in this mutation.
func (m *CommunityMutation) SignEndAtCleared() bool {
	_, ok := m.clearedFields[community.FieldSignEndAt]
	return ok
}

// ResetSignEndAt resets all changes to the "sign_end_at" field.
func (m *CommunityMutation) ResetSignEndAt() {
	m.sign_end_at = nil
	delete(m.clearedFields, community.FieldSignEndAt)
}

// SetNumber sets the "number" field.
func (m *CommunityMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *CommunityMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *CommunityMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *CommunityMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *CommunityMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[community.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *CommunityMutation) NumberCleared() bool {
	_, ok := m.clearedFields[community.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *CommunityMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, community.FieldNumber)
}

// SetStartAt sets the "start_at" field.
func (m *CommunityMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CommunityMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CommunityMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[community.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CommunityMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[community.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CommunityMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, community.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *CommunityMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *CommunityMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *CommunityMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[community.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *CommunityMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[community.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *CommunityMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, community.FieldEndAt)
}

// SetPic sets the "pic" field.
func (m *CommunityMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *CommunityMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *CommunityMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[community.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *CommunityMutation) PicCleared() bool {
	_, ok := m.clearedFields[community.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *CommunityMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, community.FieldPic)
}

// SetSponsor sets the "sponsor" field.
func (m *CommunityMutation) SetSponsor(s string) {
	m.sponsor = &s
}

// Sponsor returns the value of the "sponsor" field in the mutation.
func (m *CommunityMutation) Sponsor() (r string, exists bool) {
	v := m.sponsor
	if v == nil {
		return
	}
	return *v, true
}

// OldSponsor returns the old "sponsor" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldSponsor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSponsor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSponsor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSponsor: %w", err)
	}
	return oldValue.Sponsor, nil
}

// ClearSponsor clears the value of the "sponsor" field.
func (m *CommunityMutation) ClearSponsor() {
	m.sponsor = nil
	m.clearedFields[community.FieldSponsor] = struct{}{}
}

// SponsorCleared returns if the "sponsor" field was cleared in this mutation.
func (m *CommunityMutation) SponsorCleared() bool {
	_, ok := m.clearedFields[community.FieldSponsor]
	return ok
}

// ResetSponsor resets all changes to the "sponsor" field.
func (m *CommunityMutation) ResetSponsor() {
	m.sponsor = nil
	delete(m.clearedFields, community.FieldSponsor)
}

// SetFee sets the "fee" field.
func (m *CommunityMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *CommunityMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *CommunityMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *CommunityMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *CommunityMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[community.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *CommunityMutation) FeeCleared() bool {
	_, ok := m.clearedFields[community.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *CommunityMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, community.FieldFee)
}

// SetIsFee sets the "is_fee" field.
func (m *CommunityMutation) SetIsFee(i int64) {
	m.is_fee = &i
	m.addis_fee = nil
}

// IsFee returns the value of the "is_fee" field in the mutation.
func (m *CommunityMutation) IsFee() (r int64, exists bool) {
	v := m.is_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFee returns the old "is_fee" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldIsFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFee: %w", err)
	}
	return oldValue.IsFee, nil
}

// AddIsFee adds i to the "is_fee" field.
func (m *CommunityMutation) AddIsFee(i int64) {
	if m.addis_fee != nil {
		*m.addis_fee += i
	} else {
		m.addis_fee = &i
	}
}

// AddedIsFee returns the value that was added to the "is_fee" field in this mutation.
func (m *CommunityMutation) AddedIsFee() (r int64, exists bool) {
	v := m.addis_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsFee clears the value of the "is_fee" field.
func (m *CommunityMutation) ClearIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	m.clearedFields[community.FieldIsFee] = struct{}{}
}

// IsFeeCleared returns if the "is_fee" field was cleared in this mutation.
func (m *CommunityMutation) IsFeeCleared() bool {
	_, ok := m.clearedFields[community.FieldIsFee]
	return ok
}

// ResetIsFee resets all changes to the "is_fee" field.
func (m *CommunityMutation) ResetIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	delete(m.clearedFields, community.FieldIsFee)
}

// SetIsShow sets the "is_show" field.
func (m *CommunityMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *CommunityMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *CommunityMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *CommunityMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *CommunityMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[community.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *CommunityMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[community.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *CommunityMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, community.FieldIsShow)
}

// SetIsCancel sets the "is_cancel" field.
func (m *CommunityMutation) SetIsCancel(i int64) {
	m.is_cancel = &i
	m.addis_cancel = nil
}

// IsCancel returns the value of the "is_cancel" field in the mutation.
func (m *CommunityMutation) IsCancel() (r int64, exists bool) {
	v := m.is_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCancel returns the old "is_cancel" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldIsCancel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCancel: %w", err)
	}
	return oldValue.IsCancel, nil
}

// AddIsCancel adds i to the "is_cancel" field.
func (m *CommunityMutation) AddIsCancel(i int64) {
	if m.addis_cancel != nil {
		*m.addis_cancel += i
	} else {
		m.addis_cancel = &i
	}
}

// AddedIsCancel returns the value that was added to the "is_cancel" field in this mutation.
func (m *CommunityMutation) AddedIsCancel() (r int64, exists bool) {
	v := m.addis_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsCancel clears the value of the "is_cancel" field.
func (m *CommunityMutation) ClearIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	m.clearedFields[community.FieldIsCancel] = struct{}{}
}

// IsCancelCleared returns if the "is_cancel" field was cleared in this mutation.
func (m *CommunityMutation) IsCancelCleared() bool {
	_, ok := m.clearedFields[community.FieldIsCancel]
	return ok
}

// ResetIsCancel resets all changes to the "is_cancel" field.
func (m *CommunityMutation) ResetIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	delete(m.clearedFields, community.FieldIsCancel)
}

// SetCancelTime sets the "cancel_time" field.
func (m *CommunityMutation) SetCancelTime(i int64) {
	m.cancel_time = &i
	m.addcancel_time = nil
}

// CancelTime returns the value of the "cancel_time" field in the mutation.
func (m *CommunityMutation) CancelTime() (r int64, exists bool) {
	v := m.cancel_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelTime returns the old "cancel_time" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldCancelTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelTime: %w", err)
	}
	return oldValue.CancelTime, nil
}

// AddCancelTime adds i to the "cancel_time" field.
func (m *CommunityMutation) AddCancelTime(i int64) {
	if m.addcancel_time != nil {
		*m.addcancel_time += i
	} else {
		m.addcancel_time = &i
	}
}

// AddedCancelTime returns the value that was added to the "cancel_time" field in this mutation.
func (m *CommunityMutation) AddedCancelTime() (r int64, exists bool) {
	v := m.addcancel_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelTime clears the value of the "cancel_time" field.
func (m *CommunityMutation) ClearCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	m.clearedFields[community.FieldCancelTime] = struct{}{}
}

// CancelTimeCleared returns if the "cancel_time" field was cleared in this mutation.
func (m *CommunityMutation) CancelTimeCleared() bool {
	_, ok := m.clearedFields[community.FieldCancelTime]
	return ok
}

// ResetCancelTime resets all changes to the "cancel_time" field.
func (m *CommunityMutation) ResetCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	delete(m.clearedFields, community.FieldCancelTime)
}

// SetDetail sets the "detail" field.
func (m *CommunityMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *CommunityMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *CommunityMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[community.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *CommunityMutation) DetailCleared() bool {
	_, ok := m.clearedFields[community.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *CommunityMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, community.FieldDetail)
}

// SetSignFields sets the "sign_fields" field.
func (m *CommunityMutation) SetSignFields(s string) {
	m.sign_fields = &s
}

// SignFields returns the value of the "sign_fields" field in the mutation.
func (m *CommunityMutation) SignFields() (r string, exists bool) {
	v := m.sign_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldSignFields returns the old "sign_fields" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldSignFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignFields: %w", err)
	}
	return oldValue.SignFields, nil
}

// ClearSignFields clears the value of the "sign_fields" field.
func (m *CommunityMutation) ClearSignFields() {
	m.sign_fields = nil
	m.clearedFields[community.FieldSignFields] = struct{}{}
}

// SignFieldsCleared returns if the "sign_fields" field was cleared in this mutation.
func (m *CommunityMutation) SignFieldsCleared() bool {
	_, ok := m.clearedFields[community.FieldSignFields]
	return ok
}

// ResetSignFields resets all changes to the "sign_fields" field.
func (m *CommunityMutation) ResetSignFields() {
	m.sign_fields = nil
	delete(m.clearedFields, community.FieldSignFields)
}

// SetCondition sets the "condition" field.
func (m *CommunityMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *CommunityMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Community entity.
// If the Community object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *CommunityMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *CommunityMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *CommunityMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[community.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *CommunityMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[community.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *CommunityMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, community.FieldCondition)
}

// AddCommunityParticipantIDs adds the "community_participants" edge to the CommunityParticipant entity by ids.
func (m *CommunityMutation) AddCommunityParticipantIDs(ids ...int64) {
	if m.community_participants == nil {
		m.community_participants = make(map[int64]struct{})
	}
	for i := range ids {
		m.community_participants[ids[i]] = struct{}{}
	}
}

// ClearCommunityParticipants clears the "community_participants" edge to the CommunityParticipant entity.
func (m *CommunityMutation) ClearCommunityParticipants() {
	m.clearedcommunity_participants = true
}

// CommunityParticipantsCleared reports if the "community_participants" edge to the CommunityParticipant entity was cleared.
func (m *CommunityMutation) CommunityParticipantsCleared() bool {
	return m.clearedcommunity_participants
}

// RemoveCommunityParticipantIDs removes the "community_participants" edge to the CommunityParticipant entity by IDs.
func (m *CommunityMutation) RemoveCommunityParticipantIDs(ids ...int64) {
	if m.removedcommunity_participants == nil {
		m.removedcommunity_participants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.community_participants, ids[i])
		m.removedcommunity_participants[ids[i]] = struct{}{}
	}
}

// RemovedCommunityParticipants returns the removed IDs of the "community_participants" edge to the CommunityParticipant entity.
func (m *CommunityMutation) RemovedCommunityParticipantsIDs() (ids []int64) {
	for id := range m.removedcommunity_participants {
		ids = append(ids, id)
	}
	return
}

// CommunityParticipantsIDs returns the "community_participants" edge IDs in the mutation.
func (m *CommunityMutation) CommunityParticipantsIDs() (ids []int64) {
	for id := range m.community_participants {
		ids = append(ids, id)
	}
	return
}

// ResetCommunityParticipants resets all changes to the "community_participants" edge.
func (m *CommunityMutation) ResetCommunityParticipants() {
	m.community_participants = nil
	m.clearedcommunity_participants = false
	m.removedcommunity_participants = nil
}

// Where appends a list predicates to the CommunityMutation builder.
func (m *CommunityMutation) Where(ps ...predicate.Community) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommunityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommunityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Community, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommunityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommunityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Community).
func (m *CommunityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommunityMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, community.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, community.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, community.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, community.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, community.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, community.FieldName)
	}
	if m.sign_number != nil {
		fields = append(fields, community.FieldSignNumber)
	}
	if m.sign_start_at != nil {
		fields = append(fields, community.FieldSignStartAt)
	}
	if m.sign_end_at != nil {
		fields = append(fields, community.FieldSignEndAt)
	}
	if m.number != nil {
		fields = append(fields, community.FieldNumber)
	}
	if m.start_at != nil {
		fields = append(fields, community.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, community.FieldEndAt)
	}
	if m.pic != nil {
		fields = append(fields, community.FieldPic)
	}
	if m.sponsor != nil {
		fields = append(fields, community.FieldSponsor)
	}
	if m.fee != nil {
		fields = append(fields, community.FieldFee)
	}
	if m.is_fee != nil {
		fields = append(fields, community.FieldIsFee)
	}
	if m.is_show != nil {
		fields = append(fields, community.FieldIsShow)
	}
	if m.is_cancel != nil {
		fields = append(fields, community.FieldIsCancel)
	}
	if m.cancel_time != nil {
		fields = append(fields, community.FieldCancelTime)
	}
	if m.detail != nil {
		fields = append(fields, community.FieldDetail)
	}
	if m.sign_fields != nil {
		fields = append(fields, community.FieldSignFields)
	}
	if m.condition != nil {
		fields = append(fields, community.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommunityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case community.FieldCreatedAt:
		return m.CreatedAt()
	case community.FieldUpdatedAt:
		return m.UpdatedAt()
	case community.FieldDelete:
		return m.Delete()
	case community.FieldCreatedID:
		return m.CreatedID()
	case community.FieldStatus:
		return m.Status()
	case community.FieldName:
		return m.Name()
	case community.FieldSignNumber:
		return m.SignNumber()
	case community.FieldSignStartAt:
		return m.SignStartAt()
	case community.FieldSignEndAt:
		return m.SignEndAt()
	case community.FieldNumber:
		return m.Number()
	case community.FieldStartAt:
		return m.StartAt()
	case community.FieldEndAt:
		return m.EndAt()
	case community.FieldPic:
		return m.Pic()
	case community.FieldSponsor:
		return m.Sponsor()
	case community.FieldFee:
		return m.Fee()
	case community.FieldIsFee:
		return m.IsFee()
	case community.FieldIsShow:
		return m.IsShow()
	case community.FieldIsCancel:
		return m.IsCancel()
	case community.FieldCancelTime:
		return m.CancelTime()
	case community.FieldDetail:
		return m.Detail()
	case community.FieldSignFields:
		return m.SignFields()
	case community.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommunityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case community.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case community.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case community.FieldDelete:
		return m.OldDelete(ctx)
	case community.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case community.FieldStatus:
		return m.OldStatus(ctx)
	case community.FieldName:
		return m.OldName(ctx)
	case community.FieldSignNumber:
		return m.OldSignNumber(ctx)
	case community.FieldSignStartAt:
		return m.OldSignStartAt(ctx)
	case community.FieldSignEndAt:
		return m.OldSignEndAt(ctx)
	case community.FieldNumber:
		return m.OldNumber(ctx)
	case community.FieldStartAt:
		return m.OldStartAt(ctx)
	case community.FieldEndAt:
		return m.OldEndAt(ctx)
	case community.FieldPic:
		return m.OldPic(ctx)
	case community.FieldSponsor:
		return m.OldSponsor(ctx)
	case community.FieldFee:
		return m.OldFee(ctx)
	case community.FieldIsFee:
		return m.OldIsFee(ctx)
	case community.FieldIsShow:
		return m.OldIsShow(ctx)
	case community.FieldIsCancel:
		return m.OldIsCancel(ctx)
	case community.FieldCancelTime:
		return m.OldCancelTime(ctx)
	case community.FieldDetail:
		return m.OldDetail(ctx)
	case community.FieldSignFields:
		return m.OldSignFields(ctx)
	case community.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Community field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case community.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case community.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case community.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case community.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case community.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case community.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case community.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignNumber(v)
		return nil
	case community.FieldSignStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartAt(v)
		return nil
	case community.FieldSignEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndAt(v)
		return nil
	case community.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case community.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case community.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case community.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case community.FieldSponsor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSponsor(v)
		return nil
	case community.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case community.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFee(v)
		return nil
	case community.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case community.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCancel(v)
		return nil
	case community.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelTime(v)
		return nil
	case community.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case community.FieldSignFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignFields(v)
		return nil
	case community.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Community field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommunityMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, community.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, community.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, community.FieldStatus)
	}
	if m.addsign_number != nil {
		fields = append(fields, community.FieldSignNumber)
	}
	if m.addnumber != nil {
		fields = append(fields, community.FieldNumber)
	}
	if m.addfee != nil {
		fields = append(fields, community.FieldFee)
	}
	if m.addis_fee != nil {
		fields = append(fields, community.FieldIsFee)
	}
	if m.addis_show != nil {
		fields = append(fields, community.FieldIsShow)
	}
	if m.addis_cancel != nil {
		fields = append(fields, community.FieldIsCancel)
	}
	if m.addcancel_time != nil {
		fields = append(fields, community.FieldCancelTime)
	}
	if m.addcondition != nil {
		fields = append(fields, community.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommunityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case community.FieldDelete:
		return m.AddedDelete()
	case community.FieldCreatedID:
		return m.AddedCreatedID()
	case community.FieldStatus:
		return m.AddedStatus()
	case community.FieldSignNumber:
		return m.AddedSignNumber()
	case community.FieldNumber:
		return m.AddedNumber()
	case community.FieldFee:
		return m.AddedFee()
	case community.FieldIsFee:
		return m.AddedIsFee()
	case community.FieldIsShow:
		return m.AddedIsShow()
	case community.FieldIsCancel:
		return m.AddedIsCancel()
	case community.FieldCancelTime:
		return m.AddedCancelTime()
	case community.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case community.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case community.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case community.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case community.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignNumber(v)
		return nil
	case community.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case community.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case community.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFee(v)
		return nil
	case community.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	case community.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCancel(v)
		return nil
	case community.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelTime(v)
		return nil
	case community.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Community numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommunityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(community.FieldCreatedAt) {
		fields = append(fields, community.FieldCreatedAt)
	}
	if m.FieldCleared(community.FieldUpdatedAt) {
		fields = append(fields, community.FieldUpdatedAt)
	}
	if m.FieldCleared(community.FieldDelete) {
		fields = append(fields, community.FieldDelete)
	}
	if m.FieldCleared(community.FieldCreatedID) {
		fields = append(fields, community.FieldCreatedID)
	}
	if m.FieldCleared(community.FieldStatus) {
		fields = append(fields, community.FieldStatus)
	}
	if m.FieldCleared(community.FieldName) {
		fields = append(fields, community.FieldName)
	}
	if m.FieldCleared(community.FieldSignNumber) {
		fields = append(fields, community.FieldSignNumber)
	}
	if m.FieldCleared(community.FieldSignStartAt) {
		fields = append(fields, community.FieldSignStartAt)
	}
	if m.FieldCleared(community.FieldSignEndAt) {
		fields = append(fields, community.FieldSignEndAt)
	}
	if m.FieldCleared(community.FieldNumber) {
		fields = append(fields, community.FieldNumber)
	}
	if m.FieldCleared(community.FieldStartAt) {
		fields = append(fields, community.FieldStartAt)
	}
	if m.FieldCleared(community.FieldEndAt) {
		fields = append(fields, community.FieldEndAt)
	}
	if m.FieldCleared(community.FieldPic) {
		fields = append(fields, community.FieldPic)
	}
	if m.FieldCleared(community.FieldSponsor) {
		fields = append(fields, community.FieldSponsor)
	}
	if m.FieldCleared(community.FieldFee) {
		fields = append(fields, community.FieldFee)
	}
	if m.FieldCleared(community.FieldIsFee) {
		fields = append(fields, community.FieldIsFee)
	}
	if m.FieldCleared(community.FieldIsShow) {
		fields = append(fields, community.FieldIsShow)
	}
	if m.FieldCleared(community.FieldIsCancel) {
		fields = append(fields, community.FieldIsCancel)
	}
	if m.FieldCleared(community.FieldCancelTime) {
		fields = append(fields, community.FieldCancelTime)
	}
	if m.FieldCleared(community.FieldDetail) {
		fields = append(fields, community.FieldDetail)
	}
	if m.FieldCleared(community.FieldSignFields) {
		fields = append(fields, community.FieldSignFields)
	}
	if m.FieldCleared(community.FieldCondition) {
		fields = append(fields, community.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommunityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommunityMutation) ClearField(name string) error {
	switch name {
	case community.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case community.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case community.FieldDelete:
		m.ClearDelete()
		return nil
	case community.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case community.FieldStatus:
		m.ClearStatus()
		return nil
	case community.FieldName:
		m.ClearName()
		return nil
	case community.FieldSignNumber:
		m.ClearSignNumber()
		return nil
	case community.FieldSignStartAt:
		m.ClearSignStartAt()
		return nil
	case community.FieldSignEndAt:
		m.ClearSignEndAt()
		return nil
	case community.FieldNumber:
		m.ClearNumber()
		return nil
	case community.FieldStartAt:
		m.ClearStartAt()
		return nil
	case community.FieldEndAt:
		m.ClearEndAt()
		return nil
	case community.FieldPic:
		m.ClearPic()
		return nil
	case community.FieldSponsor:
		m.ClearSponsor()
		return nil
	case community.FieldFee:
		m.ClearFee()
		return nil
	case community.FieldIsFee:
		m.ClearIsFee()
		return nil
	case community.FieldIsShow:
		m.ClearIsShow()
		return nil
	case community.FieldIsCancel:
		m.ClearIsCancel()
		return nil
	case community.FieldCancelTime:
		m.ClearCancelTime()
		return nil
	case community.FieldDetail:
		m.ClearDetail()
		return nil
	case community.FieldSignFields:
		m.ClearSignFields()
		return nil
	case community.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Community nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommunityMutation) ResetField(name string) error {
	switch name {
	case community.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case community.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case community.FieldDelete:
		m.ResetDelete()
		return nil
	case community.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case community.FieldStatus:
		m.ResetStatus()
		return nil
	case community.FieldName:
		m.ResetName()
		return nil
	case community.FieldSignNumber:
		m.ResetSignNumber()
		return nil
	case community.FieldSignStartAt:
		m.ResetSignStartAt()
		return nil
	case community.FieldSignEndAt:
		m.ResetSignEndAt()
		return nil
	case community.FieldNumber:
		m.ResetNumber()
		return nil
	case community.FieldStartAt:
		m.ResetStartAt()
		return nil
	case community.FieldEndAt:
		m.ResetEndAt()
		return nil
	case community.FieldPic:
		m.ResetPic()
		return nil
	case community.FieldSponsor:
		m.ResetSponsor()
		return nil
	case community.FieldFee:
		m.ResetFee()
		return nil
	case community.FieldIsFee:
		m.ResetIsFee()
		return nil
	case community.FieldIsShow:
		m.ResetIsShow()
		return nil
	case community.FieldIsCancel:
		m.ResetIsCancel()
		return nil
	case community.FieldCancelTime:
		m.ResetCancelTime()
		return nil
	case community.FieldDetail:
		m.ResetDetail()
		return nil
	case community.FieldSignFields:
		m.ResetSignFields()
		return nil
	case community.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Community field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommunityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.community_participants != nil {
		edges = append(edges, community.EdgeCommunityParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommunityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case community.EdgeCommunityParticipants:
		ids := make([]ent.Value, 0, len(m.community_participants))
		for id := range m.community_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommunityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcommunity_participants != nil {
		edges = append(edges, community.EdgeCommunityParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommunityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case community.EdgeCommunityParticipants:
		ids := make([]ent.Value, 0, len(m.removedcommunity_participants))
		for id := range m.removedcommunity_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommunityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcommunity_participants {
		edges = append(edges, community.EdgeCommunityParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommunityMutation) EdgeCleared(name string) bool {
	switch name {
	case community.EdgeCommunityParticipants:
		return m.clearedcommunity_participants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommunityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Community unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommunityMutation) ResetEdge(name string) error {
	switch name {
	case community.EdgeCommunityParticipants:
		m.ResetCommunityParticipants()
		return nil
	}
	return fmt.Errorf("unknown Community edge %s", name)
}

// CommunityParticipantMutation represents an operation that mutates the CommunityParticipant nodes in the graph.
type CommunityParticipantMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	delete           *int64
	adddelete        *int64
	created_id       *int64
	addcreated_id    *int64
	status           *int64
	addstatus        *int64
	name             *string
	mobile           *string
	fields           *string
	order_id         *int64
	addorder_id      *int64
	order_sn         *string
	fee              *float64
	addfee           *float64
	member_id        *int64
	addmember_id     *int64
	clearedFields    map[string]struct{}
	community        *int64
	clearedcommunity bool
	members          map[int64]struct{}
	removedmembers   map[int64]struct{}
	clearedmembers   bool
	done             bool
	oldValue         func(context.Context) (*CommunityParticipant, error)
	predicates       []predicate.CommunityParticipant
}

var _ ent.Mutation = (*CommunityParticipantMutation)(nil)

// communityparticipantOption allows management of the mutation configuration using functional options.
type communityparticipantOption func(*CommunityParticipantMutation)

// newCommunityParticipantMutation creates new mutation for the CommunityParticipant entity.
func newCommunityParticipantMutation(c config, op Op, opts ...communityparticipantOption) *CommunityParticipantMutation {
	m := &CommunityParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeCommunityParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommunityParticipantID sets the ID field of the mutation.
func withCommunityParticipantID(id int64) communityparticipantOption {
	return func(m *CommunityParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *CommunityParticipant
		)
		m.oldValue = func(ctx context.Context) (*CommunityParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommunityParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommunityParticipant sets the old CommunityParticipant of the mutation.
func withCommunityParticipant(node *CommunityParticipant) communityparticipantOption {
	return func(m *CommunityParticipantMutation) {
		m.oldValue = func(context.Context) (*CommunityParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommunityParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommunityParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommunityParticipant entities.
func (m *CommunityParticipantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommunityParticipantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommunityParticipantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommunityParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommunityParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommunityParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *CommunityParticipantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[communityparticipant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *CommunityParticipantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommunityParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, communityparticipant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommunityParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommunityParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CommunityParticipantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[communityparticipant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CommunityParticipantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommunityParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, communityparticipant.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *CommunityParticipantMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *CommunityParticipantMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *CommunityParticipantMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *CommunityParticipantMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *CommunityParticipantMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[communityparticipant.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *CommunityParticipantMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *CommunityParticipantMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, communityparticipant.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *CommunityParticipantMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *CommunityParticipantMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *CommunityParticipantMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *CommunityParticipantMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *CommunityParticipantMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[communityparticipant.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *CommunityParticipantMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *CommunityParticipantMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, communityparticipant.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *CommunityParticipantMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommunityParticipantMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CommunityParticipantMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommunityParticipantMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CommunityParticipantMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[communityparticipant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CommunityParticipantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CommunityParticipantMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, communityparticipant.FieldStatus)
}

// SetCommunityID sets the "community_id" field.
func (m *CommunityParticipantMutation) SetCommunityID(i int64) {
	m.community = &i
}

// CommunityID returns the value of the "community_id" field in the mutation.
func (m *CommunityParticipantMutation) CommunityID() (r int64, exists bool) {
	v := m.community
	if v == nil {
		return
	}
	return *v, true
}

// OldCommunityID returns the old "community_id" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldCommunityID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommunityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommunityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommunityID: %w", err)
	}
	return oldValue.CommunityID, nil
}

// ClearCommunityID clears the value of the "community_id" field.
func (m *CommunityParticipantMutation) ClearCommunityID() {
	m.community = nil
	m.clearedFields[communityparticipant.FieldCommunityID] = struct{}{}
}

// CommunityIDCleared returns if the "community_id" field was cleared in this mutation.
func (m *CommunityParticipantMutation) CommunityIDCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldCommunityID]
	return ok
}

// ResetCommunityID resets all changes to the "community_id" field.
func (m *CommunityParticipantMutation) ResetCommunityID() {
	m.community = nil
	delete(m.clearedFields, communityparticipant.FieldCommunityID)
}

// SetName sets the "name" field.
func (m *CommunityParticipantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommunityParticipantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CommunityParticipantMutation) ClearName() {
	m.name = nil
	m.clearedFields[communityparticipant.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CommunityParticipantMutation) NameCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CommunityParticipantMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, communityparticipant.FieldName)
}

// SetMobile sets the "mobile" field.
func (m *CommunityParticipantMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *CommunityParticipantMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *CommunityParticipantMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[communityparticipant.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *CommunityParticipantMutation) MobileCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *CommunityParticipantMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, communityparticipant.FieldMobile)
}

// SetFields sets the "fields" field.
func (m *CommunityParticipantMutation) SetFields(s string) {
	m.fields = &s
}

// GetFields returns the value of the "fields" field in the mutation.
func (m *CommunityParticipantMutation) GetFields() (r string, exists bool) {
	v := m.fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFields returns the old "fields" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFields: %w", err)
	}
	return oldValue.Fields, nil
}

// ClearFields clears the value of the "fields" field.
func (m *CommunityParticipantMutation) ClearFields() {
	m.fields = nil
	m.clearedFields[communityparticipant.FieldFields] = struct{}{}
}

// FieldsCleared returns if the "fields" field was cleared in this mutation.
func (m *CommunityParticipantMutation) FieldsCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldFields]
	return ok
}

// ResetFields resets all changes to the "fields" field.
func (m *CommunityParticipantMutation) ResetFields() {
	m.fields = nil
	delete(m.clearedFields, communityparticipant.FieldFields)
}

// SetOrderID sets the "order_id" field.
func (m *CommunityParticipantMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CommunityParticipantMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *CommunityParticipantMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *CommunityParticipantMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *CommunityParticipantMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[communityparticipant.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *CommunityParticipantMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CommunityParticipantMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, communityparticipant.FieldOrderID)
}

// SetOrderSn sets the "order_sn" field.
func (m *CommunityParticipantMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *CommunityParticipantMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *CommunityParticipantMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[communityparticipant.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *CommunityParticipantMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *CommunityParticipantMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, communityparticipant.FieldOrderSn)
}

// SetFee sets the "fee" field.
func (m *CommunityParticipantMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *CommunityParticipantMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *CommunityParticipantMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *CommunityParticipantMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *CommunityParticipantMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[communityparticipant.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *CommunityParticipantMutation) FeeCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *CommunityParticipantMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, communityparticipant.FieldFee)
}

// SetMemberID sets the "member_id" field.
func (m *CommunityParticipantMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *CommunityParticipantMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the CommunityParticipant entity.
// If the CommunityParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommunityParticipantMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *CommunityParticipantMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *CommunityParticipantMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *CommunityParticipantMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[communityparticipant.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *CommunityParticipantMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[communityparticipant.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *CommunityParticipantMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, communityparticipant.FieldMemberID)
}

// ClearCommunity clears the "community" edge to the Community entity.
func (m *CommunityParticipantMutation) ClearCommunity() {
	m.clearedcommunity = true
	m.clearedFields[communityparticipant.FieldCommunityID] = struct{}{}
}

// CommunityCleared reports if the "community" edge to the Community entity was cleared.
func (m *CommunityParticipantMutation) CommunityCleared() bool {
	return m.CommunityIDCleared() || m.clearedcommunity
}

// CommunityIDs returns the "community" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommunityID instead. It exists only for internal usage by the builders.
func (m *CommunityParticipantMutation) CommunityIDs() (ids []int64) {
	if id := m.community; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommunity resets all changes to the "community" edge.
func (m *CommunityParticipantMutation) ResetCommunity() {
	m.community = nil
	m.clearedcommunity = false
}

// AddMemberIDs adds the "members" edge to the Member entity by ids.
func (m *CommunityParticipantMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *CommunityParticipantMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *CommunityParticipantMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Member entity by IDs.
func (m *CommunityParticipantMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Member entity.
func (m *CommunityParticipantMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *CommunityParticipantMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *CommunityParticipantMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the CommunityParticipantMutation builder.
func (m *CommunityParticipantMutation) Where(ps ...predicate.CommunityParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommunityParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommunityParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommunityParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommunityParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommunityParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommunityParticipant).
func (m *CommunityParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommunityParticipantMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, communityparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, communityparticipant.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, communityparticipant.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, communityparticipant.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, communityparticipant.FieldStatus)
	}
	if m.community != nil {
		fields = append(fields, communityparticipant.FieldCommunityID)
	}
	if m.name != nil {
		fields = append(fields, communityparticipant.FieldName)
	}
	if m.mobile != nil {
		fields = append(fields, communityparticipant.FieldMobile)
	}
	if m.fields != nil {
		fields = append(fields, communityparticipant.FieldFields)
	}
	if m.order_id != nil {
		fields = append(fields, communityparticipant.FieldOrderID)
	}
	if m.order_sn != nil {
		fields = append(fields, communityparticipant.FieldOrderSn)
	}
	if m.fee != nil {
		fields = append(fields, communityparticipant.FieldFee)
	}
	if m.member_id != nil {
		fields = append(fields, communityparticipant.FieldMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommunityParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case communityparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case communityparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	case communityparticipant.FieldDelete:
		return m.Delete()
	case communityparticipant.FieldCreatedID:
		return m.CreatedID()
	case communityparticipant.FieldStatus:
		return m.Status()
	case communityparticipant.FieldCommunityID:
		return m.CommunityID()
	case communityparticipant.FieldName:
		return m.Name()
	case communityparticipant.FieldMobile:
		return m.Mobile()
	case communityparticipant.FieldFields:
		return m.GetFields()
	case communityparticipant.FieldOrderID:
		return m.OrderID()
	case communityparticipant.FieldOrderSn:
		return m.OrderSn()
	case communityparticipant.FieldFee:
		return m.Fee()
	case communityparticipant.FieldMemberID:
		return m.MemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommunityParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case communityparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case communityparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case communityparticipant.FieldDelete:
		return m.OldDelete(ctx)
	case communityparticipant.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case communityparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case communityparticipant.FieldCommunityID:
		return m.OldCommunityID(ctx)
	case communityparticipant.FieldName:
		return m.OldName(ctx)
	case communityparticipant.FieldMobile:
		return m.OldMobile(ctx)
	case communityparticipant.FieldFields:
		return m.OldFields(ctx)
	case communityparticipant.FieldOrderID:
		return m.OldOrderID(ctx)
	case communityparticipant.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case communityparticipant.FieldFee:
		return m.OldFee(ctx)
	case communityparticipant.FieldMemberID:
		return m.OldMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown CommunityParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case communityparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case communityparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case communityparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case communityparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case communityparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case communityparticipant.FieldCommunityID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommunityID(v)
		return nil
	case communityparticipant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case communityparticipant.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case communityparticipant.FieldFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFields(v)
		return nil
	case communityparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case communityparticipant.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case communityparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case communityparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown CommunityParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommunityParticipantMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, communityparticipant.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, communityparticipant.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, communityparticipant.FieldStatus)
	}
	if m.addorder_id != nil {
		fields = append(fields, communityparticipant.FieldOrderID)
	}
	if m.addfee != nil {
		fields = append(fields, communityparticipant.FieldFee)
	}
	if m.addmember_id != nil {
		fields = append(fields, communityparticipant.FieldMemberID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommunityParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case communityparticipant.FieldDelete:
		return m.AddedDelete()
	case communityparticipant.FieldCreatedID:
		return m.AddedCreatedID()
	case communityparticipant.FieldStatus:
		return m.AddedStatus()
	case communityparticipant.FieldOrderID:
		return m.AddedOrderID()
	case communityparticipant.FieldFee:
		return m.AddedFee()
	case communityparticipant.FieldMemberID:
		return m.AddedMemberID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommunityParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case communityparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case communityparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case communityparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case communityparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case communityparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case communityparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown CommunityParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommunityParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(communityparticipant.FieldCreatedAt) {
		fields = append(fields, communityparticipant.FieldCreatedAt)
	}
	if m.FieldCleared(communityparticipant.FieldUpdatedAt) {
		fields = append(fields, communityparticipant.FieldUpdatedAt)
	}
	if m.FieldCleared(communityparticipant.FieldDelete) {
		fields = append(fields, communityparticipant.FieldDelete)
	}
	if m.FieldCleared(communityparticipant.FieldCreatedID) {
		fields = append(fields, communityparticipant.FieldCreatedID)
	}
	if m.FieldCleared(communityparticipant.FieldStatus) {
		fields = append(fields, communityparticipant.FieldStatus)
	}
	if m.FieldCleared(communityparticipant.FieldCommunityID) {
		fields = append(fields, communityparticipant.FieldCommunityID)
	}
	if m.FieldCleared(communityparticipant.FieldName) {
		fields = append(fields, communityparticipant.FieldName)
	}
	if m.FieldCleared(communityparticipant.FieldMobile) {
		fields = append(fields, communityparticipant.FieldMobile)
	}
	if m.FieldCleared(communityparticipant.FieldFields) {
		fields = append(fields, communityparticipant.FieldFields)
	}
	if m.FieldCleared(communityparticipant.FieldOrderID) {
		fields = append(fields, communityparticipant.FieldOrderID)
	}
	if m.FieldCleared(communityparticipant.FieldOrderSn) {
		fields = append(fields, communityparticipant.FieldOrderSn)
	}
	if m.FieldCleared(communityparticipant.FieldFee) {
		fields = append(fields, communityparticipant.FieldFee)
	}
	if m.FieldCleared(communityparticipant.FieldMemberID) {
		fields = append(fields, communityparticipant.FieldMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommunityParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommunityParticipantMutation) ClearField(name string) error {
	switch name {
	case communityparticipant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case communityparticipant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case communityparticipant.FieldDelete:
		m.ClearDelete()
		return nil
	case communityparticipant.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case communityparticipant.FieldStatus:
		m.ClearStatus()
		return nil
	case communityparticipant.FieldCommunityID:
		m.ClearCommunityID()
		return nil
	case communityparticipant.FieldName:
		m.ClearName()
		return nil
	case communityparticipant.FieldMobile:
		m.ClearMobile()
		return nil
	case communityparticipant.FieldFields:
		m.ClearFields()
		return nil
	case communityparticipant.FieldOrderID:
		m.ClearOrderID()
		return nil
	case communityparticipant.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case communityparticipant.FieldFee:
		m.ClearFee()
		return nil
	case communityparticipant.FieldMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown CommunityParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommunityParticipantMutation) ResetField(name string) error {
	switch name {
	case communityparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case communityparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case communityparticipant.FieldDelete:
		m.ResetDelete()
		return nil
	case communityparticipant.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case communityparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case communityparticipant.FieldCommunityID:
		m.ResetCommunityID()
		return nil
	case communityparticipant.FieldName:
		m.ResetName()
		return nil
	case communityparticipant.FieldMobile:
		m.ResetMobile()
		return nil
	case communityparticipant.FieldFields:
		m.ResetFields()
		return nil
	case communityparticipant.FieldOrderID:
		m.ResetOrderID()
		return nil
	case communityparticipant.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case communityparticipant.FieldFee:
		m.ResetFee()
		return nil
	case communityparticipant.FieldMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown CommunityParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommunityParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.community != nil {
		edges = append(edges, communityparticipant.EdgeCommunity)
	}
	if m.members != nil {
		edges = append(edges, communityparticipant.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommunityParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case communityparticipant.EdgeCommunity:
		if id := m.community; id != nil {
			return []ent.Value{*id}
		}
	case communityparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommunityParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, communityparticipant.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommunityParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case communityparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommunityParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcommunity {
		edges = append(edges, communityparticipant.EdgeCommunity)
	}
	if m.clearedmembers {
		edges = append(edges, communityparticipant.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommunityParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case communityparticipant.EdgeCommunity:
		return m.clearedcommunity
	case communityparticipant.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommunityParticipantMutation) ClearEdge(name string) error {
	switch name {
	case communityparticipant.EdgeCommunity:
		m.ClearCommunity()
		return nil
	}
	return fmt.Errorf("unknown CommunityParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommunityParticipantMutation) ResetEdge(name string) error {
	switch name {
	case communityparticipant.EdgeCommunity:
		m.ResetCommunity()
		return nil
	case communityparticipant.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown CommunityParticipant edge %s", name)
}

// ContestMutation represents an operation that mutates the Contest nodes in the graph.
type ContestMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	created_at                  *time.Time
	updated_at                  *time.Time
	delete                      *int64
	adddelete                   *int64
	created_id                  *int64
	addcreated_id               *int64
	status                      *int64
	addstatus                   *int64
	name                        *string
	sign_number                 *int64
	addsign_number              *int64
	sign_start_at               *time.Time
	sign_end_at                 *time.Time
	number                      *int64
	addnumber                   *int64
	start_at                    *time.Time
	end_at                      *time.Time
	pic                         *string
	sponsor                     *string
	fee                         *float64
	addfee                      *float64
	is_fee                      *int64
	addis_fee                   *int64
	is_show                     *int64
	addis_show                  *int64
	is_cancel                   *int64
	addis_cancel                *int64
	cancel_time                 *int64
	addcancel_time              *int64
	detail                      *string
	sign_fields                 *string
	condition                   *int64
	addcondition                *int64
	clearedFields               map[string]struct{}
	contest_participants        map[int64]struct{}
	removedcontest_participants map[int64]struct{}
	clearedcontest_participants bool
	done                        bool
	oldValue                    func(context.Context) (*Contest, error)
	predicates                  []predicate.Contest
}

var _ ent.Mutation = (*ContestMutation)(nil)

// contestOption allows management of the mutation configuration using functional options.
type contestOption func(*ContestMutation)

// newContestMutation creates new mutation for the Contest entity.
func newContestMutation(c config, op Op, opts ...contestOption) *ContestMutation {
	m := &ContestMutation{
		config:        c,
		op:            op,
		typ:           TypeContest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestID sets the ID field of the mutation.
func withContestID(id int64) contestOption {
	return func(m *ContestMutation) {
		var (
			err   error
			once  sync.Once
			value *Contest
		)
		m.oldValue = func(ctx context.Context) (*Contest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContest sets the old Contest of the mutation.
func withContest(node *Contest) contestOption {
	return func(m *ContestMutation) {
		m.oldValue = func(context.Context) (*Contest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contest entities.
func (m *ContestMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContestMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contest.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContestMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContestMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contest.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContestMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contest.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContestMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContestMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contest.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ContestMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ContestMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ContestMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ContestMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ContestMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[contest.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ContestMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[contest.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ContestMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, contest.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ContestMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ContestMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ContestMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ContestMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ContestMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[contest.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ContestMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[contest.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ContestMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, contest.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ContestMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContestMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContestMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContestMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContestMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contest.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContestMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contest.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContestMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contest.FieldStatus)
}

// SetName sets the "name" field.
func (m *ContestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContestMutation) ClearName() {
	m.name = nil
	m.clearedFields[contest.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContestMutation) NameCleared() bool {
	_, ok := m.clearedFields[contest.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContestMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contest.FieldName)
}

// SetSignNumber sets the "sign_number" field.
func (m *ContestMutation) SetSignNumber(i int64) {
	m.sign_number = &i
	m.addsign_number = nil
}

// SignNumber returns the value of the "sign_number" field in the mutation.
func (m *ContestMutation) SignNumber() (r int64, exists bool) {
	v := m.sign_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSignNumber returns the old "sign_number" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignNumber: %w", err)
	}
	return oldValue.SignNumber, nil
}

// AddSignNumber adds i to the "sign_number" field.
func (m *ContestMutation) AddSignNumber(i int64) {
	if m.addsign_number != nil {
		*m.addsign_number += i
	} else {
		m.addsign_number = &i
	}
}

// AddedSignNumber returns the value that was added to the "sign_number" field in this mutation.
func (m *ContestMutation) AddedSignNumber() (r int64, exists bool) {
	v := m.addsign_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearSignNumber clears the value of the "sign_number" field.
func (m *ContestMutation) ClearSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	m.clearedFields[contest.FieldSignNumber] = struct{}{}
}

// SignNumberCleared returns if the "sign_number" field was cleared in this mutation.
func (m *ContestMutation) SignNumberCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignNumber]
	return ok
}

// ResetSignNumber resets all changes to the "sign_number" field.
func (m *ContestMutation) ResetSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	delete(m.clearedFields, contest.FieldSignNumber)
}

// SetSignStartAt sets the "sign_start_at" field.
func (m *ContestMutation) SetSignStartAt(t time.Time) {
	m.sign_start_at = &t
}

// SignStartAt returns the value of the "sign_start_at" field in the mutation.
func (m *ContestMutation) SignStartAt() (r time.Time, exists bool) {
	v := m.sign_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartAt returns the old "sign_start_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartAt: %w", err)
	}
	return oldValue.SignStartAt, nil
}

// ClearSignStartAt clears the value of the "sign_start_at" field.
func (m *ContestMutation) ClearSignStartAt() {
	m.sign_start_at = nil
	m.clearedFields[contest.FieldSignStartAt] = struct{}{}
}

// SignStartAtCleared returns if the "sign_start_at" field was cleared in this mutation.
func (m *ContestMutation) SignStartAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignStartAt]
	return ok
}

// ResetSignStartAt resets all changes to the "sign_start_at" field.
func (m *ContestMutation) ResetSignStartAt() {
	m.sign_start_at = nil
	delete(m.clearedFields, contest.FieldSignStartAt)
}

// SetSignEndAt sets the "sign_end_at" field.
func (m *ContestMutation) SetSignEndAt(t time.Time) {
	m.sign_end_at = &t
}

// SignEndAt returns the value of the "sign_end_at" field in the mutation.
func (m *ContestMutation) SignEndAt() (r time.Time, exists bool) {
	v := m.sign_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndAt returns the old "sign_end_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndAt: %w", err)
	}
	return oldValue.SignEndAt, nil
}

// ClearSignEndAt clears the value of the "sign_end_at" field.
func (m *ContestMutation) ClearSignEndAt() {
	m.sign_end_at = nil
	m.clearedFields[contest.FieldSignEndAt] = struct{}{}
}

// SignEndAtCleared returns if the "sign_end_at" field was cleared in this mutation.
func (m *ContestMutation) SignEndAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignEndAt]
	return ok
}

// ResetSignEndAt resets all changes to the "sign_end_at" field.
func (m *ContestMutation) ResetSignEndAt() {
	m.sign_end_at = nil
	delete(m.clearedFields, contest.FieldSignEndAt)
}

// SetNumber sets the "number" field.
func (m *ContestMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *ContestMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *ContestMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *ContestMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *ContestMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[contest.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *ContestMutation) NumberCleared() bool {
	_, ok := m.clearedFields[contest.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *ContestMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, contest.FieldNumber)
}

// SetStartAt sets the "start_at" field.
func (m *ContestMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *ContestMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *ContestMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[contest.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *ContestMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *ContestMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, contest.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *ContestMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *ContestMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *ContestMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[contest.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *ContestMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *ContestMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, contest.FieldEndAt)
}

// SetPic sets the "pic" field.
func (m *ContestMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *ContestMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *ContestMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[contest.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *ContestMutation) PicCleared() bool {
	_, ok := m.clearedFields[contest.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *ContestMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, contest.FieldPic)
}

// SetSponsor sets the "sponsor" field.
func (m *ContestMutation) SetSponsor(s string) {
	m.sponsor = &s
}

// Sponsor returns the value of the "sponsor" field in the mutation.
func (m *ContestMutation) Sponsor() (r string, exists bool) {
	v := m.sponsor
	if v == nil {
		return
	}
	return *v, true
}

// OldSponsor returns the old "sponsor" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSponsor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSponsor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSponsor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSponsor: %w", err)
	}
	return oldValue.Sponsor, nil
}

// ClearSponsor clears the value of the "sponsor" field.
func (m *ContestMutation) ClearSponsor() {
	m.sponsor = nil
	m.clearedFields[contest.FieldSponsor] = struct{}{}
}

// SponsorCleared returns if the "sponsor" field was cleared in this mutation.
func (m *ContestMutation) SponsorCleared() bool {
	_, ok := m.clearedFields[contest.FieldSponsor]
	return ok
}

// ResetSponsor resets all changes to the "sponsor" field.
func (m *ContestMutation) ResetSponsor() {
	m.sponsor = nil
	delete(m.clearedFields, contest.FieldSponsor)
}

// SetFee sets the "fee" field.
func (m *ContestMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *ContestMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *ContestMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *ContestMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *ContestMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[contest.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *ContestMutation) FeeCleared() bool {
	_, ok := m.clearedFields[contest.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *ContestMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, contest.FieldFee)
}

// SetIsFee sets the "is_fee" field.
func (m *ContestMutation) SetIsFee(i int64) {
	m.is_fee = &i
	m.addis_fee = nil
}

// IsFee returns the value of the "is_fee" field in the mutation.
func (m *ContestMutation) IsFee() (r int64, exists bool) {
	v := m.is_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFee returns the old "is_fee" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldIsFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFee: %w", err)
	}
	return oldValue.IsFee, nil
}

// AddIsFee adds i to the "is_fee" field.
func (m *ContestMutation) AddIsFee(i int64) {
	if m.addis_fee != nil {
		*m.addis_fee += i
	} else {
		m.addis_fee = &i
	}
}

// AddedIsFee returns the value that was added to the "is_fee" field in this mutation.
func (m *ContestMutation) AddedIsFee() (r int64, exists bool) {
	v := m.addis_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsFee clears the value of the "is_fee" field.
func (m *ContestMutation) ClearIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	m.clearedFields[contest.FieldIsFee] = struct{}{}
}

// IsFeeCleared returns if the "is_fee" field was cleared in this mutation.
func (m *ContestMutation) IsFeeCleared() bool {
	_, ok := m.clearedFields[contest.FieldIsFee]
	return ok
}

// ResetIsFee resets all changes to the "is_fee" field.
func (m *ContestMutation) ResetIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	delete(m.clearedFields, contest.FieldIsFee)
}

// SetIsShow sets the "is_show" field.
func (m *ContestMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *ContestMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *ContestMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *ContestMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *ContestMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[contest.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *ContestMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[contest.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *ContestMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, contest.FieldIsShow)
}

// SetIsCancel sets the "is_cancel" field.
func (m *ContestMutation) SetIsCancel(i int64) {
	m.is_cancel = &i
	m.addis_cancel = nil
}

// IsCancel returns the value of the "is_cancel" field in the mutation.
func (m *ContestMutation) IsCancel() (r int64, exists bool) {
	v := m.is_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCancel returns the old "is_cancel" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldIsCancel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCancel: %w", err)
	}
	return oldValue.IsCancel, nil
}

// AddIsCancel adds i to the "is_cancel" field.
func (m *ContestMutation) AddIsCancel(i int64) {
	if m.addis_cancel != nil {
		*m.addis_cancel += i
	} else {
		m.addis_cancel = &i
	}
}

// AddedIsCancel returns the value that was added to the "is_cancel" field in this mutation.
func (m *ContestMutation) AddedIsCancel() (r int64, exists bool) {
	v := m.addis_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsCancel clears the value of the "is_cancel" field.
func (m *ContestMutation) ClearIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	m.clearedFields[contest.FieldIsCancel] = struct{}{}
}

// IsCancelCleared returns if the "is_cancel" field was cleared in this mutation.
func (m *ContestMutation) IsCancelCleared() bool {
	_, ok := m.clearedFields[contest.FieldIsCancel]
	return ok
}

// ResetIsCancel resets all changes to the "is_cancel" field.
func (m *ContestMutation) ResetIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	delete(m.clearedFields, contest.FieldIsCancel)
}

// SetCancelTime sets the "cancel_time" field.
func (m *ContestMutation) SetCancelTime(i int64) {
	m.cancel_time = &i
	m.addcancel_time = nil
}

// CancelTime returns the value of the "cancel_time" field in the mutation.
func (m *ContestMutation) CancelTime() (r int64, exists bool) {
	v := m.cancel_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelTime returns the old "cancel_time" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCancelTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelTime: %w", err)
	}
	return oldValue.CancelTime, nil
}

// AddCancelTime adds i to the "cancel_time" field.
func (m *ContestMutation) AddCancelTime(i int64) {
	if m.addcancel_time != nil {
		*m.addcancel_time += i
	} else {
		m.addcancel_time = &i
	}
}

// AddedCancelTime returns the value that was added to the "cancel_time" field in this mutation.
func (m *ContestMutation) AddedCancelTime() (r int64, exists bool) {
	v := m.addcancel_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelTime clears the value of the "cancel_time" field.
func (m *ContestMutation) ClearCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	m.clearedFields[contest.FieldCancelTime] = struct{}{}
}

// CancelTimeCleared returns if the "cancel_time" field was cleared in this mutation.
func (m *ContestMutation) CancelTimeCleared() bool {
	_, ok := m.clearedFields[contest.FieldCancelTime]
	return ok
}

// ResetCancelTime resets all changes to the "cancel_time" field.
func (m *ContestMutation) ResetCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	delete(m.clearedFields, contest.FieldCancelTime)
}

// SetDetail sets the "detail" field.
func (m *ContestMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ContestMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *ContestMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[contest.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *ContestMutation) DetailCleared() bool {
	_, ok := m.clearedFields[contest.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *ContestMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, contest.FieldDetail)
}

// SetSignFields sets the "sign_fields" field.
func (m *ContestMutation) SetSignFields(s string) {
	m.sign_fields = &s
}

// SignFields returns the value of the "sign_fields" field in the mutation.
func (m *ContestMutation) SignFields() (r string, exists bool) {
	v := m.sign_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldSignFields returns the old "sign_fields" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignFields: %w", err)
	}
	return oldValue.SignFields, nil
}

// ClearSignFields clears the value of the "sign_fields" field.
func (m *ContestMutation) ClearSignFields() {
	m.sign_fields = nil
	m.clearedFields[contest.FieldSignFields] = struct{}{}
}

// SignFieldsCleared returns if the "sign_fields" field was cleared in this mutation.
func (m *ContestMutation) SignFieldsCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignFields]
	return ok
}

// ResetSignFields resets all changes to the "sign_fields" field.
func (m *ContestMutation) ResetSignFields() {
	m.sign_fields = nil
	delete(m.clearedFields, contest.FieldSignFields)
}

// SetCondition sets the "condition" field.
func (m *ContestMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *ContestMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *ContestMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *ContestMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *ContestMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[contest.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *ContestMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[contest.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *ContestMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, contest.FieldCondition)
}

// AddContestParticipantIDs adds the "contest_participants" edge to the ContestParticipant entity by ids.
func (m *ContestMutation) AddContestParticipantIDs(ids ...int64) {
	if m.contest_participants == nil {
		m.contest_participants = make(map[int64]struct{})
	}
	for i := range ids {
		m.contest_participants[ids[i]] = struct{}{}
	}
}

// ClearContestParticipants clears the "contest_participants" edge to the ContestParticipant entity.
func (m *ContestMutation) ClearContestParticipants() {
	m.clearedcontest_participants = true
}

// ContestParticipantsCleared reports if the "contest_participants" edge to the ContestParticipant entity was cleared.
func (m *ContestMutation) ContestParticipantsCleared() bool {
	return m.clearedcontest_participants
}

// RemoveContestParticipantIDs removes the "contest_participants" edge to the ContestParticipant entity by IDs.
func (m *ContestMutation) RemoveContestParticipantIDs(ids ...int64) {
	if m.removedcontest_participants == nil {
		m.removedcontest_participants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.contest_participants, ids[i])
		m.removedcontest_participants[ids[i]] = struct{}{}
	}
}

// RemovedContestParticipants returns the removed IDs of the "contest_participants" edge to the ContestParticipant entity.
func (m *ContestMutation) RemovedContestParticipantsIDs() (ids []int64) {
	for id := range m.removedcontest_participants {
		ids = append(ids, id)
	}
	return
}

// ContestParticipantsIDs returns the "contest_participants" edge IDs in the mutation.
func (m *ContestMutation) ContestParticipantsIDs() (ids []int64) {
	for id := range m.contest_participants {
		ids = append(ids, id)
	}
	return
}

// ResetContestParticipants resets all changes to the "contest_participants" edge.
func (m *ContestMutation) ResetContestParticipants() {
	m.contest_participants = nil
	m.clearedcontest_participants = false
	m.removedcontest_participants = nil
}

// Where appends a list predicates to the ContestMutation builder.
func (m *ContestMutation) Where(ps ...predicate.Contest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contest).
func (m *ContestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, contest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contest.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, contest.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, contest.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, contest.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, contest.FieldName)
	}
	if m.sign_number != nil {
		fields = append(fields, contest.FieldSignNumber)
	}
	if m.sign_start_at != nil {
		fields = append(fields, contest.FieldSignStartAt)
	}
	if m.sign_end_at != nil {
		fields = append(fields, contest.FieldSignEndAt)
	}
	if m.number != nil {
		fields = append(fields, contest.FieldNumber)
	}
	if m.start_at != nil {
		fields = append(fields, contest.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, contest.FieldEndAt)
	}
	if m.pic != nil {
		fields = append(fields, contest.FieldPic)
	}
	if m.sponsor != nil {
		fields = append(fields, contest.FieldSponsor)
	}
	if m.fee != nil {
		fields = append(fields, contest.FieldFee)
	}
	if m.is_fee != nil {
		fields = append(fields, contest.FieldIsFee)
	}
	if m.is_show != nil {
		fields = append(fields, contest.FieldIsShow)
	}
	if m.is_cancel != nil {
		fields = append(fields, contest.FieldIsCancel)
	}
	if m.cancel_time != nil {
		fields = append(fields, contest.FieldCancelTime)
	}
	if m.detail != nil {
		fields = append(fields, contest.FieldDetail)
	}
	if m.sign_fields != nil {
		fields = append(fields, contest.FieldSignFields)
	}
	if m.condition != nil {
		fields = append(fields, contest.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldCreatedAt:
		return m.CreatedAt()
	case contest.FieldUpdatedAt:
		return m.UpdatedAt()
	case contest.FieldDelete:
		return m.Delete()
	case contest.FieldCreatedID:
		return m.CreatedID()
	case contest.FieldStatus:
		return m.Status()
	case contest.FieldName:
		return m.Name()
	case contest.FieldSignNumber:
		return m.SignNumber()
	case contest.FieldSignStartAt:
		return m.SignStartAt()
	case contest.FieldSignEndAt:
		return m.SignEndAt()
	case contest.FieldNumber:
		return m.Number()
	case contest.FieldStartAt:
		return m.StartAt()
	case contest.FieldEndAt:
		return m.EndAt()
	case contest.FieldPic:
		return m.Pic()
	case contest.FieldSponsor:
		return m.Sponsor()
	case contest.FieldFee:
		return m.Fee()
	case contest.FieldIsFee:
		return m.IsFee()
	case contest.FieldIsShow:
		return m.IsShow()
	case contest.FieldIsCancel:
		return m.IsCancel()
	case contest.FieldCancelTime:
		return m.CancelTime()
	case contest.FieldDetail:
		return m.Detail()
	case contest.FieldSignFields:
		return m.SignFields()
	case contest.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contest.FieldDelete:
		return m.OldDelete(ctx)
	case contest.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case contest.FieldStatus:
		return m.OldStatus(ctx)
	case contest.FieldName:
		return m.OldName(ctx)
	case contest.FieldSignNumber:
		return m.OldSignNumber(ctx)
	case contest.FieldSignStartAt:
		return m.OldSignStartAt(ctx)
	case contest.FieldSignEndAt:
		return m.OldSignEndAt(ctx)
	case contest.FieldNumber:
		return m.OldNumber(ctx)
	case contest.FieldStartAt:
		return m.OldStartAt(ctx)
	case contest.FieldEndAt:
		return m.OldEndAt(ctx)
	case contest.FieldPic:
		return m.OldPic(ctx)
	case contest.FieldSponsor:
		return m.OldSponsor(ctx)
	case contest.FieldFee:
		return m.OldFee(ctx)
	case contest.FieldIsFee:
		return m.OldIsFee(ctx)
	case contest.FieldIsShow:
		return m.OldIsShow(ctx)
	case contest.FieldIsCancel:
		return m.OldIsCancel(ctx)
	case contest.FieldCancelTime:
		return m.OldCancelTime(ctx)
	case contest.FieldDetail:
		return m.OldDetail(ctx)
	case contest.FieldSignFields:
		return m.OldSignFields(ctx)
	case contest.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Contest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contest.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case contest.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case contest.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contest.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignNumber(v)
		return nil
	case contest.FieldSignStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartAt(v)
		return nil
	case contest.FieldSignEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndAt(v)
		return nil
	case contest.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case contest.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case contest.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case contest.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case contest.FieldSponsor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSponsor(v)
		return nil
	case contest.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case contest.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFee(v)
		return nil
	case contest.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case contest.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCancel(v)
		return nil
	case contest.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelTime(v)
		return nil
	case contest.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case contest.FieldSignFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignFields(v)
		return nil
	case contest.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, contest.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, contest.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, contest.FieldStatus)
	}
	if m.addsign_number != nil {
		fields = append(fields, contest.FieldSignNumber)
	}
	if m.addnumber != nil {
		fields = append(fields, contest.FieldNumber)
	}
	if m.addfee != nil {
		fields = append(fields, contest.FieldFee)
	}
	if m.addis_fee != nil {
		fields = append(fields, contest.FieldIsFee)
	}
	if m.addis_show != nil {
		fields = append(fields, contest.FieldIsShow)
	}
	if m.addis_cancel != nil {
		fields = append(fields, contest.FieldIsCancel)
	}
	if m.addcancel_time != nil {
		fields = append(fields, contest.FieldCancelTime)
	}
	if m.addcondition != nil {
		fields = append(fields, contest.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldDelete:
		return m.AddedDelete()
	case contest.FieldCreatedID:
		return m.AddedCreatedID()
	case contest.FieldStatus:
		return m.AddedStatus()
	case contest.FieldSignNumber:
		return m.AddedSignNumber()
	case contest.FieldNumber:
		return m.AddedNumber()
	case contest.FieldFee:
		return m.AddedFee()
	case contest.FieldIsFee:
		return m.AddedIsFee()
	case contest.FieldIsShow:
		return m.AddedIsShow()
	case contest.FieldIsCancel:
		return m.AddedIsCancel()
	case contest.FieldCancelTime:
		return m.AddedCancelTime()
	case contest.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contest.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case contest.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case contest.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case contest.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignNumber(v)
		return nil
	case contest.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case contest.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case contest.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFee(v)
		return nil
	case contest.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	case contest.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCancel(v)
		return nil
	case contest.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelTime(v)
		return nil
	case contest.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Contest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contest.FieldCreatedAt) {
		fields = append(fields, contest.FieldCreatedAt)
	}
	if m.FieldCleared(contest.FieldUpdatedAt) {
		fields = append(fields, contest.FieldUpdatedAt)
	}
	if m.FieldCleared(contest.FieldDelete) {
		fields = append(fields, contest.FieldDelete)
	}
	if m.FieldCleared(contest.FieldCreatedID) {
		fields = append(fields, contest.FieldCreatedID)
	}
	if m.FieldCleared(contest.FieldStatus) {
		fields = append(fields, contest.FieldStatus)
	}
	if m.FieldCleared(contest.FieldName) {
		fields = append(fields, contest.FieldName)
	}
	if m.FieldCleared(contest.FieldSignNumber) {
		fields = append(fields, contest.FieldSignNumber)
	}
	if m.FieldCleared(contest.FieldSignStartAt) {
		fields = append(fields, contest.FieldSignStartAt)
	}
	if m.FieldCleared(contest.FieldSignEndAt) {
		fields = append(fields, contest.FieldSignEndAt)
	}
	if m.FieldCleared(contest.FieldNumber) {
		fields = append(fields, contest.FieldNumber)
	}
	if m.FieldCleared(contest.FieldStartAt) {
		fields = append(fields, contest.FieldStartAt)
	}
	if m.FieldCleared(contest.FieldEndAt) {
		fields = append(fields, contest.FieldEndAt)
	}
	if m.FieldCleared(contest.FieldPic) {
		fields = append(fields, contest.FieldPic)
	}
	if m.FieldCleared(contest.FieldSponsor) {
		fields = append(fields, contest.FieldSponsor)
	}
	if m.FieldCleared(contest.FieldFee) {
		fields = append(fields, contest.FieldFee)
	}
	if m.FieldCleared(contest.FieldIsFee) {
		fields = append(fields, contest.FieldIsFee)
	}
	if m.FieldCleared(contest.FieldIsShow) {
		fields = append(fields, contest.FieldIsShow)
	}
	if m.FieldCleared(contest.FieldIsCancel) {
		fields = append(fields, contest.FieldIsCancel)
	}
	if m.FieldCleared(contest.FieldCancelTime) {
		fields = append(fields, contest.FieldCancelTime)
	}
	if m.FieldCleared(contest.FieldDetail) {
		fields = append(fields, contest.FieldDetail)
	}
	if m.FieldCleared(contest.FieldSignFields) {
		fields = append(fields, contest.FieldSignFields)
	}
	if m.FieldCleared(contest.FieldCondition) {
		fields = append(fields, contest.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestMutation) ClearField(name string) error {
	switch name {
	case contest.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contest.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contest.FieldDelete:
		m.ClearDelete()
		return nil
	case contest.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case contest.FieldStatus:
		m.ClearStatus()
		return nil
	case contest.FieldName:
		m.ClearName()
		return nil
	case contest.FieldSignNumber:
		m.ClearSignNumber()
		return nil
	case contest.FieldSignStartAt:
		m.ClearSignStartAt()
		return nil
	case contest.FieldSignEndAt:
		m.ClearSignEndAt()
		return nil
	case contest.FieldNumber:
		m.ClearNumber()
		return nil
	case contest.FieldStartAt:
		m.ClearStartAt()
		return nil
	case contest.FieldEndAt:
		m.ClearEndAt()
		return nil
	case contest.FieldPic:
		m.ClearPic()
		return nil
	case contest.FieldSponsor:
		m.ClearSponsor()
		return nil
	case contest.FieldFee:
		m.ClearFee()
		return nil
	case contest.FieldIsFee:
		m.ClearIsFee()
		return nil
	case contest.FieldIsShow:
		m.ClearIsShow()
		return nil
	case contest.FieldIsCancel:
		m.ClearIsCancel()
		return nil
	case contest.FieldCancelTime:
		m.ClearCancelTime()
		return nil
	case contest.FieldDetail:
		m.ClearDetail()
		return nil
	case contest.FieldSignFields:
		m.ClearSignFields()
		return nil
	case contest.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Contest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestMutation) ResetField(name string) error {
	switch name {
	case contest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contest.FieldDelete:
		m.ResetDelete()
		return nil
	case contest.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case contest.FieldStatus:
		m.ResetStatus()
		return nil
	case contest.FieldName:
		m.ResetName()
		return nil
	case contest.FieldSignNumber:
		m.ResetSignNumber()
		return nil
	case contest.FieldSignStartAt:
		m.ResetSignStartAt()
		return nil
	case contest.FieldSignEndAt:
		m.ResetSignEndAt()
		return nil
	case contest.FieldNumber:
		m.ResetNumber()
		return nil
	case contest.FieldStartAt:
		m.ResetStartAt()
		return nil
	case contest.FieldEndAt:
		m.ResetEndAt()
		return nil
	case contest.FieldPic:
		m.ResetPic()
		return nil
	case contest.FieldSponsor:
		m.ResetSponsor()
		return nil
	case contest.FieldFee:
		m.ResetFee()
		return nil
	case contest.FieldIsFee:
		m.ResetIsFee()
		return nil
	case contest.FieldIsShow:
		m.ResetIsShow()
		return nil
	case contest.FieldIsCancel:
		m.ResetIsCancel()
		return nil
	case contest.FieldCancelTime:
		m.ResetCancelTime()
		return nil
	case contest.FieldDetail:
		m.ResetDetail()
		return nil
	case contest.FieldSignFields:
		m.ResetSignFields()
		return nil
	case contest.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contest_participants != nil {
		edges = append(edges, contest.EdgeContestParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgeContestParticipants:
		ids := make([]ent.Value, 0, len(m.contest_participants))
		for id := range m.contest_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcontest_participants != nil {
		edges = append(edges, contest.EdgeContestParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgeContestParticipants:
		ids := make([]ent.Value, 0, len(m.removedcontest_participants))
		for id := range m.removedcontest_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontest_participants {
		edges = append(edges, contest.EdgeContestParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestMutation) EdgeCleared(name string) bool {
	switch name {
	case contest.EdgeContestParticipants:
		return m.clearedcontest_participants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Contest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestMutation) ResetEdge(name string) error {
	switch name {
	case contest.EdgeContestParticipants:
		m.ResetContestParticipants()
		return nil
	}
	return fmt.Errorf("unknown Contest edge %s", name)
}

// ContestParticipantMutation represents an operation that mutates the ContestParticipant nodes in the graph.
type ContestParticipantMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	name           *string
	mobile         *string
	fields         *string
	order_id       *int64
	addorder_id    *int64
	order_sn       *string
	fee            *float64
	addfee         *float64
	member_id      *int64
	addmember_id   *int64
	clearedFields  map[string]struct{}
	contest        *int64
	clearedcontest bool
	members        map[int64]struct{}
	removedmembers map[int64]struct{}
	clearedmembers bool
	done           bool
	oldValue       func(context.Context) (*ContestParticipant, error)
	predicates     []predicate.ContestParticipant
}

var _ ent.Mutation = (*ContestParticipantMutation)(nil)

// contestparticipantOption allows management of the mutation configuration using functional options.
type contestparticipantOption func(*ContestParticipantMutation)

// newContestParticipantMutation creates new mutation for the ContestParticipant entity.
func newContestParticipantMutation(c config, op Op, opts ...contestparticipantOption) *ContestParticipantMutation {
	m := &ContestParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeContestParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestParticipantID sets the ID field of the mutation.
func withContestParticipantID(id int64) contestparticipantOption {
	return func(m *ContestParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *ContestParticipant
		)
		m.oldValue = func(ctx context.Context) (*ContestParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContestParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContestParticipant sets the old ContestParticipant of the mutation.
func withContestParticipant(node *ContestParticipant) contestparticipantOption {
	return func(m *ContestParticipantMutation) {
		m.oldValue = func(context.Context) (*ContestParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContestParticipant entities.
func (m *ContestParticipantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestParticipantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestParticipantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContestParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContestParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContestParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContestParticipantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contestparticipant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContestParticipantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContestParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contestparticipant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContestParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContestParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContestParticipantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contestparticipant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContestParticipantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContestParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contestparticipant.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ContestParticipantMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ContestParticipantMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ContestParticipantMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ContestParticipantMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ContestParticipantMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[contestparticipant.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ContestParticipantMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ContestParticipantMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, contestparticipant.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ContestParticipantMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ContestParticipantMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ContestParticipantMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ContestParticipantMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ContestParticipantMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[contestparticipant.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ContestParticipantMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, contestparticipant.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ContestParticipantMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContestParticipantMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContestParticipantMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContestParticipantMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContestParticipantMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contestparticipant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContestParticipantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContestParticipantMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contestparticipant.FieldStatus)
}

// SetContestID sets the "contest_id" field.
func (m *ContestParticipantMutation) SetContestID(i int64) {
	m.contest = &i
}

// ContestID returns the value of the "contest_id" field in the mutation.
func (m *ContestParticipantMutation) ContestID() (r int64, exists bool) {
	v := m.contest
	if v == nil {
		return
	}
	return *v, true
}

// OldContestID returns the old "contest_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldContestID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContestID: %w", err)
	}
	return oldValue.ContestID, nil
}

// ClearContestID clears the value of the "contest_id" field.
func (m *ContestParticipantMutation) ClearContestID() {
	m.contest = nil
	m.clearedFields[contestparticipant.FieldContestID] = struct{}{}
}

// ContestIDCleared returns if the "contest_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) ContestIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldContestID]
	return ok
}

// ResetContestID resets all changes to the "contest_id" field.
func (m *ContestParticipantMutation) ResetContestID() {
	m.contest = nil
	delete(m.clearedFields, contestparticipant.FieldContestID)
}

// SetName sets the "name" field.
func (m *ContestParticipantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContestParticipantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContestParticipantMutation) ClearName() {
	m.name = nil
	m.clearedFields[contestparticipant.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContestParticipantMutation) NameCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContestParticipantMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contestparticipant.FieldName)
}

// SetMobile sets the "mobile" field.
func (m *ContestParticipantMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *ContestParticipantMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *ContestParticipantMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[contestparticipant.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *ContestParticipantMutation) MobileCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *ContestParticipantMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, contestparticipant.FieldMobile)
}

// SetFields sets the "fields" field.
func (m *ContestParticipantMutation) SetFields(s string) {
	m.fields = &s
}

// GetFields returns the value of the "fields" field in the mutation.
func (m *ContestParticipantMutation) GetFields() (r string, exists bool) {
	v := m.fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFields returns the old "fields" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFields: %w", err)
	}
	return oldValue.Fields, nil
}

// ClearFields clears the value of the "fields" field.
func (m *ContestParticipantMutation) ClearFields() {
	m.fields = nil
	m.clearedFields[contestparticipant.FieldFields] = struct{}{}
}

// FieldsCleared returns if the "fields" field was cleared in this mutation.
func (m *ContestParticipantMutation) FieldsCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldFields]
	return ok
}

// ResetFields resets all changes to the "fields" field.
func (m *ContestParticipantMutation) ResetFields() {
	m.fields = nil
	delete(m.clearedFields, contestparticipant.FieldFields)
}

// SetOrderID sets the "order_id" field.
func (m *ContestParticipantMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *ContestParticipantMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *ContestParticipantMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *ContestParticipantMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *ContestParticipantMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[contestparticipant.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *ContestParticipantMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, contestparticipant.FieldOrderID)
}

// SetOrderSn sets the "order_sn" field.
func (m *ContestParticipantMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *ContestParticipantMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *ContestParticipantMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[contestparticipant.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *ContestParticipantMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *ContestParticipantMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, contestparticipant.FieldOrderSn)
}

// SetFee sets the "fee" field.
func (m *ContestParticipantMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *ContestParticipantMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *ContestParticipantMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *ContestParticipantMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *ContestParticipantMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[contestparticipant.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *ContestParticipantMutation) FeeCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *ContestParticipantMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, contestparticipant.FieldFee)
}

// SetMemberID sets the "member_id" field.
func (m *ContestParticipantMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *ContestParticipantMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *ContestParticipantMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *ContestParticipantMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *ContestParticipantMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[contestparticipant.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *ContestParticipantMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, contestparticipant.FieldMemberID)
}

// ClearContest clears the "contest" edge to the Contest entity.
func (m *ContestParticipantMutation) ClearContest() {
	m.clearedcontest = true
	m.clearedFields[contestparticipant.FieldContestID] = struct{}{}
}

// ContestCleared reports if the "contest" edge to the Contest entity was cleared.
func (m *ContestParticipantMutation) ContestCleared() bool {
	return m.ContestIDCleared() || m.clearedcontest
}

// ContestIDs returns the "contest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContestID instead. It exists only for internal usage by the builders.
func (m *ContestParticipantMutation) ContestIDs() (ids []int64) {
	if id := m.contest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContest resets all changes to the "contest" edge.
func (m *ContestParticipantMutation) ResetContest() {
	m.contest = nil
	m.clearedcontest = false
}

// AddMemberIDs adds the "members" edge to the Member entity by ids.
func (m *ContestParticipantMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *ContestParticipantMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *ContestParticipantMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Member entity by IDs.
func (m *ContestParticipantMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Member entity.
func (m *ContestParticipantMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ContestParticipantMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ContestParticipantMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the ContestParticipantMutation builder.
func (m *ContestParticipantMutation) Where(ps ...predicate.ContestParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContestParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContestParticipant).
func (m *ContestParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestParticipantMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, contestparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contestparticipant.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, contestparticipant.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, contestparticipant.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, contestparticipant.FieldStatus)
	}
	if m.contest != nil {
		fields = append(fields, contestparticipant.FieldContestID)
	}
	if m.name != nil {
		fields = append(fields, contestparticipant.FieldName)
	}
	if m.mobile != nil {
		fields = append(fields, contestparticipant.FieldMobile)
	}
	if m.fields != nil {
		fields = append(fields, contestparticipant.FieldFields)
	}
	if m.order_id != nil {
		fields = append(fields, contestparticipant.FieldOrderID)
	}
	if m.order_sn != nil {
		fields = append(fields, contestparticipant.FieldOrderSn)
	}
	if m.fee != nil {
		fields = append(fields, contestparticipant.FieldFee)
	}
	if m.member_id != nil {
		fields = append(fields, contestparticipant.FieldMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contestparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case contestparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	case contestparticipant.FieldDelete:
		return m.Delete()
	case contestparticipant.FieldCreatedID:
		return m.CreatedID()
	case contestparticipant.FieldStatus:
		return m.Status()
	case contestparticipant.FieldContestID:
		return m.ContestID()
	case contestparticipant.FieldName:
		return m.Name()
	case contestparticipant.FieldMobile:
		return m.Mobile()
	case contestparticipant.FieldFields:
		return m.GetFields()
	case contestparticipant.FieldOrderID:
		return m.OrderID()
	case contestparticipant.FieldOrderSn:
		return m.OrderSn()
	case contestparticipant.FieldFee:
		return m.Fee()
	case contestparticipant.FieldMemberID:
		return m.MemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contestparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contestparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contestparticipant.FieldDelete:
		return m.OldDelete(ctx)
	case contestparticipant.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case contestparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case contestparticipant.FieldContestID:
		return m.OldContestID(ctx)
	case contestparticipant.FieldName:
		return m.OldName(ctx)
	case contestparticipant.FieldMobile:
		return m.OldMobile(ctx)
	case contestparticipant.FieldFields:
		return m.OldFields(ctx)
	case contestparticipant.FieldOrderID:
		return m.OldOrderID(ctx)
	case contestparticipant.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case contestparticipant.FieldFee:
		return m.OldFee(ctx)
	case contestparticipant.FieldMemberID:
		return m.OldMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown ContestParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contestparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contestparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contestparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case contestparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case contestparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contestparticipant.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContestID(v)
		return nil
	case contestparticipant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contestparticipant.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case contestparticipant.FieldFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFields(v)
		return nil
	case contestparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case contestparticipant.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case contestparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case contestparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestParticipantMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, contestparticipant.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, contestparticipant.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, contestparticipant.FieldStatus)
	}
	if m.addorder_id != nil {
		fields = append(fields, contestparticipant.FieldOrderID)
	}
	if m.addfee != nil {
		fields = append(fields, contestparticipant.FieldFee)
	}
	if m.addmember_id != nil {
		fields = append(fields, contestparticipant.FieldMemberID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contestparticipant.FieldDelete:
		return m.AddedDelete()
	case contestparticipant.FieldCreatedID:
		return m.AddedCreatedID()
	case contestparticipant.FieldStatus:
		return m.AddedStatus()
	case contestparticipant.FieldOrderID:
		return m.AddedOrderID()
	case contestparticipant.FieldFee:
		return m.AddedFee()
	case contestparticipant.FieldMemberID:
		return m.AddedMemberID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contestparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case contestparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case contestparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case contestparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case contestparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case contestparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contestparticipant.FieldCreatedAt) {
		fields = append(fields, contestparticipant.FieldCreatedAt)
	}
	if m.FieldCleared(contestparticipant.FieldUpdatedAt) {
		fields = append(fields, contestparticipant.FieldUpdatedAt)
	}
	if m.FieldCleared(contestparticipant.FieldDelete) {
		fields = append(fields, contestparticipant.FieldDelete)
	}
	if m.FieldCleared(contestparticipant.FieldCreatedID) {
		fields = append(fields, contestparticipant.FieldCreatedID)
	}
	if m.FieldCleared(contestparticipant.FieldStatus) {
		fields = append(fields, contestparticipant.FieldStatus)
	}
	if m.FieldCleared(contestparticipant.FieldContestID) {
		fields = append(fields, contestparticipant.FieldContestID)
	}
	if m.FieldCleared(contestparticipant.FieldName) {
		fields = append(fields, contestparticipant.FieldName)
	}
	if m.FieldCleared(contestparticipant.FieldMobile) {
		fields = append(fields, contestparticipant.FieldMobile)
	}
	if m.FieldCleared(contestparticipant.FieldFields) {
		fields = append(fields, contestparticipant.FieldFields)
	}
	if m.FieldCleared(contestparticipant.FieldOrderID) {
		fields = append(fields, contestparticipant.FieldOrderID)
	}
	if m.FieldCleared(contestparticipant.FieldOrderSn) {
		fields = append(fields, contestparticipant.FieldOrderSn)
	}
	if m.FieldCleared(contestparticipant.FieldFee) {
		fields = append(fields, contestparticipant.FieldFee)
	}
	if m.FieldCleared(contestparticipant.FieldMemberID) {
		fields = append(fields, contestparticipant.FieldMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestParticipantMutation) ClearField(name string) error {
	switch name {
	case contestparticipant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contestparticipant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contestparticipant.FieldDelete:
		m.ClearDelete()
		return nil
	case contestparticipant.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case contestparticipant.FieldStatus:
		m.ClearStatus()
		return nil
	case contestparticipant.FieldContestID:
		m.ClearContestID()
		return nil
	case contestparticipant.FieldName:
		m.ClearName()
		return nil
	case contestparticipant.FieldMobile:
		m.ClearMobile()
		return nil
	case contestparticipant.FieldFields:
		m.ClearFields()
		return nil
	case contestparticipant.FieldOrderID:
		m.ClearOrderID()
		return nil
	case contestparticipant.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case contestparticipant.FieldFee:
		m.ClearFee()
		return nil
	case contestparticipant.FieldMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestParticipantMutation) ResetField(name string) error {
	switch name {
	case contestparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contestparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contestparticipant.FieldDelete:
		m.ResetDelete()
		return nil
	case contestparticipant.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case contestparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case contestparticipant.FieldContestID:
		m.ResetContestID()
		return nil
	case contestparticipant.FieldName:
		m.ResetName()
		return nil
	case contestparticipant.FieldMobile:
		m.ResetMobile()
		return nil
	case contestparticipant.FieldFields:
		m.ResetFields()
		return nil
	case contestparticipant.FieldOrderID:
		m.ResetOrderID()
		return nil
	case contestparticipant.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case contestparticipant.FieldFee:
		m.ResetFee()
		return nil
	case contestparticipant.FieldMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.contest != nil {
		edges = append(edges, contestparticipant.EdgeContest)
	}
	if m.members != nil {
		edges = append(edges, contestparticipant.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contestparticipant.EdgeContest:
		if id := m.contest; id != nil {
			return []ent.Value{*id}
		}
	case contestparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, contestparticipant.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contestparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontest {
		edges = append(edges, contestparticipant.EdgeContest)
	}
	if m.clearedmembers {
		edges = append(edges, contestparticipant.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case contestparticipant.EdgeContest:
		return m.clearedcontest
	case contestparticipant.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestParticipantMutation) ClearEdge(name string) error {
	switch name {
	case contestparticipant.EdgeContest:
		m.ClearContest()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestParticipantMutation) ResetEdge(name string) error {
	switch name {
	case contestparticipant.EdgeContest:
		m.ResetContest()
		return nil
	case contestparticipant.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	name            *string
	content         *string
	venue_id        *int64
	addvenue_id     *int64
	clearedFields   map[string]struct{}
	products        map[int64]struct{}
	removedproducts map[int64]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Contract, error)
	predicates      []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id int64) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contract entities.
func (m *ContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContractMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contract.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContractMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contract.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContractMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contract.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContractMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contract.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ContractMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ContractMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ContractMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ContractMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ContractMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[contract.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ContractMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[contract.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ContractMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, contract.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ContractMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ContractMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ContractMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ContractMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ContractMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[contract.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ContractMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[contract.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ContractMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, contract.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contract.FieldStatus)
}

// SetName sets the "name" field.
func (m *ContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[contract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[contract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contract.FieldName)
}

// SetContent sets the "content" field.
func (m *ContractMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ContractMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ContractMutation) ClearContent() {
	m.content = nil
	m.clearedFields[contract.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ContractMutation) ContentCleared() bool {
	_, ok := m.clearedFields[contract.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ContractMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, contract.FieldContent)
}

// SetVenueID sets the "venue_id" field.
func (m *ContractMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ContractMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ContractMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ContractMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ContractMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[contract.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ContractMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[contract.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ContractMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, contract.FieldVenueID)
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ContractMutation) AddProductIDs(ids ...int64) {
	if m.products == nil {
		m.products = make(map[int64]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ContractMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ContractMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ContractMutation) RemoveProductIDs(ids ...int64) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ContractMutation) RemovedProductsIDs() (ids []int64) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ContractMutation) ProductsIDs() (ids []int64) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ContractMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, contract.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, contract.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, contract.FieldName)
	}
	if m.content != nil {
		fields = append(fields, contract.FieldContent)
	}
	if m.venue_id != nil {
		fields = append(fields, contract.FieldVenueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldDelete:
		return m.Delete()
	case contract.FieldCreatedID:
		return m.CreatedID()
	case contract.FieldStatus:
		return m.Status()
	case contract.FieldName:
		return m.Name()
	case contract.FieldContent:
		return m.Content()
	case contract.FieldVenueID:
		return m.VenueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldDelete:
		return m.OldDelete(ctx)
	case contract.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case contract.FieldStatus:
		return m.OldStatus(ctx)
	case contract.FieldName:
		return m.OldName(ctx)
	case contract.FieldContent:
		return m.OldContent(ctx)
	case contract.FieldVenueID:
		return m.OldVenueID(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case contract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contract.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case contract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, contract.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, contract.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, contract.FieldVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldDelete:
		return m.AddedDelete()
	case contract.FieldCreatedID:
		return m.AddedCreatedID()
	case contract.FieldStatus:
		return m.AddedStatus()
	case contract.FieldVenueID:
		return m.AddedVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case contract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case contract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldCreatedAt) {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.FieldCleared(contract.FieldUpdatedAt) {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.FieldCleared(contract.FieldDelete) {
		fields = append(fields, contract.FieldDelete)
	}
	if m.FieldCleared(contract.FieldCreatedID) {
		fields = append(fields, contract.FieldCreatedID)
	}
	if m.FieldCleared(contract.FieldStatus) {
		fields = append(fields, contract.FieldStatus)
	}
	if m.FieldCleared(contract.FieldName) {
		fields = append(fields, contract.FieldName)
	}
	if m.FieldCleared(contract.FieldContent) {
		fields = append(fields, contract.FieldContent)
	}
	if m.FieldCleared(contract.FieldVenueID) {
		fields = append(fields, contract.FieldVenueID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contract.FieldDelete:
		m.ClearDelete()
		return nil
	case contract.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case contract.FieldStatus:
		m.ClearStatus()
		return nil
	case contract.FieldName:
		m.ClearName()
		return nil
	case contract.FieldContent:
		m.ClearContent()
		return nil
	case contract.FieldVenueID:
		m.ClearVenueID()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldDelete:
		m.ResetDelete()
		return nil
	case contract.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case contract.FieldStatus:
		m.ResetStatus()
		return nil
	case contract.FieldName:
		m.ResetName()
		return nil
	case contract.FieldContent:
		m.ResetContent()
		return nil
	case contract.FieldVenueID:
		m.ResetVenueID()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, contract.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, contract.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, contract.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	switch name {
	case contract.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	switch name {
	case contract.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Contract edge %s", name)
}

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	created_at                *time.Time
	updated_at                *time.Time
	delete                    *int64
	adddelete                 *int64
	created_id                *int64
	addcreated_id             *int64
	status                    *int64
	addstatus                 *int64
	title                     *string
	name                      *string
	description               *string
	clearedFields             map[string]struct{}
	dictionary_details        map[int64]struct{}
	removeddictionary_details map[int64]struct{}
	cleareddictionary_details bool
	done                      bool
	oldValue                  func(context.Context) (*Dictionary, error)
	predicates                []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id int64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictionaryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictionary.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictionaryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictionary.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictionaryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictionary.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictionaryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictionary.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DictionaryMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DictionaryMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DictionaryMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DictionaryMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DictionaryMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dictionary.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DictionaryMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DictionaryMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dictionary.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DictionaryMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DictionaryMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DictionaryMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DictionaryMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DictionaryMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dictionary.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DictionaryMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DictionaryMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dictionary.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DictionaryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictionaryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DictionaryMutation) ResetDescription() {
	m.description = nil
}

// AddDictionaryDetailIDs adds the "dictionary_details" edge to the DictionaryDetail entity by ids.
func (m *DictionaryMutation) AddDictionaryDetailIDs(ids ...int64) {
	if m.dictionary_details == nil {
		m.dictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.dictionary_details[ids[i]] = struct{}{}
	}
}

// ClearDictionaryDetails clears the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) ClearDictionaryDetails() {
	m.cleareddictionary_details = true
}

// DictionaryDetailsCleared reports if the "dictionary_details" edge to the DictionaryDetail entity was cleared.
func (m *DictionaryMutation) DictionaryDetailsCleared() bool {
	return m.cleareddictionary_details
}

// RemoveDictionaryDetailIDs removes the "dictionary_details" edge to the DictionaryDetail entity by IDs.
func (m *DictionaryMutation) RemoveDictionaryDetailIDs(ids ...int64) {
	if m.removeddictionary_details == nil {
		m.removeddictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.dictionary_details, ids[i])
		m.removeddictionary_details[ids[i]] = struct{}{}
	}
}

// RemovedDictionaryDetails returns the removed IDs of the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) RemovedDictionaryDetailsIDs() (ids []int64) {
	for id := range m.removeddictionary_details {
		ids = append(ids, id)
	}
	return
}

// DictionaryDetailsIDs returns the "dictionary_details" edge IDs in the mutation.
func (m *DictionaryMutation) DictionaryDetailsIDs() (ids []int64) {
	for id := range m.dictionary_details {
		ids = append(ids, id)
	}
	return
}

// ResetDictionaryDetails resets all changes to the "dictionary_details" edge.
func (m *DictionaryMutation) ResetDictionaryDetails() {
	m.dictionary_details = nil
	m.cleareddictionary_details = false
	m.removeddictionary_details = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionary.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dictionary.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldDelete:
		return m.Delete()
	case dictionary.FieldCreatedID:
		return m.CreatedID()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldTitle:
		return m.Title()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldDelete:
		return m.OldDelete(ctx)
	case dictionary.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldTitle:
		return m.OldTitle(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dictionary.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldDelete:
		return m.AddedDelete()
	case dictionary.FieldCreatedID:
		return m.AddedCreatedID()
	case dictionary.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dictionary.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldCreatedAt) {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.FieldCleared(dictionary.FieldUpdatedAt) {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.FieldCleared(dictionary.FieldDelete) {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.FieldCleared(dictionary.FieldCreatedID) {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictionary.FieldDelete:
		m.ClearDelete()
		return nil
	case dictionary.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldDelete:
		m.ResetDelete()
		return nil
	case dictionary.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.dictionary_details))
		for id := range m.dictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.removeddictionary_details))
		for id := range m.removeddictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary_details {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		return m.cleareddictionary_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		m.ResetDictionaryDetails()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryDetailMutation represents an operation that mutates the DictionaryDetail nodes in the graph.
type DictionaryDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	delete            *int64
	adddelete         *int64
	created_id        *int64
	addcreated_id     *int64
	status            *int64
	addstatus         *int64
	title             *string
	key               *string
	value             *string
	clearedFields     map[string]struct{}
	dictionary        *int64
	cleareddictionary bool
	users             map[int64]struct{}
	removedusers      map[int64]struct{}
	clearedusers      bool
	products          map[int64]struct{}
	removedproducts   map[int64]struct{}
	clearedproducts   bool
	done              bool
	oldValue          func(context.Context) (*DictionaryDetail, error)
	predicates        []predicate.DictionaryDetail
}

var _ ent.Mutation = (*DictionaryDetailMutation)(nil)

// dictionarydetailOption allows management of the mutation configuration using functional options.
type dictionarydetailOption func(*DictionaryDetailMutation)

// newDictionaryDetailMutation creates new mutation for the DictionaryDetail entity.
func newDictionaryDetailMutation(c config, op Op, opts ...dictionarydetailOption) *DictionaryDetailMutation {
	m := &DictionaryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryDetailID sets the ID field of the mutation.
func withDictionaryDetailID(id int64) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DictionaryDetail
		)
		m.oldValue = func(ctx context.Context) (*DictionaryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictionaryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionaryDetail sets the old DictionaryDetail of the mutation.
func withDictionaryDetail(node *DictionaryDetail) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		m.oldValue = func(context.Context) (*DictionaryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictionaryDetail entities.
func (m *DictionaryDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictionaryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictionaryDetailMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictionarydetail.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictionaryDetailMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictionarydetail.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictionaryDetailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictionarydetail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictionaryDetailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictionarydetail.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DictionaryDetailMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DictionaryDetailMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DictionaryDetailMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DictionaryDetailMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DictionaryDetailMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dictionarydetail.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DictionaryDetailMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dictionarydetail.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DictionaryDetailMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DictionaryDetailMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DictionaryDetailMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DictionaryDetailMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DictionaryDetailMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dictionarydetail.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DictionaryDetailMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dictionarydetail.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DictionaryDetailMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryDetailMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryDetailMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryDetailMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryDetailMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionarydetail.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryDetailMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionarydetail.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetKey sets the "key" field.
func (m *DictionaryDetailMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DictionaryDetailMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DictionaryDetailMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DictionaryDetailMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryDetailMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryDetailMutation) ResetValue() {
	m.value = nil
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryDetailMutation) SetDictionaryID(i int64) {
	m.dictionary = &i
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryDetailMutation) DictionaryID() (r int64, exists bool) {
	v := m.dictionary
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDictionaryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ClearDictionaryID clears the value of the "dictionary_id" field.
func (m *DictionaryDetailMutation) ClearDictionaryID() {
	m.dictionary = nil
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryIDCleared returns if the "dictionary_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DictionaryIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDictionaryID]
	return ok
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryDetailMutation) ResetDictionaryID() {
	m.dictionary = nil
	delete(m.clearedFields, dictionarydetail.FieldDictionaryID)
}

// ClearDictionary clears the "dictionary" edge to the Dictionary entity.
func (m *DictionaryDetailMutation) ClearDictionary() {
	m.cleareddictionary = true
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryCleared reports if the "dictionary" edge to the Dictionary entity was cleared.
func (m *DictionaryDetailMutation) DictionaryCleared() bool {
	return m.DictionaryIDCleared() || m.cleareddictionary
}

// DictionaryIDs returns the "dictionary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionaryID instead. It exists only for internal usage by the builders.
func (m *DictionaryDetailMutation) DictionaryIDs() (ids []int64) {
	if id := m.dictionary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionary resets all changes to the "dictionary" edge.
func (m *DictionaryDetailMutation) ResetDictionary() {
	m.dictionary = nil
	m.cleareddictionary = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DictionaryDetailMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DictionaryDetailMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DictionaryDetailMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DictionaryDetailMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DictionaryDetailMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DictionaryDetailMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DictionaryDetailMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *DictionaryDetailMutation) AddProductIDs(ids ...int64) {
	if m.products == nil {
		m.products = make(map[int64]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *DictionaryDetailMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *DictionaryDetailMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *DictionaryDetailMutation) RemoveProductIDs(ids ...int64) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *DictionaryDetailMutation) RemovedProductsIDs() (ids []int64) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *DictionaryDetailMutation) ProductsIDs() (ids []int64) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *DictionaryDetailMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the DictionaryDetailMutation builder.
func (m *DictionaryDetailMutation) Where(ps ...predicate.DictionaryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictionaryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictionaryDetail).
func (m *DictionaryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryDetailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionarydetail.FieldTitle)
	}
	if m.key != nil {
		fields = append(fields, dictionarydetail.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dictionarydetail.FieldValue)
	}
	if m.dictionary != nil {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case dictionarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionarydetail.FieldDelete:
		return m.Delete()
	case dictionarydetail.FieldCreatedID:
		return m.CreatedID()
	case dictionarydetail.FieldStatus:
		return m.Status()
	case dictionarydetail.FieldTitle:
		return m.Title()
	case dictionarydetail.FieldKey:
		return m.Key()
	case dictionarydetail.FieldValue:
		return m.Value()
	case dictionarydetail.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionarydetail.FieldDelete:
		return m.OldDelete(ctx)
	case dictionarydetail.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dictionarydetail.FieldStatus:
		return m.OldStatus(ctx)
	case dictionarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case dictionarydetail.FieldKey:
		return m.OldKey(ctx)
	case dictionarydetail.FieldValue:
		return m.OldValue(ctx)
	case dictionarydetail.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionarydetail.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dictionarydetail.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionarydetail.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dictionarydetail.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionarydetail.FieldDictionaryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryDetailMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldDelete:
		return m.AddedDelete()
	case dictionarydetail.FieldCreatedID:
		return m.AddedCreatedID()
	case dictionarydetail.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dictionarydetail.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionarydetail.FieldCreatedAt) {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.FieldCleared(dictionarydetail.FieldUpdatedAt) {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.FieldCleared(dictionarydetail.FieldDelete) {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.FieldCleared(dictionarydetail.FieldCreatedID) {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.FieldCleared(dictionarydetail.FieldStatus) {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.FieldCleared(dictionarydetail.FieldDictionaryID) {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ClearField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictionarydetail.FieldDelete:
		m.ClearDelete()
		return nil
	case dictionarydetail.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dictionarydetail.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ClearDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ResetField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionarydetail.FieldDelete:
		m.ResetDelete()
		return nil
	case dictionarydetail.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dictionarydetail.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionarydetail.FieldKey:
		m.ResetKey()
		return nil
	case dictionarydetail.FieldValue:
		m.ResetValue()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dictionary != nil {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	if m.users != nil {
		edges = append(edges, dictionarydetail.EdgeUsers)
	}
	if m.products != nil {
		edges = append(edges, dictionarydetail.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeDictionary:
		if id := m.dictionary; id != nil {
			return []ent.Value{*id}
		}
	case dictionarydetail.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case dictionarydetail.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, dictionarydetail.EdgeUsers)
	}
	if m.removedproducts != nil {
		edges = append(edges, dictionarydetail.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case dictionarydetail.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddictionary {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	if m.clearedusers {
		edges = append(edges, dictionarydetail.EdgeUsers)
	}
	if m.clearedproducts {
		edges = append(edges, dictionarydetail.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionarydetail.EdgeDictionary:
		return m.cleareddictionary
	case dictionarydetail.EdgeUsers:
		return m.clearedusers
	case dictionarydetail.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryDetailMutation) ClearEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ClearDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryDetailMutation) ResetEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ResetDictionary()
		return nil
	case dictionarydetail.EdgeUsers:
		m.ResetUsers()
		return nil
	case dictionarydetail.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail edge %s", name)
}

// EntryLogsMutation represents an operation that mutates the EntryLogs nodes in the graph.
type EntryLogsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	delete               *int64
	adddelete            *int64
	created_id           *int64
	addcreated_id        *int64
	member_product_id    *int64
	addmember_product_id *int64
	entry_time           *time.Time
	leaving_time         *time.Time
	clearedFields        map[string]struct{}
	venues               *int64
	clearedvenues        bool
	members              *int64
	clearedmembers       bool
	users                *int64
	clearedusers         bool
	done                 bool
	oldValue             func(context.Context) (*EntryLogs, error)
	predicates           []predicate.EntryLogs
}

var _ ent.Mutation = (*EntryLogsMutation)(nil)

// entrylogsOption allows management of the mutation configuration using functional options.
type entrylogsOption func(*EntryLogsMutation)

// newEntryLogsMutation creates new mutation for the EntryLogs entity.
func newEntryLogsMutation(c config, op Op, opts ...entrylogsOption) *EntryLogsMutation {
	m := &EntryLogsMutation{
		config:        c,
		op:            op,
		typ:           TypeEntryLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryLogsID sets the ID field of the mutation.
func withEntryLogsID(id int64) entrylogsOption {
	return func(m *EntryLogsMutation) {
		var (
			err   error
			once  sync.Once
			value *EntryLogs
		)
		m.oldValue = func(ctx context.Context) (*EntryLogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntryLogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntryLogs sets the old EntryLogs of the mutation.
func withEntryLogs(node *EntryLogs) entrylogsOption {
	return func(m *EntryLogsMutation) {
		m.oldValue = func(context.Context) (*EntryLogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryLogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryLogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntryLogs entities.
func (m *EntryLogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntryLogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntryLogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntryLogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntryLogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntryLogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntryLogsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entrylogs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntryLogsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntryLogsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entrylogs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntryLogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntryLogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntryLogsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entrylogs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntryLogsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntryLogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entrylogs.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *EntryLogsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *EntryLogsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *EntryLogsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *EntryLogsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *EntryLogsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[entrylogs.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *EntryLogsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *EntryLogsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, entrylogs.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *EntryLogsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *EntryLogsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *EntryLogsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *EntryLogsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *EntryLogsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[entrylogs.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *EntryLogsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *EntryLogsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, entrylogs.FieldCreatedID)
}

// SetMemberID sets the "member_id" field.
func (m *EntryLogsMutation) SetMemberID(i int64) {
	m.members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *EntryLogsMutation) MemberID() (r int64, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *EntryLogsMutation) ClearMemberID() {
	m.members = nil
	m.clearedFields[entrylogs.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *EntryLogsMutation) ResetMemberID() {
	m.members = nil
	delete(m.clearedFields, entrylogs.FieldMemberID)
}

// SetUserID sets the "user_id" field.
func (m *EntryLogsMutation) SetUserID(i int64) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EntryLogsMutation) UserID() (r int64, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *EntryLogsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[entrylogs.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *EntryLogsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EntryLogsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, entrylogs.FieldUserID)
}

// SetVenueID sets the "venue_id" field.
func (m *EntryLogsMutation) SetVenueID(i int64) {
	m.venues = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *EntryLogsMutation) VenueID() (r int64, exists bool) {
	v := m.venues
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *EntryLogsMutation) ClearVenueID() {
	m.venues = nil
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *EntryLogsMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *EntryLogsMutation) ResetVenueID() {
	m.venues = nil
	delete(m.clearedFields, entrylogs.FieldVenueID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *EntryLogsMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *EntryLogsMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *EntryLogsMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *EntryLogsMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *EntryLogsMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[entrylogs.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *EntryLogsMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, entrylogs.FieldMemberProductID)
}

// SetEntryTime sets the "entry_time" field.
func (m *EntryLogsMutation) SetEntryTime(t time.Time) {
	m.entry_time = &t
}

// EntryTime returns the value of the "entry_time" field in the mutation.
func (m *EntryLogsMutation) EntryTime() (r time.Time, exists bool) {
	v := m.entry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryTime returns the old "entry_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldEntryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryTime: %w", err)
	}
	return oldValue.EntryTime, nil
}

// ClearEntryTime clears the value of the "entry_time" field.
func (m *EntryLogsMutation) ClearEntryTime() {
	m.entry_time = nil
	m.clearedFields[entrylogs.FieldEntryTime] = struct{}{}
}

// EntryTimeCleared returns if the "entry_time" field was cleared in this mutation.
func (m *EntryLogsMutation) EntryTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldEntryTime]
	return ok
}

// ResetEntryTime resets all changes to the "entry_time" field.
func (m *EntryLogsMutation) ResetEntryTime() {
	m.entry_time = nil
	delete(m.clearedFields, entrylogs.FieldEntryTime)
}

// SetLeavingTime sets the "leaving_time" field.
func (m *EntryLogsMutation) SetLeavingTime(t time.Time) {
	m.leaving_time = &t
}

// LeavingTime returns the value of the "leaving_time" field in the mutation.
func (m *EntryLogsMutation) LeavingTime() (r time.Time, exists bool) {
	v := m.leaving_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLeavingTime returns the old "leaving_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldLeavingTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeavingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeavingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeavingTime: %w", err)
	}
	return oldValue.LeavingTime, nil
}

// ClearLeavingTime clears the value of the "leaving_time" field.
func (m *EntryLogsMutation) ClearLeavingTime() {
	m.leaving_time = nil
	m.clearedFields[entrylogs.FieldLeavingTime] = struct{}{}
}

// LeavingTimeCleared returns if the "leaving_time" field was cleared in this mutation.
func (m *EntryLogsMutation) LeavingTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldLeavingTime]
	return ok
}

// ResetLeavingTime resets all changes to the "leaving_time" field.
func (m *EntryLogsMutation) ResetLeavingTime() {
	m.leaving_time = nil
	delete(m.clearedFields, entrylogs.FieldLeavingTime)
}

// SetVenuesID sets the "venues" edge to the Venue entity by id.
func (m *EntryLogsMutation) SetVenuesID(id int64) {
	m.venues = &id
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *EntryLogsMutation) ClearVenues() {
	m.clearedvenues = true
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *EntryLogsMutation) VenuesCleared() bool {
	return m.VenueIDCleared() || m.clearedvenues
}

// VenuesID returns the "venues" edge ID in the mutation.
func (m *EntryLogsMutation) VenuesID() (id int64, exists bool) {
	if m.venues != nil {
		return *m.venues, true
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenuesID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) VenuesIDs() (ids []int64) {
	if id := m.venues; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *EntryLogsMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
}

// SetMembersID sets the "members" edge to the Member entity by id.
func (m *EntryLogsMutation) SetMembersID(id int64) {
	m.members = &id
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *EntryLogsMutation) ClearMembers() {
	m.clearedmembers = true
	m.clearedFields[entrylogs.FieldMemberID] = struct{}{}
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *EntryLogsMutation) MembersCleared() bool {
	return m.MemberIDCleared() || m.clearedmembers
}

// MembersID returns the "members" edge ID in the mutation.
func (m *EntryLogsMutation) MembersID() (id int64, exists bool) {
	if m.members != nil {
		return *m.members, true
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MembersID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) MembersIDs() (ids []int64) {
	if id := m.members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *EntryLogsMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *EntryLogsMutation) SetUsersID(id int64) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *EntryLogsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[entrylogs.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *EntryLogsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *EntryLogsMutation) UsersID() (id int64, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) UsersIDs() (ids []int64) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *EntryLogsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the EntryLogsMutation builder.
func (m *EntryLogsMutation) Where(ps ...predicate.EntryLogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntryLogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntryLogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntryLogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntryLogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntryLogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntryLogs).
func (m *EntryLogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryLogsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, entrylogs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entrylogs.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, entrylogs.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, entrylogs.FieldCreatedID)
	}
	if m.members != nil {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.users != nil {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.venues != nil {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.member_product_id != nil {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.entry_time != nil {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.leaving_time != nil {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryLogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.CreatedAt()
	case entrylogs.FieldUpdatedAt:
		return m.UpdatedAt()
	case entrylogs.FieldDelete:
		return m.Delete()
	case entrylogs.FieldCreatedID:
		return m.CreatedID()
	case entrylogs.FieldMemberID:
		return m.MemberID()
	case entrylogs.FieldUserID:
		return m.UserID()
	case entrylogs.FieldVenueID:
		return m.VenueID()
	case entrylogs.FieldMemberProductID:
		return m.MemberProductID()
	case entrylogs.FieldEntryTime:
		return m.EntryTime()
	case entrylogs.FieldLeavingTime:
		return m.LeavingTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryLogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entrylogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entrylogs.FieldDelete:
		return m.OldDelete(ctx)
	case entrylogs.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case entrylogs.FieldMemberID:
		return m.OldMemberID(ctx)
	case entrylogs.FieldUserID:
		return m.OldUserID(ctx)
	case entrylogs.FieldVenueID:
		return m.OldVenueID(ctx)
	case entrylogs.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case entrylogs.FieldEntryTime:
		return m.OldEntryTime(ctx)
	case entrylogs.FieldLeavingTime:
		return m.OldLeavingTime(ctx)
	}
	return nil, fmt.Errorf("unknown EntryLogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entrylogs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entrylogs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case entrylogs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case entrylogs.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case entrylogs.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case entrylogs.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case entrylogs.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case entrylogs.FieldEntryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryTime(v)
		return nil
	case entrylogs.FieldLeavingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeavingTime(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryLogsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, entrylogs.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, entrylogs.FieldCreatedID)
	}
	if m.addmember_product_id != nil {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryLogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldDelete:
		return m.AddedDelete()
	case entrylogs.FieldCreatedID:
		return m.AddedCreatedID()
	case entrylogs.FieldMemberProductID:
		return m.AddedMemberProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case entrylogs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case entrylogs.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryLogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entrylogs.FieldCreatedAt) {
		fields = append(fields, entrylogs.FieldCreatedAt)
	}
	if m.FieldCleared(entrylogs.FieldUpdatedAt) {
		fields = append(fields, entrylogs.FieldUpdatedAt)
	}
	if m.FieldCleared(entrylogs.FieldDelete) {
		fields = append(fields, entrylogs.FieldDelete)
	}
	if m.FieldCleared(entrylogs.FieldCreatedID) {
		fields = append(fields, entrylogs.FieldCreatedID)
	}
	if m.FieldCleared(entrylogs.FieldMemberID) {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.FieldCleared(entrylogs.FieldUserID) {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.FieldCleared(entrylogs.FieldVenueID) {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.FieldCleared(entrylogs.FieldMemberProductID) {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.FieldCleared(entrylogs.FieldEntryTime) {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.FieldCleared(entrylogs.FieldLeavingTime) {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryLogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryLogsMutation) ClearField(name string) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entrylogs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entrylogs.FieldDelete:
		m.ClearDelete()
		return nil
	case entrylogs.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case entrylogs.FieldMemberID:
		m.ClearMemberID()
		return nil
	case entrylogs.FieldUserID:
		m.ClearUserID()
		return nil
	case entrylogs.FieldVenueID:
		m.ClearVenueID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ClearEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ClearLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryLogsMutation) ResetField(name string) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entrylogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entrylogs.FieldDelete:
		m.ResetDelete()
		return nil
	case entrylogs.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case entrylogs.FieldMemberID:
		m.ResetMemberID()
		return nil
	case entrylogs.FieldUserID:
		m.ResetUserID()
		return nil
	case entrylogs.FieldVenueID:
		m.ResetVenueID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ResetEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ResetLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryLogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.venues != nil {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	if m.members != nil {
		edges = append(edges, entrylogs.EdgeMembers)
	}
	if m.users != nil {
		edges = append(edges, entrylogs.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryLogsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entrylogs.EdgeVenues:
		if id := m.venues; id != nil {
			return []ent.Value{*id}
		}
	case entrylogs.EdgeMembers:
		if id := m.members; id != nil {
			return []ent.Value{*id}
		}
	case entrylogs.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryLogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryLogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryLogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedvenues {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	if m.clearedmembers {
		edges = append(edges, entrylogs.EdgeMembers)
	}
	if m.clearedusers {
		edges = append(edges, entrylogs.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryLogsMutation) EdgeCleared(name string) bool {
	switch name {
	case entrylogs.EdgeVenues:
		return m.clearedvenues
	case entrylogs.EdgeMembers:
		return m.clearedmembers
	case entrylogs.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryLogsMutation) ClearEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ClearVenues()
		return nil
	case entrylogs.EdgeMembers:
		m.ClearMembers()
		return nil
	case entrylogs.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryLogsMutation) ResetEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ResetVenues()
		return nil
	case entrylogs.EdgeMembers:
		m.ResetMembers()
		return nil
	case entrylogs.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	method        *string
	api           *string
	success       *bool
	req_content   *string
	resp_content  *string
	ip            *string
	user_agent    *string
	operator      *string
	time          *int
	addtime       *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int64) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LogsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[logs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LogsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, logs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LogsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[logs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LogsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, logs.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *LogsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *LogsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *LogsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *LogsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *LogsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[logs.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *LogsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[logs.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *LogsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, logs.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *LogsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *LogsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *LogsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *LogsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *LogsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[logs.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *LogsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *LogsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, logs.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *LogsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LogsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LogsMutation) ResetType() {
	m._type = nil
}

// SetMethod sets the "method" field.
func (m *LogsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *LogsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *LogsMutation) ResetMethod() {
	m.method = nil
}

// SetAPI sets the "api" field.
func (m *LogsMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *LogsMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *LogsMutation) ResetAPI() {
	m.api = nil
}

// SetSuccess sets the "success" field.
func (m *LogsMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LogsMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LogsMutation) ResetSuccess() {
	m.success = nil
}

// SetReqContent sets the "req_content" field.
func (m *LogsMutation) SetReqContent(s string) {
	m.req_content = &s
}

// ReqContent returns the value of the "req_content" field in the mutation.
func (m *LogsMutation) ReqContent() (r string, exists bool) {
	v := m.req_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReqContent returns the old "req_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldReqContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqContent: %w", err)
	}
	return oldValue.ReqContent, nil
}

// ClearReqContent clears the value of the "req_content" field.
func (m *LogsMutation) ClearReqContent() {
	m.req_content = nil
	m.clearedFields[logs.FieldReqContent] = struct{}{}
}

// ReqContentCleared returns if the "req_content" field was cleared in this mutation.
func (m *LogsMutation) ReqContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldReqContent]
	return ok
}

// ResetReqContent resets all changes to the "req_content" field.
func (m *LogsMutation) ResetReqContent() {
	m.req_content = nil
	delete(m.clearedFields, logs.FieldReqContent)
}

// SetRespContent sets the "resp_content" field.
func (m *LogsMutation) SetRespContent(s string) {
	m.resp_content = &s
}

// RespContent returns the value of the "resp_content" field in the mutation.
func (m *LogsMutation) RespContent() (r string, exists bool) {
	v := m.resp_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRespContent returns the old "resp_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRespContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespContent: %w", err)
	}
	return oldValue.RespContent, nil
}

// ClearRespContent clears the value of the "resp_content" field.
func (m *LogsMutation) ClearRespContent() {
	m.resp_content = nil
	m.clearedFields[logs.FieldRespContent] = struct{}{}
}

// RespContentCleared returns if the "resp_content" field was cleared in this mutation.
func (m *LogsMutation) RespContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldRespContent]
	return ok
}

// ResetRespContent resets all changes to the "resp_content" field.
func (m *LogsMutation) ResetRespContent() {
	m.resp_content = nil
	delete(m.clearedFields, logs.FieldRespContent)
}

// SetIP sets the "ip" field.
func (m *LogsMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *LogsMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[logs.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *LogsMutation) IPCleared() bool {
	_, ok := m.clearedFields[logs.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *LogsMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, logs.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LogsMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LogsMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LogsMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[logs.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LogsMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LogsMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, logs.FieldUserAgent)
}

// SetOperator sets the "operator" field.
func (m *LogsMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the value of the "operator" field in the mutation.
func (m *LogsMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldOperator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ClearOperator clears the value of the "operator" field.
func (m *LogsMutation) ClearOperator() {
	m.operator = nil
	m.clearedFields[logs.FieldOperator] = struct{}{}
}

// OperatorCleared returns if the "operator" field was cleared in this mutation.
func (m *LogsMutation) OperatorCleared() bool {
	_, ok := m.clearedFields[logs.FieldOperator]
	return ok
}

// ResetOperator resets all changes to the "operator" field.
func (m *LogsMutation) ResetOperator() {
	m.operator = nil
	delete(m.clearedFields, logs.FieldOperator)
}

// SetTime sets the "time" field.
func (m *LogsMutation) SetTime(i int) {
	m.time = &i
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *LogsMutation) Time() (r int, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to the "time" field.
func (m *LogsMutation) AddTime(i int) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *LogsMutation) AddedTime() (r int, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *LogsMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[logs.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *LogsMutation) TimeCleared() bool {
	_, ok := m.clearedFields[logs.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *LogsMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, logs.FieldTime)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, logs.FieldType)
	}
	if m.method != nil {
		fields = append(fields, logs.FieldMethod)
	}
	if m.api != nil {
		fields = append(fields, logs.FieldAPI)
	}
	if m.success != nil {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.req_content != nil {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.resp_content != nil {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.ip != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.operator != nil {
		fields = append(fields, logs.FieldOperator)
	}
	if m.time != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldDelete:
		return m.Delete()
	case logs.FieldCreatedID:
		return m.CreatedID()
	case logs.FieldType:
		return m.GetType()
	case logs.FieldMethod:
		return m.Method()
	case logs.FieldAPI:
		return m.API()
	case logs.FieldSuccess:
		return m.Success()
	case logs.FieldReqContent:
		return m.ReqContent()
	case logs.FieldRespContent:
		return m.RespContent()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldUserAgent:
		return m.UserAgent()
	case logs.FieldOperator:
		return m.Operator()
	case logs.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldDelete:
		return m.OldDelete(ctx)
	case logs.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case logs.FieldType:
		return m.OldType(ctx)
	case logs.FieldMethod:
		return m.OldMethod(ctx)
	case logs.FieldAPI:
		return m.OldAPI(ctx)
	case logs.FieldSuccess:
		return m.OldSuccess(ctx)
	case logs.FieldReqContent:
		return m.OldReqContent(ctx)
	case logs.FieldRespContent:
		return m.OldRespContent(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case logs.FieldOperator:
		return m.OldOperator(ctx)
	case logs.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case logs.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case logs.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case logs.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case logs.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case logs.FieldReqContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqContent(v)
		return nil
	case logs.FieldRespContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespContent(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case logs.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.addtime != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldDelete:
		return m.AddedDelete()
	case logs.FieldCreatedID:
		return m.AddedCreatedID()
	case logs.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldCreatedAt) {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.FieldCleared(logs.FieldUpdatedAt) {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.FieldCleared(logs.FieldDelete) {
		fields = append(fields, logs.FieldDelete)
	}
	if m.FieldCleared(logs.FieldCreatedID) {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.FieldCleared(logs.FieldReqContent) {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.FieldCleared(logs.FieldRespContent) {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.FieldCleared(logs.FieldIP) {
		fields = append(fields, logs.FieldIP)
	}
	if m.FieldCleared(logs.FieldUserAgent) {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.FieldCleared(logs.FieldOperator) {
		fields = append(fields, logs.FieldOperator)
	}
	if m.FieldCleared(logs.FieldTime) {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ClearDelete()
		return nil
	case logs.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case logs.FieldReqContent:
		m.ClearReqContent()
		return nil
	case logs.FieldRespContent:
		m.ClearRespContent()
		return nil
	case logs.FieldIP:
		m.ClearIP()
		return nil
	case logs.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case logs.FieldOperator:
		m.ClearOperator()
		return nil
	case logs.FieldTime:
		m.ClearTime()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ResetDelete()
		return nil
	case logs.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case logs.FieldType:
		m.ResetType()
		return nil
	case logs.FieldMethod:
		m.ResetMethod()
		return nil
	case logs.FieldAPI:
		m.ResetAPI()
		return nil
	case logs.FieldSuccess:
		m.ResetSuccess()
		return nil
	case logs.FieldReqContent:
		m.ResetReqContent()
		return nil
	case logs.FieldRespContent:
		m.ResetRespContent()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case logs.FieldOperator:
		m.ResetOperator()
		return nil
	case logs.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	delete                   *int64
	adddelete                *int64
	created_id               *int64
	addcreated_id            *int64
	status                   *int64
	addstatus                *int64
	password                 *string
	username                 *string
	mobile                   *string
	avatar                   *string
	clearedFields            map[string]struct{}
	member_profile           map[int64]struct{}
	removedmember_profile    map[int64]struct{}
	clearedmember_profile    bool
	member_details           map[int64]struct{}
	removedmember_details    map[int64]struct{}
	clearedmember_details    bool
	member_notes             map[int64]struct{}
	removedmember_notes      map[int64]struct{}
	clearedmember_notes      bool
	member_orders            map[int64]struct{}
	removedmember_orders     map[int64]struct{}
	clearedmember_orders     bool
	member_products          map[int64]struct{}
	removedmember_products   map[int64]struct{}
	clearedmember_products   bool
	member_entry             map[int64]struct{}
	removedmember_entry      map[int64]struct{}
	clearedmember_entry      bool
	member_contents          map[int64]struct{}
	removedmember_contents   map[int64]struct{}
	clearedmember_contents   bool
	member_contests          map[int64]struct{}
	removedmember_contests   map[int64]struct{}
	clearedmember_contests   bool
	member_bootcamps         map[int64]struct{}
	removedmember_bootcamps  map[int64]struct{}
	clearedmember_bootcamps  bool
	member_communitys        map[int64]struct{}
	removedmember_communitys map[int64]struct{}
	clearedmember_communitys bool
	done                     bool
	oldValue                 func(context.Context) (*Member, error)
	predicates               []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int64) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[member.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[member.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, member.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[member.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[member.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, member.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[member.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[member.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, member.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[member.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[member.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, member.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[member.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[member.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, member.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *MemberMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[member.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *MemberMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[member.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, member.FieldPassword)
}

// SetUsername sets the "username" field.
func (m *MemberMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *MemberMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *MemberMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[member.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *MemberMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[member.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *MemberMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, member.FieldUsername)
}

// SetMobile sets the "mobile" field.
func (m *MemberMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *MemberMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *MemberMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[member.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *MemberMutation) MobileCleared() bool {
	_, ok := m.clearedFields[member.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *MemberMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, member.FieldMobile)
}

// SetAvatar sets the "avatar" field.
func (m *MemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *MemberMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[member.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *MemberMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[member.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, member.FieldAvatar)
}

// AddMemberProfileIDs adds the "member_profile" edge to the MemberProfile entity by ids.
func (m *MemberMutation) AddMemberProfileIDs(ids ...int64) {
	if m.member_profile == nil {
		m.member_profile = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_profile[ids[i]] = struct{}{}
	}
}

// ClearMemberProfile clears the "member_profile" edge to the MemberProfile entity.
func (m *MemberMutation) ClearMemberProfile() {
	m.clearedmember_profile = true
}

// MemberProfileCleared reports if the "member_profile" edge to the MemberProfile entity was cleared.
func (m *MemberMutation) MemberProfileCleared() bool {
	return m.clearedmember_profile
}

// RemoveMemberProfileIDs removes the "member_profile" edge to the MemberProfile entity by IDs.
func (m *MemberMutation) RemoveMemberProfileIDs(ids ...int64) {
	if m.removedmember_profile == nil {
		m.removedmember_profile = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_profile, ids[i])
		m.removedmember_profile[ids[i]] = struct{}{}
	}
}

// RemovedMemberProfile returns the removed IDs of the "member_profile" edge to the MemberProfile entity.
func (m *MemberMutation) RemovedMemberProfileIDs() (ids []int64) {
	for id := range m.removedmember_profile {
		ids = append(ids, id)
	}
	return
}

// MemberProfileIDs returns the "member_profile" edge IDs in the mutation.
func (m *MemberMutation) MemberProfileIDs() (ids []int64) {
	for id := range m.member_profile {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProfile resets all changes to the "member_profile" edge.
func (m *MemberMutation) ResetMemberProfile() {
	m.member_profile = nil
	m.clearedmember_profile = false
	m.removedmember_profile = nil
}

// AddMemberDetailIDs adds the "member_details" edge to the MemberDetails entity by ids.
func (m *MemberMutation) AddMemberDetailIDs(ids ...int64) {
	if m.member_details == nil {
		m.member_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_details[ids[i]] = struct{}{}
	}
}

// ClearMemberDetails clears the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) ClearMemberDetails() {
	m.clearedmember_details = true
}

// MemberDetailsCleared reports if the "member_details" edge to the MemberDetails entity was cleared.
func (m *MemberMutation) MemberDetailsCleared() bool {
	return m.clearedmember_details
}

// RemoveMemberDetailIDs removes the "member_details" edge to the MemberDetails entity by IDs.
func (m *MemberMutation) RemoveMemberDetailIDs(ids ...int64) {
	if m.removedmember_details == nil {
		m.removedmember_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_details, ids[i])
		m.removedmember_details[ids[i]] = struct{}{}
	}
}

// RemovedMemberDetails returns the removed IDs of the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) RemovedMemberDetailsIDs() (ids []int64) {
	for id := range m.removedmember_details {
		ids = append(ids, id)
	}
	return
}

// MemberDetailsIDs returns the "member_details" edge IDs in the mutation.
func (m *MemberMutation) MemberDetailsIDs() (ids []int64) {
	for id := range m.member_details {
		ids = append(ids, id)
	}
	return
}

// ResetMemberDetails resets all changes to the "member_details" edge.
func (m *MemberMutation) ResetMemberDetails() {
	m.member_details = nil
	m.clearedmember_details = false
	m.removedmember_details = nil
}

// AddMemberNoteIDs adds the "member_notes" edge to the MemberNote entity by ids.
func (m *MemberMutation) AddMemberNoteIDs(ids ...int64) {
	if m.member_notes == nil {
		m.member_notes = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_notes[ids[i]] = struct{}{}
	}
}

// ClearMemberNotes clears the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) ClearMemberNotes() {
	m.clearedmember_notes = true
}

// MemberNotesCleared reports if the "member_notes" edge to the MemberNote entity was cleared.
func (m *MemberMutation) MemberNotesCleared() bool {
	return m.clearedmember_notes
}

// RemoveMemberNoteIDs removes the "member_notes" edge to the MemberNote entity by IDs.
func (m *MemberMutation) RemoveMemberNoteIDs(ids ...int64) {
	if m.removedmember_notes == nil {
		m.removedmember_notes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_notes, ids[i])
		m.removedmember_notes[ids[i]] = struct{}{}
	}
}

// RemovedMemberNotes returns the removed IDs of the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) RemovedMemberNotesIDs() (ids []int64) {
	for id := range m.removedmember_notes {
		ids = append(ids, id)
	}
	return
}

// MemberNotesIDs returns the "member_notes" edge IDs in the mutation.
func (m *MemberMutation) MemberNotesIDs() (ids []int64) {
	for id := range m.member_notes {
		ids = append(ids, id)
	}
	return
}

// ResetMemberNotes resets all changes to the "member_notes" edge.
func (m *MemberMutation) ResetMemberNotes() {
	m.member_notes = nil
	m.clearedmember_notes = false
	m.removedmember_notes = nil
}

// AddMemberOrderIDs adds the "member_orders" edge to the Order entity by ids.
func (m *MemberMutation) AddMemberOrderIDs(ids ...int64) {
	if m.member_orders == nil {
		m.member_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_orders[ids[i]] = struct{}{}
	}
}

// ClearMemberOrders clears the "member_orders" edge to the Order entity.
func (m *MemberMutation) ClearMemberOrders() {
	m.clearedmember_orders = true
}

// MemberOrdersCleared reports if the "member_orders" edge to the Order entity was cleared.
func (m *MemberMutation) MemberOrdersCleared() bool {
	return m.clearedmember_orders
}

// RemoveMemberOrderIDs removes the "member_orders" edge to the Order entity by IDs.
func (m *MemberMutation) RemoveMemberOrderIDs(ids ...int64) {
	if m.removedmember_orders == nil {
		m.removedmember_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_orders, ids[i])
		m.removedmember_orders[ids[i]] = struct{}{}
	}
}

// RemovedMemberOrders returns the removed IDs of the "member_orders" edge to the Order entity.
func (m *MemberMutation) RemovedMemberOrdersIDs() (ids []int64) {
	for id := range m.removedmember_orders {
		ids = append(ids, id)
	}
	return
}

// MemberOrdersIDs returns the "member_orders" edge IDs in the mutation.
func (m *MemberMutation) MemberOrdersIDs() (ids []int64) {
	for id := range m.member_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMemberOrders resets all changes to the "member_orders" edge.
func (m *MemberMutation) ResetMemberOrders() {
	m.member_orders = nil
	m.clearedmember_orders = false
	m.removedmember_orders = nil
}

// AddMemberProductIDs adds the "member_products" edge to the MemberProduct entity by ids.
func (m *MemberMutation) AddMemberProductIDs(ids ...int64) {
	if m.member_products == nil {
		m.member_products = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_products[ids[i]] = struct{}{}
	}
}

// ClearMemberProducts clears the "member_products" edge to the MemberProduct entity.
func (m *MemberMutation) ClearMemberProducts() {
	m.clearedmember_products = true
}

// MemberProductsCleared reports if the "member_products" edge to the MemberProduct entity was cleared.
func (m *MemberMutation) MemberProductsCleared() bool {
	return m.clearedmember_products
}

// RemoveMemberProductIDs removes the "member_products" edge to the MemberProduct entity by IDs.
func (m *MemberMutation) RemoveMemberProductIDs(ids ...int64) {
	if m.removedmember_products == nil {
		m.removedmember_products = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_products, ids[i])
		m.removedmember_products[ids[i]] = struct{}{}
	}
}

// RemovedMemberProducts returns the removed IDs of the "member_products" edge to the MemberProduct entity.
func (m *MemberMutation) RemovedMemberProductsIDs() (ids []int64) {
	for id := range m.removedmember_products {
		ids = append(ids, id)
	}
	return
}

// MemberProductsIDs returns the "member_products" edge IDs in the mutation.
func (m *MemberMutation) MemberProductsIDs() (ids []int64) {
	for id := range m.member_products {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProducts resets all changes to the "member_products" edge.
func (m *MemberMutation) ResetMemberProducts() {
	m.member_products = nil
	m.clearedmember_products = false
	m.removedmember_products = nil
}

// AddMemberEntryIDs adds the "member_entry" edge to the EntryLogs entity by ids.
func (m *MemberMutation) AddMemberEntryIDs(ids ...int64) {
	if m.member_entry == nil {
		m.member_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_entry[ids[i]] = struct{}{}
	}
}

// ClearMemberEntry clears the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) ClearMemberEntry() {
	m.clearedmember_entry = true
}

// MemberEntryCleared reports if the "member_entry" edge to the EntryLogs entity was cleared.
func (m *MemberMutation) MemberEntryCleared() bool {
	return m.clearedmember_entry
}

// RemoveMemberEntryIDs removes the "member_entry" edge to the EntryLogs entity by IDs.
func (m *MemberMutation) RemoveMemberEntryIDs(ids ...int64) {
	if m.removedmember_entry == nil {
		m.removedmember_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_entry, ids[i])
		m.removedmember_entry[ids[i]] = struct{}{}
	}
}

// RemovedMemberEntry returns the removed IDs of the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) RemovedMemberEntryIDs() (ids []int64) {
	for id := range m.removedmember_entry {
		ids = append(ids, id)
	}
	return
}

// MemberEntryIDs returns the "member_entry" edge IDs in the mutation.
func (m *MemberMutation) MemberEntryIDs() (ids []int64) {
	for id := range m.member_entry {
		ids = append(ids, id)
	}
	return
}

// ResetMemberEntry resets all changes to the "member_entry" edge.
func (m *MemberMutation) ResetMemberEntry() {
	m.member_entry = nil
	m.clearedmember_entry = false
	m.removedmember_entry = nil
}

// AddMemberContentIDs adds the "member_contents" edge to the MemberContract entity by ids.
func (m *MemberMutation) AddMemberContentIDs(ids ...int64) {
	if m.member_contents == nil {
		m.member_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_contents[ids[i]] = struct{}{}
	}
}

// ClearMemberContents clears the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) ClearMemberContents() {
	m.clearedmember_contents = true
}

// MemberContentsCleared reports if the "member_contents" edge to the MemberContract entity was cleared.
func (m *MemberMutation) MemberContentsCleared() bool {
	return m.clearedmember_contents
}

// RemoveMemberContentIDs removes the "member_contents" edge to the MemberContract entity by IDs.
func (m *MemberMutation) RemoveMemberContentIDs(ids ...int64) {
	if m.removedmember_contents == nil {
		m.removedmember_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_contents, ids[i])
		m.removedmember_contents[ids[i]] = struct{}{}
	}
}

// RemovedMemberContents returns the removed IDs of the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) RemovedMemberContentsIDs() (ids []int64) {
	for id := range m.removedmember_contents {
		ids = append(ids, id)
	}
	return
}

// MemberContentsIDs returns the "member_contents" edge IDs in the mutation.
func (m *MemberMutation) MemberContentsIDs() (ids []int64) {
	for id := range m.member_contents {
		ids = append(ids, id)
	}
	return
}

// ResetMemberContents resets all changes to the "member_contents" edge.
func (m *MemberMutation) ResetMemberContents() {
	m.member_contents = nil
	m.clearedmember_contents = false
	m.removedmember_contents = nil
}

// AddMemberContestIDs adds the "member_contests" edge to the ContestParticipant entity by ids.
func (m *MemberMutation) AddMemberContestIDs(ids ...int64) {
	if m.member_contests == nil {
		m.member_contests = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_contests[ids[i]] = struct{}{}
	}
}

// ClearMemberContests clears the "member_contests" edge to the ContestParticipant entity.
func (m *MemberMutation) ClearMemberContests() {
	m.clearedmember_contests = true
}

// MemberContestsCleared reports if the "member_contests" edge to the ContestParticipant entity was cleared.
func (m *MemberMutation) MemberContestsCleared() bool {
	return m.clearedmember_contests
}

// RemoveMemberContestIDs removes the "member_contests" edge to the ContestParticipant entity by IDs.
func (m *MemberMutation) RemoveMemberContestIDs(ids ...int64) {
	if m.removedmember_contests == nil {
		m.removedmember_contests = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_contests, ids[i])
		m.removedmember_contests[ids[i]] = struct{}{}
	}
}

// RemovedMemberContests returns the removed IDs of the "member_contests" edge to the ContestParticipant entity.
func (m *MemberMutation) RemovedMemberContestsIDs() (ids []int64) {
	for id := range m.removedmember_contests {
		ids = append(ids, id)
	}
	return
}

// MemberContestsIDs returns the "member_contests" edge IDs in the mutation.
func (m *MemberMutation) MemberContestsIDs() (ids []int64) {
	for id := range m.member_contests {
		ids = append(ids, id)
	}
	return
}

// ResetMemberContests resets all changes to the "member_contests" edge.
func (m *MemberMutation) ResetMemberContests() {
	m.member_contests = nil
	m.clearedmember_contests = false
	m.removedmember_contests = nil
}

// AddMemberBootcampIDs adds the "member_bootcamps" edge to the BootcampParticipant entity by ids.
func (m *MemberMutation) AddMemberBootcampIDs(ids ...int64) {
	if m.member_bootcamps == nil {
		m.member_bootcamps = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_bootcamps[ids[i]] = struct{}{}
	}
}

// ClearMemberBootcamps clears the "member_bootcamps" edge to the BootcampParticipant entity.
func (m *MemberMutation) ClearMemberBootcamps() {
	m.clearedmember_bootcamps = true
}

// MemberBootcampsCleared reports if the "member_bootcamps" edge to the BootcampParticipant entity was cleared.
func (m *MemberMutation) MemberBootcampsCleared() bool {
	return m.clearedmember_bootcamps
}

// RemoveMemberBootcampIDs removes the "member_bootcamps" edge to the BootcampParticipant entity by IDs.
func (m *MemberMutation) RemoveMemberBootcampIDs(ids ...int64) {
	if m.removedmember_bootcamps == nil {
		m.removedmember_bootcamps = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_bootcamps, ids[i])
		m.removedmember_bootcamps[ids[i]] = struct{}{}
	}
}

// RemovedMemberBootcamps returns the removed IDs of the "member_bootcamps" edge to the BootcampParticipant entity.
func (m *MemberMutation) RemovedMemberBootcampsIDs() (ids []int64) {
	for id := range m.removedmember_bootcamps {
		ids = append(ids, id)
	}
	return
}

// MemberBootcampsIDs returns the "member_bootcamps" edge IDs in the mutation.
func (m *MemberMutation) MemberBootcampsIDs() (ids []int64) {
	for id := range m.member_bootcamps {
		ids = append(ids, id)
	}
	return
}

// ResetMemberBootcamps resets all changes to the "member_bootcamps" edge.
func (m *MemberMutation) ResetMemberBootcamps() {
	m.member_bootcamps = nil
	m.clearedmember_bootcamps = false
	m.removedmember_bootcamps = nil
}

// AddMemberCommunityIDs adds the "member_communitys" edge to the CommunityParticipant entity by ids.
func (m *MemberMutation) AddMemberCommunityIDs(ids ...int64) {
	if m.member_communitys == nil {
		m.member_communitys = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_communitys[ids[i]] = struct{}{}
	}
}

// ClearMemberCommunitys clears the "member_communitys" edge to the CommunityParticipant entity.
func (m *MemberMutation) ClearMemberCommunitys() {
	m.clearedmember_communitys = true
}

// MemberCommunitysCleared reports if the "member_communitys" edge to the CommunityParticipant entity was cleared.
func (m *MemberMutation) MemberCommunitysCleared() bool {
	return m.clearedmember_communitys
}

// RemoveMemberCommunityIDs removes the "member_communitys" edge to the CommunityParticipant entity by IDs.
func (m *MemberMutation) RemoveMemberCommunityIDs(ids ...int64) {
	if m.removedmember_communitys == nil {
		m.removedmember_communitys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_communitys, ids[i])
		m.removedmember_communitys[ids[i]] = struct{}{}
	}
}

// RemovedMemberCommunitys returns the removed IDs of the "member_communitys" edge to the CommunityParticipant entity.
func (m *MemberMutation) RemovedMemberCommunitysIDs() (ids []int64) {
	for id := range m.removedmember_communitys {
		ids = append(ids, id)
	}
	return
}

// MemberCommunitysIDs returns the "member_communitys" edge IDs in the mutation.
func (m *MemberMutation) MemberCommunitysIDs() (ids []int64) {
	for id := range m.member_communitys {
		ids = append(ids, id)
	}
	return
}

// ResetMemberCommunitys resets all changes to the "member_communitys" edge.
func (m *MemberMutation) ResetMemberCommunitys() {
	m.member_communitys = nil
	m.clearedmember_communitys = false
	m.removedmember_communitys = nil
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, member.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.username != nil {
		fields = append(fields, member.FieldUsername)
	}
	if m.mobile != nil {
		fields = append(fields, member.FieldMobile)
	}
	if m.avatar != nil {
		fields = append(fields, member.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldDelete:
		return m.Delete()
	case member.FieldCreatedID:
		return m.CreatedID()
	case member.FieldStatus:
		return m.Status()
	case member.FieldPassword:
		return m.Password()
	case member.FieldUsername:
		return m.Username()
	case member.FieldMobile:
		return m.Mobile()
	case member.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldDelete:
		return m.OldDelete(ctx)
	case member.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case member.FieldStatus:
		return m.OldStatus(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldUsername:
		return m.OldUsername(ctx)
	case member.FieldMobile:
		return m.OldMobile(ctx)
	case member.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case member.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case member.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case member.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, member.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, member.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldDelete:
		return m.AddedDelete()
	case member.FieldCreatedID:
		return m.AddedCreatedID()
	case member.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case member.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldCreatedAt) {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.FieldCleared(member.FieldUpdatedAt) {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.FieldCleared(member.FieldDelete) {
		fields = append(fields, member.FieldDelete)
	}
	if m.FieldCleared(member.FieldCreatedID) {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.FieldCleared(member.FieldStatus) {
		fields = append(fields, member.FieldStatus)
	}
	if m.FieldCleared(member.FieldPassword) {
		fields = append(fields, member.FieldPassword)
	}
	if m.FieldCleared(member.FieldUsername) {
		fields = append(fields, member.FieldUsername)
	}
	if m.FieldCleared(member.FieldMobile) {
		fields = append(fields, member.FieldMobile)
	}
	if m.FieldCleared(member.FieldAvatar) {
		fields = append(fields, member.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case member.FieldDelete:
		m.ClearDelete()
		return nil
	case member.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case member.FieldStatus:
		m.ClearStatus()
		return nil
	case member.FieldPassword:
		m.ClearPassword()
		return nil
	case member.FieldUsername:
		m.ClearUsername()
		return nil
	case member.FieldMobile:
		m.ClearMobile()
		return nil
	case member.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldDelete:
		m.ResetDelete()
		return nil
	case member.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case member.FieldStatus:
		m.ResetStatus()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldUsername:
		m.ResetUsername()
		return nil
	case member.FieldMobile:
		m.ResetMobile()
		return nil
	case member.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.member_profile != nil {
		edges = append(edges, member.EdgeMemberProfile)
	}
	if m.member_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.member_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.member_orders != nil {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.member_products != nil {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.member_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.member_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	if m.member_contests != nil {
		edges = append(edges, member.EdgeMemberContests)
	}
	if m.member_bootcamps != nil {
		edges = append(edges, member.EdgeMemberBootcamps)
	}
	if m.member_communitys != nil {
		edges = append(edges, member.EdgeMemberCommunitys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberProfile:
		ids := make([]ent.Value, 0, len(m.member_profile))
		for id := range m.member_profile {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.member_details))
		for id := range m.member_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.member_notes))
		for id := range m.member_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberOrders:
		ids := make([]ent.Value, 0, len(m.member_orders))
		for id := range m.member_orders {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberProducts:
		ids := make([]ent.Value, 0, len(m.member_products))
		for id := range m.member_products {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.member_entry))
		for id := range m.member_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.member_contents))
		for id := range m.member_contents {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContests:
		ids := make([]ent.Value, 0, len(m.member_contests))
		for id := range m.member_contests {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberBootcamps:
		ids := make([]ent.Value, 0, len(m.member_bootcamps))
		for id := range m.member_bootcamps {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberCommunitys:
		ids := make([]ent.Value, 0, len(m.member_communitys))
		for id := range m.member_communitys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedmember_profile != nil {
		edges = append(edges, member.EdgeMemberProfile)
	}
	if m.removedmember_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.removedmember_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.removedmember_orders != nil {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.removedmember_products != nil {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.removedmember_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.removedmember_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	if m.removedmember_contests != nil {
		edges = append(edges, member.EdgeMemberContests)
	}
	if m.removedmember_bootcamps != nil {
		edges = append(edges, member.EdgeMemberBootcamps)
	}
	if m.removedmember_communitys != nil {
		edges = append(edges, member.EdgeMemberCommunitys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberProfile:
		ids := make([]ent.Value, 0, len(m.removedmember_profile))
		for id := range m.removedmember_profile {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.removedmember_details))
		for id := range m.removedmember_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.removedmember_notes))
		for id := range m.removedmember_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberOrders:
		ids := make([]ent.Value, 0, len(m.removedmember_orders))
		for id := range m.removedmember_orders {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberProducts:
		ids := make([]ent.Value, 0, len(m.removedmember_products))
		for id := range m.removedmember_products {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.removedmember_entry))
		for id := range m.removedmember_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.removedmember_contents))
		for id := range m.removedmember_contents {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContests:
		ids := make([]ent.Value, 0, len(m.removedmember_contests))
		for id := range m.removedmember_contests {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberBootcamps:
		ids := make([]ent.Value, 0, len(m.removedmember_bootcamps))
		for id := range m.removedmember_bootcamps {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberCommunitys:
		ids := make([]ent.Value, 0, len(m.removedmember_communitys))
		for id := range m.removedmember_communitys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedmember_profile {
		edges = append(edges, member.EdgeMemberProfile)
	}
	if m.clearedmember_details {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.clearedmember_notes {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.clearedmember_orders {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.clearedmember_products {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.clearedmember_entry {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.clearedmember_contents {
		edges = append(edges, member.EdgeMemberContents)
	}
	if m.clearedmember_contests {
		edges = append(edges, member.EdgeMemberContests)
	}
	if m.clearedmember_bootcamps {
		edges = append(edges, member.EdgeMemberBootcamps)
	}
	if m.clearedmember_communitys {
		edges = append(edges, member.EdgeMemberCommunitys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeMemberProfile:
		return m.clearedmember_profile
	case member.EdgeMemberDetails:
		return m.clearedmember_details
	case member.EdgeMemberNotes:
		return m.clearedmember_notes
	case member.EdgeMemberOrders:
		return m.clearedmember_orders
	case member.EdgeMemberProducts:
		return m.clearedmember_products
	case member.EdgeMemberEntry:
		return m.clearedmember_entry
	case member.EdgeMemberContents:
		return m.clearedmember_contents
	case member.EdgeMemberContests:
		return m.clearedmember_contests
	case member.EdgeMemberBootcamps:
		return m.clearedmember_bootcamps
	case member.EdgeMemberCommunitys:
		return m.clearedmember_communitys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberProfile:
		m.ResetMemberProfile()
		return nil
	case member.EdgeMemberDetails:
		m.ResetMemberDetails()
		return nil
	case member.EdgeMemberNotes:
		m.ResetMemberNotes()
		return nil
	case member.EdgeMemberOrders:
		m.ResetMemberOrders()
		return nil
	case member.EdgeMemberProducts:
		m.ResetMemberProducts()
		return nil
	case member.EdgeMemberEntry:
		m.ResetMemberEntry()
		return nil
	case member.EdgeMemberContents:
		m.ResetMemberContents()
		return nil
	case member.EdgeMemberContests:
		m.ResetMemberContests()
		return nil
	case member.EdgeMemberBootcamps:
		m.ResetMemberBootcamps()
		return nil
	case member.EdgeMemberCommunitys:
		m.ResetMemberCommunitys()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// MemberContractMutation represents an operation that mutates the MemberContract nodes in the graph.
type MemberContractMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	delete               *int64
	adddelete            *int64
	created_id           *int64
	addcreated_id        *int64
	status               *int64
	addstatus            *int64
	contract_id          *int64
	addcontract_id       *int64
	venue_id             *int64
	addvenue_id          *int64
	member_product_id    *int64
	addmember_product_id *int64
	name                 *string
	sign                 *string
	clearedFields        map[string]struct{}
	content              map[int64]struct{}
	removedcontent       map[int64]struct{}
	clearedcontent       bool
	member               *int64
	clearedmember        bool
	_order               *int64
	cleared_order        bool
	done                 bool
	oldValue             func(context.Context) (*MemberContract, error)
	predicates           []predicate.MemberContract
}

var _ ent.Mutation = (*MemberContractMutation)(nil)

// membercontractOption allows management of the mutation configuration using functional options.
type membercontractOption func(*MemberContractMutation)

// newMemberContractMutation creates new mutation for the MemberContract entity.
func newMemberContractMutation(c config, op Op, opts ...membercontractOption) *MemberContractMutation {
	m := &MemberContractMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractID sets the ID field of the mutation.
func withMemberContractID(id int64) membercontractOption {
	return func(m *MemberContractMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContract
		)
		m.oldValue = func(ctx context.Context) (*MemberContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContract sets the old MemberContract of the mutation.
func withMemberContract(node *MemberContract) membercontractOption {
	return func(m *MemberContractMutation) {
		m.oldValue = func(context.Context) (*MemberContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContract entities.
func (m *MemberContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberContractMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membercontract.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberContractMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membercontract.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberContractMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membercontract.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberContractMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membercontract.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberContractMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberContractMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberContractMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberContractMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberContractMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membercontract.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberContractMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberContractMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membercontract.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberContractMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberContractMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberContractMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberContractMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberContractMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membercontract.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberContractMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberContractMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membercontract.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membercontract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membercontract.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberContractMutation) SetMemberID(i int64) {
	m.member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberContractMutation) MemberID() (r int64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberContractMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberContractMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, membercontract.FieldMemberID)
}

// SetContractID sets the "contract_id" field.
func (m *MemberContractMutation) SetContractID(i int64) {
	m.contract_id = &i
	m.addcontract_id = nil
}

// ContractID returns the value of the "contract_id" field in the mutation.
func (m *MemberContractMutation) ContractID() (r int64, exists bool) {
	v := m.contract_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContractID returns the old "contract_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractID: %w", err)
	}
	return oldValue.ContractID, nil
}

// AddContractID adds i to the "contract_id" field.
func (m *MemberContractMutation) AddContractID(i int64) {
	if m.addcontract_id != nil {
		*m.addcontract_id += i
	} else {
		m.addcontract_id = &i
	}
}

// AddedContractID returns the value that was added to the "contract_id" field in this mutation.
func (m *MemberContractMutation) AddedContractID() (r int64, exists bool) {
	v := m.addcontract_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContractID clears the value of the "contract_id" field.
func (m *MemberContractMutation) ClearContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	m.clearedFields[membercontract.FieldContractID] = struct{}{}
}

// ContractIDCleared returns if the "contract_id" field was cleared in this mutation.
func (m *MemberContractMutation) ContractIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldContractID]
	return ok
}

// ResetContractID resets all changes to the "contract_id" field.
func (m *MemberContractMutation) ResetContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	delete(m.clearedFields, membercontract.FieldContractID)
}

// SetOrderID sets the "order_id" field.
func (m *MemberContractMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MemberContractMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MemberContractMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[membercontract.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MemberContractMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MemberContractMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, membercontract.FieldOrderID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberContractMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberContractMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberContractMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberContractMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberContractMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[membercontract.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberContractMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberContractMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, membercontract.FieldVenueID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *MemberContractMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *MemberContractMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *MemberContractMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *MemberContractMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *MemberContractMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[membercontract.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *MemberContractMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, membercontract.FieldMemberProductID)
}

// SetName sets the "name" field.
func (m *MemberContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[membercontract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, membercontract.FieldName)
}

// SetSign sets the "sign" field.
func (m *MemberContractMutation) SetSign(s string) {
	m.sign = &s
}

// Sign returns the value of the "sign" field in the mutation.
func (m *MemberContractMutation) Sign() (r string, exists bool) {
	v := m.sign
	if v == nil {
		return
	}
	return *v, true
}

// OldSign returns the old "sign" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldSign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSign: %w", err)
	}
	return oldValue.Sign, nil
}

// ClearSign clears the value of the "sign" field.
func (m *MemberContractMutation) ClearSign() {
	m.sign = nil
	m.clearedFields[membercontract.FieldSign] = struct{}{}
}

// SignCleared returns if the "sign" field was cleared in this mutation.
func (m *MemberContractMutation) SignCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldSign]
	return ok
}

// ResetSign resets all changes to the "sign" field.
func (m *MemberContractMutation) ResetSign() {
	m.sign = nil
	delete(m.clearedFields, membercontract.FieldSign)
}

// AddContentIDs adds the "content" edge to the MemberContractContent entity by ids.
func (m *MemberContractMutation) AddContentIDs(ids ...int64) {
	if m.content == nil {
		m.content = make(map[int64]struct{})
	}
	for i := range ids {
		m.content[ids[i]] = struct{}{}
	}
}

// ClearContent clears the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) ClearContent() {
	m.clearedcontent = true
}

// ContentCleared reports if the "content" edge to the MemberContractContent entity was cleared.
func (m *MemberContractMutation) ContentCleared() bool {
	return m.clearedcontent
}

// RemoveContentIDs removes the "content" edge to the MemberContractContent entity by IDs.
func (m *MemberContractMutation) RemoveContentIDs(ids ...int64) {
	if m.removedcontent == nil {
		m.removedcontent = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.content, ids[i])
		m.removedcontent[ids[i]] = struct{}{}
	}
}

// RemovedContent returns the removed IDs of the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) RemovedContentIDs() (ids []int64) {
	for id := range m.removedcontent {
		ids = append(ids, id)
	}
	return
}

// ContentIDs returns the "content" edge IDs in the mutation.
func (m *MemberContractMutation) ContentIDs() (ids []int64) {
	for id := range m.content {
		ids = append(ids, id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *MemberContractMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
	m.removedcontent = nil
}

// ClearMember clears the "member" edge to the Member entity.
func (m *MemberContractMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *MemberContractMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) MemberIDs() (ids []int64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *MemberContractMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *MemberContractMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[membercontract.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *MemberContractMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *MemberContractMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the MemberContractMutation builder.
func (m *MemberContractMutation) Where(ps ...predicate.MemberContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContract).
func (m *MemberContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, membercontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontract.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.member != nil {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m.contract_id != nil {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m._order != nil {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.venue_id != nil {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.member_product_id != nil {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.name != nil {
		fields = append(fields, membercontract.FieldName)
	}
	if m.sign != nil {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.CreatedAt()
	case membercontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontract.FieldDelete:
		return m.Delete()
	case membercontract.FieldCreatedID:
		return m.CreatedID()
	case membercontract.FieldStatus:
		return m.Status()
	case membercontract.FieldMemberID:
		return m.MemberID()
	case membercontract.FieldContractID:
		return m.ContractID()
	case membercontract.FieldOrderID:
		return m.OrderID()
	case membercontract.FieldVenueID:
		return m.VenueID()
	case membercontract.FieldMemberProductID:
		return m.MemberProductID()
	case membercontract.FieldName:
		return m.Name()
	case membercontract.FieldSign:
		return m.Sign()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontract.FieldDelete:
		return m.OldDelete(ctx)
	case membercontract.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membercontract.FieldStatus:
		return m.OldStatus(ctx)
	case membercontract.FieldMemberID:
		return m.OldMemberID(ctx)
	case membercontract.FieldContractID:
		return m.OldContractID(ctx)
	case membercontract.FieldOrderID:
		return m.OldOrderID(ctx)
	case membercontract.FieldVenueID:
		return m.OldVenueID(ctx)
	case membercontract.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case membercontract.FieldName:
		return m.OldName(ctx)
	case membercontract.FieldSign:
		return m.OldSign(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membercontract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membercontract.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membercontract.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractID(v)
		return nil
	case membercontract.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case membercontract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case membercontract.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case membercontract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case membercontract.FieldSign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSign(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.addcontract_id != nil {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m.addvenue_id != nil {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.addmember_product_id != nil {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldDelete:
		return m.AddedDelete()
	case membercontract.FieldCreatedID:
		return m.AddedCreatedID()
	case membercontract.FieldStatus:
		return m.AddedStatus()
	case membercontract.FieldContractID:
		return m.AddedContractID()
	case membercontract.FieldVenueID:
		return m.AddedVenueID()
	case membercontract.FieldMemberProductID:
		return m.AddedMemberProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membercontract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case membercontract.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractID(v)
		return nil
	case membercontract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case membercontract.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontract.FieldCreatedAt) {
		fields = append(fields, membercontract.FieldCreatedAt)
	}
	if m.FieldCleared(membercontract.FieldUpdatedAt) {
		fields = append(fields, membercontract.FieldUpdatedAt)
	}
	if m.FieldCleared(membercontract.FieldDelete) {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.FieldCleared(membercontract.FieldCreatedID) {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.FieldCleared(membercontract.FieldStatus) {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.FieldCleared(membercontract.FieldMemberID) {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m.FieldCleared(membercontract.FieldContractID) {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m.FieldCleared(membercontract.FieldOrderID) {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.FieldCleared(membercontract.FieldVenueID) {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.FieldCleared(membercontract.FieldMemberProductID) {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.FieldCleared(membercontract.FieldName) {
		fields = append(fields, membercontract.FieldName)
	}
	if m.FieldCleared(membercontract.FieldSign) {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractMutation) ClearField(name string) error {
	switch name {
	case membercontract.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membercontract.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membercontract.FieldDelete:
		m.ClearDelete()
		return nil
	case membercontract.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membercontract.FieldStatus:
		m.ClearStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membercontract.FieldContractID:
		m.ClearContractID()
		return nil
	case membercontract.FieldOrderID:
		m.ClearOrderID()
		return nil
	case membercontract.FieldVenueID:
		m.ClearVenueID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ClearName()
		return nil
	case membercontract.FieldSign:
		m.ClearSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractMutation) ResetField(name string) error {
	switch name {
	case membercontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontract.FieldDelete:
		m.ResetDelete()
		return nil
	case membercontract.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membercontract.FieldStatus:
		m.ResetStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membercontract.FieldContractID:
		m.ResetContractID()
		return nil
	case membercontract.FieldOrderID:
		m.ResetOrderID()
		return nil
	case membercontract.FieldVenueID:
		m.ResetVenueID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ResetName()
		return nil
	case membercontract.FieldSign:
		m.ResetSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.content != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.member != nil {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m._order != nil {
		edges = append(edges, membercontract.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.content))
		for id := range m.content {
			ids = append(ids, id)
		}
		return ids
	case membercontract.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case membercontract.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcontent != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.removedcontent))
		for id := range m.removedcontent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcontent {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.clearedmember {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m.cleared_order {
		edges = append(edges, membercontract.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontract.EdgeContent:
		return m.clearedcontent
	case membercontract.EdgeMember:
		return m.clearedmember
	case membercontract.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractMutation) ClearEdge(name string) error {
	switch name {
	case membercontract.EdgeMember:
		m.ClearMember()
		return nil
	case membercontract.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown MemberContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractMutation) ResetEdge(name string) error {
	switch name {
	case membercontract.EdgeContent:
		m.ResetContent()
		return nil
	case membercontract.EdgeMember:
		m.ResetMember()
		return nil
	case membercontract.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown MemberContract edge %s", name)
}

// MemberContractContentMutation represents an operation that mutates the MemberContractContent nodes in the graph.
type MemberContractContentMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	content         *string
	sign_img        *string
	clearedFields   map[string]struct{}
	contract        *int64
	clearedcontract bool
	done            bool
	oldValue        func(context.Context) (*MemberContractContent, error)
	predicates      []predicate.MemberContractContent
}

var _ ent.Mutation = (*MemberContractContentMutation)(nil)

// membercontractcontentOption allows management of the mutation configuration using functional options.
type membercontractcontentOption func(*MemberContractContentMutation)

// newMemberContractContentMutation creates new mutation for the MemberContractContent entity.
func newMemberContractContentMutation(c config, op Op, opts ...membercontractcontentOption) *MemberContractContentMutation {
	m := &MemberContractContentMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContractContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractContentID sets the ID field of the mutation.
func withMemberContractContentID(id int64) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContractContent
		)
		m.oldValue = func(ctx context.Context) (*MemberContractContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContractContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContractContent sets the old MemberContractContent of the mutation.
func withMemberContractContent(node *MemberContractContent) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		m.oldValue = func(context.Context) (*MemberContractContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContractContent entities.
func (m *MemberContractContentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractContentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractContentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContractContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberContractContentMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membercontractcontent.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberContractContentMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractContentMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membercontractcontent.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberContractContentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membercontractcontent.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberContractContentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membercontractcontent.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberContractContentMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberContractContentMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberContractContentMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberContractContentMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberContractContentMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membercontractcontent.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberContractContentMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberContractContentMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membercontractcontent.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberContractContentMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberContractContentMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberContractContentMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberContractContentMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberContractContentMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membercontractcontent.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberContractContentMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberContractContentMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membercontractcontent.FieldCreatedID)
}

// SetMemberContractID sets the "member_contract_id" field.
func (m *MemberContractContentMutation) SetMemberContractID(i int64) {
	m.contract = &i
}

// MemberContractID returns the value of the "member_contract_id" field in the mutation.
func (m *MemberContractContentMutation) MemberContractID() (r int64, exists bool) {
	v := m.contract
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberContractID returns the old "member_contract_id" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldMemberContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberContractID: %w", err)
	}
	return oldValue.MemberContractID, nil
}

// ClearMemberContractID clears the value of the "member_contract_id" field.
func (m *MemberContractContentMutation) ClearMemberContractID() {
	m.contract = nil
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// MemberContractIDCleared returns if the "member_contract_id" field was cleared in this mutation.
func (m *MemberContractContentMutation) MemberContractIDCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldMemberContractID]
	return ok
}

// ResetMemberContractID resets all changes to the "member_contract_id" field.
func (m *MemberContractContentMutation) ResetMemberContractID() {
	m.contract = nil
	delete(m.clearedFields, membercontractcontent.FieldMemberContractID)
}

// SetContent sets the "content" field.
func (m *MemberContractContentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MemberContractContentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MemberContractContentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[membercontractcontent.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MemberContractContentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MemberContractContentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, membercontractcontent.FieldContent)
}

// SetSignImg sets the "sign_img" field.
func (m *MemberContractContentMutation) SetSignImg(s string) {
	m.sign_img = &s
}

// SignImg returns the value of the "sign_img" field in the mutation.
func (m *MemberContractContentMutation) SignImg() (r string, exists bool) {
	v := m.sign_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSignImg returns the old "sign_img" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldSignImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignImg: %w", err)
	}
	return oldValue.SignImg, nil
}

// ClearSignImg clears the value of the "sign_img" field.
func (m *MemberContractContentMutation) ClearSignImg() {
	m.sign_img = nil
	m.clearedFields[membercontractcontent.FieldSignImg] = struct{}{}
}

// SignImgCleared returns if the "sign_img" field was cleared in this mutation.
func (m *MemberContractContentMutation) SignImgCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldSignImg]
	return ok
}

// ResetSignImg resets all changes to the "sign_img" field.
func (m *MemberContractContentMutation) ResetSignImg() {
	m.sign_img = nil
	delete(m.clearedFields, membercontractcontent.FieldSignImg)
}

// SetContractID sets the "contract" edge to the MemberContract entity by id.
func (m *MemberContractContentMutation) SetContractID(id int64) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the MemberContract entity.
func (m *MemberContractContentMutation) ClearContract() {
	m.clearedcontract = true
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// ContractCleared reports if the "contract" edge to the MemberContract entity was cleared.
func (m *MemberContractContentMutation) ContractCleared() bool {
	return m.MemberContractIDCleared() || m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *MemberContractContentMutation) ContractID() (id int64, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *MemberContractContentMutation) ContractIDs() (ids []int64) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *MemberContractContentMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// Where appends a list predicates to the MemberContractContentMutation builder.
func (m *MemberContractContentMutation) Where(ps ...predicate.MemberContractContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContractContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContractContent).
func (m *MemberContractContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractContentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, membercontractcontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontractcontent.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	if m.contract != nil {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.content != nil {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.sign_img != nil {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.CreatedAt()
	case membercontractcontent.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontractcontent.FieldDelete:
		return m.Delete()
	case membercontractcontent.FieldCreatedID:
		return m.CreatedID()
	case membercontractcontent.FieldMemberContractID:
		return m.MemberContractID()
	case membercontractcontent.FieldContent:
		return m.Content()
	case membercontractcontent.FieldSignImg:
		return m.SignImg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontractcontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontractcontent.FieldDelete:
		return m.OldDelete(ctx)
	case membercontractcontent.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membercontractcontent.FieldMemberContractID:
		return m.OldMemberContractID(ctx)
	case membercontractcontent.FieldContent:
		return m.OldContent(ctx)
	case membercontractcontent.FieldSignImg:
		return m.OldSignImg(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContractContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontractcontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontractcontent.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membercontractcontent.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membercontractcontent.FieldMemberContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberContractID(v)
		return nil
	case membercontractcontent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case membercontractcontent.FieldSignImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignImg(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractContentMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractContentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membercontractcontent.FieldDelete:
		return m.AddedDelete()
	case membercontractcontent.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membercontractcontent.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membercontractcontent.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontractcontent.FieldCreatedAt) {
		fields = append(fields, membercontractcontent.FieldCreatedAt)
	}
	if m.FieldCleared(membercontractcontent.FieldUpdatedAt) {
		fields = append(fields, membercontractcontent.FieldUpdatedAt)
	}
	if m.FieldCleared(membercontractcontent.FieldDelete) {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.FieldCleared(membercontractcontent.FieldCreatedID) {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	if m.FieldCleared(membercontractcontent.FieldMemberContractID) {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.FieldCleared(membercontractcontent.FieldContent) {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.FieldCleared(membercontractcontent.FieldSignImg) {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ClearField(name string) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membercontractcontent.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membercontractcontent.FieldDelete:
		m.ClearDelete()
		return nil
	case membercontractcontent.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membercontractcontent.FieldMemberContractID:
		m.ClearMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ClearContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ClearSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ResetField(name string) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontractcontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontractcontent.FieldDelete:
		m.ResetDelete()
		return nil
	case membercontractcontent.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membercontractcontent.FieldMemberContractID:
		m.ResetMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ResetContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ResetSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contract != nil {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontractcontent.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontract {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractContentMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontractcontent.EdgeContract:
		return m.clearedcontract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractContentMutation) ClearEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractContentMutation) ResetEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ResetContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent edge %s", name)
}

// MemberDetailsMutation represents an operation that mutates the MemberDetails nodes in the graph.
type MemberDetailsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete              *int64
	adddelete           *int64
	created_id          *int64
	addcreated_id       *int64
	venue_id            *int64
	addvenue_id         *int64
	money_sum           *float64
	addmoney_sum        *float64
	product_id          *int64
	addproduct_id       *int64
	product_name        *string
	entry_sum           *int64
	addentry_sum        *int64
	entry_last_time     *time.Time
	entry_deadline_time *time.Time
	class_last_time     *time.Time
	relation_uid        *int64
	addrelation_uid     *int64
	relation_uname      *string
	relation_mid        *int64
	addrelation_mid     *int64
	relation_mame       *string
	first_time          *time.Time
	clearedFields       map[string]struct{}
	member              *int64
	clearedmember       bool
	done                bool
	oldValue            func(context.Context) (*MemberDetails, error)
	predicates          []predicate.MemberDetails
}

var _ ent.Mutation = (*MemberDetailsMutation)(nil)

// memberdetailsOption allows management of the mutation configuration using functional options.
type memberdetailsOption func(*MemberDetailsMutation)

// newMemberDetailsMutation creates new mutation for the MemberDetails entity.
func newMemberDetailsMutation(c config, op Op, opts ...memberdetailsOption) *MemberDetailsMutation {
	m := &MemberDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberDetailsID sets the ID field of the mutation.
func withMemberDetailsID(id int64) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberDetails
		)
		m.oldValue = func(ctx context.Context) (*MemberDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberDetails sets the old MemberDetails of the mutation.
func withMemberDetails(node *MemberDetails) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		m.oldValue = func(context.Context) (*MemberDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberDetails entities.
func (m *MemberDetailsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberDetailsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberDetailsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberDetailsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberDetailsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberDetailsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberdetails.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberDetailsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberdetails.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberDetailsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberDetailsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberDetailsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberdetails.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberDetailsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberDetailsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberdetails.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberDetailsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberDetailsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberDetailsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberDetailsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberDetailsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberdetails.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberDetailsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberDetailsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberdetails.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberDetailsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberDetailsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberDetailsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberDetailsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberDetailsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberdetails.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberDetailsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberdetails.FieldCreatedID)
}

// SetMemberID sets the "member_id" field.
func (m *MemberDetailsMutation) SetMemberID(i int64) {
	m.member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberDetailsMutation) MemberID() (r int64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberDetailsMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberDetailsMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, memberdetails.FieldMemberID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberDetailsMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberDetailsMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberDetailsMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberDetailsMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberDetailsMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[memberdetails.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberDetailsMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, memberdetails.FieldVenueID)
}

// SetMoneySum sets the "money_sum" field.
func (m *MemberDetailsMutation) SetMoneySum(f float64) {
	m.money_sum = &f
	m.addmoney_sum = nil
}

// MoneySum returns the value of the "money_sum" field in the mutation.
func (m *MemberDetailsMutation) MoneySum() (r float64, exists bool) {
	v := m.money_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldMoneySum returns the old "money_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMoneySum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoneySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoneySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoneySum: %w", err)
	}
	return oldValue.MoneySum, nil
}

// AddMoneySum adds f to the "money_sum" field.
func (m *MemberDetailsMutation) AddMoneySum(f float64) {
	if m.addmoney_sum != nil {
		*m.addmoney_sum += f
	} else {
		m.addmoney_sum = &f
	}
}

// AddedMoneySum returns the value that was added to the "money_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedMoneySum() (r float64, exists bool) {
	v := m.addmoney_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearMoneySum clears the value of the "money_sum" field.
func (m *MemberDetailsMutation) ClearMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	m.clearedFields[memberdetails.FieldMoneySum] = struct{}{}
}

// MoneySumCleared returns if the "money_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) MoneySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMoneySum]
	return ok
}

// ResetMoneySum resets all changes to the "money_sum" field.
func (m *MemberDetailsMutation) ResetMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	delete(m.clearedFields, memberdetails.FieldMoneySum)
}

// SetProductID sets the "product_id" field.
func (m *MemberDetailsMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MemberDetailsMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *MemberDetailsMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *MemberDetailsMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *MemberDetailsMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[memberdetails.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MemberDetailsMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, memberdetails.FieldProductID)
}

// SetProductName sets the "product_name" field.
func (m *MemberDetailsMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *MemberDetailsMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *MemberDetailsMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[memberdetails.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *MemberDetailsMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, memberdetails.FieldProductName)
}

// SetEntrySum sets the "entry_sum" field.
func (m *MemberDetailsMutation) SetEntrySum(i int64) {
	m.entry_sum = &i
	m.addentry_sum = nil
}

// EntrySum returns the value of the "entry_sum" field in the mutation.
func (m *MemberDetailsMutation) EntrySum() (r int64, exists bool) {
	v := m.entry_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldEntrySum returns the old "entry_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntrySum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntrySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntrySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntrySum: %w", err)
	}
	return oldValue.EntrySum, nil
}

// AddEntrySum adds i to the "entry_sum" field.
func (m *MemberDetailsMutation) AddEntrySum(i int64) {
	if m.addentry_sum != nil {
		*m.addentry_sum += i
	} else {
		m.addentry_sum = &i
	}
}

// AddedEntrySum returns the value that was added to the "entry_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedEntrySum() (r int64, exists bool) {
	v := m.addentry_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearEntrySum clears the value of the "entry_sum" field.
func (m *MemberDetailsMutation) ClearEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	m.clearedFields[memberdetails.FieldEntrySum] = struct{}{}
}

// EntrySumCleared returns if the "entry_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntrySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntrySum]
	return ok
}

// ResetEntrySum resets all changes to the "entry_sum" field.
func (m *MemberDetailsMutation) ResetEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	delete(m.clearedFields, memberdetails.FieldEntrySum)
}

// SetEntryLastTime sets the "entry_last_time" field.
func (m *MemberDetailsMutation) SetEntryLastTime(t time.Time) {
	m.entry_last_time = &t
}

// EntryLastTime returns the value of the "entry_last_time" field in the mutation.
func (m *MemberDetailsMutation) EntryLastTime() (r time.Time, exists bool) {
	v := m.entry_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryLastTime returns the old "entry_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryLastTime: %w", err)
	}
	return oldValue.EntryLastTime, nil
}

// ClearEntryLastTime clears the value of the "entry_last_time" field.
func (m *MemberDetailsMutation) ClearEntryLastTime() {
	m.entry_last_time = nil
	m.clearedFields[memberdetails.FieldEntryLastTime] = struct{}{}
}

// EntryLastTimeCleared returns if the "entry_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryLastTime]
	return ok
}

// ResetEntryLastTime resets all changes to the "entry_last_time" field.
func (m *MemberDetailsMutation) ResetEntryLastTime() {
	m.entry_last_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryLastTime)
}

// SetEntryDeadlineTime sets the "entry_deadline_time" field.
func (m *MemberDetailsMutation) SetEntryDeadlineTime(t time.Time) {
	m.entry_deadline_time = &t
}

// EntryDeadlineTime returns the value of the "entry_deadline_time" field in the mutation.
func (m *MemberDetailsMutation) EntryDeadlineTime() (r time.Time, exists bool) {
	v := m.entry_deadline_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryDeadlineTime returns the old "entry_deadline_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryDeadlineTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryDeadlineTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryDeadlineTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryDeadlineTime: %w", err)
	}
	return oldValue.EntryDeadlineTime, nil
}

// ClearEntryDeadlineTime clears the value of the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ClearEntryDeadlineTime() {
	m.entry_deadline_time = nil
	m.clearedFields[memberdetails.FieldEntryDeadlineTime] = struct{}{}
}

// EntryDeadlineTimeCleared returns if the "entry_deadline_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryDeadlineTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryDeadlineTime]
	return ok
}

// ResetEntryDeadlineTime resets all changes to the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ResetEntryDeadlineTime() {
	m.entry_deadline_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryDeadlineTime)
}

// SetClassLastTime sets the "class_last_time" field.
func (m *MemberDetailsMutation) SetClassLastTime(t time.Time) {
	m.class_last_time = &t
}

// ClassLastTime returns the value of the "class_last_time" field in the mutation.
func (m *MemberDetailsMutation) ClassLastTime() (r time.Time, exists bool) {
	v := m.class_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClassLastTime returns the old "class_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldClassLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassLastTime: %w", err)
	}
	return oldValue.ClassLastTime, nil
}

// ClearClassLastTime clears the value of the "class_last_time" field.
func (m *MemberDetailsMutation) ClearClassLastTime() {
	m.class_last_time = nil
	m.clearedFields[memberdetails.FieldClassLastTime] = struct{}{}
}

// ClassLastTimeCleared returns if the "class_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) ClassLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldClassLastTime]
	return ok
}

// ResetClassLastTime resets all changes to the "class_last_time" field.
func (m *MemberDetailsMutation) ResetClassLastTime() {
	m.class_last_time = nil
	delete(m.clearedFields, memberdetails.FieldClassLastTime)
}

// SetRelationUID sets the "relation_uid" field.
func (m *MemberDetailsMutation) SetRelationUID(i int64) {
	m.relation_uid = &i
	m.addrelation_uid = nil
}

// RelationUID returns the value of the "relation_uid" field in the mutation.
func (m *MemberDetailsMutation) RelationUID() (r int64, exists bool) {
	v := m.relation_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationUID returns the old "relation_uid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationUID: %w", err)
	}
	return oldValue.RelationUID, nil
}

// AddRelationUID adds i to the "relation_uid" field.
func (m *MemberDetailsMutation) AddRelationUID(i int64) {
	if m.addrelation_uid != nil {
		*m.addrelation_uid += i
	} else {
		m.addrelation_uid = &i
	}
}

// AddedRelationUID returns the value that was added to the "relation_uid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationUID() (r int64, exists bool) {
	v := m.addrelation_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationUID clears the value of the "relation_uid" field.
func (m *MemberDetailsMutation) ClearRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	m.clearedFields[memberdetails.FieldRelationUID] = struct{}{}
}

// RelationUIDCleared returns if the "relation_uid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationUIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationUID]
	return ok
}

// ResetRelationUID resets all changes to the "relation_uid" field.
func (m *MemberDetailsMutation) ResetRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	delete(m.clearedFields, memberdetails.FieldRelationUID)
}

// SetRelationUname sets the "relation_uname" field.
func (m *MemberDetailsMutation) SetRelationUname(s string) {
	m.relation_uname = &s
}

// RelationUname returns the value of the "relation_uname" field in the mutation.
func (m *MemberDetailsMutation) RelationUname() (r string, exists bool) {
	v := m.relation_uname
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationUname returns the old "relation_uname" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationUname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationUname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationUname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationUname: %w", err)
	}
	return oldValue.RelationUname, nil
}

// ClearRelationUname clears the value of the "relation_uname" field.
func (m *MemberDetailsMutation) ClearRelationUname() {
	m.relation_uname = nil
	m.clearedFields[memberdetails.FieldRelationUname] = struct{}{}
}

// RelationUnameCleared returns if the "relation_uname" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationUnameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationUname]
	return ok
}

// ResetRelationUname resets all changes to the "relation_uname" field.
func (m *MemberDetailsMutation) ResetRelationUname() {
	m.relation_uname = nil
	delete(m.clearedFields, memberdetails.FieldRelationUname)
}

// SetRelationMid sets the "relation_mid" field.
func (m *MemberDetailsMutation) SetRelationMid(i int64) {
	m.relation_mid = &i
	m.addrelation_mid = nil
}

// RelationMid returns the value of the "relation_mid" field in the mutation.
func (m *MemberDetailsMutation) RelationMid() (r int64, exists bool) {
	v := m.relation_mid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMid returns the old "relation_mid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationMid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMid: %w", err)
	}
	return oldValue.RelationMid, nil
}

// AddRelationMid adds i to the "relation_mid" field.
func (m *MemberDetailsMutation) AddRelationMid(i int64) {
	if m.addrelation_mid != nil {
		*m.addrelation_mid += i
	} else {
		m.addrelation_mid = &i
	}
}

// AddedRelationMid returns the value that was added to the "relation_mid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationMid() (r int64, exists bool) {
	v := m.addrelation_mid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationMid clears the value of the "relation_mid" field.
func (m *MemberDetailsMutation) ClearRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	m.clearedFields[memberdetails.FieldRelationMid] = struct{}{}
}

// RelationMidCleared returns if the "relation_mid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationMidCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationMid]
	return ok
}

// ResetRelationMid resets all changes to the "relation_mid" field.
func (m *MemberDetailsMutation) ResetRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	delete(m.clearedFields, memberdetails.FieldRelationMid)
}

// SetRelationMame sets the "relation_mame" field.
func (m *MemberDetailsMutation) SetRelationMame(s string) {
	m.relation_mame = &s
}

// RelationMame returns the value of the "relation_mame" field in the mutation.
func (m *MemberDetailsMutation) RelationMame() (r string, exists bool) {
	v := m.relation_mame
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMame returns the old "relation_mame" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationMame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMame: %w", err)
	}
	return oldValue.RelationMame, nil
}

// ClearRelationMame clears the value of the "relation_mame" field.
func (m *MemberDetailsMutation) ClearRelationMame() {
	m.relation_mame = nil
	m.clearedFields[memberdetails.FieldRelationMame] = struct{}{}
}

// RelationMameCleared returns if the "relation_mame" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationMameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationMame]
	return ok
}

// ResetRelationMame resets all changes to the "relation_mame" field.
func (m *MemberDetailsMutation) ResetRelationMame() {
	m.relation_mame = nil
	delete(m.clearedFields, memberdetails.FieldRelationMame)
}

// SetFirstTime sets the "first_time" field.
func (m *MemberDetailsMutation) SetFirstTime(t time.Time) {
	m.first_time = &t
}

// FirstTime returns the value of the "first_time" field in the mutation.
func (m *MemberDetailsMutation) FirstTime() (r time.Time, exists bool) {
	v := m.first_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstTime returns the old "first_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldFirstTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstTime: %w", err)
	}
	return oldValue.FirstTime, nil
}

// ClearFirstTime clears the value of the "first_time" field.
func (m *MemberDetailsMutation) ClearFirstTime() {
	m.first_time = nil
	m.clearedFields[memberdetails.FieldFirstTime] = struct{}{}
}

// FirstTimeCleared returns if the "first_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) FirstTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldFirstTime]
	return ok
}

// ResetFirstTime resets all changes to the "first_time" field.
func (m *MemberDetailsMutation) ResetFirstTime() {
	m.first_time = nil
	delete(m.clearedFields, memberdetails.FieldFirstTime)
}

// ClearMember clears the "member" edge to the Member entity.
func (m *MemberDetailsMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *MemberDetailsMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *MemberDetailsMutation) MemberIDs() (ids []int64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *MemberDetailsMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// Where appends a list predicates to the MemberDetailsMutation builder.
func (m *MemberDetailsMutation) Where(ps ...predicate.MemberDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberDetails).
func (m *MemberDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberDetailsMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, memberdetails.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberdetails.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberdetails.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberdetails.FieldCreatedID)
	}
	if m.member != nil {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.venue_id != nil {
		fields = append(fields, memberdetails.FieldVenueID)
	}
	if m.money_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.product_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, memberdetails.FieldProductName)
	}
	if m.entry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.entry_last_time != nil {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.entry_deadline_time != nil {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.class_last_time != nil {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.relation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.relation_uname != nil {
		fields = append(fields, memberdetails.FieldRelationUname)
	}
	if m.relation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.relation_mame != nil {
		fields = append(fields, memberdetails.FieldRelationMame)
	}
	if m.first_time != nil {
		fields = append(fields, memberdetails.FieldFirstTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.CreatedAt()
	case memberdetails.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberdetails.FieldDelete:
		return m.Delete()
	case memberdetails.FieldCreatedID:
		return m.CreatedID()
	case memberdetails.FieldMemberID:
		return m.MemberID()
	case memberdetails.FieldVenueID:
		return m.VenueID()
	case memberdetails.FieldMoneySum:
		return m.MoneySum()
	case memberdetails.FieldProductID:
		return m.ProductID()
	case memberdetails.FieldProductName:
		return m.ProductName()
	case memberdetails.FieldEntrySum:
		return m.EntrySum()
	case memberdetails.FieldEntryLastTime:
		return m.EntryLastTime()
	case memberdetails.FieldEntryDeadlineTime:
		return m.EntryDeadlineTime()
	case memberdetails.FieldClassLastTime:
		return m.ClassLastTime()
	case memberdetails.FieldRelationUID:
		return m.RelationUID()
	case memberdetails.FieldRelationUname:
		return m.RelationUname()
	case memberdetails.FieldRelationMid:
		return m.RelationMid()
	case memberdetails.FieldRelationMame:
		return m.RelationMame()
	case memberdetails.FieldFirstTime:
		return m.FirstTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberdetails.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberdetails.FieldDelete:
		return m.OldDelete(ctx)
	case memberdetails.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberdetails.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberdetails.FieldVenueID:
		return m.OldVenueID(ctx)
	case memberdetails.FieldMoneySum:
		return m.OldMoneySum(ctx)
	case memberdetails.FieldProductID:
		return m.OldProductID(ctx)
	case memberdetails.FieldProductName:
		return m.OldProductName(ctx)
	case memberdetails.FieldEntrySum:
		return m.OldEntrySum(ctx)
	case memberdetails.FieldEntryLastTime:
		return m.OldEntryLastTime(ctx)
	case memberdetails.FieldEntryDeadlineTime:
		return m.OldEntryDeadlineTime(ctx)
	case memberdetails.FieldClassLastTime:
		return m.OldClassLastTime(ctx)
	case memberdetails.FieldRelationUID:
		return m.OldRelationUID(ctx)
	case memberdetails.FieldRelationUname:
		return m.OldRelationUname(ctx)
	case memberdetails.FieldRelationMid:
		return m.OldRelationMid(ctx)
	case memberdetails.FieldRelationMame:
		return m.OldRelationMame(ctx)
	case memberdetails.FieldFirstTime:
		return m.OldFirstTime(ctx)
	}
	return nil, fmt.Errorf("unknown MemberDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberdetails.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberdetails.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberdetails.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberdetails.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberdetails.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case memberdetails.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntrySum(v)
		return nil
	case memberdetails.FieldEntryLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryLastTime(v)
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryDeadlineTime(v)
		return nil
	case memberdetails.FieldClassLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassLastTime(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationUID(v)
		return nil
	case memberdetails.FieldRelationUname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationUname(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMid(v)
		return nil
	case memberdetails.FieldRelationMame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMame(v)
		return nil
	case memberdetails.FieldFirstTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstTime(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberDetailsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberdetails.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberdetails.FieldCreatedID)
	}
	if m.addvenue_id != nil {
		fields = append(fields, memberdetails.FieldVenueID)
	}
	if m.addmoney_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.addproduct_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.addentry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.addrelation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.addrelation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldDelete:
		return m.AddedDelete()
	case memberdetails.FieldCreatedID:
		return m.AddedCreatedID()
	case memberdetails.FieldVenueID:
		return m.AddedVenueID()
	case memberdetails.FieldMoneySum:
		return m.AddedMoneySum()
	case memberdetails.FieldProductID:
		return m.AddedProductID()
	case memberdetails.FieldEntrySum:
		return m.AddedEntrySum()
	case memberdetails.FieldRelationUID:
		return m.AddedRelationUID()
	case memberdetails.FieldRelationMid:
		return m.AddedRelationMid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberdetails.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberdetails.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntrySum(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationUID(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationMid(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberdetails.FieldCreatedAt) {
		fields = append(fields, memberdetails.FieldCreatedAt)
	}
	if m.FieldCleared(memberdetails.FieldUpdatedAt) {
		fields = append(fields, memberdetails.FieldUpdatedAt)
	}
	if m.FieldCleared(memberdetails.FieldDelete) {
		fields = append(fields, memberdetails.FieldDelete)
	}
	if m.FieldCleared(memberdetails.FieldCreatedID) {
		fields = append(fields, memberdetails.FieldCreatedID)
	}
	if m.FieldCleared(memberdetails.FieldMemberID) {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.FieldCleared(memberdetails.FieldVenueID) {
		fields = append(fields, memberdetails.FieldVenueID)
	}
	if m.FieldCleared(memberdetails.FieldMoneySum) {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.FieldCleared(memberdetails.FieldProductID) {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.FieldCleared(memberdetails.FieldProductName) {
		fields = append(fields, memberdetails.FieldProductName)
	}
	if m.FieldCleared(memberdetails.FieldEntrySum) {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.FieldCleared(memberdetails.FieldEntryLastTime) {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.FieldCleared(memberdetails.FieldEntryDeadlineTime) {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.FieldCleared(memberdetails.FieldClassLastTime) {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.FieldCleared(memberdetails.FieldRelationUID) {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.FieldCleared(memberdetails.FieldRelationUname) {
		fields = append(fields, memberdetails.FieldRelationUname)
	}
	if m.FieldCleared(memberdetails.FieldRelationMid) {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.FieldCleared(memberdetails.FieldRelationMame) {
		fields = append(fields, memberdetails.FieldRelationMame)
	}
	if m.FieldCleared(memberdetails.FieldFirstTime) {
		fields = append(fields, memberdetails.FieldFirstTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ClearField(name string) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberdetails.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberdetails.FieldDelete:
		m.ClearDelete()
		return nil
	case memberdetails.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberdetails.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberdetails.FieldVenueID:
		m.ClearVenueID()
		return nil
	case memberdetails.FieldMoneySum:
		m.ClearMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ClearProductID()
		return nil
	case memberdetails.FieldProductName:
		m.ClearProductName()
		return nil
	case memberdetails.FieldEntrySum:
		m.ClearEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ClearEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ClearEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ClearClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ClearRelationUID()
		return nil
	case memberdetails.FieldRelationUname:
		m.ClearRelationUname()
		return nil
	case memberdetails.FieldRelationMid:
		m.ClearRelationMid()
		return nil
	case memberdetails.FieldRelationMame:
		m.ClearRelationMame()
		return nil
	case memberdetails.FieldFirstTime:
		m.ClearFirstTime()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ResetField(name string) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberdetails.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberdetails.FieldDelete:
		m.ResetDelete()
		return nil
	case memberdetails.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberdetails.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberdetails.FieldVenueID:
		m.ResetVenueID()
		return nil
	case memberdetails.FieldMoneySum:
		m.ResetMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ResetProductID()
		return nil
	case memberdetails.FieldProductName:
		m.ResetProductName()
		return nil
	case memberdetails.FieldEntrySum:
		m.ResetEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ResetEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ResetEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ResetClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ResetRelationUID()
		return nil
	case memberdetails.FieldRelationUname:
		m.ResetRelationUname()
		return nil
	case memberdetails.FieldRelationMid:
		m.ResetRelationMid()
		return nil
	case memberdetails.FieldRelationMame:
		m.ResetRelationMame()
		return nil
	case memberdetails.FieldFirstTime:
		m.ResetFirstTime()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.member != nil {
		edges = append(edges, memberdetails.EdgeMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberdetails.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmember {
		edges = append(edges, memberdetails.EdgeMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case memberdetails.EdgeMember:
		return m.clearedmember
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberDetailsMutation) ClearEdge(name string) error {
	switch name {
	case memberdetails.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberDetailsMutation) ResetEdge(name string) error {
	switch name {
	case memberdetails.EdgeMember:
		m.ResetMember()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails edge %s", name)
}

// MemberNoteMutation represents an operation that mutates the MemberNote nodes in the graph.
type MemberNoteMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	venue_id      *int64
	addvenue_id   *int64
	note          *string
	clearedFields map[string]struct{}
	notes         *int64
	clearednotes  bool
	done          bool
	oldValue      func(context.Context) (*MemberNote, error)
	predicates    []predicate.MemberNote
}

var _ ent.Mutation = (*MemberNoteMutation)(nil)

// membernoteOption allows management of the mutation configuration using functional options.
type membernoteOption func(*MemberNoteMutation)

// newMemberNoteMutation creates new mutation for the MemberNote entity.
func newMemberNoteMutation(c config, op Op, opts ...membernoteOption) *MemberNoteMutation {
	m := &MemberNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberNoteID sets the ID field of the mutation.
func withMemberNoteID(id int64) membernoteOption {
	return func(m *MemberNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberNote
		)
		m.oldValue = func(ctx context.Context) (*MemberNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberNote sets the old MemberNote of the mutation.
func withMemberNote(node *MemberNote) membernoteOption {
	return func(m *MemberNoteMutation) {
		m.oldValue = func(context.Context) (*MemberNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberNote entities.
func (m *MemberNoteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberNoteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberNoteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberNoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberNoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberNoteMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membernote.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberNoteMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membernote.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberNoteMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membernote.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberNoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberNoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberNoteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membernote.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberNoteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membernote.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberNoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membernote.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberNoteMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberNoteMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberNoteMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberNoteMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberNoteMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membernote.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberNoteMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberNoteMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membernote.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberNoteMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberNoteMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberNoteMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberNoteMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberNoteMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membernote.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberNoteMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberNoteMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membernote.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberNoteMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberNoteMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberNoteMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberNoteMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberNoteMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membernote.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberNoteMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membernote.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberNoteMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membernote.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberNoteMutation) SetMemberID(i int64) {
	m.notes = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberNoteMutation) MemberID() (r int64, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberNoteMutation) ClearMemberID() {
	m.notes = nil
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberNoteMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberNoteMutation) ResetMemberID() {
	m.notes = nil
	delete(m.clearedFields, membernote.FieldMemberID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberNoteMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberNoteMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberNoteMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberNoteMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberNoteMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[membernote.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberNoteMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberNoteMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, membernote.FieldVenueID)
}

// SetNote sets the "note" field.
func (m *MemberNoteMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MemberNoteMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *MemberNoteMutation) ClearNote() {
	m.note = nil
	m.clearedFields[membernote.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *MemberNoteMutation) NoteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *MemberNoteMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, membernote.FieldNote)
}

// SetNotesID sets the "notes" edge to the Member entity by id.
func (m *MemberNoteMutation) SetNotesID(id int64) {
	m.notes = &id
}

// ClearNotes clears the "notes" edge to the Member entity.
func (m *MemberNoteMutation) ClearNotes() {
	m.clearednotes = true
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// NotesCleared reports if the "notes" edge to the Member entity was cleared.
func (m *MemberNoteMutation) NotesCleared() bool {
	return m.MemberIDCleared() || m.clearednotes
}

// NotesID returns the "notes" edge ID in the mutation.
func (m *MemberNoteMutation) NotesID() (id int64, exists bool) {
	if m.notes != nil {
		return *m.notes, true
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotesID instead. It exists only for internal usage by the builders.
func (m *MemberNoteMutation) NotesIDs() (ids []int64) {
	if id := m.notes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *MemberNoteMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
}

// Where appends a list predicates to the MemberNoteMutation builder.
func (m *MemberNoteMutation) Where(ps ...predicate.MemberNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberNote).
func (m *MemberNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberNoteMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.venue_id != nil {
		fields = append(fields, membernote.FieldVenueID)
	}
	if m.note != nil {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.CreatedAt()
	case membernote.FieldUpdatedAt:
		return m.UpdatedAt()
	case membernote.FieldDelete:
		return m.Delete()
	case membernote.FieldCreatedID:
		return m.CreatedID()
	case membernote.FieldStatus:
		return m.Status()
	case membernote.FieldMemberID:
		return m.MemberID()
	case membernote.FieldVenueID:
		return m.VenueID()
	case membernote.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membernote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membernote.FieldDelete:
		return m.OldDelete(ctx)
	case membernote.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membernote.FieldStatus:
		return m.OldStatus(ctx)
	case membernote.FieldMemberID:
		return m.OldMemberID(ctx)
	case membernote.FieldVenueID:
		return m.OldVenueID(ctx)
	case membernote.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown MemberNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membernote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membernote.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membernote.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membernote.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membernote.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case membernote.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberNoteMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, membernote.FieldVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberNoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldDelete:
		return m.AddedDelete()
	case membernote.FieldCreatedID:
		return m.AddedCreatedID()
	case membernote.FieldStatus:
		return m.AddedStatus()
	case membernote.FieldVenueID:
		return m.AddedVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membernote.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case membernote.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberNoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membernote.FieldCreatedAt) {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.FieldCleared(membernote.FieldUpdatedAt) {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.FieldCleared(membernote.FieldDelete) {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.FieldCleared(membernote.FieldCreatedID) {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.FieldCleared(membernote.FieldStatus) {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.FieldCleared(membernote.FieldMemberID) {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.FieldCleared(membernote.FieldVenueID) {
		fields = append(fields, membernote.FieldVenueID)
	}
	if m.FieldCleared(membernote.FieldNote) {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberNoteMutation) ClearField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membernote.FieldDelete:
		m.ClearDelete()
		return nil
	case membernote.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membernote.FieldStatus:
		m.ClearStatus()
		return nil
	case membernote.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membernote.FieldVenueID:
		m.ClearVenueID()
		return nil
	case membernote.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberNoteMutation) ResetField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membernote.FieldDelete:
		m.ResetDelete()
		return nil
	case membernote.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membernote.FieldStatus:
		m.ResetStatus()
		return nil
	case membernote.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membernote.FieldVenueID:
		m.ResetVenueID()
		return nil
	case membernote.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.notes != nil {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membernote.EdgeNotes:
		if id := m.notes; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednotes {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case membernote.EdgeNotes:
		return m.clearednotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberNoteMutation) ClearEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberNoteMutation) ResetEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote edge %s", name)
}

// MemberProductMutation represents an operation that mutates the MemberProduct nodes in the graph.
type MemberProductMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	created_at                     *time.Time
	updated_at                     *time.Time
	delete                         *int64
	adddelete                      *int64
	created_id                     *int64
	addcreated_id                  *int64
	status                         *int64
	addstatus                      *int64
	sn                             *string
	_type                          *string
	sub_type                       *string
	product_id                     *int64
	addproduct_id                  *int64
	venue_id                       *int64
	addvenue_id                    *int64
	order_id                       *int64
	addorder_id                    *int64
	name                           *string
	price                          *float64
	addprice                       *float64
	fee                            *float64
	addfee                         *float64
	duration                       *int64
	addduration                    *int64
	length                         *int64
	addlength                      *int64
	count                          *int64
	addcount                       *int64
	count_surplus                  *int64
	addcount_surplus               *int64
	deadline                       *int64
	adddeadline                    *int64
	validity_at                    *time.Time
	cancel_at                      *time.Time
	clearedFields                  map[string]struct{}
	members                        *int64
	clearedmembers                 bool
	member_product_entry           map[int64]struct{}
	removedmember_product_entry    map[int64]struct{}
	clearedmember_product_entry    bool
	member_product_contents        map[int64]struct{}
	removedmember_product_contents map[int64]struct{}
	clearedmember_product_contents bool
	memberCourses                  map[int64]struct{}
	removedmemberCourses           map[int64]struct{}
	clearedmemberCourses           bool
	memberLessons                  map[int64]struct{}
	removedmemberLessons           map[int64]struct{}
	clearedmemberLessons           bool
	done                           bool
	oldValue                       func(context.Context) (*MemberProduct, error)
	predicates                     []predicate.MemberProduct
}

var _ ent.Mutation = (*MemberProductMutation)(nil)

// memberproductOption allows management of the mutation configuration using functional options.
type memberproductOption func(*MemberProductMutation)

// newMemberProductMutation creates new mutation for the MemberProduct entity.
func newMemberProductMutation(c config, op Op, opts ...memberproductOption) *MemberProductMutation {
	m := &MemberProductMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProductID sets the ID field of the mutation.
func withMemberProductID(id int64) memberproductOption {
	return func(m *MemberProductMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProduct
		)
		m.oldValue = func(ctx context.Context) (*MemberProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProduct sets the old MemberProduct of the mutation.
func withMemberProduct(node *MemberProduct) memberproductOption {
	return func(m *MemberProductMutation) {
		m.oldValue = func(context.Context) (*MemberProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProduct entities.
func (m *MemberProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberproduct.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProductMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberproduct.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberProductMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberproduct.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberProductMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberproduct.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberProductMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberProductMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberProductMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberProductMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberProductMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberproduct.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberProductMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberProductMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberproduct.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberProductMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberProductMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberProductMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberProductMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberProductMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberproduct.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberProductMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberProductMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberproduct.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberProductMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberProductMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberProductMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberProductMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberProductMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[memberproduct.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberProductMutation) StatusCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, memberproduct.FieldStatus)
}

// SetSn sets the "sn" field.
func (m *MemberProductMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *MemberProductMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *MemberProductMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[memberproduct.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *MemberProductMutation) SnCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *MemberProductMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, memberproduct.FieldSn)
}

// SetType sets the "type" field.
func (m *MemberProductMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MemberProductMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MemberProductMutation) ClearType() {
	m._type = nil
	m.clearedFields[memberproduct.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MemberProductMutation) TypeCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MemberProductMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, memberproduct.FieldType)
}

// SetSubType sets the "sub_type" field.
func (m *MemberProductMutation) SetSubType(s string) {
	m.sub_type = &s
}

// SubType returns the value of the "sub_type" field in the mutation.
func (m *MemberProductMutation) SubType() (r string, exists bool) {
	v := m.sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubType returns the old "sub_type" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubType: %w", err)
	}
	return oldValue.SubType, nil
}

// ClearSubType clears the value of the "sub_type" field.
func (m *MemberProductMutation) ClearSubType() {
	m.sub_type = nil
	m.clearedFields[memberproduct.FieldSubType] = struct{}{}
}

// SubTypeCleared returns if the "sub_type" field was cleared in this mutation.
func (m *MemberProductMutation) SubTypeCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldSubType]
	return ok
}

// ResetSubType resets all changes to the "sub_type" field.
func (m *MemberProductMutation) ResetSubType() {
	m.sub_type = nil
	delete(m.clearedFields, memberproduct.FieldSubType)
}

// SetMemberID sets the "member_id" field.
func (m *MemberProductMutation) SetMemberID(i int64) {
	m.members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberProductMutation) MemberID() (r int64, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberProductMutation) ClearMemberID() {
	m.members = nil
	m.clearedFields[memberproduct.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberProductMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberProductMutation) ResetMemberID() {
	m.members = nil
	delete(m.clearedFields, memberproduct.FieldMemberID)
}

// SetProductID sets the "product_id" field.
func (m *MemberProductMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MemberProductMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *MemberProductMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *MemberProductMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *MemberProductMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[memberproduct.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *MemberProductMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MemberProductMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, memberproduct.FieldProductID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberProductMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberProductMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberProductMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberProductMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberProductMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[memberproduct.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberProductMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberProductMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, memberproduct.FieldVenueID)
}

// SetOrderID sets the "order_id" field.
func (m *MemberProductMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MemberProductMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *MemberProductMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *MemberProductMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MemberProductMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[memberproduct.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MemberProductMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MemberProductMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, memberproduct.FieldOrderID)
}

// SetName sets the "name" field.
func (m *MemberProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[memberproduct.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, memberproduct.FieldName)
}

// SetPrice sets the "price" field.
func (m *MemberProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MemberProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MemberProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MemberProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *MemberProductMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[memberproduct.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *MemberProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *MemberProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, memberproduct.FieldPrice)
}

// SetFee sets the "fee" field.
func (m *MemberProductMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *MemberProductMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *MemberProductMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *MemberProductMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *MemberProductMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[memberproduct.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *MemberProductMutation) FeeCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *MemberProductMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, memberproduct.FieldFee)
}

// SetDuration sets the "duration" field.
func (m *MemberProductMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *MemberProductMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *MemberProductMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *MemberProductMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *MemberProductMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[memberproduct.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *MemberProductMutation) DurationCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *MemberProductMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, memberproduct.FieldDuration)
}

// SetLength sets the "length" field.
func (m *MemberProductMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *MemberProductMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *MemberProductMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *MemberProductMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *MemberProductMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[memberproduct.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *MemberProductMutation) LengthCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *MemberProductMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, memberproduct.FieldLength)
}

// SetCount sets the "count" field.
func (m *MemberProductMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *MemberProductMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *MemberProductMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *MemberProductMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *MemberProductMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[memberproduct.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *MemberProductMutation) CountCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *MemberProductMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, memberproduct.FieldCount)
}

// SetCountSurplus sets the "count_surplus" field.
func (m *MemberProductMutation) SetCountSurplus(i int64) {
	m.count_surplus = &i
	m.addcount_surplus = nil
}

// CountSurplus returns the value of the "count_surplus" field in the mutation.
func (m *MemberProductMutation) CountSurplus() (r int64, exists bool) {
	v := m.count_surplus
	if v == nil {
		return
	}
	return *v, true
}

// OldCountSurplus returns the old "count_surplus" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCountSurplus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountSurplus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountSurplus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountSurplus: %w", err)
	}
	return oldValue.CountSurplus, nil
}

// AddCountSurplus adds i to the "count_surplus" field.
func (m *MemberProductMutation) AddCountSurplus(i int64) {
	if m.addcount_surplus != nil {
		*m.addcount_surplus += i
	} else {
		m.addcount_surplus = &i
	}
}

// AddedCountSurplus returns the value that was added to the "count_surplus" field in this mutation.
func (m *MemberProductMutation) AddedCountSurplus() (r int64, exists bool) {
	v := m.addcount_surplus
	if v == nil {
		return
	}
	return *v, true
}

// ClearCountSurplus clears the value of the "count_surplus" field.
func (m *MemberProductMutation) ClearCountSurplus() {
	m.count_surplus = nil
	m.addcount_surplus = nil
	m.clearedFields[memberproduct.FieldCountSurplus] = struct{}{}
}

// CountSurplusCleared returns if the "count_surplus" field was cleared in this mutation.
func (m *MemberProductMutation) CountSurplusCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCountSurplus]
	return ok
}

// ResetCountSurplus resets all changes to the "count_surplus" field.
func (m *MemberProductMutation) ResetCountSurplus() {
	m.count_surplus = nil
	m.addcount_surplus = nil
	delete(m.clearedFields, memberproduct.FieldCountSurplus)
}

// SetDeadline sets the "deadline" field.
func (m *MemberProductMutation) SetDeadline(i int64) {
	m.deadline = &i
	m.adddeadline = nil
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *MemberProductMutation) Deadline() (r int64, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldDeadline(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// AddDeadline adds i to the "deadline" field.
func (m *MemberProductMutation) AddDeadline(i int64) {
	if m.adddeadline != nil {
		*m.adddeadline += i
	} else {
		m.adddeadline = &i
	}
}

// AddedDeadline returns the value that was added to the "deadline" field in this mutation.
func (m *MemberProductMutation) AddedDeadline() (r int64, exists bool) {
	v := m.adddeadline
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeadline clears the value of the "deadline" field.
func (m *MemberProductMutation) ClearDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	m.clearedFields[memberproduct.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *MemberProductMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *MemberProductMutation) ResetDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	delete(m.clearedFields, memberproduct.FieldDeadline)
}

// SetValidityAt sets the "validity_at" field.
func (m *MemberProductMutation) SetValidityAt(t time.Time) {
	m.validity_at = &t
}

// ValidityAt returns the value of the "validity_at" field in the mutation.
func (m *MemberProductMutation) ValidityAt() (r time.Time, exists bool) {
	v := m.validity_at
	if v == nil {
		return
	}
	return *v, true
}

// OldValidityAt returns the old "validity_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldValidityAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidityAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidityAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidityAt: %w", err)
	}
	return oldValue.ValidityAt, nil
}

// ClearValidityAt clears the value of the "validity_at" field.
func (m *MemberProductMutation) ClearValidityAt() {
	m.validity_at = nil
	m.clearedFields[memberproduct.FieldValidityAt] = struct{}{}
}

// ValidityAtCleared returns if the "validity_at" field was cleared in this mutation.
func (m *MemberProductMutation) ValidityAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldValidityAt]
	return ok
}

// ResetValidityAt resets all changes to the "validity_at" field.
func (m *MemberProductMutation) ResetValidityAt() {
	m.validity_at = nil
	delete(m.clearedFields, memberproduct.FieldValidityAt)
}

// SetCancelAt sets the "cancel_at" field.
func (m *MemberProductMutation) SetCancelAt(t time.Time) {
	m.cancel_at = &t
}

// CancelAt returns the value of the "cancel_at" field in the mutation.
func (m *MemberProductMutation) CancelAt() (r time.Time, exists bool) {
	v := m.cancel_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelAt returns the old "cancel_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCancelAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelAt: %w", err)
	}
	return oldValue.CancelAt, nil
}

// ClearCancelAt clears the value of the "cancel_at" field.
func (m *MemberProductMutation) ClearCancelAt() {
	m.cancel_at = nil
	m.clearedFields[memberproduct.FieldCancelAt] = struct{}{}
}

// CancelAtCleared returns if the "cancel_at" field was cleared in this mutation.
func (m *MemberProductMutation) CancelAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCancelAt]
	return ok
}

// ResetCancelAt resets all changes to the "cancel_at" field.
func (m *MemberProductMutation) ResetCancelAt() {
	m.cancel_at = nil
	delete(m.clearedFields, memberproduct.FieldCancelAt)
}

// SetMembersID sets the "members" edge to the Member entity by id.
func (m *MemberProductMutation) SetMembersID(id int64) {
	m.members = &id
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *MemberProductMutation) ClearMembers() {
	m.clearedmembers = true
	m.clearedFields[memberproduct.FieldMemberID] = struct{}{}
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *MemberProductMutation) MembersCleared() bool {
	return m.MemberIDCleared() || m.clearedmembers
}

// MembersID returns the "members" edge ID in the mutation.
func (m *MemberProductMutation) MembersID() (id int64, exists bool) {
	if m.members != nil {
		return *m.members, true
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MembersID instead. It exists only for internal usage by the builders.
func (m *MemberProductMutation) MembersIDs() (ids []int64) {
	if id := m.members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *MemberProductMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
}

// AddMemberProductEntryIDs adds the "member_product_entry" edge to the EntryLogs entity by ids.
func (m *MemberProductMutation) AddMemberProductEntryIDs(ids ...int64) {
	if m.member_product_entry == nil {
		m.member_product_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_product_entry[ids[i]] = struct{}{}
	}
}

// ClearMemberProductEntry clears the "member_product_entry" edge to the EntryLogs entity.
func (m *MemberProductMutation) ClearMemberProductEntry() {
	m.clearedmember_product_entry = true
}

// MemberProductEntryCleared reports if the "member_product_entry" edge to the EntryLogs entity was cleared.
func (m *MemberProductMutation) MemberProductEntryCleared() bool {
	return m.clearedmember_product_entry
}

// RemoveMemberProductEntryIDs removes the "member_product_entry" edge to the EntryLogs entity by IDs.
func (m *MemberProductMutation) RemoveMemberProductEntryIDs(ids ...int64) {
	if m.removedmember_product_entry == nil {
		m.removedmember_product_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_product_entry, ids[i])
		m.removedmember_product_entry[ids[i]] = struct{}{}
	}
}

// RemovedMemberProductEntry returns the removed IDs of the "member_product_entry" edge to the EntryLogs entity.
func (m *MemberProductMutation) RemovedMemberProductEntryIDs() (ids []int64) {
	for id := range m.removedmember_product_entry {
		ids = append(ids, id)
	}
	return
}

// MemberProductEntryIDs returns the "member_product_entry" edge IDs in the mutation.
func (m *MemberProductMutation) MemberProductEntryIDs() (ids []int64) {
	for id := range m.member_product_entry {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProductEntry resets all changes to the "member_product_entry" edge.
func (m *MemberProductMutation) ResetMemberProductEntry() {
	m.member_product_entry = nil
	m.clearedmember_product_entry = false
	m.removedmember_product_entry = nil
}

// AddMemberProductContentIDs adds the "member_product_contents" edge to the MemberContract entity by ids.
func (m *MemberProductMutation) AddMemberProductContentIDs(ids ...int64) {
	if m.member_product_contents == nil {
		m.member_product_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_product_contents[ids[i]] = struct{}{}
	}
}

// ClearMemberProductContents clears the "member_product_contents" edge to the MemberContract entity.
func (m *MemberProductMutation) ClearMemberProductContents() {
	m.clearedmember_product_contents = true
}

// MemberProductContentsCleared reports if the "member_product_contents" edge to the MemberContract entity was cleared.
func (m *MemberProductMutation) MemberProductContentsCleared() bool {
	return m.clearedmember_product_contents
}

// RemoveMemberProductContentIDs removes the "member_product_contents" edge to the MemberContract entity by IDs.
func (m *MemberProductMutation) RemoveMemberProductContentIDs(ids ...int64) {
	if m.removedmember_product_contents == nil {
		m.removedmember_product_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_product_contents, ids[i])
		m.removedmember_product_contents[ids[i]] = struct{}{}
	}
}

// RemovedMemberProductContents returns the removed IDs of the "member_product_contents" edge to the MemberContract entity.
func (m *MemberProductMutation) RemovedMemberProductContentsIDs() (ids []int64) {
	for id := range m.removedmember_product_contents {
		ids = append(ids, id)
	}
	return
}

// MemberProductContentsIDs returns the "member_product_contents" edge IDs in the mutation.
func (m *MemberProductMutation) MemberProductContentsIDs() (ids []int64) {
	for id := range m.member_product_contents {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProductContents resets all changes to the "member_product_contents" edge.
func (m *MemberProductMutation) ResetMemberProductContents() {
	m.member_product_contents = nil
	m.clearedmember_product_contents = false
	m.removedmember_product_contents = nil
}

// AddMemberCourseIDs adds the "memberCourses" edge to the MemberProductCourses entity by ids.
func (m *MemberProductMutation) AddMemberCourseIDs(ids ...int64) {
	if m.memberCourses == nil {
		m.memberCourses = make(map[int64]struct{})
	}
	for i := range ids {
		m.memberCourses[ids[i]] = struct{}{}
	}
}

// ClearMemberCourses clears the "memberCourses" edge to the MemberProductCourses entity.
func (m *MemberProductMutation) ClearMemberCourses() {
	m.clearedmemberCourses = true
}

// MemberCoursesCleared reports if the "memberCourses" edge to the MemberProductCourses entity was cleared.
func (m *MemberProductMutation) MemberCoursesCleared() bool {
	return m.clearedmemberCourses
}

// RemoveMemberCourseIDs removes the "memberCourses" edge to the MemberProductCourses entity by IDs.
func (m *MemberProductMutation) RemoveMemberCourseIDs(ids ...int64) {
	if m.removedmemberCourses == nil {
		m.removedmemberCourses = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.memberCourses, ids[i])
		m.removedmemberCourses[ids[i]] = struct{}{}
	}
}

// RemovedMemberCourses returns the removed IDs of the "memberCourses" edge to the MemberProductCourses entity.
func (m *MemberProductMutation) RemovedMemberCoursesIDs() (ids []int64) {
	for id := range m.removedmemberCourses {
		ids = append(ids, id)
	}
	return
}

// MemberCoursesIDs returns the "memberCourses" edge IDs in the mutation.
func (m *MemberProductMutation) MemberCoursesIDs() (ids []int64) {
	for id := range m.memberCourses {
		ids = append(ids, id)
	}
	return
}

// ResetMemberCourses resets all changes to the "memberCourses" edge.
func (m *MemberProductMutation) ResetMemberCourses() {
	m.memberCourses = nil
	m.clearedmemberCourses = false
	m.removedmemberCourses = nil
}

// AddMemberLessonIDs adds the "memberLessons" edge to the MemberProductCourses entity by ids.
func (m *MemberProductMutation) AddMemberLessonIDs(ids ...int64) {
	if m.memberLessons == nil {
		m.memberLessons = make(map[int64]struct{})
	}
	for i := range ids {
		m.memberLessons[ids[i]] = struct{}{}
	}
}

// ClearMemberLessons clears the "memberLessons" edge to the MemberProductCourses entity.
func (m *MemberProductMutation) ClearMemberLessons() {
	m.clearedmemberLessons = true
}

// MemberLessonsCleared reports if the "memberLessons" edge to the MemberProductCourses entity was cleared.
func (m *MemberProductMutation) MemberLessonsCleared() bool {
	return m.clearedmemberLessons
}

// RemoveMemberLessonIDs removes the "memberLessons" edge to the MemberProductCourses entity by IDs.
func (m *MemberProductMutation) RemoveMemberLessonIDs(ids ...int64) {
	if m.removedmemberLessons == nil {
		m.removedmemberLessons = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.memberLessons, ids[i])
		m.removedmemberLessons[ids[i]] = struct{}{}
	}
}

// RemovedMemberLessons returns the removed IDs of the "memberLessons" edge to the MemberProductCourses entity.
func (m *MemberProductMutation) RemovedMemberLessonsIDs() (ids []int64) {
	for id := range m.removedmemberLessons {
		ids = append(ids, id)
	}
	return
}

// MemberLessonsIDs returns the "memberLessons" edge IDs in the mutation.
func (m *MemberProductMutation) MemberLessonsIDs() (ids []int64) {
	for id := range m.memberLessons {
		ids = append(ids, id)
	}
	return
}

// ResetMemberLessons resets all changes to the "memberLessons" edge.
func (m *MemberProductMutation) ResetMemberLessons() {
	m.memberLessons = nil
	m.clearedmemberLessons = false
	m.removedmemberLessons = nil
}

// Where appends a list predicates to the MemberProductMutation builder.
func (m *MemberProductMutation) Where(ps ...predicate.MemberProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProduct).
func (m *MemberProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProductMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, memberproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberproduct.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberproduct.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberproduct.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.sn != nil {
		fields = append(fields, memberproduct.FieldSn)
	}
	if m._type != nil {
		fields = append(fields, memberproduct.FieldType)
	}
	if m.sub_type != nil {
		fields = append(fields, memberproduct.FieldSubType)
	}
	if m.members != nil {
		fields = append(fields, memberproduct.FieldMemberID)
	}
	if m.product_id != nil {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.venue_id != nil {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.order_id != nil {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.name != nil {
		fields = append(fields, memberproduct.FieldName)
	}
	if m.price != nil {
		fields = append(fields, memberproduct.FieldPrice)
	}
	if m.fee != nil {
		fields = append(fields, memberproduct.FieldFee)
	}
	if m.duration != nil {
		fields = append(fields, memberproduct.FieldDuration)
	}
	if m.length != nil {
		fields = append(fields, memberproduct.FieldLength)
	}
	if m.count != nil {
		fields = append(fields, memberproduct.FieldCount)
	}
	if m.count_surplus != nil {
		fields = append(fields, memberproduct.FieldCountSurplus)
	}
	if m.deadline != nil {
		fields = append(fields, memberproduct.FieldDeadline)
	}
	if m.validity_at != nil {
		fields = append(fields, memberproduct.FieldValidityAt)
	}
	if m.cancel_at != nil {
		fields = append(fields, memberproduct.FieldCancelAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberproduct.FieldCreatedAt:
		return m.CreatedAt()
	case memberproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberproduct.FieldDelete:
		return m.Delete()
	case memberproduct.FieldCreatedID:
		return m.CreatedID()
	case memberproduct.FieldStatus:
		return m.Status()
	case memberproduct.FieldSn:
		return m.Sn()
	case memberproduct.FieldType:
		return m.GetType()
	case memberproduct.FieldSubType:
		return m.SubType()
	case memberproduct.FieldMemberID:
		return m.MemberID()
	case memberproduct.FieldProductID:
		return m.ProductID()
	case memberproduct.FieldVenueID:
		return m.VenueID()
	case memberproduct.FieldOrderID:
		return m.OrderID()
	case memberproduct.FieldName:
		return m.Name()
	case memberproduct.FieldPrice:
		return m.Price()
	case memberproduct.FieldFee:
		return m.Fee()
	case memberproduct.FieldDuration:
		return m.Duration()
	case memberproduct.FieldLength:
		return m.Length()
	case memberproduct.FieldCount:
		return m.Count()
	case memberproduct.FieldCountSurplus:
		return m.CountSurplus()
	case memberproduct.FieldDeadline:
		return m.Deadline()
	case memberproduct.FieldValidityAt:
		return m.ValidityAt()
	case memberproduct.FieldCancelAt:
		return m.CancelAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberproduct.FieldDelete:
		return m.OldDelete(ctx)
	case memberproduct.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberproduct.FieldStatus:
		return m.OldStatus(ctx)
	case memberproduct.FieldSn:
		return m.OldSn(ctx)
	case memberproduct.FieldType:
		return m.OldType(ctx)
	case memberproduct.FieldSubType:
		return m.OldSubType(ctx)
	case memberproduct.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberproduct.FieldProductID:
		return m.OldProductID(ctx)
	case memberproduct.FieldVenueID:
		return m.OldVenueID(ctx)
	case memberproduct.FieldOrderID:
		return m.OldOrderID(ctx)
	case memberproduct.FieldName:
		return m.OldName(ctx)
	case memberproduct.FieldPrice:
		return m.OldPrice(ctx)
	case memberproduct.FieldFee:
		return m.OldFee(ctx)
	case memberproduct.FieldDuration:
		return m.OldDuration(ctx)
	case memberproduct.FieldLength:
		return m.OldLength(ctx)
	case memberproduct.FieldCount:
		return m.OldCount(ctx)
	case memberproduct.FieldCountSurplus:
		return m.OldCountSurplus(ctx)
	case memberproduct.FieldDeadline:
		return m.OldDeadline(ctx)
	case memberproduct.FieldValidityAt:
		return m.OldValidityAt(ctx)
	case memberproduct.FieldCancelAt:
		return m.OldCancelAt(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberproduct.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberproduct.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberproduct.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case memberproduct.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case memberproduct.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case memberproduct.FieldSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubType(v)
		return nil
	case memberproduct.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberproduct.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case memberproduct.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case memberproduct.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case memberproduct.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case memberproduct.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case memberproduct.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case memberproduct.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case memberproduct.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case memberproduct.FieldCountSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountSurplus(v)
		return nil
	case memberproduct.FieldDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case memberproduct.FieldValidityAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidityAt(v)
		return nil
	case memberproduct.FieldCancelAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelAt(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProductMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberproduct.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberproduct.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.addproduct_id != nil {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.addvenue_id != nil {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.addorder_id != nil {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.addprice != nil {
		fields = append(fields, memberproduct.FieldPrice)
	}
	if m.addfee != nil {
		fields = append(fields, memberproduct.FieldFee)
	}
	if m.addduration != nil {
		fields = append(fields, memberproduct.FieldDuration)
	}
	if m.addlength != nil {
		fields = append(fields, memberproduct.FieldLength)
	}
	if m.addcount != nil {
		fields = append(fields, memberproduct.FieldCount)
	}
	if m.addcount_surplus != nil {
		fields = append(fields, memberproduct.FieldCountSurplus)
	}
	if m.adddeadline != nil {
		fields = append(fields, memberproduct.FieldDeadline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberproduct.FieldDelete:
		return m.AddedDelete()
	case memberproduct.FieldCreatedID:
		return m.AddedCreatedID()
	case memberproduct.FieldStatus:
		return m.AddedStatus()
	case memberproduct.FieldProductID:
		return m.AddedProductID()
	case memberproduct.FieldVenueID:
		return m.AddedVenueID()
	case memberproduct.FieldOrderID:
		return m.AddedOrderID()
	case memberproduct.FieldPrice:
		return m.AddedPrice()
	case memberproduct.FieldFee:
		return m.AddedFee()
	case memberproduct.FieldDuration:
		return m.AddedDuration()
	case memberproduct.FieldLength:
		return m.AddedLength()
	case memberproduct.FieldCount:
		return m.AddedCount()
	case memberproduct.FieldCountSurplus:
		return m.AddedCountSurplus()
	case memberproduct.FieldDeadline:
		return m.AddedDeadline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberproduct.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberproduct.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberproduct.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case memberproduct.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case memberproduct.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case memberproduct.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case memberproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case memberproduct.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case memberproduct.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case memberproduct.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case memberproduct.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case memberproduct.FieldCountSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCountSurplus(v)
		return nil
	case memberproduct.FieldDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadline(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberproduct.FieldCreatedAt) {
		fields = append(fields, memberproduct.FieldCreatedAt)
	}
	if m.FieldCleared(memberproduct.FieldUpdatedAt) {
		fields = append(fields, memberproduct.FieldUpdatedAt)
	}
	if m.FieldCleared(memberproduct.FieldDelete) {
		fields = append(fields, memberproduct.FieldDelete)
	}
	if m.FieldCleared(memberproduct.FieldCreatedID) {
		fields = append(fields, memberproduct.FieldCreatedID)
	}
	if m.FieldCleared(memberproduct.FieldStatus) {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.FieldCleared(memberproduct.FieldSn) {
		fields = append(fields, memberproduct.FieldSn)
	}
	if m.FieldCleared(memberproduct.FieldType) {
		fields = append(fields, memberproduct.FieldType)
	}
	if m.FieldCleared(memberproduct.FieldSubType) {
		fields = append(fields, memberproduct.FieldSubType)
	}
	if m.FieldCleared(memberproduct.FieldMemberID) {
		fields = append(fields, memberproduct.FieldMemberID)
	}
	if m.FieldCleared(memberproduct.FieldProductID) {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.FieldCleared(memberproduct.FieldVenueID) {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.FieldCleared(memberproduct.FieldOrderID) {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.FieldCleared(memberproduct.FieldName) {
		fields = append(fields, memberproduct.FieldName)
	}
	if m.FieldCleared(memberproduct.FieldPrice) {
		fields = append(fields, memberproduct.FieldPrice)
	}
	if m.FieldCleared(memberproduct.FieldFee) {
		fields = append(fields, memberproduct.FieldFee)
	}
	if m.FieldCleared(memberproduct.FieldDuration) {
		fields = append(fields, memberproduct.FieldDuration)
	}
	if m.FieldCleared(memberproduct.FieldLength) {
		fields = append(fields, memberproduct.FieldLength)
	}
	if m.FieldCleared(memberproduct.FieldCount) {
		fields = append(fields, memberproduct.FieldCount)
	}
	if m.FieldCleared(memberproduct.FieldCountSurplus) {
		fields = append(fields, memberproduct.FieldCountSurplus)
	}
	if m.FieldCleared(memberproduct.FieldDeadline) {
		fields = append(fields, memberproduct.FieldDeadline)
	}
	if m.FieldCleared(memberproduct.FieldValidityAt) {
		fields = append(fields, memberproduct.FieldValidityAt)
	}
	if m.FieldCleared(memberproduct.FieldCancelAt) {
		fields = append(fields, memberproduct.FieldCancelAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProductMutation) ClearField(name string) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberproduct.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberproduct.FieldDelete:
		m.ClearDelete()
		return nil
	case memberproduct.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberproduct.FieldStatus:
		m.ClearStatus()
		return nil
	case memberproduct.FieldSn:
		m.ClearSn()
		return nil
	case memberproduct.FieldType:
		m.ClearType()
		return nil
	case memberproduct.FieldSubType:
		m.ClearSubType()
		return nil
	case memberproduct.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberproduct.FieldProductID:
		m.ClearProductID()
		return nil
	case memberproduct.FieldVenueID:
		m.ClearVenueID()
		return nil
	case memberproduct.FieldOrderID:
		m.ClearOrderID()
		return nil
	case memberproduct.FieldName:
		m.ClearName()
		return nil
	case memberproduct.FieldPrice:
		m.ClearPrice()
		return nil
	case memberproduct.FieldFee:
		m.ClearFee()
		return nil
	case memberproduct.FieldDuration:
		m.ClearDuration()
		return nil
	case memberproduct.FieldLength:
		m.ClearLength()
		return nil
	case memberproduct.FieldCount:
		m.ClearCount()
		return nil
	case memberproduct.FieldCountSurplus:
		m.ClearCountSurplus()
		return nil
	case memberproduct.FieldDeadline:
		m.ClearDeadline()
		return nil
	case memberproduct.FieldValidityAt:
		m.ClearValidityAt()
		return nil
	case memberproduct.FieldCancelAt:
		m.ClearCancelAt()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProductMutation) ResetField(name string) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberproduct.FieldDelete:
		m.ResetDelete()
		return nil
	case memberproduct.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberproduct.FieldStatus:
		m.ResetStatus()
		return nil
	case memberproduct.FieldSn:
		m.ResetSn()
		return nil
	case memberproduct.FieldType:
		m.ResetType()
		return nil
	case memberproduct.FieldSubType:
		m.ResetSubType()
		return nil
	case memberproduct.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberproduct.FieldProductID:
		m.ResetProductID()
		return nil
	case memberproduct.FieldVenueID:
		m.ResetVenueID()
		return nil
	case memberproduct.FieldOrderID:
		m.ResetOrderID()
		return nil
	case memberproduct.FieldName:
		m.ResetName()
		return nil
	case memberproduct.FieldPrice:
		m.ResetPrice()
		return nil
	case memberproduct.FieldFee:
		m.ResetFee()
		return nil
	case memberproduct.FieldDuration:
		m.ResetDuration()
		return nil
	case memberproduct.FieldLength:
		m.ResetLength()
		return nil
	case memberproduct.FieldCount:
		m.ResetCount()
		return nil
	case memberproduct.FieldCountSurplus:
		m.ResetCountSurplus()
		return nil
	case memberproduct.FieldDeadline:
		m.ResetDeadline()
		return nil
	case memberproduct.FieldValidityAt:
		m.ResetValidityAt()
		return nil
	case memberproduct.FieldCancelAt:
		m.ResetCancelAt()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.members != nil {
		edges = append(edges, memberproduct.EdgeMembers)
	}
	if m.member_product_entry != nil {
		edges = append(edges, memberproduct.EdgeMemberProductEntry)
	}
	if m.member_product_contents != nil {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	if m.memberCourses != nil {
		edges = append(edges, memberproduct.EdgeMemberCourses)
	}
	if m.memberLessons != nil {
		edges = append(edges, memberproduct.EdgeMemberLessons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberproduct.EdgeMembers:
		if id := m.members; id != nil {
			return []ent.Value{*id}
		}
	case memberproduct.EdgeMemberProductEntry:
		ids := make([]ent.Value, 0, len(m.member_product_entry))
		for id := range m.member_product_entry {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductContents:
		ids := make([]ent.Value, 0, len(m.member_product_contents))
		for id := range m.member_product_contents {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberCourses:
		ids := make([]ent.Value, 0, len(m.memberCourses))
		for id := range m.memberCourses {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberLessons:
		ids := make([]ent.Value, 0, len(m.memberLessons))
		for id := range m.memberLessons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmember_product_entry != nil {
		edges = append(edges, memberproduct.EdgeMemberProductEntry)
	}
	if m.removedmember_product_contents != nil {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	if m.removedmemberCourses != nil {
		edges = append(edges, memberproduct.EdgeMemberCourses)
	}
	if m.removedmemberLessons != nil {
		edges = append(edges, memberproduct.EdgeMemberLessons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case memberproduct.EdgeMemberProductEntry:
		ids := make([]ent.Value, 0, len(m.removedmember_product_entry))
		for id := range m.removedmember_product_entry {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductContents:
		ids := make([]ent.Value, 0, len(m.removedmember_product_contents))
		for id := range m.removedmember_product_contents {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberCourses:
		ids := make([]ent.Value, 0, len(m.removedmemberCourses))
		for id := range m.removedmemberCourses {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberLessons:
		ids := make([]ent.Value, 0, len(m.removedmemberLessons))
		for id := range m.removedmemberLessons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmembers {
		edges = append(edges, memberproduct.EdgeMembers)
	}
	if m.clearedmember_product_entry {
		edges = append(edges, memberproduct.EdgeMemberProductEntry)
	}
	if m.clearedmember_product_contents {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	if m.clearedmemberCourses {
		edges = append(edges, memberproduct.EdgeMemberCourses)
	}
	if m.clearedmemberLessons {
		edges = append(edges, memberproduct.EdgeMemberLessons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProductMutation) EdgeCleared(name string) bool {
	switch name {
	case memberproduct.EdgeMembers:
		return m.clearedmembers
	case memberproduct.EdgeMemberProductEntry:
		return m.clearedmember_product_entry
	case memberproduct.EdgeMemberProductContents:
		return m.clearedmember_product_contents
	case memberproduct.EdgeMemberCourses:
		return m.clearedmemberCourses
	case memberproduct.EdgeMemberLessons:
		return m.clearedmemberLessons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProductMutation) ClearEdge(name string) error {
	switch name {
	case memberproduct.EdgeMembers:
		m.ClearMembers()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProductMutation) ResetEdge(name string) error {
	switch name {
	case memberproduct.EdgeMembers:
		m.ResetMembers()
		return nil
	case memberproduct.EdgeMemberProductEntry:
		m.ResetMemberProductEntry()
		return nil
	case memberproduct.EdgeMemberProductContents:
		m.ResetMemberProductContents()
		return nil
	case memberproduct.EdgeMemberCourses:
		m.ResetMemberCourses()
		return nil
	case memberproduct.EdgeMemberLessons:
		m.ResetMemberLessons()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct edge %s", name)
}

// MemberProductCoursesMutation represents an operation that mutates the MemberProductCourses nodes in the graph.
type MemberProductCoursesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	_type         *string
	name          *string
	number        *int64
	addnumber     *int64
	courses_id    *int64
	addcourses_id *int64
	clearedFields map[string]struct{}
	nodeC         *int64
	clearednodeC  bool
	nodeL         *int64
	clearednodeL  bool
	done          bool
	oldValue      func(context.Context) (*MemberProductCourses, error)
	predicates    []predicate.MemberProductCourses
}

var _ ent.Mutation = (*MemberProductCoursesMutation)(nil)

// memberproductcoursesOption allows management of the mutation configuration using functional options.
type memberproductcoursesOption func(*MemberProductCoursesMutation)

// newMemberProductCoursesMutation creates new mutation for the MemberProductCourses entity.
func newMemberProductCoursesMutation(c config, op Op, opts ...memberproductcoursesOption) *MemberProductCoursesMutation {
	m := &MemberProductCoursesMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProductCourses,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProductCoursesID sets the ID field of the mutation.
func withMemberProductCoursesID(id int64) memberproductcoursesOption {
	return func(m *MemberProductCoursesMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProductCourses
		)
		m.oldValue = func(ctx context.Context) (*MemberProductCourses, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProductCourses.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProductCourses sets the old MemberProductCourses of the mutation.
func withMemberProductCourses(node *MemberProductCourses) memberproductcoursesOption {
	return func(m *MemberProductCoursesMutation) {
		m.oldValue = func(context.Context) (*MemberProductCourses, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProductCoursesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProductCoursesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProductCourses entities.
func (m *MemberProductCoursesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProductCoursesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProductCoursesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProductCourses.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProductCoursesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProductCoursesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberProductCoursesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberproductcourses.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProductCoursesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberproductcourses.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProductCoursesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProductCoursesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberProductCoursesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberproductcourses.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProductCoursesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberproductcourses.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberProductCoursesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberProductCoursesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberProductCoursesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberProductCoursesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberProductCoursesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberproductcourses.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberProductCoursesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberproductcourses.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberProductCoursesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberProductCoursesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberProductCoursesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberProductCoursesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberProductCoursesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberproductcourses.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberProductCoursesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberproductcourses.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberProductCoursesMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberProductCoursesMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberProductCoursesMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberProductCoursesMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberProductCoursesMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[memberproductcourses.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberProductCoursesMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, memberproductcourses.FieldStatus)
}

// SetType sets the "type" field.
func (m *MemberProductCoursesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MemberProductCoursesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MemberProductCoursesMutation) ClearType() {
	m._type = nil
	m.clearedFields[memberproductcourses.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) TypeCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MemberProductCoursesMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, memberproductcourses.FieldType)
}

// SetName sets the "name" field.
func (m *MemberProductCoursesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberProductCoursesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberProductCoursesMutation) ClearName() {
	m.name = nil
	m.clearedFields[memberproductcourses.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) NameCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberProductCoursesMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, memberproductcourses.FieldName)
}

// SetNumber sets the "number" field.
func (m *MemberProductCoursesMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *MemberProductCoursesMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *MemberProductCoursesMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *MemberProductCoursesMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *MemberProductCoursesMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[memberproductcourses.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) NumberCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *MemberProductCoursesMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, memberproductcourses.FieldNumber)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *MemberProductCoursesMutation) SetMemberProductID(i int64) {
	m.nodeL = &i
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *MemberProductCoursesMutation) MemberProductID() (r int64, exists bool) {
	v := m.nodeL
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *MemberProductCoursesMutation) ClearMemberProductID() {
	m.nodeL = nil
	m.clearedFields[memberproductcourses.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *MemberProductCoursesMutation) ResetMemberProductID() {
	m.nodeL = nil
	delete(m.clearedFields, memberproductcourses.FieldMemberProductID)
}

// SetCoursesID sets the "courses_id" field.
func (m *MemberProductCoursesMutation) SetCoursesID(i int64) {
	m.courses_id = &i
	m.addcourses_id = nil
}

// CoursesID returns the value of the "courses_id" field in the mutation.
func (m *MemberProductCoursesMutation) CoursesID() (r int64, exists bool) {
	v := m.courses_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursesID returns the old "courses_id" field's value of the MemberProductCourses entity.
// If the MemberProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductCoursesMutation) OldCoursesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoursesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoursesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursesID: %w", err)
	}
	return oldValue.CoursesID, nil
}

// AddCoursesID adds i to the "courses_id" field.
func (m *MemberProductCoursesMutation) AddCoursesID(i int64) {
	if m.addcourses_id != nil {
		*m.addcourses_id += i
	} else {
		m.addcourses_id = &i
	}
}

// AddedCoursesID returns the value that was added to the "courses_id" field in this mutation.
func (m *MemberProductCoursesMutation) AddedCoursesID() (r int64, exists bool) {
	v := m.addcourses_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoursesID clears the value of the "courses_id" field.
func (m *MemberProductCoursesMutation) ClearCoursesID() {
	m.courses_id = nil
	m.addcourses_id = nil
	m.clearedFields[memberproductcourses.FieldCoursesID] = struct{}{}
}

// CoursesIDCleared returns if the "courses_id" field was cleared in this mutation.
func (m *MemberProductCoursesMutation) CoursesIDCleared() bool {
	_, ok := m.clearedFields[memberproductcourses.FieldCoursesID]
	return ok
}

// ResetCoursesID resets all changes to the "courses_id" field.
func (m *MemberProductCoursesMutation) ResetCoursesID() {
	m.courses_id = nil
	m.addcourses_id = nil
	delete(m.clearedFields, memberproductcourses.FieldCoursesID)
}

// SetNodeCID sets the "nodeC" edge to the MemberProduct entity by id.
func (m *MemberProductCoursesMutation) SetNodeCID(id int64) {
	m.nodeC = &id
}

// ClearNodeC clears the "nodeC" edge to the MemberProduct entity.
func (m *MemberProductCoursesMutation) ClearNodeC() {
	m.clearednodeC = true
	m.clearedFields[memberproductcourses.FieldMemberProductID] = struct{}{}
}

// NodeCCleared reports if the "nodeC" edge to the MemberProduct entity was cleared.
func (m *MemberProductCoursesMutation) NodeCCleared() bool {
	return m.MemberProductIDCleared() || m.clearednodeC
}

// NodeCID returns the "nodeC" edge ID in the mutation.
func (m *MemberProductCoursesMutation) NodeCID() (id int64, exists bool) {
	if m.nodeC != nil {
		return *m.nodeC, true
	}
	return
}

// NodeCIDs returns the "nodeC" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeCID instead. It exists only for internal usage by the builders.
func (m *MemberProductCoursesMutation) NodeCIDs() (ids []int64) {
	if id := m.nodeC; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodeC resets all changes to the "nodeC" edge.
func (m *MemberProductCoursesMutation) ResetNodeC() {
	m.nodeC = nil
	m.clearednodeC = false
}

// SetNodeLID sets the "nodeL" edge to the MemberProduct entity by id.
func (m *MemberProductCoursesMutation) SetNodeLID(id int64) {
	m.nodeL = &id
}

// ClearNodeL clears the "nodeL" edge to the MemberProduct entity.
func (m *MemberProductCoursesMutation) ClearNodeL() {
	m.clearednodeL = true
	m.clearedFields[memberproductcourses.FieldMemberProductID] = struct{}{}
}

// NodeLCleared reports if the "nodeL" edge to the MemberProduct entity was cleared.
func (m *MemberProductCoursesMutation) NodeLCleared() bool {
	return m.MemberProductIDCleared() || m.clearednodeL
}

// NodeLID returns the "nodeL" edge ID in the mutation.
func (m *MemberProductCoursesMutation) NodeLID() (id int64, exists bool) {
	if m.nodeL != nil {
		return *m.nodeL, true
	}
	return
}

// NodeLIDs returns the "nodeL" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeLID instead. It exists only for internal usage by the builders.
func (m *MemberProductCoursesMutation) NodeLIDs() (ids []int64) {
	if id := m.nodeL; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodeL resets all changes to the "nodeL" edge.
func (m *MemberProductCoursesMutation) ResetNodeL() {
	m.nodeL = nil
	m.clearednodeL = false
}

// Where appends a list predicates to the MemberProductCoursesMutation builder.
func (m *MemberProductCoursesMutation) Where(ps ...predicate.MemberProductCourses) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProductCoursesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProductCoursesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProductCourses, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProductCoursesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProductCoursesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProductCourses).
func (m *MemberProductCoursesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProductCoursesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, memberproductcourses.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberproductcourses.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberproductcourses.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberproductcourses.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, memberproductcourses.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, memberproductcourses.FieldType)
	}
	if m.name != nil {
		fields = append(fields, memberproductcourses.FieldName)
	}
	if m.number != nil {
		fields = append(fields, memberproductcourses.FieldNumber)
	}
	if m.nodeL != nil {
		fields = append(fields, memberproductcourses.FieldMemberProductID)
	}
	if m.courses_id != nil {
		fields = append(fields, memberproductcourses.FieldCoursesID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProductCoursesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberproductcourses.FieldCreatedAt:
		return m.CreatedAt()
	case memberproductcourses.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberproductcourses.FieldDelete:
		return m.Delete()
	case memberproductcourses.FieldCreatedID:
		return m.CreatedID()
	case memberproductcourses.FieldStatus:
		return m.Status()
	case memberproductcourses.FieldType:
		return m.GetType()
	case memberproductcourses.FieldName:
		return m.Name()
	case memberproductcourses.FieldNumber:
		return m.Number()
	case memberproductcourses.FieldMemberProductID:
		return m.MemberProductID()
	case memberproductcourses.FieldCoursesID:
		return m.CoursesID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProductCoursesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberproductcourses.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberproductcourses.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberproductcourses.FieldDelete:
		return m.OldDelete(ctx)
	case memberproductcourses.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberproductcourses.FieldStatus:
		return m.OldStatus(ctx)
	case memberproductcourses.FieldType:
		return m.OldType(ctx)
	case memberproductcourses.FieldName:
		return m.OldName(ctx)
	case memberproductcourses.FieldNumber:
		return m.OldNumber(ctx)
	case memberproductcourses.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case memberproductcourses.FieldCoursesID:
		return m.OldCoursesID(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProductCourses field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductCoursesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberproductcourses.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberproductcourses.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberproductcourses.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberproductcourses.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberproductcourses.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case memberproductcourses.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case memberproductcourses.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberproductcourses.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case memberproductcourses.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case memberproductcourses.FieldCoursesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursesID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProductCourses field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProductCoursesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberproductcourses.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberproductcourses.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, memberproductcourses.FieldStatus)
	}
	if m.addnumber != nil {
		fields = append(fields, memberproductcourses.FieldNumber)
	}
	if m.addcourses_id != nil {
		fields = append(fields, memberproductcourses.FieldCoursesID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProductCoursesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberproductcourses.FieldDelete:
		return m.AddedDelete()
	case memberproductcourses.FieldCreatedID:
		return m.AddedCreatedID()
	case memberproductcourses.FieldStatus:
		return m.AddedStatus()
	case memberproductcourses.FieldNumber:
		return m.AddedNumber()
	case memberproductcourses.FieldCoursesID:
		return m.AddedCoursesID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductCoursesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberproductcourses.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberproductcourses.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberproductcourses.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case memberproductcourses.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case memberproductcourses.FieldCoursesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoursesID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProductCourses numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProductCoursesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberproductcourses.FieldCreatedAt) {
		fields = append(fields, memberproductcourses.FieldCreatedAt)
	}
	if m.FieldCleared(memberproductcourses.FieldUpdatedAt) {
		fields = append(fields, memberproductcourses.FieldUpdatedAt)
	}
	if m.FieldCleared(memberproductcourses.FieldDelete) {
		fields = append(fields, memberproductcourses.FieldDelete)
	}
	if m.FieldCleared(memberproductcourses.FieldCreatedID) {
		fields = append(fields, memberproductcourses.FieldCreatedID)
	}
	if m.FieldCleared(memberproductcourses.FieldStatus) {
		fields = append(fields, memberproductcourses.FieldStatus)
	}
	if m.FieldCleared(memberproductcourses.FieldType) {
		fields = append(fields, memberproductcourses.FieldType)
	}
	if m.FieldCleared(memberproductcourses.FieldName) {
		fields = append(fields, memberproductcourses.FieldName)
	}
	if m.FieldCleared(memberproductcourses.FieldNumber) {
		fields = append(fields, memberproductcourses.FieldNumber)
	}
	if m.FieldCleared(memberproductcourses.FieldMemberProductID) {
		fields = append(fields, memberproductcourses.FieldMemberProductID)
	}
	if m.FieldCleared(memberproductcourses.FieldCoursesID) {
		fields = append(fields, memberproductcourses.FieldCoursesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProductCoursesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProductCoursesMutation) ClearField(name string) error {
	switch name {
	case memberproductcourses.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberproductcourses.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberproductcourses.FieldDelete:
		m.ClearDelete()
		return nil
	case memberproductcourses.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberproductcourses.FieldStatus:
		m.ClearStatus()
		return nil
	case memberproductcourses.FieldType:
		m.ClearType()
		return nil
	case memberproductcourses.FieldName:
		m.ClearName()
		return nil
	case memberproductcourses.FieldNumber:
		m.ClearNumber()
		return nil
	case memberproductcourses.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case memberproductcourses.FieldCoursesID:
		m.ClearCoursesID()
		return nil
	}
	return fmt.Errorf("unknown MemberProductCourses nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProductCoursesMutation) ResetField(name string) error {
	switch name {
	case memberproductcourses.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberproductcourses.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberproductcourses.FieldDelete:
		m.ResetDelete()
		return nil
	case memberproductcourses.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberproductcourses.FieldStatus:
		m.ResetStatus()
		return nil
	case memberproductcourses.FieldType:
		m.ResetType()
		return nil
	case memberproductcourses.FieldName:
		m.ResetName()
		return nil
	case memberproductcourses.FieldNumber:
		m.ResetNumber()
		return nil
	case memberproductcourses.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case memberproductcourses.FieldCoursesID:
		m.ResetCoursesID()
		return nil
	}
	return fmt.Errorf("unknown MemberProductCourses field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProductCoursesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nodeC != nil {
		edges = append(edges, memberproductcourses.EdgeNodeC)
	}
	if m.nodeL != nil {
		edges = append(edges, memberproductcourses.EdgeNodeL)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProductCoursesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberproductcourses.EdgeNodeC:
		if id := m.nodeC; id != nil {
			return []ent.Value{*id}
		}
	case memberproductcourses.EdgeNodeL:
		if id := m.nodeL; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProductCoursesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProductCoursesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProductCoursesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednodeC {
		edges = append(edges, memberproductcourses.EdgeNodeC)
	}
	if m.clearednodeL {
		edges = append(edges, memberproductcourses.EdgeNodeL)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProductCoursesMutation) EdgeCleared(name string) bool {
	switch name {
	case memberproductcourses.EdgeNodeC:
		return m.clearednodeC
	case memberproductcourses.EdgeNodeL:
		return m.clearednodeL
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProductCoursesMutation) ClearEdge(name string) error {
	switch name {
	case memberproductcourses.EdgeNodeC:
		m.ClearNodeC()
		return nil
	case memberproductcourses.EdgeNodeL:
		m.ClearNodeL()
		return nil
	}
	return fmt.Errorf("unknown MemberProductCourses unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProductCoursesMutation) ResetEdge(name string) error {
	switch name {
	case memberproductcourses.EdgeNodeC:
		m.ResetNodeC()
		return nil
	case memberproductcourses.EdgeNodeL:
		m.ResetNodeL()
		return nil
	}
	return fmt.Errorf("unknown MemberProductCourses edge %s", name)
}

// MemberProfileMutation represents an operation that mutates the MemberProfile nodes in the graph.
type MemberProfileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	delete               *int64
	adddelete            *int64
	created_id           *int64
	addcreated_id        *int64
	intention            *int64
	addintention         *int64
	source               *int64
	addsource            *int64
	name                 *string
	venue_id             *int64
	addvenue_id          *int64
	condition            *int64
	addcondition         *int64
	mobile_ascription    *int64
	addmobile_ascription *int64
	father_name          *string
	mother_name          *string
	gender               *int64
	addgender            *int64
	birthday             *time.Time
	grade                *int64
	addgrade             *int64
	email                *string
	wecom                *string
	clearedFields        map[string]struct{}
	member               *int64
	clearedmember        bool
	done                 bool
	oldValue             func(context.Context) (*MemberProfile, error)
	predicates           []predicate.MemberProfile
}

var _ ent.Mutation = (*MemberProfileMutation)(nil)

// memberprofileOption allows management of the mutation configuration using functional options.
type memberprofileOption func(*MemberProfileMutation)

// newMemberProfileMutation creates new mutation for the MemberProfile entity.
func newMemberProfileMutation(c config, op Op, opts ...memberprofileOption) *MemberProfileMutation {
	m := &MemberProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProfileID sets the ID field of the mutation.
func withMemberProfileID(id int64) memberprofileOption {
	return func(m *MemberProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProfile
		)
		m.oldValue = func(ctx context.Context) (*MemberProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProfile sets the old MemberProfile of the mutation.
func withMemberProfile(node *MemberProfile) memberprofileOption {
	return func(m *MemberProfileMutation) {
		m.oldValue = func(context.Context) (*MemberProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProfile entities.
func (m *MemberProfileMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProfileMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProfileMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberProfileMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberprofile.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberProfileMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProfileMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberprofile.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberProfileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberprofile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberProfileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberprofile.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberProfileMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberProfileMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberProfileMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberProfileMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberProfileMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberprofile.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberProfileMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberProfileMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberprofile.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberProfileMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberProfileMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberProfileMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberProfileMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberProfileMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberprofile.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberProfileMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberProfileMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberprofile.FieldCreatedID)
}

// SetIntention sets the "intention" field.
func (m *MemberProfileMutation) SetIntention(i int64) {
	m.intention = &i
	m.addintention = nil
}

// Intention returns the value of the "intention" field in the mutation.
func (m *MemberProfileMutation) Intention() (r int64, exists bool) {
	v := m.intention
	if v == nil {
		return
	}
	return *v, true
}

// OldIntention returns the old "intention" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldIntention(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntention is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntention requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntention: %w", err)
	}
	return oldValue.Intention, nil
}

// AddIntention adds i to the "intention" field.
func (m *MemberProfileMutation) AddIntention(i int64) {
	if m.addintention != nil {
		*m.addintention += i
	} else {
		m.addintention = &i
	}
}

// AddedIntention returns the value that was added to the "intention" field in this mutation.
func (m *MemberProfileMutation) AddedIntention() (r int64, exists bool) {
	v := m.addintention
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntention clears the value of the "intention" field.
func (m *MemberProfileMutation) ClearIntention() {
	m.intention = nil
	m.addintention = nil
	m.clearedFields[memberprofile.FieldIntention] = struct{}{}
}

// IntentionCleared returns if the "intention" field was cleared in this mutation.
func (m *MemberProfileMutation) IntentionCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldIntention]
	return ok
}

// ResetIntention resets all changes to the "intention" field.
func (m *MemberProfileMutation) ResetIntention() {
	m.intention = nil
	m.addintention = nil
	delete(m.clearedFields, memberprofile.FieldIntention)
}

// SetSource sets the "source" field.
func (m *MemberProfileMutation) SetSource(i int64) {
	m.source = &i
	m.addsource = nil
}

// Source returns the value of the "source" field in the mutation.
func (m *MemberProfileMutation) Source() (r int64, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldSource(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// AddSource adds i to the "source" field.
func (m *MemberProfileMutation) AddSource(i int64) {
	if m.addsource != nil {
		*m.addsource += i
	} else {
		m.addsource = &i
	}
}

// AddedSource returns the value that was added to the "source" field in this mutation.
func (m *MemberProfileMutation) AddedSource() (r int64, exists bool) {
	v := m.addsource
	if v == nil {
		return
	}
	return *v, true
}

// ClearSource clears the value of the "source" field.
func (m *MemberProfileMutation) ClearSource() {
	m.source = nil
	m.addsource = nil
	m.clearedFields[memberprofile.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *MemberProfileMutation) SourceCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *MemberProfileMutation) ResetSource() {
	m.source = nil
	m.addsource = nil
	delete(m.clearedFields, memberprofile.FieldSource)
}

// SetName sets the "name" field.
func (m *MemberProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberProfileMutation) ClearName() {
	m.name = nil
	m.clearedFields[memberprofile.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberProfileMutation) NameCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberProfileMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, memberprofile.FieldName)
}

// SetMemberID sets the "member_id" field.
func (m *MemberProfileMutation) SetMemberID(i int64) {
	m.member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberProfileMutation) MemberID() (r int64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberProfileMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[memberprofile.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberProfileMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberProfileMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, memberprofile.FieldMemberID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberProfileMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberProfileMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberProfileMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberProfileMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberProfileMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[memberprofile.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberProfileMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberProfileMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, memberprofile.FieldVenueID)
}

// SetCondition sets the "condition" field.
func (m *MemberProfileMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *MemberProfileMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *MemberProfileMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *MemberProfileMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *MemberProfileMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[memberprofile.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *MemberProfileMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *MemberProfileMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, memberprofile.FieldCondition)
}

// SetMobileAscription sets the "mobile_ascription" field.
func (m *MemberProfileMutation) SetMobileAscription(i int64) {
	m.mobile_ascription = &i
	m.addmobile_ascription = nil
}

// MobileAscription returns the value of the "mobile_ascription" field in the mutation.
func (m *MemberProfileMutation) MobileAscription() (r int64, exists bool) {
	v := m.mobile_ascription
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileAscription returns the old "mobile_ascription" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldMobileAscription(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileAscription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileAscription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileAscription: %w", err)
	}
	return oldValue.MobileAscription, nil
}

// AddMobileAscription adds i to the "mobile_ascription" field.
func (m *MemberProfileMutation) AddMobileAscription(i int64) {
	if m.addmobile_ascription != nil {
		*m.addmobile_ascription += i
	} else {
		m.addmobile_ascription = &i
	}
}

// AddedMobileAscription returns the value that was added to the "mobile_ascription" field in this mutation.
func (m *MemberProfileMutation) AddedMobileAscription() (r int64, exists bool) {
	v := m.addmobile_ascription
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileAscription clears the value of the "mobile_ascription" field.
func (m *MemberProfileMutation) ClearMobileAscription() {
	m.mobile_ascription = nil
	m.addmobile_ascription = nil
	m.clearedFields[memberprofile.FieldMobileAscription] = struct{}{}
}

// MobileAscriptionCleared returns if the "mobile_ascription" field was cleared in this mutation.
func (m *MemberProfileMutation) MobileAscriptionCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldMobileAscription]
	return ok
}

// ResetMobileAscription resets all changes to the "mobile_ascription" field.
func (m *MemberProfileMutation) ResetMobileAscription() {
	m.mobile_ascription = nil
	m.addmobile_ascription = nil
	delete(m.clearedFields, memberprofile.FieldMobileAscription)
}

// SetFatherName sets the "father_name" field.
func (m *MemberProfileMutation) SetFatherName(s string) {
	m.father_name = &s
}

// FatherName returns the value of the "father_name" field in the mutation.
func (m *MemberProfileMutation) FatherName() (r string, exists bool) {
	v := m.father_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFatherName returns the old "father_name" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldFatherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFatherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFatherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFatherName: %w", err)
	}
	return oldValue.FatherName, nil
}

// ClearFatherName clears the value of the "father_name" field.
func (m *MemberProfileMutation) ClearFatherName() {
	m.father_name = nil
	m.clearedFields[memberprofile.FieldFatherName] = struct{}{}
}

// FatherNameCleared returns if the "father_name" field was cleared in this mutation.
func (m *MemberProfileMutation) FatherNameCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldFatherName]
	return ok
}

// ResetFatherName resets all changes to the "father_name" field.
func (m *MemberProfileMutation) ResetFatherName() {
	m.father_name = nil
	delete(m.clearedFields, memberprofile.FieldFatherName)
}

// SetMotherName sets the "mother_name" field.
func (m *MemberProfileMutation) SetMotherName(s string) {
	m.mother_name = &s
}

// MotherName returns the value of the "mother_name" field in the mutation.
func (m *MemberProfileMutation) MotherName() (r string, exists bool) {
	v := m.mother_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMotherName returns the old "mother_name" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldMotherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMotherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMotherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotherName: %w", err)
	}
	return oldValue.MotherName, nil
}

// ClearMotherName clears the value of the "mother_name" field.
func (m *MemberProfileMutation) ClearMotherName() {
	m.mother_name = nil
	m.clearedFields[memberprofile.FieldMotherName] = struct{}{}
}

// MotherNameCleared returns if the "mother_name" field was cleared in this mutation.
func (m *MemberProfileMutation) MotherNameCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldMotherName]
	return ok
}

// ResetMotherName resets all changes to the "mother_name" field.
func (m *MemberProfileMutation) ResetMotherName() {
	m.mother_name = nil
	delete(m.clearedFields, memberprofile.FieldMotherName)
}

// SetGender sets the "gender" field.
func (m *MemberProfileMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *MemberProfileMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *MemberProfileMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *MemberProfileMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *MemberProfileMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[memberprofile.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *MemberProfileMutation) GenderCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *MemberProfileMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, memberprofile.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *MemberProfileMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *MemberProfileMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *MemberProfileMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[memberprofile.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *MemberProfileMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *MemberProfileMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, memberprofile.FieldBirthday)
}

// SetGrade sets the "grade" field.
func (m *MemberProfileMutation) SetGrade(i int64) {
	m.grade = &i
	m.addgrade = nil
}

// Grade returns the value of the "grade" field in the mutation.
func (m *MemberProfileMutation) Grade() (r int64, exists bool) {
	v := m.grade
	if v == nil {
		return
	}
	return *v, true
}

// OldGrade returns the old "grade" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldGrade(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrade: %w", err)
	}
	return oldValue.Grade, nil
}

// AddGrade adds i to the "grade" field.
func (m *MemberProfileMutation) AddGrade(i int64) {
	if m.addgrade != nil {
		*m.addgrade += i
	} else {
		m.addgrade = &i
	}
}

// AddedGrade returns the value that was added to the "grade" field in this mutation.
func (m *MemberProfileMutation) AddedGrade() (r int64, exists bool) {
	v := m.addgrade
	if v == nil {
		return
	}
	return *v, true
}

// ClearGrade clears the value of the "grade" field.
func (m *MemberProfileMutation) ClearGrade() {
	m.grade = nil
	m.addgrade = nil
	m.clearedFields[memberprofile.FieldGrade] = struct{}{}
}

// GradeCleared returns if the "grade" field was cleared in this mutation.
func (m *MemberProfileMutation) GradeCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldGrade]
	return ok
}

// ResetGrade resets all changes to the "grade" field.
func (m *MemberProfileMutation) ResetGrade() {
	m.grade = nil
	m.addgrade = nil
	delete(m.clearedFields, memberprofile.FieldGrade)
}

// SetEmail sets the "email" field.
func (m *MemberProfileMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberProfileMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MemberProfileMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[memberprofile.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MemberProfileMutation) EmailCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberProfileMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, memberprofile.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *MemberProfileMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *MemberProfileMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *MemberProfileMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[memberprofile.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *MemberProfileMutation) WecomCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *MemberProfileMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, memberprofile.FieldWecom)
}

// ClearMember clears the "member" edge to the Member entity.
func (m *MemberProfileMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[memberprofile.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *MemberProfileMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *MemberProfileMutation) MemberIDs() (ids []int64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *MemberProfileMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// Where appends a list predicates to the MemberProfileMutation builder.
func (m *MemberProfileMutation) Where(ps ...predicate.MemberProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProfile).
func (m *MemberProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProfileMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, memberprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberprofile.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberprofile.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberprofile.FieldCreatedID)
	}
	if m.intention != nil {
		fields = append(fields, memberprofile.FieldIntention)
	}
	if m.source != nil {
		fields = append(fields, memberprofile.FieldSource)
	}
	if m.name != nil {
		fields = append(fields, memberprofile.FieldName)
	}
	if m.member != nil {
		fields = append(fields, memberprofile.FieldMemberID)
	}
	if m.venue_id != nil {
		fields = append(fields, memberprofile.FieldVenueID)
	}
	if m.condition != nil {
		fields = append(fields, memberprofile.FieldCondition)
	}
	if m.mobile_ascription != nil {
		fields = append(fields, memberprofile.FieldMobileAscription)
	}
	if m.father_name != nil {
		fields = append(fields, memberprofile.FieldFatherName)
	}
	if m.mother_name != nil {
		fields = append(fields, memberprofile.FieldMotherName)
	}
	if m.gender != nil {
		fields = append(fields, memberprofile.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, memberprofile.FieldBirthday)
	}
	if m.grade != nil {
		fields = append(fields, memberprofile.FieldGrade)
	}
	if m.email != nil {
		fields = append(fields, memberprofile.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, memberprofile.FieldWecom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberprofile.FieldCreatedAt:
		return m.CreatedAt()
	case memberprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberprofile.FieldDelete:
		return m.Delete()
	case memberprofile.FieldCreatedID:
		return m.CreatedID()
	case memberprofile.FieldIntention:
		return m.Intention()
	case memberprofile.FieldSource:
		return m.Source()
	case memberprofile.FieldName:
		return m.Name()
	case memberprofile.FieldMemberID:
		return m.MemberID()
	case memberprofile.FieldVenueID:
		return m.VenueID()
	case memberprofile.FieldCondition:
		return m.Condition()
	case memberprofile.FieldMobileAscription:
		return m.MobileAscription()
	case memberprofile.FieldFatherName:
		return m.FatherName()
	case memberprofile.FieldMotherName:
		return m.MotherName()
	case memberprofile.FieldGender:
		return m.Gender()
	case memberprofile.FieldBirthday:
		return m.Birthday()
	case memberprofile.FieldGrade:
		return m.Grade()
	case memberprofile.FieldEmail:
		return m.Email()
	case memberprofile.FieldWecom:
		return m.Wecom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberprofile.FieldDelete:
		return m.OldDelete(ctx)
	case memberprofile.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberprofile.FieldIntention:
		return m.OldIntention(ctx)
	case memberprofile.FieldSource:
		return m.OldSource(ctx)
	case memberprofile.FieldName:
		return m.OldName(ctx)
	case memberprofile.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberprofile.FieldVenueID:
		return m.OldVenueID(ctx)
	case memberprofile.FieldCondition:
		return m.OldCondition(ctx)
	case memberprofile.FieldMobileAscription:
		return m.OldMobileAscription(ctx)
	case memberprofile.FieldFatherName:
		return m.OldFatherName(ctx)
	case memberprofile.FieldMotherName:
		return m.OldMotherName(ctx)
	case memberprofile.FieldGender:
		return m.OldGender(ctx)
	case memberprofile.FieldBirthday:
		return m.OldBirthday(ctx)
	case memberprofile.FieldGrade:
		return m.OldGrade(ctx)
	case memberprofile.FieldEmail:
		return m.OldEmail(ctx)
	case memberprofile.FieldWecom:
		return m.OldWecom(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberprofile.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberprofile.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberprofile.FieldIntention:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntention(v)
		return nil
	case memberprofile.FieldSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case memberprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberprofile.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberprofile.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case memberprofile.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case memberprofile.FieldMobileAscription:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileAscription(v)
		return nil
	case memberprofile.FieldFatherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFatherName(v)
		return nil
	case memberprofile.FieldMotherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotherName(v)
		return nil
	case memberprofile.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case memberprofile.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case memberprofile.FieldGrade:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrade(v)
		return nil
	case memberprofile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case memberprofile.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProfileMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberprofile.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberprofile.FieldCreatedID)
	}
	if m.addintention != nil {
		fields = append(fields, memberprofile.FieldIntention)
	}
	if m.addsource != nil {
		fields = append(fields, memberprofile.FieldSource)
	}
	if m.addvenue_id != nil {
		fields = append(fields, memberprofile.FieldVenueID)
	}
	if m.addcondition != nil {
		fields = append(fields, memberprofile.FieldCondition)
	}
	if m.addmobile_ascription != nil {
		fields = append(fields, memberprofile.FieldMobileAscription)
	}
	if m.addgender != nil {
		fields = append(fields, memberprofile.FieldGender)
	}
	if m.addgrade != nil {
		fields = append(fields, memberprofile.FieldGrade)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberprofile.FieldDelete:
		return m.AddedDelete()
	case memberprofile.FieldCreatedID:
		return m.AddedCreatedID()
	case memberprofile.FieldIntention:
		return m.AddedIntention()
	case memberprofile.FieldSource:
		return m.AddedSource()
	case memberprofile.FieldVenueID:
		return m.AddedVenueID()
	case memberprofile.FieldCondition:
		return m.AddedCondition()
	case memberprofile.FieldMobileAscription:
		return m.AddedMobileAscription()
	case memberprofile.FieldGender:
		return m.AddedGender()
	case memberprofile.FieldGrade:
		return m.AddedGrade()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberprofile.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberprofile.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberprofile.FieldIntention:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntention(v)
		return nil
	case memberprofile.FieldSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSource(v)
		return nil
	case memberprofile.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case memberprofile.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	case memberprofile.FieldMobileAscription:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileAscription(v)
		return nil
	case memberprofile.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case memberprofile.FieldGrade:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrade(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberprofile.FieldCreatedAt) {
		fields = append(fields, memberprofile.FieldCreatedAt)
	}
	if m.FieldCleared(memberprofile.FieldUpdatedAt) {
		fields = append(fields, memberprofile.FieldUpdatedAt)
	}
	if m.FieldCleared(memberprofile.FieldDelete) {
		fields = append(fields, memberprofile.FieldDelete)
	}
	if m.FieldCleared(memberprofile.FieldCreatedID) {
		fields = append(fields, memberprofile.FieldCreatedID)
	}
	if m.FieldCleared(memberprofile.FieldIntention) {
		fields = append(fields, memberprofile.FieldIntention)
	}
	if m.FieldCleared(memberprofile.FieldSource) {
		fields = append(fields, memberprofile.FieldSource)
	}
	if m.FieldCleared(memberprofile.FieldName) {
		fields = append(fields, memberprofile.FieldName)
	}
	if m.FieldCleared(memberprofile.FieldMemberID) {
		fields = append(fields, memberprofile.FieldMemberID)
	}
	if m.FieldCleared(memberprofile.FieldVenueID) {
		fields = append(fields, memberprofile.FieldVenueID)
	}
	if m.FieldCleared(memberprofile.FieldCondition) {
		fields = append(fields, memberprofile.FieldCondition)
	}
	if m.FieldCleared(memberprofile.FieldMobileAscription) {
		fields = append(fields, memberprofile.FieldMobileAscription)
	}
	if m.FieldCleared(memberprofile.FieldFatherName) {
		fields = append(fields, memberprofile.FieldFatherName)
	}
	if m.FieldCleared(memberprofile.FieldMotherName) {
		fields = append(fields, memberprofile.FieldMotherName)
	}
	if m.FieldCleared(memberprofile.FieldGender) {
		fields = append(fields, memberprofile.FieldGender)
	}
	if m.FieldCleared(memberprofile.FieldBirthday) {
		fields = append(fields, memberprofile.FieldBirthday)
	}
	if m.FieldCleared(memberprofile.FieldGrade) {
		fields = append(fields, memberprofile.FieldGrade)
	}
	if m.FieldCleared(memberprofile.FieldEmail) {
		fields = append(fields, memberprofile.FieldEmail)
	}
	if m.FieldCleared(memberprofile.FieldWecom) {
		fields = append(fields, memberprofile.FieldWecom)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProfileMutation) ClearField(name string) error {
	switch name {
	case memberprofile.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberprofile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberprofile.FieldDelete:
		m.ClearDelete()
		return nil
	case memberprofile.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberprofile.FieldIntention:
		m.ClearIntention()
		return nil
	case memberprofile.FieldSource:
		m.ClearSource()
		return nil
	case memberprofile.FieldName:
		m.ClearName()
		return nil
	case memberprofile.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberprofile.FieldVenueID:
		m.ClearVenueID()
		return nil
	case memberprofile.FieldCondition:
		m.ClearCondition()
		return nil
	case memberprofile.FieldMobileAscription:
		m.ClearMobileAscription()
		return nil
	case memberprofile.FieldFatherName:
		m.ClearFatherName()
		return nil
	case memberprofile.FieldMotherName:
		m.ClearMotherName()
		return nil
	case memberprofile.FieldGender:
		m.ClearGender()
		return nil
	case memberprofile.FieldBirthday:
		m.ClearBirthday()
		return nil
	case memberprofile.FieldGrade:
		m.ClearGrade()
		return nil
	case memberprofile.FieldEmail:
		m.ClearEmail()
		return nil
	case memberprofile.FieldWecom:
		m.ClearWecom()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProfileMutation) ResetField(name string) error {
	switch name {
	case memberprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberprofile.FieldDelete:
		m.ResetDelete()
		return nil
	case memberprofile.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberprofile.FieldIntention:
		m.ResetIntention()
		return nil
	case memberprofile.FieldSource:
		m.ResetSource()
		return nil
	case memberprofile.FieldName:
		m.ResetName()
		return nil
	case memberprofile.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberprofile.FieldVenueID:
		m.ResetVenueID()
		return nil
	case memberprofile.FieldCondition:
		m.ResetCondition()
		return nil
	case memberprofile.FieldMobileAscription:
		m.ResetMobileAscription()
		return nil
	case memberprofile.FieldFatherName:
		m.ResetFatherName()
		return nil
	case memberprofile.FieldMotherName:
		m.ResetMotherName()
		return nil
	case memberprofile.FieldGender:
		m.ResetGender()
		return nil
	case memberprofile.FieldBirthday:
		m.ResetBirthday()
		return nil
	case memberprofile.FieldGrade:
		m.ResetGrade()
		return nil
	case memberprofile.FieldEmail:
		m.ResetEmail()
		return nil
	case memberprofile.FieldWecom:
		m.ResetWecom()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.member != nil {
		edges = append(edges, memberprofile.EdgeMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberprofile.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmember {
		edges = append(edges, memberprofile.EdgeMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case memberprofile.EdgeMember:
		return m.clearedmember
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProfileMutation) ClearEdge(name string) error {
	switch name {
	case memberprofile.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProfileMutation) ResetEdge(name string) error {
	switch name {
	case memberprofile.EdgeMember:
		m.ResetMember()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	_path           *string
	name            *string
	sort            *int64
	addsort         *int64
	disabled        *int64
	adddisabled     *int64
	ignore          *bool
	level           *int64
	addlevel        *int64
	menu_type       *int64
	addmenu_type    *int64
	redirect        *string
	component       *string
	url             *string
	hidden          *bool
	title           *string
	icon            *string
	active_menu     *string
	affix           *bool
	no_cache        *bool
	_type           *string
	clearedFields   map[string]struct{}
	roles           map[int64]struct{}
	removedroles    map[int64]struct{}
	clearedroles    bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	params          map[int64]struct{}
	removedparams   map[int64]struct{}
	clearedparams   bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menu.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menu.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menu.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MenuMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MenuMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MenuMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MenuMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MenuMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[menu.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MenuMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[menu.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MenuMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, menu.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MenuMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MenuMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MenuMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MenuMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MenuMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[menu.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MenuMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MenuMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, menu.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MenuMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MenuMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MenuMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MenuMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MenuMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[menu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MenuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[menu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, menu.FieldStatus)
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[menu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[menu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, menu.FieldName)
}

// SetSort sets the "sort" field.
func (m *MenuMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MenuMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *MenuMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MenuMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *MenuMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[menu.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *MenuMutation) SortCleared() bool {
	_, ok := m.clearedFields[menu.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *MenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, menu.FieldSort)
}

// SetDisabled sets the "disabled" field.
func (m *MenuMutation) SetDisabled(i int64) {
	m.disabled = &i
	m.adddisabled = nil
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *MenuMutation) Disabled() (r int64, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDisabled(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// AddDisabled adds i to the "disabled" field.
func (m *MenuMutation) AddDisabled(i int64) {
	if m.adddisabled != nil {
		*m.adddisabled += i
	} else {
		m.adddisabled = &i
	}
}

// AddedDisabled returns the value that was added to the "disabled" field in this mutation.
func (m *MenuMutation) AddedDisabled() (r int64, exists bool) {
	v := m.adddisabled
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabled clears the value of the "disabled" field.
func (m *MenuMutation) ClearDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	m.clearedFields[menu.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *MenuMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[menu.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *MenuMutation) ResetDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	delete(m.clearedFields, menu.FieldDisabled)
}

// SetIgnore sets the "ignore" field.
func (m *MenuMutation) SetIgnore(b bool) {
	m.ignore = &b
}

// Ignore returns the value of the "ignore" field in the mutation.
func (m *MenuMutation) Ignore() (r bool, exists bool) {
	v := m.ignore
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnore returns the old "ignore" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIgnore(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnore: %w", err)
	}
	return oldValue.Ignore, nil
}

// ClearIgnore clears the value of the "ignore" field.
func (m *MenuMutation) ClearIgnore() {
	m.ignore = nil
	m.clearedFields[menu.FieldIgnore] = struct{}{}
}

// IgnoreCleared returns if the "ignore" field was cleared in this mutation.
func (m *MenuMutation) IgnoreCleared() bool {
	_, ok := m.clearedFields[menu.FieldIgnore]
	return ok
}

// ResetIgnore resets all changes to the "ignore" field.
func (m *MenuMutation) ResetIgnore() {
	m.ignore = nil
	delete(m.clearedFields, menu.FieldIgnore)
}

// SetLevel sets the "level" field.
func (m *MenuMutation) SetLevel(i int64) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *MenuMutation) Level() (r int64, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldLevel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *MenuMutation) AddLevel(i int64) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *MenuMutation) AddedLevel() (r int64, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *MenuMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[menu.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *MenuMutation) LevelCleared() bool {
	_, ok := m.clearedFields[menu.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *MenuMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, menu.FieldLevel)
}

// SetMenuType sets the "menu_type" field.
func (m *MenuMutation) SetMenuType(i int64) {
	m.menu_type = &i
	m.addmenu_type = nil
}

// MenuType returns the value of the "menu_type" field in the mutation.
func (m *MenuMutation) MenuType() (r int64, exists bool) {
	v := m.menu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuType returns the old "menu_type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuType: %w", err)
	}
	return oldValue.MenuType, nil
}

// AddMenuType adds i to the "menu_type" field.
func (m *MenuMutation) AddMenuType(i int64) {
	if m.addmenu_type != nil {
		*m.addmenu_type += i
	} else {
		m.addmenu_type = &i
	}
}

// AddedMenuType returns the value that was added to the "menu_type" field in this mutation.
func (m *MenuMutation) AddedMenuType() (r int64, exists bool) {
	v := m.addmenu_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearMenuType clears the value of the "menu_type" field.
func (m *MenuMutation) ClearMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
	m.clearedFields[menu.FieldMenuType] = struct{}{}
}

// MenuTypeCleared returns if the "menu_type" field was cleared in this mutation.
func (m *MenuMutation) MenuTypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldMenuType]
	return ok
}

// ResetMenuType resets all changes to the "menu_type" field.
func (m *MenuMutation) ResetMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
	delete(m.clearedFields, menu.FieldMenuType)
}

// SetRedirect sets the "redirect" field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of the "redirect" field.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the "redirect" field was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetURL sets the "url" field.
func (m *MenuMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *MenuMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *MenuMutation) ClearURL() {
	m.url = nil
	m.clearedFields[menu.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *MenuMutation) URLCleared() bool {
	_, ok := m.clearedFields[menu.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *MenuMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, menu.FieldURL)
}

// SetHidden sets the "hidden" field.
func (m *MenuMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *MenuMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *MenuMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[menu.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *MenuMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[menu.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *MenuMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, menu.FieldHidden)
}

// SetTitle sets the "title" field.
func (m *MenuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MenuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *MenuMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[menu.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *MenuMutation) TitleCleared() bool {
	_, ok := m.clearedFields[menu.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *MenuMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, menu.FieldTitle)
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetActiveMenu sets the "active_menu" field.
func (m *MenuMutation) SetActiveMenu(s string) {
	m.active_menu = &s
}

// ActiveMenu returns the value of the "active_menu" field in the mutation.
func (m *MenuMutation) ActiveMenu() (r string, exists bool) {
	v := m.active_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveMenu returns the old "active_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldActiveMenu(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveMenu: %w", err)
	}
	return oldValue.ActiveMenu, nil
}

// ClearActiveMenu clears the value of the "active_menu" field.
func (m *MenuMutation) ClearActiveMenu() {
	m.active_menu = nil
	m.clearedFields[menu.FieldActiveMenu] = struct{}{}
}

// ActiveMenuCleared returns if the "active_menu" field was cleared in this mutation.
func (m *MenuMutation) ActiveMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldActiveMenu]
	return ok
}

// ResetActiveMenu resets all changes to the "active_menu" field.
func (m *MenuMutation) ResetActiveMenu() {
	m.active_menu = nil
	delete(m.clearedFields, menu.FieldActiveMenu)
}

// SetAffix sets the "affix" field.
func (m *MenuMutation) SetAffix(b bool) {
	m.affix = &b
}

// Affix returns the value of the "affix" field in the mutation.
func (m *MenuMutation) Affix() (r bool, exists bool) {
	v := m.affix
	if v == nil {
		return
	}
	return *v, true
}

// OldAffix returns the old "affix" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldAffix(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffix: %w", err)
	}
	return oldValue.Affix, nil
}

// ClearAffix clears the value of the "affix" field.
func (m *MenuMutation) ClearAffix() {
	m.affix = nil
	m.clearedFields[menu.FieldAffix] = struct{}{}
}

// AffixCleared returns if the "affix" field was cleared in this mutation.
func (m *MenuMutation) AffixCleared() bool {
	_, ok := m.clearedFields[menu.FieldAffix]
	return ok
}

// ResetAffix resets all changes to the "affix" field.
func (m *MenuMutation) ResetAffix() {
	m.affix = nil
	delete(m.clearedFields, menu.FieldAffix)
}

// SetNoCache sets the "no_cache" field.
func (m *MenuMutation) SetNoCache(b bool) {
	m.no_cache = &b
}

// NoCache returns the value of the "no_cache" field in the mutation.
func (m *MenuMutation) NoCache() (r bool, exists bool) {
	v := m.no_cache
	if v == nil {
		return
	}
	return *v, true
}

// OldNoCache returns the old "no_cache" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldNoCache(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoCache is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoCache requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoCache: %w", err)
	}
	return oldValue.NoCache, nil
}

// ClearNoCache clears the value of the "no_cache" field.
func (m *MenuMutation) ClearNoCache() {
	m.no_cache = nil
	m.clearedFields[menu.FieldNoCache] = struct{}{}
}

// NoCacheCleared returns if the "no_cache" field was cleared in this mutation.
func (m *MenuMutation) NoCacheCleared() bool {
	_, ok := m.clearedFields[menu.FieldNoCache]
	return ok
}

// ResetNoCache resets all changes to the "no_cache" field.
func (m *MenuMutation) ResetNoCache() {
	m.no_cache = nil
	delete(m.clearedFields, menu.FieldNoCache)
}

// SetType sets the "type" field.
func (m *MenuMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MenuMutation) ClearType() {
	m._type = nil
	m.clearedFields[menu.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MenuMutation) TypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MenuMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, menu.FieldType)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddParamIDs adds the "params" edge to the MenuParam entity by ids.
func (m *MenuMutation) AddParamIDs(ids ...int64) {
	if m.params == nil {
		m.params = make(map[int64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the MenuParam entity.
func (m *MenuMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the MenuParam entity was cleared.
func (m *MenuMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the MenuParam entity by IDs.
func (m *MenuMutation) RemoveParamIDs(ids ...int64) {
	if m.removedparams == nil {
		m.removedparams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the MenuParam entity.
func (m *MenuMutation) RemovedParamsIDs() (ids []int64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *MenuMutation) ParamsIDs() (ids []int64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *MenuMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.disabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.ignore != nil {
		fields = append(fields, menu.FieldIgnore)
	}
	if m.level != nil {
		fields = append(fields, menu.FieldLevel)
	}
	if m.menu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.url != nil {
		fields = append(fields, menu.FieldURL)
	}
	if m.hidden != nil {
		fields = append(fields, menu.FieldHidden)
	}
	if m.title != nil {
		fields = append(fields, menu.FieldTitle)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.active_menu != nil {
		fields = append(fields, menu.FieldActiveMenu)
	}
	if m.affix != nil {
		fields = append(fields, menu.FieldAffix)
	}
	if m.no_cache != nil {
		fields = append(fields, menu.FieldNoCache)
	}
	if m._type != nil {
		fields = append(fields, menu.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldDelete:
		return m.Delete()
	case menu.FieldCreatedID:
		return m.CreatedID()
	case menu.FieldStatus:
		return m.Status()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldSort:
		return m.Sort()
	case menu.FieldDisabled:
		return m.Disabled()
	case menu.FieldIgnore:
		return m.Ignore()
	case menu.FieldLevel:
		return m.Level()
	case menu.FieldMenuType:
		return m.MenuType()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldURL:
		return m.URL()
	case menu.FieldHidden:
		return m.Hidden()
	case menu.FieldTitle:
		return m.Title()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldActiveMenu:
		return m.ActiveMenu()
	case menu.FieldAffix:
		return m.Affix()
	case menu.FieldNoCache:
		return m.NoCache()
	case menu.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldDelete:
		return m.OldDelete(ctx)
	case menu.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case menu.FieldStatus:
		return m.OldStatus(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldSort:
		return m.OldSort(ctx)
	case menu.FieldDisabled:
		return m.OldDisabled(ctx)
	case menu.FieldIgnore:
		return m.OldIgnore(ctx)
	case menu.FieldLevel:
		return m.OldLevel(ctx)
	case menu.FieldMenuType:
		return m.OldMenuType(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldURL:
		return m.OldURL(ctx)
	case menu.FieldHidden:
		return m.OldHidden(ctx)
	case menu.FieldTitle:
		return m.OldTitle(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldActiveMenu:
		return m.OldActiveMenu(ctx)
	case menu.FieldAffix:
		return m.OldAffix(ctx)
	case menu.FieldNoCache:
		return m.OldNoCache(ctx)
	case menu.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case menu.FieldIgnore:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnore(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuType(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case menu.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case menu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldActiveMenu:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveMenu(v)
		return nil
	case menu.FieldAffix:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffix(v)
		return nil
	case menu.FieldNoCache:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoCache(v)
		return nil
	case menu.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.adddisabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.addlevel != nil {
		fields = append(fields, menu.FieldLevel)
	}
	if m.addmenu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldDelete:
		return m.AddedDelete()
	case menu.FieldCreatedID:
		return m.AddedCreatedID()
	case menu.FieldStatus:
		return m.AddedStatus()
	case menu.FieldSort:
		return m.AddedSort()
	case menu.FieldDisabled:
		return m.AddedDisabled()
	case menu.FieldLevel:
		return m.AddedLevel()
	case menu.FieldMenuType:
		return m.AddedMenuType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabled(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuType(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldCreatedAt) {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.FieldCleared(menu.FieldUpdatedAt) {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.FieldCleared(menu.FieldDelete) {
		fields = append(fields, menu.FieldDelete)
	}
	if m.FieldCleared(menu.FieldCreatedID) {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.FieldCleared(menu.FieldStatus) {
		fields = append(fields, menu.FieldStatus)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldName) {
		fields = append(fields, menu.FieldName)
	}
	if m.FieldCleared(menu.FieldSort) {
		fields = append(fields, menu.FieldSort)
	}
	if m.FieldCleared(menu.FieldDisabled) {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.FieldCleared(menu.FieldIgnore) {
		fields = append(fields, menu.FieldIgnore)
	}
	if m.FieldCleared(menu.FieldLevel) {
		fields = append(fields, menu.FieldLevel)
	}
	if m.FieldCleared(menu.FieldMenuType) {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldURL) {
		fields = append(fields, menu.FieldURL)
	}
	if m.FieldCleared(menu.FieldHidden) {
		fields = append(fields, menu.FieldHidden)
	}
	if m.FieldCleared(menu.FieldTitle) {
		fields = append(fields, menu.FieldTitle)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldActiveMenu) {
		fields = append(fields, menu.FieldActiveMenu)
	}
	if m.FieldCleared(menu.FieldAffix) {
		fields = append(fields, menu.FieldAffix)
	}
	if m.FieldCleared(menu.FieldNoCache) {
		fields = append(fields, menu.FieldNoCache)
	}
	if m.FieldCleared(menu.FieldType) {
		fields = append(fields, menu.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ClearDelete()
		return nil
	case menu.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case menu.FieldStatus:
		m.ClearStatus()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldName:
		m.ClearName()
		return nil
	case menu.FieldSort:
		m.ClearSort()
		return nil
	case menu.FieldDisabled:
		m.ClearDisabled()
		return nil
	case menu.FieldIgnore:
		m.ClearIgnore()
		return nil
	case menu.FieldLevel:
		m.ClearLevel()
		return nil
	case menu.FieldMenuType:
		m.ClearMenuType()
		return nil
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldURL:
		m.ClearURL()
		return nil
	case menu.FieldHidden:
		m.ClearHidden()
		return nil
	case menu.FieldTitle:
		m.ClearTitle()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldActiveMenu:
		m.ClearActiveMenu()
		return nil
	case menu.FieldAffix:
		m.ClearAffix()
		return nil
	case menu.FieldNoCache:
		m.ClearNoCache()
		return nil
	case menu.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ResetDelete()
		return nil
	case menu.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case menu.FieldStatus:
		m.ResetStatus()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldSort:
		m.ResetSort()
		return nil
	case menu.FieldDisabled:
		m.ResetDisabled()
		return nil
	case menu.FieldIgnore:
		m.ResetIgnore()
		return nil
	case menu.FieldLevel:
		m.ResetLevel()
		return nil
	case menu.FieldMenuType:
		m.ResetMenuType()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldURL:
		m.ResetURL()
		return nil
	case menu.FieldHidden:
		m.ResetHidden()
		return nil
	case menu.FieldTitle:
		m.ResetTitle()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldActiveMenu:
		m.ResetActiveMenu()
		return nil
	case menu.FieldAffix:
		m.ResetAffix()
		return nil
	case menu.FieldNoCache:
		m.ResetNoCache()
		return nil
	case menu.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.params != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedparams != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedparams {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeParams:
		return m.clearedparams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuParamMutation represents an operation that mutates the MenuParam nodes in the graph.
type MenuParamMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	key           *string
	value         *string
	clearedFields map[string]struct{}
	menus         *int64
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*MenuParam, error)
	predicates    []predicate.MenuParam
}

var _ ent.Mutation = (*MenuParamMutation)(nil)

// menuparamOption allows management of the mutation configuration using functional options.
type menuparamOption func(*MenuParamMutation)

// newMenuParamMutation creates new mutation for the MenuParam entity.
func newMenuParamMutation(c config, op Op, opts ...menuparamOption) *MenuParamMutation {
	m := &MenuParamMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuParamID sets the ID field of the mutation.
func withMenuParamID(id int64) menuparamOption {
	return func(m *MenuParamMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuParam
		)
		m.oldValue = func(ctx context.Context) (*MenuParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuParam sets the old MenuParam of the mutation.
func withMenuParam(node *MenuParam) menuparamOption {
	return func(m *MenuParamMutation) {
		m.oldValue = func(context.Context) (*MenuParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuParam entities.
func (m *MenuParamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuParamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuParamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuParamMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menuparam.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuParamMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuParamMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menuparam.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuParamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menuparam.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuParamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menuparam.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MenuParamMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MenuParamMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MenuParamMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MenuParamMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MenuParamMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[menuparam.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MenuParamMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MenuParamMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, menuparam.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MenuParamMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MenuParamMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MenuParamMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MenuParamMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MenuParamMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[menuparam.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MenuParamMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MenuParamMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, menuparam.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *MenuParamMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuParamMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MenuParamMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *MenuParamMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *MenuParamMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *MenuParamMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *MenuParamMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MenuParamMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MenuParamMutation) ResetValue() {
	m.value = nil
}

// SetMenusID sets the "menus" edge to the Menu entity by id.
func (m *MenuParamMutation) SetMenusID(id int64) {
	m.menus = &id
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *MenuParamMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *MenuParamMutation) MenusCleared() bool {
	return m.clearedmenus
}

// MenusID returns the "menus" edge ID in the mutation.
func (m *MenuParamMutation) MenusID() (id int64, exists bool) {
	if m.menus != nil {
		return *m.menus, true
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenusID instead. It exists only for internal usage by the builders.
func (m *MenuParamMutation) MenusIDs() (ids []int64) {
	if id := m.menus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *MenuParamMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
}

// Where appends a list predicates to the MenuParamMutation builder.
func (m *MenuParamMutation) Where(ps ...predicate.MenuParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuParam).
func (m *MenuParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuParamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, menuparam.FieldType)
	}
	if m.key != nil {
		fields = append(fields, menuparam.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, menuparam.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.CreatedAt()
	case menuparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuparam.FieldDelete:
		return m.Delete()
	case menuparam.FieldCreatedID:
		return m.CreatedID()
	case menuparam.FieldType:
		return m.GetType()
	case menuparam.FieldKey:
		return m.Key()
	case menuparam.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuparam.FieldDelete:
		return m.OldDelete(ctx)
	case menuparam.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case menuparam.FieldType:
		return m.OldType(ctx)
	case menuparam.FieldKey:
		return m.OldKey(ctx)
	case menuparam.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown MenuParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuparam.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case menuparam.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case menuparam.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menuparam.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case menuparam.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuParamMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuParamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldDelete:
		return m.AddedDelete()
	case menuparam.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case menuparam.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuParamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menuparam.FieldCreatedAt) {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.FieldCleared(menuparam.FieldUpdatedAt) {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m.FieldCleared(menuparam.FieldDelete) {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.FieldCleared(menuparam.FieldCreatedID) {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuParamMutation) ClearField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menuparam.FieldDelete:
		m.ClearDelete()
		return nil
	case menuparam.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown MenuParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuParamMutation) ResetField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuparam.FieldDelete:
		m.ResetDelete()
		return nil
	case menuparam.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case menuparam.FieldType:
		m.ResetType()
		return nil
	case menuparam.FieldKey:
		m.ResetKey()
		return nil
	case menuparam.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuparam.EdgeMenus:
		if id := m.menus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuParamMutation) EdgeCleared(name string) bool {
	switch name {
	case menuparam.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuParamMutation) ClearEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ClearMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuParamMutation) ResetEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam edge %s", name)
}

// MessagesMutation represents an operation that mutates the Messages nodes in the graph.
type MessagesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	to_user_id    *string
	from_user_id  *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Messages, error)
	predicates    []predicate.Messages
}

var _ ent.Mutation = (*MessagesMutation)(nil)

// messagesOption allows management of the mutation configuration using functional options.
type messagesOption func(*MessagesMutation)

// newMessagesMutation creates new mutation for the Messages entity.
func newMessagesMutation(c config, op Op, opts ...messagesOption) *MessagesMutation {
	m := &MessagesMutation{
		config:        c,
		op:            op,
		typ:           TypeMessages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesID sets the ID field of the mutation.
func withMessagesID(id int64) messagesOption {
	return func(m *MessagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Messages
		)
		m.oldValue = func(ctx context.Context) (*Messages, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Messages.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessages sets the old Messages of the mutation.
func withMessages(node *Messages) messagesOption {
	return func(m *MessagesMutation) {
		m.oldValue = func(context.Context) (*Messages, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Messages entities.
func (m *MessagesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Messages.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MessagesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[messages.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MessagesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, messages.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MessagesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[messages.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MessagesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, messages.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MessagesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MessagesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MessagesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MessagesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MessagesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[messages.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MessagesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[messages.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MessagesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, messages.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MessagesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MessagesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MessagesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MessagesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MessagesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[messages.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MessagesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MessagesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, messages.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *MessagesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessagesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessagesMutation) ResetType() {
	m._type = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *MessagesMutation) SetToUserID(s string) {
	m.to_user_id = &s
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *MessagesMutation) ToUserID() (r string, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldToUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *MessagesMutation) ResetToUserID() {
	m.to_user_id = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *MessagesMutation) SetFromUserID(s string) {
	m.from_user_id = &s
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *MessagesMutation) FromUserID() (r string, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldFromUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *MessagesMutation) ResetFromUserID() {
	m.from_user_id = nil
}

// SetContent sets the "content" field.
func (m *MessagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessagesMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the MessagesMutation builder.
func (m *MessagesMutation) Where(ps ...predicate.Messages) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Messages, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Messages).
func (m *MessagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, messages.FieldType)
	}
	if m.to_user_id != nil {
		fields = append(fields, messages.FieldToUserID)
	}
	if m.from_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.content != nil {
		fields = append(fields, messages.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldCreatedAt:
		return m.CreatedAt()
	case messages.FieldUpdatedAt:
		return m.UpdatedAt()
	case messages.FieldDelete:
		return m.Delete()
	case messages.FieldCreatedID:
		return m.CreatedID()
	case messages.FieldType:
		return m.GetType()
	case messages.FieldToUserID:
		return m.ToUserID()
	case messages.FieldFromUserID:
		return m.FromUserID()
	case messages.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messages.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messages.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messages.FieldDelete:
		return m.OldDelete(ctx)
	case messages.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case messages.FieldType:
		return m.OldType(ctx)
	case messages.FieldToUserID:
		return m.OldToUserID(ctx)
	case messages.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case messages.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Messages field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messages.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messages.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case messages.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case messages.FieldToUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case messages.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldDelete:
		return m.AddedDelete()
	case messages.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown Messages numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(messages.FieldCreatedAt) {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.FieldCleared(messages.FieldUpdatedAt) {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.FieldCleared(messages.FieldDelete) {
		fields = append(fields, messages.FieldDelete)
	}
	if m.FieldCleared(messages.FieldCreatedID) {
		fields = append(fields, messages.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesMutation) ClearField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ClearDelete()
		return nil
	case messages.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown Messages nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesMutation) ResetField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ResetDelete()
		return nil
	case messages.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case messages.FieldType:
		m.ResetType()
		return nil
	case messages.FieldToUserID:
		m.ResetToUserID()
		return nil
	case messages.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case messages.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Messages unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Messages edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	delete                *int64
	adddelete             *int64
	order_sn              *string
	nature                *string
	product_type          *string
	status                *int64
	addstatus             *int64
	source                *string
	device                *string
	completion_at         *time.Time
	clearedFields         map[string]struct{}
	amount                map[int64]struct{}
	removedamount         map[int64]struct{}
	clearedamount         bool
	item                  map[int64]struct{}
	removeditem           map[int64]struct{}
	cleareditem           bool
	pay                   map[int64]struct{}
	removedpay            map[int64]struct{}
	clearedpay            bool
	order_contents        map[int64]struct{}
	removedorder_contents map[int64]struct{}
	clearedorder_contents bool
	sales                 map[int64]struct{}
	removedsales          map[int64]struct{}
	clearedsales          bool
	order_venues          *int64
	clearedorder_venues   bool
	order_members         *int64
	clearedorder_members  bool
	order_creates         *int64
	clearedorder_creates  bool
	done                  bool
	oldValue              func(context.Context) (*Order, error)
	predicates            []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[order.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, order.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[order.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, order.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[order.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[order.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, order.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderMutation) SetCreatedID(i int64) {
	m.order_creates = &i
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderMutation) CreatedID() (r int64, exists bool) {
	v := m.order_creates
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderMutation) ClearCreatedID() {
	m.order_creates = nil
	m.clearedFields[order.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[order.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderMutation) ResetCreatedID() {
	m.order_creates = nil
	delete(m.clearedFields, order.FieldCreatedID)
}

// SetOrderSn sets the "order_sn" field.
func (m *OrderMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *OrderMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *OrderMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[order.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *OrderMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[order.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *OrderMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, order.FieldOrderSn)
}

// SetVenueID sets the "venue_id" field.
func (m *OrderMutation) SetVenueID(i int64) {
	m.order_venues = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *OrderMutation) VenueID() (r int64, exists bool) {
	v := m.order_venues
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *OrderMutation) ClearVenueID() {
	m.order_venues = nil
	m.clearedFields[order.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *OrderMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[order.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *OrderMutation) ResetVenueID() {
	m.order_venues = nil
	delete(m.clearedFields, order.FieldVenueID)
}

// SetMemberID sets the "member_id" field.
func (m *OrderMutation) SetMemberID(i int64) {
	m.order_members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OrderMutation) MemberID() (r int64, exists bool) {
	v := m.order_members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *OrderMutation) ClearMemberID() {
	m.order_members = nil
	m.clearedFields[order.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *OrderMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[order.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OrderMutation) ResetMemberID() {
	m.order_members = nil
	delete(m.clearedFields, order.FieldMemberID)
}

// SetNature sets the "nature" field.
func (m *OrderMutation) SetNature(s string) {
	m.nature = &s
}

// Nature returns the value of the "nature" field in the mutation.
func (m *OrderMutation) Nature() (r string, exists bool) {
	v := m.nature
	if v == nil {
		return
	}
	return *v, true
}

// OldNature returns the old "nature" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNature: %w", err)
	}
	return oldValue.Nature, nil
}

// ClearNature clears the value of the "nature" field.
func (m *OrderMutation) ClearNature() {
	m.nature = nil
	m.clearedFields[order.FieldNature] = struct{}{}
}

// NatureCleared returns if the "nature" field was cleared in this mutation.
func (m *OrderMutation) NatureCleared() bool {
	_, ok := m.clearedFields[order.FieldNature]
	return ok
}

// ResetNature resets all changes to the "nature" field.
func (m *OrderMutation) ResetNature() {
	m.nature = nil
	delete(m.clearedFields, order.FieldNature)
}

// SetProductType sets the "product_type" field.
func (m *OrderMutation) SetProductType(s string) {
	m.product_type = &s
}

// ProductType returns the value of the "product_type" field in the mutation.
func (m *OrderMutation) ProductType() (r string, exists bool) {
	v := m.product_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProductType returns the old "product_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldProductType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductType: %w", err)
	}
	return oldValue.ProductType, nil
}

// ClearProductType clears the value of the "product_type" field.
func (m *OrderMutation) ClearProductType() {
	m.product_type = nil
	m.clearedFields[order.FieldProductType] = struct{}{}
}

// ProductTypeCleared returns if the "product_type" field was cleared in this mutation.
func (m *OrderMutation) ProductTypeCleared() bool {
	_, ok := m.clearedFields[order.FieldProductType]
	return ok
}

// ResetProductType resets all changes to the "product_type" field.
func (m *OrderMutation) ResetProductType() {
	m.product_type = nil
	delete(m.clearedFields, order.FieldProductType)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[order.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[order.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, order.FieldStatus)
}

// SetSource sets the "source" field.
func (m *OrderMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *OrderMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *OrderMutation) ClearSource() {
	m.source = nil
	m.clearedFields[order.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *OrderMutation) SourceCleared() bool {
	_, ok := m.clearedFields[order.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *OrderMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, order.FieldSource)
}

// SetDevice sets the "device" field.
func (m *OrderMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *OrderMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *OrderMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[order.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *OrderMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[order.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *OrderMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, order.FieldDevice)
}

// SetCompletionAt sets the "completion_at" field.
func (m *OrderMutation) SetCompletionAt(t time.Time) {
	m.completion_at = &t
}

// CompletionAt returns the value of the "completion_at" field in the mutation.
func (m *OrderMutation) CompletionAt() (r time.Time, exists bool) {
	v := m.completion_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAt returns the old "completion_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCompletionAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAt: %w", err)
	}
	return oldValue.CompletionAt, nil
}

// ClearCompletionAt clears the value of the "completion_at" field.
func (m *OrderMutation) ClearCompletionAt() {
	m.completion_at = nil
	m.clearedFields[order.FieldCompletionAt] = struct{}{}
}

// CompletionAtCleared returns if the "completion_at" field was cleared in this mutation.
func (m *OrderMutation) CompletionAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCompletionAt]
	return ok
}

// ResetCompletionAt resets all changes to the "completion_at" field.
func (m *OrderMutation) ResetCompletionAt() {
	m.completion_at = nil
	delete(m.clearedFields, order.FieldCompletionAt)
}

// AddAmountIDs adds the "amount" edge to the OrderAmount entity by ids.
func (m *OrderMutation) AddAmountIDs(ids ...int64) {
	if m.amount == nil {
		m.amount = make(map[int64]struct{})
	}
	for i := range ids {
		m.amount[ids[i]] = struct{}{}
	}
}

// ClearAmount clears the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) ClearAmount() {
	m.clearedamount = true
}

// AmountCleared reports if the "amount" edge to the OrderAmount entity was cleared.
func (m *OrderMutation) AmountCleared() bool {
	return m.clearedamount
}

// RemoveAmountIDs removes the "amount" edge to the OrderAmount entity by IDs.
func (m *OrderMutation) RemoveAmountIDs(ids ...int64) {
	if m.removedamount == nil {
		m.removedamount = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.amount, ids[i])
		m.removedamount[ids[i]] = struct{}{}
	}
}

// RemovedAmount returns the removed IDs of the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) RemovedAmountIDs() (ids []int64) {
	for id := range m.removedamount {
		ids = append(ids, id)
	}
	return
}

// AmountIDs returns the "amount" edge IDs in the mutation.
func (m *OrderMutation) AmountIDs() (ids []int64) {
	for id := range m.amount {
		ids = append(ids, id)
	}
	return
}

// ResetAmount resets all changes to the "amount" edge.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.clearedamount = false
	m.removedamount = nil
}

// AddItemIDs adds the "item" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddItemIDs(ids ...int64) {
	if m.item == nil {
		m.item = make(map[int64]struct{})
	}
	for i := range ids {
		m.item[ids[i]] = struct{}{}
	}
}

// ClearItem clears the "item" edge to the OrderItem entity.
func (m *OrderMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the OrderItem entity was cleared.
func (m *OrderMutation) ItemCleared() bool {
	return m.cleareditem
}

// RemoveItemIDs removes the "item" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveItemIDs(ids ...int64) {
	if m.removeditem == nil {
		m.removeditem = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.item, ids[i])
		m.removeditem[ids[i]] = struct{}{}
	}
}

// RemovedItem returns the removed IDs of the "item" edge to the OrderItem entity.
func (m *OrderMutation) RemovedItemIDs() (ids []int64) {
	for id := range m.removeditem {
		ids = append(ids, id)
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
func (m *OrderMutation) ItemIDs() (ids []int64) {
	for id := range m.item {
		ids = append(ids, id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *OrderMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
	m.removeditem = nil
}

// AddPayIDs adds the "pay" edge to the OrderPay entity by ids.
func (m *OrderMutation) AddPayIDs(ids ...int64) {
	if m.pay == nil {
		m.pay = make(map[int64]struct{})
	}
	for i := range ids {
		m.pay[ids[i]] = struct{}{}
	}
}

// ClearPay clears the "pay" edge to the OrderPay entity.
func (m *OrderMutation) ClearPay() {
	m.clearedpay = true
}

// PayCleared reports if the "pay" edge to the OrderPay entity was cleared.
func (m *OrderMutation) PayCleared() bool {
	return m.clearedpay
}

// RemovePayIDs removes the "pay" edge to the OrderPay entity by IDs.
func (m *OrderMutation) RemovePayIDs(ids ...int64) {
	if m.removedpay == nil {
		m.removedpay = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.pay, ids[i])
		m.removedpay[ids[i]] = struct{}{}
	}
}

// RemovedPay returns the removed IDs of the "pay" edge to the OrderPay entity.
func (m *OrderMutation) RemovedPayIDs() (ids []int64) {
	for id := range m.removedpay {
		ids = append(ids, id)
	}
	return
}

// PayIDs returns the "pay" edge IDs in the mutation.
func (m *OrderMutation) PayIDs() (ids []int64) {
	for id := range m.pay {
		ids = append(ids, id)
	}
	return
}

// ResetPay resets all changes to the "pay" edge.
func (m *OrderMutation) ResetPay() {
	m.pay = nil
	m.clearedpay = false
	m.removedpay = nil
}

// AddOrderContentIDs adds the "order_contents" edge to the MemberContract entity by ids.
func (m *OrderMutation) AddOrderContentIDs(ids ...int64) {
	if m.order_contents == nil {
		m.order_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_contents[ids[i]] = struct{}{}
	}
}

// ClearOrderContents clears the "order_contents" edge to the MemberContract entity.
func (m *OrderMutation) ClearOrderContents() {
	m.clearedorder_contents = true
}

// OrderContentsCleared reports if the "order_contents" edge to the MemberContract entity was cleared.
func (m *OrderMutation) OrderContentsCleared() bool {
	return m.clearedorder_contents
}

// RemoveOrderContentIDs removes the "order_contents" edge to the MemberContract entity by IDs.
func (m *OrderMutation) RemoveOrderContentIDs(ids ...int64) {
	if m.removedorder_contents == nil {
		m.removedorder_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_contents, ids[i])
		m.removedorder_contents[ids[i]] = struct{}{}
	}
}

// RemovedOrderContents returns the removed IDs of the "order_contents" edge to the MemberContract entity.
func (m *OrderMutation) RemovedOrderContentsIDs() (ids []int64) {
	for id := range m.removedorder_contents {
		ids = append(ids, id)
	}
	return
}

// OrderContentsIDs returns the "order_contents" edge IDs in the mutation.
func (m *OrderMutation) OrderContentsIDs() (ids []int64) {
	for id := range m.order_contents {
		ids = append(ids, id)
	}
	return
}

// ResetOrderContents resets all changes to the "order_contents" edge.
func (m *OrderMutation) ResetOrderContents() {
	m.order_contents = nil
	m.clearedorder_contents = false
	m.removedorder_contents = nil
}

// AddSaleIDs adds the "sales" edge to the OrderSales entity by ids.
func (m *OrderMutation) AddSaleIDs(ids ...int64) {
	if m.sales == nil {
		m.sales = make(map[int64]struct{})
	}
	for i := range ids {
		m.sales[ids[i]] = struct{}{}
	}
}

// ClearSales clears the "sales" edge to the OrderSales entity.
func (m *OrderMutation) ClearSales() {
	m.clearedsales = true
}

// SalesCleared reports if the "sales" edge to the OrderSales entity was cleared.
func (m *OrderMutation) SalesCleared() bool {
	return m.clearedsales
}

// RemoveSaleIDs removes the "sales" edge to the OrderSales entity by IDs.
func (m *OrderMutation) RemoveSaleIDs(ids ...int64) {
	if m.removedsales == nil {
		m.removedsales = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sales, ids[i])
		m.removedsales[ids[i]] = struct{}{}
	}
}

// RemovedSales returns the removed IDs of the "sales" edge to the OrderSales entity.
func (m *OrderMutation) RemovedSalesIDs() (ids []int64) {
	for id := range m.removedsales {
		ids = append(ids, id)
	}
	return
}

// SalesIDs returns the "sales" edge IDs in the mutation.
func (m *OrderMutation) SalesIDs() (ids []int64) {
	for id := range m.sales {
		ids = append(ids, id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *OrderMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
	m.removedsales = nil
}

// SetOrderVenuesID sets the "order_venues" edge to the Venue entity by id.
func (m *OrderMutation) SetOrderVenuesID(id int64) {
	m.order_venues = &id
}

// ClearOrderVenues clears the "order_venues" edge to the Venue entity.
func (m *OrderMutation) ClearOrderVenues() {
	m.clearedorder_venues = true
	m.clearedFields[order.FieldVenueID] = struct{}{}
}

// OrderVenuesCleared reports if the "order_venues" edge to the Venue entity was cleared.
func (m *OrderMutation) OrderVenuesCleared() bool {
	return m.VenueIDCleared() || m.clearedorder_venues
}

// OrderVenuesID returns the "order_venues" edge ID in the mutation.
func (m *OrderMutation) OrderVenuesID() (id int64, exists bool) {
	if m.order_venues != nil {
		return *m.order_venues, true
	}
	return
}

// OrderVenuesIDs returns the "order_venues" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderVenuesID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderVenuesIDs() (ids []int64) {
	if id := m.order_venues; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderVenues resets all changes to the "order_venues" edge.
func (m *OrderMutation) ResetOrderVenues() {
	m.order_venues = nil
	m.clearedorder_venues = false
}

// SetOrderMembersID sets the "order_members" edge to the Member entity by id.
func (m *OrderMutation) SetOrderMembersID(id int64) {
	m.order_members = &id
}

// ClearOrderMembers clears the "order_members" edge to the Member entity.
func (m *OrderMutation) ClearOrderMembers() {
	m.clearedorder_members = true
	m.clearedFields[order.FieldMemberID] = struct{}{}
}

// OrderMembersCleared reports if the "order_members" edge to the Member entity was cleared.
func (m *OrderMutation) OrderMembersCleared() bool {
	return m.MemberIDCleared() || m.clearedorder_members
}

// OrderMembersID returns the "order_members" edge ID in the mutation.
func (m *OrderMutation) OrderMembersID() (id int64, exists bool) {
	if m.order_members != nil {
		return *m.order_members, true
	}
	return
}

// OrderMembersIDs returns the "order_members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderMembersID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderMembersIDs() (ids []int64) {
	if id := m.order_members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderMembers resets all changes to the "order_members" edge.
func (m *OrderMutation) ResetOrderMembers() {
	m.order_members = nil
	m.clearedorder_members = false
}

// SetOrderCreatesID sets the "order_creates" edge to the User entity by id.
func (m *OrderMutation) SetOrderCreatesID(id int64) {
	m.order_creates = &id
}

// ClearOrderCreates clears the "order_creates" edge to the User entity.
func (m *OrderMutation) ClearOrderCreates() {
	m.clearedorder_creates = true
	m.clearedFields[order.FieldCreatedID] = struct{}{}
}

// OrderCreatesCleared reports if the "order_creates" edge to the User entity was cleared.
func (m *OrderMutation) OrderCreatesCleared() bool {
	return m.CreatedIDCleared() || m.clearedorder_creates
}

// OrderCreatesID returns the "order_creates" edge ID in the mutation.
func (m *OrderMutation) OrderCreatesID() (id int64, exists bool) {
	if m.order_creates != nil {
		return *m.order_creates, true
	}
	return
}

// OrderCreatesIDs returns the "order_creates" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderCreatesID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderCreatesIDs() (ids []int64) {
	if id := m.order_creates; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderCreates resets all changes to the "order_creates" edge.
func (m *OrderMutation) ResetOrderCreates() {
	m.order_creates = nil
	m.clearedorder_creates = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, order.FieldDelete)
	}
	if m.order_creates != nil {
		fields = append(fields, order.FieldCreatedID)
	}
	if m.order_sn != nil {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.order_venues != nil {
		fields = append(fields, order.FieldVenueID)
	}
	if m.order_members != nil {
		fields = append(fields, order.FieldMemberID)
	}
	if m.nature != nil {
		fields = append(fields, order.FieldNature)
	}
	if m.product_type != nil {
		fields = append(fields, order.FieldProductType)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, order.FieldSource)
	}
	if m.device != nil {
		fields = append(fields, order.FieldDevice)
	}
	if m.completion_at != nil {
		fields = append(fields, order.FieldCompletionAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldDelete:
		return m.Delete()
	case order.FieldCreatedID:
		return m.CreatedID()
	case order.FieldOrderSn:
		return m.OrderSn()
	case order.FieldVenueID:
		return m.VenueID()
	case order.FieldMemberID:
		return m.MemberID()
	case order.FieldNature:
		return m.Nature()
	case order.FieldProductType:
		return m.ProductType()
	case order.FieldStatus:
		return m.Status()
	case order.FieldSource:
		return m.Source()
	case order.FieldDevice:
		return m.Device()
	case order.FieldCompletionAt:
		return m.CompletionAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldDelete:
		return m.OldDelete(ctx)
	case order.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case order.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case order.FieldVenueID:
		return m.OldVenueID(ctx)
	case order.FieldMemberID:
		return m.OldMemberID(ctx)
	case order.FieldNature:
		return m.OldNature(ctx)
	case order.FieldProductType:
		return m.OldProductType(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldSource:
		return m.OldSource(ctx)
	case order.FieldDevice:
		return m.OldDevice(ctx)
	case order.FieldCompletionAt:
		return m.OldCompletionAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case order.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case order.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case order.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case order.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case order.FieldNature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNature(v)
		return nil
	case order.FieldProductType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductType(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case order.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case order.FieldCompletionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, order.FieldDelete)
	}
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldDelete:
		return m.AddedDelete()
	case order.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldCreatedAt) {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.FieldCleared(order.FieldUpdatedAt) {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.FieldCleared(order.FieldDelete) {
		fields = append(fields, order.FieldDelete)
	}
	if m.FieldCleared(order.FieldCreatedID) {
		fields = append(fields, order.FieldCreatedID)
	}
	if m.FieldCleared(order.FieldOrderSn) {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.FieldCleared(order.FieldVenueID) {
		fields = append(fields, order.FieldVenueID)
	}
	if m.FieldCleared(order.FieldMemberID) {
		fields = append(fields, order.FieldMemberID)
	}
	if m.FieldCleared(order.FieldNature) {
		fields = append(fields, order.FieldNature)
	}
	if m.FieldCleared(order.FieldProductType) {
		fields = append(fields, order.FieldProductType)
	}
	if m.FieldCleared(order.FieldStatus) {
		fields = append(fields, order.FieldStatus)
	}
	if m.FieldCleared(order.FieldSource) {
		fields = append(fields, order.FieldSource)
	}
	if m.FieldCleared(order.FieldDevice) {
		fields = append(fields, order.FieldDevice)
	}
	if m.FieldCleared(order.FieldCompletionAt) {
		fields = append(fields, order.FieldCompletionAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case order.FieldDelete:
		m.ClearDelete()
		return nil
	case order.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case order.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case order.FieldVenueID:
		m.ClearVenueID()
		return nil
	case order.FieldMemberID:
		m.ClearMemberID()
		return nil
	case order.FieldNature:
		m.ClearNature()
		return nil
	case order.FieldProductType:
		m.ClearProductType()
		return nil
	case order.FieldStatus:
		m.ClearStatus()
		return nil
	case order.FieldSource:
		m.ClearSource()
		return nil
	case order.FieldDevice:
		m.ClearDevice()
		return nil
	case order.FieldCompletionAt:
		m.ClearCompletionAt()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldDelete:
		m.ResetDelete()
		return nil
	case order.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case order.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case order.FieldVenueID:
		m.ResetVenueID()
		return nil
	case order.FieldMemberID:
		m.ResetMemberID()
		return nil
	case order.FieldNature:
		m.ResetNature()
		return nil
	case order.FieldProductType:
		m.ResetProductType()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldSource:
		m.ResetSource()
		return nil
	case order.FieldDevice:
		m.ResetDevice()
		return nil
	case order.FieldCompletionAt:
		m.ResetCompletionAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.amount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.item != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.pay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.order_contents != nil {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.sales != nil {
		edges = append(edges, order.EdgeSales)
	}
	if m.order_venues != nil {
		edges = append(edges, order.EdgeOrderVenues)
	}
	if m.order_members != nil {
		edges = append(edges, order.EdgeOrderMembers)
	}
	if m.order_creates != nil {
		edges = append(edges, order.EdgeOrderCreates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.amount))
		for id := range m.amount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.item))
		for id := range m.item {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.pay))
		for id := range m.pay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderContents:
		ids := make([]ent.Value, 0, len(m.order_contents))
		for id := range m.order_contents {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.sales))
		for id := range m.sales {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderVenues:
		if id := m.order_venues; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderMembers:
		if id := m.order_members; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderCreates:
		if id := m.order_creates; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedamount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.removeditem != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.removedpay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.removedorder_contents != nil {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.removedsales != nil {
		edges = append(edges, order.EdgeSales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.removedamount))
		for id := range m.removedamount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.removeditem))
		for id := range m.removeditem {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.removedpay))
		for id := range m.removedpay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderContents:
		ids := make([]ent.Value, 0, len(m.removedorder_contents))
		for id := range m.removedorder_contents {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.removedsales))
		for id := range m.removedsales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedamount {
		edges = append(edges, order.EdgeAmount)
	}
	if m.cleareditem {
		edges = append(edges, order.EdgeItem)
	}
	if m.clearedpay {
		edges = append(edges, order.EdgePay)
	}
	if m.clearedorder_contents {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.clearedsales {
		edges = append(edges, order.EdgeSales)
	}
	if m.clearedorder_venues {
		edges = append(edges, order.EdgeOrderVenues)
	}
	if m.clearedorder_members {
		edges = append(edges, order.EdgeOrderMembers)
	}
	if m.clearedorder_creates {
		edges = append(edges, order.EdgeOrderCreates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeAmount:
		return m.clearedamount
	case order.EdgeItem:
		return m.cleareditem
	case order.EdgePay:
		return m.clearedpay
	case order.EdgeOrderContents:
		return m.clearedorder_contents
	case order.EdgeSales:
		return m.clearedsales
	case order.EdgeOrderVenues:
		return m.clearedorder_venues
	case order.EdgeOrderMembers:
		return m.clearedorder_members
	case order.EdgeOrderCreates:
		return m.clearedorder_creates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeOrderVenues:
		m.ClearOrderVenues()
		return nil
	case order.EdgeOrderMembers:
		m.ClearOrderMembers()
		return nil
	case order.EdgeOrderCreates:
		m.ClearOrderCreates()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeAmount:
		m.ResetAmount()
		return nil
	case order.EdgeItem:
		m.ResetItem()
		return nil
	case order.EdgePay:
		m.ResetPay()
		return nil
	case order.EdgeOrderContents:
		m.ResetOrderContents()
		return nil
	case order.EdgeSales:
		m.ResetSales()
		return nil
	case order.EdgeOrderVenues:
		m.ResetOrderVenues()
		return nil
	case order.EdgeOrderMembers:
		m.ResetOrderMembers()
		return nil
	case order.EdgeOrderCreates:
		m.ResetOrderCreates()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderAmountMutation represents an operation that mutates the OrderAmount nodes in the graph.
type OrderAmountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	total         *float64
	addtotal      *float64
	actual        *float64
	addactual     *float64
	residue       *float64
	addresidue    *float64
	remission     *float64
	addremission  *float64
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderAmount, error)
	predicates    []predicate.OrderAmount
}

var _ ent.Mutation = (*OrderAmountMutation)(nil)

// orderamountOption allows management of the mutation configuration using functional options.
type orderamountOption func(*OrderAmountMutation)

// newOrderAmountMutation creates new mutation for the OrderAmount entity.
func newOrderAmountMutation(c config, op Op, opts ...orderamountOption) *OrderAmountMutation {
	m := &OrderAmountMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAmount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAmountID sets the ID field of the mutation.
func withOrderAmountID(id int64) orderamountOption {
	return func(m *OrderAmountMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAmount
		)
		m.oldValue = func(ctx context.Context) (*OrderAmount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAmount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAmount sets the old OrderAmount of the mutation.
func withOrderAmount(node *OrderAmount) orderamountOption {
	return func(m *OrderAmountMutation) {
		m.oldValue = func(context.Context) (*OrderAmount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAmountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAmountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderAmount entities.
func (m *OrderAmountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAmountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderAmountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderAmount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderAmountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderAmountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderAmountMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderamount.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderAmountMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderAmountMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderamount.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderAmountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderAmountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderAmountMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderamount.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderAmountMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderAmountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderamount.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderAmountMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderAmountMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderAmountMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderAmountMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderAmountMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[orderamount.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderAmountMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderAmountMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, orderamount.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderAmountMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderAmountMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderAmountMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderAmountMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderAmountMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[orderamount.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderAmountMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderAmountMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, orderamount.FieldCreatedID)
}

// SetOrderID sets the "order_id" field.
func (m *OrderAmountMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderAmountMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderAmountMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderAmountMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderAmountMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderamount.FieldOrderID)
}

// SetTotal sets the "total" field.
func (m *OrderAmountMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderAmountMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *OrderAmountMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *OrderAmountMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *OrderAmountMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[orderamount.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *OrderAmountMutation) TotalCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderAmountMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, orderamount.FieldTotal)
}

// SetActual sets the "actual" field.
func (m *OrderAmountMutation) SetActual(f float64) {
	m.actual = &f
	m.addactual = nil
}

// Actual returns the value of the "actual" field in the mutation.
func (m *OrderAmountMutation) Actual() (r float64, exists bool) {
	v := m.actual
	if v == nil {
		return
	}
	return *v, true
}

// OldActual returns the old "actual" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldActual(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActual: %w", err)
	}
	return oldValue.Actual, nil
}

// AddActual adds f to the "actual" field.
func (m *OrderAmountMutation) AddActual(f float64) {
	if m.addactual != nil {
		*m.addactual += f
	} else {
		m.addactual = &f
	}
}

// AddedActual returns the value that was added to the "actual" field in this mutation.
func (m *OrderAmountMutation) AddedActual() (r float64, exists bool) {
	v := m.addactual
	if v == nil {
		return
	}
	return *v, true
}

// ClearActual clears the value of the "actual" field.
func (m *OrderAmountMutation) ClearActual() {
	m.actual = nil
	m.addactual = nil
	m.clearedFields[orderamount.FieldActual] = struct{}{}
}

// ActualCleared returns if the "actual" field was cleared in this mutation.
func (m *OrderAmountMutation) ActualCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldActual]
	return ok
}

// ResetActual resets all changes to the "actual" field.
func (m *OrderAmountMutation) ResetActual() {
	m.actual = nil
	m.addactual = nil
	delete(m.clearedFields, orderamount.FieldActual)
}

// SetResidue sets the "residue" field.
func (m *OrderAmountMutation) SetResidue(f float64) {
	m.residue = &f
	m.addresidue = nil
}

// Residue returns the value of the "residue" field in the mutation.
func (m *OrderAmountMutation) Residue() (r float64, exists bool) {
	v := m.residue
	if v == nil {
		return
	}
	return *v, true
}

// OldResidue returns the old "residue" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldResidue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResidue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResidue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResidue: %w", err)
	}
	return oldValue.Residue, nil
}

// AddResidue adds f to the "residue" field.
func (m *OrderAmountMutation) AddResidue(f float64) {
	if m.addresidue != nil {
		*m.addresidue += f
	} else {
		m.addresidue = &f
	}
}

// AddedResidue returns the value that was added to the "residue" field in this mutation.
func (m *OrderAmountMutation) AddedResidue() (r float64, exists bool) {
	v := m.addresidue
	if v == nil {
		return
	}
	return *v, true
}

// ClearResidue clears the value of the "residue" field.
func (m *OrderAmountMutation) ClearResidue() {
	m.residue = nil
	m.addresidue = nil
	m.clearedFields[orderamount.FieldResidue] = struct{}{}
}

// ResidueCleared returns if the "residue" field was cleared in this mutation.
func (m *OrderAmountMutation) ResidueCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldResidue]
	return ok
}

// ResetResidue resets all changes to the "residue" field.
func (m *OrderAmountMutation) ResetResidue() {
	m.residue = nil
	m.addresidue = nil
	delete(m.clearedFields, orderamount.FieldResidue)
}

// SetRemission sets the "remission" field.
func (m *OrderAmountMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderAmountMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderAmountMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderAmountMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderAmountMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderamount.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderAmountMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderAmountMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderamount.FieldRemission)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderAmountMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderAmountMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderAmountMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderAmountMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderAmountMutation builder.
func (m *OrderAmountMutation) Where(ps ...predicate.OrderAmount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderAmountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderAmountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderAmount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderAmountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderAmountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderAmount).
func (m *OrderAmountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAmountMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, orderamount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderamount.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, orderamount.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, orderamount.FieldCreatedID)
	}
	if m._order != nil {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.total != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.actual != nil {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.residue != nil {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.remission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAmountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.CreatedAt()
	case orderamount.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderamount.FieldDelete:
		return m.Delete()
	case orderamount.FieldCreatedID:
		return m.CreatedID()
	case orderamount.FieldOrderID:
		return m.OrderID()
	case orderamount.FieldTotal:
		return m.Total()
	case orderamount.FieldActual:
		return m.Actual()
	case orderamount.FieldResidue:
		return m.Residue()
	case orderamount.FieldRemission:
		return m.Remission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAmountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderamount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderamount.FieldDelete:
		return m.OldDelete(ctx)
	case orderamount.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case orderamount.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderamount.FieldTotal:
		return m.OldTotal(ctx)
	case orderamount.FieldActual:
		return m.OldActual(ctx)
	case orderamount.FieldResidue:
		return m.OldResidue(ctx)
	case orderamount.FieldRemission:
		return m.OldRemission(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAmount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderamount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderamount.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case orderamount.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case orderamount.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case orderamount.FieldActual:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActual(v)
		return nil
	case orderamount.FieldResidue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResidue(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAmountMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, orderamount.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, orderamount.FieldCreatedID)
	}
	if m.addtotal != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.addactual != nil {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.addresidue != nil {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.addremission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAmountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldDelete:
		return m.AddedDelete()
	case orderamount.FieldCreatedID:
		return m.AddedCreatedID()
	case orderamount.FieldTotal:
		return m.AddedTotal()
	case orderamount.FieldActual:
		return m.AddedActual()
	case orderamount.FieldResidue:
		return m.AddedResidue()
	case orderamount.FieldRemission:
		return m.AddedRemission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case orderamount.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case orderamount.FieldActual:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActual(v)
		return nil
	case orderamount.FieldResidue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResidue(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAmountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderamount.FieldCreatedAt) {
		fields = append(fields, orderamount.FieldCreatedAt)
	}
	if m.FieldCleared(orderamount.FieldUpdatedAt) {
		fields = append(fields, orderamount.FieldUpdatedAt)
	}
	if m.FieldCleared(orderamount.FieldDelete) {
		fields = append(fields, orderamount.FieldDelete)
	}
	if m.FieldCleared(orderamount.FieldCreatedID) {
		fields = append(fields, orderamount.FieldCreatedID)
	}
	if m.FieldCleared(orderamount.FieldOrderID) {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.FieldCleared(orderamount.FieldTotal) {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.FieldCleared(orderamount.FieldActual) {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.FieldCleared(orderamount.FieldResidue) {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.FieldCleared(orderamount.FieldRemission) {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAmountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAmountMutation) ClearField(name string) error {
	switch name {
	case orderamount.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderamount.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderamount.FieldDelete:
		m.ClearDelete()
		return nil
	case orderamount.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case orderamount.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ClearTotal()
		return nil
	case orderamount.FieldActual:
		m.ClearActual()
		return nil
	case orderamount.FieldResidue:
		m.ClearResidue()
		return nil
	case orderamount.FieldRemission:
		m.ClearRemission()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAmountMutation) ResetField(name string) error {
	switch name {
	case orderamount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderamount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderamount.FieldDelete:
		m.ResetDelete()
		return nil
	case orderamount.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case orderamount.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ResetTotal()
		return nil
	case orderamount.FieldActual:
		m.ResetActual()
		return nil
	case orderamount.FieldResidue:
		m.ResetResidue()
		return nil
	case orderamount.FieldRemission:
		m.ResetRemission()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAmountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderamount.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAmountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderamount.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAmountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAmountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAmountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderamount.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAmountMutation) EdgeCleared(name string) bool {
	switch name {
	case orderamount.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAmountMutation) ClearEdge(name string) error {
	switch name {
	case orderamount.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAmountMutation) ResetEdge(name string) error {
	switch name {
	case orderamount.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	delete                     *int64
	adddelete                  *int64
	created_id                 *int64
	addcreated_id              *int64
	number                     *int64
	addnumber                  *int64
	product_id                 *int64
	addproduct_id              *int64
	related_user_product_id    *int64
	addrelated_user_product_id *int64
	contest_id                 *int64
	addcontest_id              *int64
	bootcamp_id                *int64
	addbootcamp_id             *int64
	name                       *string
	data                       *[]string
	appenddata                 []string
	clearedFields              map[string]struct{}
	_order                     *int64
	cleared_order              bool
	done                       bool
	oldValue                   func(context.Context) (*OrderItem, error)
	predicates                 []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int64) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderItemMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderitem.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderItemMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderitem.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderItemMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderitem.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderItemMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderitem.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderItemMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderItemMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderItemMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderItemMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderItemMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[orderitem.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderItemMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderItemMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, orderitem.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderItemMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderItemMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderItemMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderItemMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderItemMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[orderitem.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderItemMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderItemMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, orderitem.FieldCreatedID)
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderItemMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderitem.FieldOrderID)
}

// SetNumber sets the "number" field.
func (m *OrderItemMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *OrderItemMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *OrderItemMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *OrderItemMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *OrderItemMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[orderitem.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *OrderItemMutation) NumberCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *OrderItemMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, orderitem.FieldNumber)
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, orderitem.FieldProductID)
}

// SetRelatedUserProductID sets the "related_user_product_id" field.
func (m *OrderItemMutation) SetRelatedUserProductID(i int64) {
	m.related_user_product_id = &i
	m.addrelated_user_product_id = nil
}

// RelatedUserProductID returns the value of the "related_user_product_id" field in the mutation.
func (m *OrderItemMutation) RelatedUserProductID() (r int64, exists bool) {
	v := m.related_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedUserProductID returns the old "related_user_product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRelatedUserProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedUserProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedUserProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedUserProductID: %w", err)
	}
	return oldValue.RelatedUserProductID, nil
}

// AddRelatedUserProductID adds i to the "related_user_product_id" field.
func (m *OrderItemMutation) AddRelatedUserProductID(i int64) {
	if m.addrelated_user_product_id != nil {
		*m.addrelated_user_product_id += i
	} else {
		m.addrelated_user_product_id = &i
	}
}

// AddedRelatedUserProductID returns the value that was added to the "related_user_product_id" field in this mutation.
func (m *OrderItemMutation) AddedRelatedUserProductID() (r int64, exists bool) {
	v := m.addrelated_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelatedUserProductID clears the value of the "related_user_product_id" field.
func (m *OrderItemMutation) ClearRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	m.clearedFields[orderitem.FieldRelatedUserProductID] = struct{}{}
}

// RelatedUserProductIDCleared returns if the "related_user_product_id" field was cleared in this mutation.
func (m *OrderItemMutation) RelatedUserProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldRelatedUserProductID]
	return ok
}

// ResetRelatedUserProductID resets all changes to the "related_user_product_id" field.
func (m *OrderItemMutation) ResetRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	delete(m.clearedFields, orderitem.FieldRelatedUserProductID)
}

// SetContestID sets the "contest_id" field.
func (m *OrderItemMutation) SetContestID(i int64) {
	m.contest_id = &i
	m.addcontest_id = nil
}

// ContestID returns the value of the "contest_id" field in the mutation.
func (m *OrderItemMutation) ContestID() (r int64, exists bool) {
	v := m.contest_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContestID returns the old "contest_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldContestID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContestID: %w", err)
	}
	return oldValue.ContestID, nil
}

// AddContestID adds i to the "contest_id" field.
func (m *OrderItemMutation) AddContestID(i int64) {
	if m.addcontest_id != nil {
		*m.addcontest_id += i
	} else {
		m.addcontest_id = &i
	}
}

// AddedContestID returns the value that was added to the "contest_id" field in this mutation.
func (m *OrderItemMutation) AddedContestID() (r int64, exists bool) {
	v := m.addcontest_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContestID clears the value of the "contest_id" field.
func (m *OrderItemMutation) ClearContestID() {
	m.contest_id = nil
	m.addcontest_id = nil
	m.clearedFields[orderitem.FieldContestID] = struct{}{}
}

// ContestIDCleared returns if the "contest_id" field was cleared in this mutation.
func (m *OrderItemMutation) ContestIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldContestID]
	return ok
}

// ResetContestID resets all changes to the "contest_id" field.
func (m *OrderItemMutation) ResetContestID() {
	m.contest_id = nil
	m.addcontest_id = nil
	delete(m.clearedFields, orderitem.FieldContestID)
}

// SetBootcampID sets the "bootcamp_id" field.
func (m *OrderItemMutation) SetBootcampID(i int64) {
	m.bootcamp_id = &i
	m.addbootcamp_id = nil
}

// BootcampID returns the value of the "bootcamp_id" field in the mutation.
func (m *OrderItemMutation) BootcampID() (r int64, exists bool) {
	v := m.bootcamp_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBootcampID returns the old "bootcamp_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldBootcampID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBootcampID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBootcampID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBootcampID: %w", err)
	}
	return oldValue.BootcampID, nil
}

// AddBootcampID adds i to the "bootcamp_id" field.
func (m *OrderItemMutation) AddBootcampID(i int64) {
	if m.addbootcamp_id != nil {
		*m.addbootcamp_id += i
	} else {
		m.addbootcamp_id = &i
	}
}

// AddedBootcampID returns the value that was added to the "bootcamp_id" field in this mutation.
func (m *OrderItemMutation) AddedBootcampID() (r int64, exists bool) {
	v := m.addbootcamp_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBootcampID clears the value of the "bootcamp_id" field.
func (m *OrderItemMutation) ClearBootcampID() {
	m.bootcamp_id = nil
	m.addbootcamp_id = nil
	m.clearedFields[orderitem.FieldBootcampID] = struct{}{}
}

// BootcampIDCleared returns if the "bootcamp_id" field was cleared in this mutation.
func (m *OrderItemMutation) BootcampIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldBootcampID]
	return ok
}

// ResetBootcampID resets all changes to the "bootcamp_id" field.
func (m *OrderItemMutation) ResetBootcampID() {
	m.bootcamp_id = nil
	m.addbootcamp_id = nil
	delete(m.clearedFields, orderitem.FieldBootcampID)
}

// SetName sets the "name" field.
func (m *OrderItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *OrderItemMutation) ClearName() {
	m.name = nil
	m.clearedFields[orderitem.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *OrderItemMutation) NameCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *OrderItemMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, orderitem.FieldName)
}

// SetData sets the "data" field.
func (m *OrderItemMutation) SetData(s []string) {
	m.data = &s
	m.appenddata = nil
}

// Data returns the value of the "data" field in the mutation.
func (m *OrderItemMutation) Data() (r []string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldData(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// AppendData adds s to the "data" field.
func (m *OrderItemMutation) AppendData(s []string) {
	m.appenddata = append(m.appenddata, s...)
}

// AppendedData returns the list of values that were appended to the "data" field in this mutation.
func (m *OrderItemMutation) AppendedData() ([]string, bool) {
	if len(m.appenddata) == 0 {
		return nil, false
	}
	return m.appenddata, true
}

// ClearData clears the value of the "data" field.
func (m *OrderItemMutation) ClearData() {
	m.data = nil
	m.appenddata = nil
	m.clearedFields[orderitem.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *OrderItemMutation) DataCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *OrderItemMutation) ResetData() {
	m.data = nil
	m.appenddata = nil
	delete(m.clearedFields, orderitem.FieldData)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, orderitem.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, orderitem.FieldCreatedID)
	}
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.number != nil {
		fields = append(fields, orderitem.FieldNumber)
	}
	if m.product_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.related_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.contest_id != nil {
		fields = append(fields, orderitem.FieldContestID)
	}
	if m.bootcamp_id != nil {
		fields = append(fields, orderitem.FieldBootcampID)
	}
	if m.name != nil {
		fields = append(fields, orderitem.FieldName)
	}
	if m.data != nil {
		fields = append(fields, orderitem.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldDelete:
		return m.Delete()
	case orderitem.FieldCreatedID:
		return m.CreatedID()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldNumber:
		return m.Number()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldRelatedUserProductID:
		return m.RelatedUserProductID()
	case orderitem.FieldContestID:
		return m.ContestID()
	case orderitem.FieldBootcampID:
		return m.BootcampID()
	case orderitem.FieldName:
		return m.Name()
	case orderitem.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldDelete:
		return m.OldDelete(ctx)
	case orderitem.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldNumber:
		return m.OldNumber(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldRelatedUserProductID:
		return m.OldRelatedUserProductID(ctx)
	case orderitem.FieldContestID:
		return m.OldContestID(ctx)
	case orderitem.FieldBootcampID:
		return m.OldBootcampID(ctx)
	case orderitem.FieldName:
		return m.OldName(ctx)
	case orderitem.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case orderitem.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedUserProductID(v)
		return nil
	case orderitem.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContestID(v)
		return nil
	case orderitem.FieldBootcampID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBootcampID(v)
		return nil
	case orderitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderitem.FieldData:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, orderitem.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, orderitem.FieldCreatedID)
	}
	if m.addnumber != nil {
		fields = append(fields, orderitem.FieldNumber)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.addrelated_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.addcontest_id != nil {
		fields = append(fields, orderitem.FieldContestID)
	}
	if m.addbootcamp_id != nil {
		fields = append(fields, orderitem.FieldBootcampID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldDelete:
		return m.AddedDelete()
	case orderitem.FieldCreatedID:
		return m.AddedCreatedID()
	case orderitem.FieldNumber:
		return m.AddedNumber()
	case orderitem.FieldProductID:
		return m.AddedProductID()
	case orderitem.FieldRelatedUserProductID:
		return m.AddedRelatedUserProductID()
	case orderitem.FieldContestID:
		return m.AddedContestID()
	case orderitem.FieldBootcampID:
		return m.AddedBootcampID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case orderitem.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case orderitem.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedUserProductID(v)
		return nil
	case orderitem.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContestID(v)
		return nil
	case orderitem.FieldBootcampID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBootcampID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldCreatedAt) {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.FieldCleared(orderitem.FieldUpdatedAt) {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.FieldCleared(orderitem.FieldDelete) {
		fields = append(fields, orderitem.FieldDelete)
	}
	if m.FieldCleared(orderitem.FieldCreatedID) {
		fields = append(fields, orderitem.FieldCreatedID)
	}
	if m.FieldCleared(orderitem.FieldOrderID) {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.FieldCleared(orderitem.FieldNumber) {
		fields = append(fields, orderitem.FieldNumber)
	}
	if m.FieldCleared(orderitem.FieldProductID) {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.FieldCleared(orderitem.FieldRelatedUserProductID) {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.FieldCleared(orderitem.FieldContestID) {
		fields = append(fields, orderitem.FieldContestID)
	}
	if m.FieldCleared(orderitem.FieldBootcampID) {
		fields = append(fields, orderitem.FieldBootcampID)
	}
	if m.FieldCleared(orderitem.FieldName) {
		fields = append(fields, orderitem.FieldName)
	}
	if m.FieldCleared(orderitem.FieldData) {
		fields = append(fields, orderitem.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderitem.FieldDelete:
		m.ClearDelete()
		return nil
	case orderitem.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case orderitem.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderitem.FieldNumber:
		m.ClearNumber()
		return nil
	case orderitem.FieldProductID:
		m.ClearProductID()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ClearRelatedUserProductID()
		return nil
	case orderitem.FieldContestID:
		m.ClearContestID()
		return nil
	case orderitem.FieldBootcampID:
		m.ClearBootcampID()
		return nil
	case orderitem.FieldName:
		m.ClearName()
		return nil
	case orderitem.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldDelete:
		m.ResetDelete()
		return nil
	case orderitem.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldNumber:
		m.ResetNumber()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ResetRelatedUserProductID()
		return nil
	case orderitem.FieldContestID:
		m.ResetContestID()
		return nil
	case orderitem.FieldBootcampID:
		m.ResetBootcampID()
		return nil
	case orderitem.FieldName:
		m.ResetName()
		return nil
	case orderitem.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderPayMutation represents an operation that mutates the OrderPay nodes in the graph.
type OrderPayMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	remission       *float64
	addremission    *float64
	pay             *float64
	addpay          *float64
	note            *string
	pay_at          *time.Time
	pay_way         *string
	pay_sn          *string
	prepay_id       *string
	pay_extra       *[]string
	appendpay_extra []string
	clearedFields   map[string]struct{}
	_order          *int64
	cleared_order   bool
	done            bool
	oldValue        func(context.Context) (*OrderPay, error)
	predicates      []predicate.OrderPay
}

var _ ent.Mutation = (*OrderPayMutation)(nil)

// orderpayOption allows management of the mutation configuration using functional options.
type orderpayOption func(*OrderPayMutation)

// newOrderPayMutation creates new mutation for the OrderPay entity.
func newOrderPayMutation(c config, op Op, opts ...orderpayOption) *OrderPayMutation {
	m := &OrderPayMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPayID sets the ID field of the mutation.
func withOrderPayID(id int64) orderpayOption {
	return func(m *OrderPayMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPay
		)
		m.oldValue = func(ctx context.Context) (*OrderPay, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPay sets the old OrderPay of the mutation.
func withOrderPay(node *OrderPay) orderpayOption {
	return func(m *OrderPayMutation) {
		m.oldValue = func(context.Context) (*OrderPay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderPay entities.
func (m *OrderPayMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPayMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderPayMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderPay.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderPayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderPayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderPayMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderpay.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderPayMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderPayMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderpay.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderPayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderPayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderPayMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderpay.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderPayMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderPayMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderpay.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderPayMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderPayMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderPayMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderPayMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderPayMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[orderpay.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderPayMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderPayMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, orderpay.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderPayMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderPayMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderPayMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderPayMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderPayMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[orderpay.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderPayMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderPayMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, orderpay.FieldCreatedID)
}

// SetOrderID sets the "order_id" field.
func (m *OrderPayMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderPayMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderPayMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderPayMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderPayMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderpay.FieldOrderID)
}

// SetRemission sets the "remission" field.
func (m *OrderPayMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderPayMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderPayMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderPayMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderPayMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderpay.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderPayMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderPayMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderpay.FieldRemission)
}

// SetPay sets the "pay" field.
func (m *OrderPayMutation) SetPay(f float64) {
	m.pay = &f
	m.addpay = nil
}

// Pay returns the value of the "pay" field in the mutation.
func (m *OrderPayMutation) Pay() (r float64, exists bool) {
	v := m.pay
	if v == nil {
		return
	}
	return *v, true
}

// OldPay returns the old "pay" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPay: %w", err)
	}
	return oldValue.Pay, nil
}

// AddPay adds f to the "pay" field.
func (m *OrderPayMutation) AddPay(f float64) {
	if m.addpay != nil {
		*m.addpay += f
	} else {
		m.addpay = &f
	}
}

// AddedPay returns the value that was added to the "pay" field in this mutation.
func (m *OrderPayMutation) AddedPay() (r float64, exists bool) {
	v := m.addpay
	if v == nil {
		return
	}
	return *v, true
}

// ClearPay clears the value of the "pay" field.
func (m *OrderPayMutation) ClearPay() {
	m.pay = nil
	m.addpay = nil
	m.clearedFields[orderpay.FieldPay] = struct{}{}
}

// PayCleared returns if the "pay" field was cleared in this mutation.
func (m *OrderPayMutation) PayCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPay]
	return ok
}

// ResetPay resets all changes to the "pay" field.
func (m *OrderPayMutation) ResetPay() {
	m.pay = nil
	m.addpay = nil
	delete(m.clearedFields, orderpay.FieldPay)
}

// SetNote sets the "note" field.
func (m *OrderPayMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderPayMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OrderPayMutation) ClearNote() {
	m.note = nil
	m.clearedFields[orderpay.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OrderPayMutation) NoteCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OrderPayMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, orderpay.FieldNote)
}

// SetPayAt sets the "pay_at" field.
func (m *OrderPayMutation) SetPayAt(t time.Time) {
	m.pay_at = &t
}

// PayAt returns the value of the "pay_at" field in the mutation.
func (m *OrderPayMutation) PayAt() (r time.Time, exists bool) {
	v := m.pay_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPayAt returns the old "pay_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPayAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayAt: %w", err)
	}
	return oldValue.PayAt, nil
}

// ClearPayAt clears the value of the "pay_at" field.
func (m *OrderPayMutation) ClearPayAt() {
	m.pay_at = nil
	m.clearedFields[orderpay.FieldPayAt] = struct{}{}
}

// PayAtCleared returns if the "pay_at" field was cleared in this mutation.
func (m *OrderPayMutation) PayAtCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPayAt]
	return ok
}

// ResetPayAt resets all changes to the "pay_at" field.
func (m *OrderPayMutation) ResetPayAt() {
	m.pay_at = nil
	delete(m.clearedFields, orderpay.FieldPayAt)
}

// SetPayWay sets the "pay_way" field.
func (m *OrderPayMutation) SetPayWay(s string) {
	m.pay_way = &s
}

// PayWay returns the value of the "pay_way" field in the mutation.
func (m *OrderPayMutation) PayWay() (r string, exists bool) {
	v := m.pay_way
	if v == nil {
		return
	}
	return *v, true
}

// OldPayWay returns the old "pay_way" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPayWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayWay: %w", err)
	}
	return oldValue.PayWay, nil
}

// ClearPayWay clears the value of the "pay_way" field.
func (m *OrderPayMutation) ClearPayWay() {
	m.pay_way = nil
	m.clearedFields[orderpay.FieldPayWay] = struct{}{}
}

// PayWayCleared returns if the "pay_way" field was cleared in this mutation.
func (m *OrderPayMutation) PayWayCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPayWay]
	return ok
}

// ResetPayWay resets all changes to the "pay_way" field.
func (m *OrderPayMutation) ResetPayWay() {
	m.pay_way = nil
	delete(m.clearedFields, orderpay.FieldPayWay)
}

// SetPaySn sets the "pay_sn" field.
func (m *OrderPayMutation) SetPaySn(s string) {
	m.pay_sn = &s
}

// PaySn returns the value of the "pay_sn" field in the mutation.
func (m *OrderPayMutation) PaySn() (r string, exists bool) {
	v := m.pay_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldPaySn returns the old "pay_sn" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPaySn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaySn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaySn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaySn: %w", err)
	}
	return oldValue.PaySn, nil
}

// ClearPaySn clears the value of the "pay_sn" field.
func (m *OrderPayMutation) ClearPaySn() {
	m.pay_sn = nil
	m.clearedFields[orderpay.FieldPaySn] = struct{}{}
}

// PaySnCleared returns if the "pay_sn" field was cleared in this mutation.
func (m *OrderPayMutation) PaySnCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPaySn]
	return ok
}

// ResetPaySn resets all changes to the "pay_sn" field.
func (m *OrderPayMutation) ResetPaySn() {
	m.pay_sn = nil
	delete(m.clearedFields, orderpay.FieldPaySn)
}

// SetPrepayID sets the "prepay_id" field.
func (m *OrderPayMutation) SetPrepayID(s string) {
	m.prepay_id = &s
}

// PrepayID returns the value of the "prepay_id" field in the mutation.
func (m *OrderPayMutation) PrepayID() (r string, exists bool) {
	v := m.prepay_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepayID returns the old "prepay_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPrepayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepayID: %w", err)
	}
	return oldValue.PrepayID, nil
}

// ClearPrepayID clears the value of the "prepay_id" field.
func (m *OrderPayMutation) ClearPrepayID() {
	m.prepay_id = nil
	m.clearedFields[orderpay.FieldPrepayID] = struct{}{}
}

// PrepayIDCleared returns if the "prepay_id" field was cleared in this mutation.
func (m *OrderPayMutation) PrepayIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPrepayID]
	return ok
}

// ResetPrepayID resets all changes to the "prepay_id" field.
func (m *OrderPayMutation) ResetPrepayID() {
	m.prepay_id = nil
	delete(m.clearedFields, orderpay.FieldPrepayID)
}

// SetPayExtra sets the "pay_extra" field.
func (m *OrderPayMutation) SetPayExtra(s []string) {
	m.pay_extra = &s
	m.appendpay_extra = nil
}

// PayExtra returns the value of the "pay_extra" field in the mutation.
func (m *OrderPayMutation) PayExtra() (r []string, exists bool) {
	v := m.pay_extra
	if v == nil {
		return
	}
	return *v, true
}

// OldPayExtra returns the old "pay_extra" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPayExtra(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayExtra: %w", err)
	}
	return oldValue.PayExtra, nil
}

// AppendPayExtra adds s to the "pay_extra" field.
func (m *OrderPayMutation) AppendPayExtra(s []string) {
	m.appendpay_extra = append(m.appendpay_extra, s...)
}

// AppendedPayExtra returns the list of values that were appended to the "pay_extra" field in this mutation.
func (m *OrderPayMutation) AppendedPayExtra() ([]string, bool) {
	if len(m.appendpay_extra) == 0 {
		return nil, false
	}
	return m.appendpay_extra, true
}

// ClearPayExtra clears the value of the "pay_extra" field.
func (m *OrderPayMutation) ClearPayExtra() {
	m.pay_extra = nil
	m.appendpay_extra = nil
	m.clearedFields[orderpay.FieldPayExtra] = struct{}{}
}

// PayExtraCleared returns if the "pay_extra" field was cleared in this mutation.
func (m *OrderPayMutation) PayExtraCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPayExtra]
	return ok
}

// ResetPayExtra resets all changes to the "pay_extra" field.
func (m *OrderPayMutation) ResetPayExtra() {
	m.pay_extra = nil
	m.appendpay_extra = nil
	delete(m.clearedFields, orderpay.FieldPayExtra)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderPayMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderPayMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderPayMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderPayMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderPayMutation builder.
func (m *OrderPayMutation) Where(ps ...predicate.OrderPay) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderPayMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderPayMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderPay, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderPayMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderPayMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderPay).
func (m *OrderPayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPayMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, orderpay.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, orderpay.FieldCreatedID)
	}
	if m._order != nil {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.remission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.pay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.note != nil {
		fields = append(fields, orderpay.FieldNote)
	}
	if m.pay_at != nil {
		fields = append(fields, orderpay.FieldPayAt)
	}
	if m.pay_way != nil {
		fields = append(fields, orderpay.FieldPayWay)
	}
	if m.pay_sn != nil {
		fields = append(fields, orderpay.FieldPaySn)
	}
	if m.prepay_id != nil {
		fields = append(fields, orderpay.FieldPrepayID)
	}
	if m.pay_extra != nil {
		fields = append(fields, orderpay.FieldPayExtra)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.CreatedAt()
	case orderpay.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderpay.FieldDelete:
		return m.Delete()
	case orderpay.FieldCreatedID:
		return m.CreatedID()
	case orderpay.FieldOrderID:
		return m.OrderID()
	case orderpay.FieldRemission:
		return m.Remission()
	case orderpay.FieldPay:
		return m.Pay()
	case orderpay.FieldNote:
		return m.Note()
	case orderpay.FieldPayAt:
		return m.PayAt()
	case orderpay.FieldPayWay:
		return m.PayWay()
	case orderpay.FieldPaySn:
		return m.PaySn()
	case orderpay.FieldPrepayID:
		return m.PrepayID()
	case orderpay.FieldPayExtra:
		return m.PayExtra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderpay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderpay.FieldDelete:
		return m.OldDelete(ctx)
	case orderpay.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case orderpay.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderpay.FieldRemission:
		return m.OldRemission(ctx)
	case orderpay.FieldPay:
		return m.OldPay(ctx)
	case orderpay.FieldNote:
		return m.OldNote(ctx)
	case orderpay.FieldPayAt:
		return m.OldPayAt(ctx)
	case orderpay.FieldPayWay:
		return m.OldPayWay(ctx)
	case orderpay.FieldPaySn:
		return m.OldPaySn(ctx)
	case orderpay.FieldPrepayID:
		return m.OldPrepayID(ctx)
	case orderpay.FieldPayExtra:
		return m.OldPayExtra(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderpay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderpay.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case orderpay.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case orderpay.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPay(v)
		return nil
	case orderpay.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case orderpay.FieldPayAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayAt(v)
		return nil
	case orderpay.FieldPayWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayWay(v)
		return nil
	case orderpay.FieldPaySn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaySn(v)
		return nil
	case orderpay.FieldPrepayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepayID(v)
		return nil
	case orderpay.FieldPayExtra:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayExtra(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPayMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, orderpay.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, orderpay.FieldCreatedID)
	}
	if m.addremission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.addpay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldDelete:
		return m.AddedDelete()
	case orderpay.FieldCreatedID:
		return m.AddedCreatedID()
	case orderpay.FieldRemission:
		return m.AddedRemission()
	case orderpay.FieldPay:
		return m.AddedPay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case orderpay.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPay(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpay.FieldCreatedAt) {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.FieldCleared(orderpay.FieldUpdatedAt) {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m.FieldCleared(orderpay.FieldDelete) {
		fields = append(fields, orderpay.FieldDelete)
	}
	if m.FieldCleared(orderpay.FieldCreatedID) {
		fields = append(fields, orderpay.FieldCreatedID)
	}
	if m.FieldCleared(orderpay.FieldOrderID) {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.FieldCleared(orderpay.FieldRemission) {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.FieldCleared(orderpay.FieldPay) {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.FieldCleared(orderpay.FieldNote) {
		fields = append(fields, orderpay.FieldNote)
	}
	if m.FieldCleared(orderpay.FieldPayAt) {
		fields = append(fields, orderpay.FieldPayAt)
	}
	if m.FieldCleared(orderpay.FieldPayWay) {
		fields = append(fields, orderpay.FieldPayWay)
	}
	if m.FieldCleared(orderpay.FieldPaySn) {
		fields = append(fields, orderpay.FieldPaySn)
	}
	if m.FieldCleared(orderpay.FieldPrepayID) {
		fields = append(fields, orderpay.FieldPrepayID)
	}
	if m.FieldCleared(orderpay.FieldPayExtra) {
		fields = append(fields, orderpay.FieldPayExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPayMutation) ClearField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderpay.FieldDelete:
		m.ClearDelete()
		return nil
	case orderpay.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case orderpay.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderpay.FieldRemission:
		m.ClearRemission()
		return nil
	case orderpay.FieldPay:
		m.ClearPay()
		return nil
	case orderpay.FieldNote:
		m.ClearNote()
		return nil
	case orderpay.FieldPayAt:
		m.ClearPayAt()
		return nil
	case orderpay.FieldPayWay:
		m.ClearPayWay()
		return nil
	case orderpay.FieldPaySn:
		m.ClearPaySn()
		return nil
	case orderpay.FieldPrepayID:
		m.ClearPrepayID()
		return nil
	case orderpay.FieldPayExtra:
		m.ClearPayExtra()
		return nil
	}
	return fmt.Errorf("unknown OrderPay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPayMutation) ResetField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderpay.FieldDelete:
		m.ResetDelete()
		return nil
	case orderpay.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case orderpay.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderpay.FieldRemission:
		m.ResetRemission()
		return nil
	case orderpay.FieldPay:
		m.ResetPay()
		return nil
	case orderpay.FieldNote:
		m.ResetNote()
		return nil
	case orderpay.FieldPayAt:
		m.ResetPayAt()
		return nil
	case orderpay.FieldPayWay:
		m.ResetPayWay()
		return nil
	case orderpay.FieldPaySn:
		m.ResetPaySn()
		return nil
	case orderpay.FieldPrepayID:
		m.ResetPrepayID()
		return nil
	case orderpay.FieldPayExtra:
		m.ResetPayExtra()
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderpay.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPayMutation) EdgeCleared(name string) bool {
	switch name {
	case orderpay.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPayMutation) ClearEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPayMutation) ResetEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay edge %s", name)
}

// OrderSalesMutation represents an operation that mutates the OrderSales nodes in the graph.
type OrderSalesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	member_id     *int64
	addmember_id  *int64
	sales_id      *int64
	addsales_id   *int64
	ratio         *int64
	addratio      *int64
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderSales, error)
	predicates    []predicate.OrderSales
}

var _ ent.Mutation = (*OrderSalesMutation)(nil)

// ordersalesOption allows management of the mutation configuration using functional options.
type ordersalesOption func(*OrderSalesMutation)

// newOrderSalesMutation creates new mutation for the OrderSales entity.
func newOrderSalesMutation(c config, op Op, opts ...ordersalesOption) *OrderSalesMutation {
	m := &OrderSalesMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSales,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSalesID sets the ID field of the mutation.
func withOrderSalesID(id int64) ordersalesOption {
	return func(m *OrderSalesMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSales
		)
		m.oldValue = func(ctx context.Context) (*OrderSales, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSales.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSales sets the old OrderSales of the mutation.
func withOrderSales(node *OrderSales) ordersalesOption {
	return func(m *OrderSalesMutation) {
		m.oldValue = func(context.Context) (*OrderSales, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSalesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSalesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderSales entities.
func (m *OrderSalesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSalesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderSalesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderSales.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderSalesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderSalesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderSalesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[ordersales.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderSalesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderSalesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, ordersales.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderSalesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderSalesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderSalesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[ordersales.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderSalesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderSalesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, ordersales.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderSalesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderSalesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderSalesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderSalesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderSalesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[ordersales.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderSalesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderSalesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, ordersales.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderSalesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderSalesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderSalesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderSalesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderSalesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[ordersales.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderSalesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderSalesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, ordersales.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *OrderSalesMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderSalesMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderSalesMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderSalesMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderSalesMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[ordersales.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderSalesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderSalesMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, ordersales.FieldStatus)
}

// SetOrderID sets the "order_id" field.
func (m *OrderSalesMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderSalesMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderSalesMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderSalesMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderSalesMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, ordersales.FieldOrderID)
}

// SetMemberID sets the "member_id" field.
func (m *OrderSalesMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OrderSalesMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *OrderSalesMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *OrderSalesMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *OrderSalesMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[ordersales.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *OrderSalesMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OrderSalesMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, ordersales.FieldMemberID)
}

// SetSalesID sets the "sales_id" field.
func (m *OrderSalesMutation) SetSalesID(i int64) {
	m.sales_id = &i
	m.addsales_id = nil
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *OrderSalesMutation) SalesID() (r int64, exists bool) {
	v := m.sales_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldSalesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// AddSalesID adds i to the "sales_id" field.
func (m *OrderSalesMutation) AddSalesID(i int64) {
	if m.addsales_id != nil {
		*m.addsales_id += i
	} else {
		m.addsales_id = &i
	}
}

// AddedSalesID returns the value that was added to the "sales_id" field in this mutation.
func (m *OrderSalesMutation) AddedSalesID() (r int64, exists bool) {
	v := m.addsales_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *OrderSalesMutation) ClearSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	m.clearedFields[ordersales.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *OrderSalesMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *OrderSalesMutation) ResetSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	delete(m.clearedFields, ordersales.FieldSalesID)
}

// SetRatio sets the "ratio" field.
func (m *OrderSalesMutation) SetRatio(i int64) {
	m.ratio = &i
	m.addratio = nil
}

// Ratio returns the value of the "ratio" field in the mutation.
func (m *OrderSalesMutation) Ratio() (r int64, exists bool) {
	v := m.ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldRatio returns the old "ratio" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldRatio(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatio: %w", err)
	}
	return oldValue.Ratio, nil
}

// AddRatio adds i to the "ratio" field.
func (m *OrderSalesMutation) AddRatio(i int64) {
	if m.addratio != nil {
		*m.addratio += i
	} else {
		m.addratio = &i
	}
}

// AddedRatio returns the value that was added to the "ratio" field in this mutation.
func (m *OrderSalesMutation) AddedRatio() (r int64, exists bool) {
	v := m.addratio
	if v == nil {
		return
	}
	return *v, true
}

// ClearRatio clears the value of the "ratio" field.
func (m *OrderSalesMutation) ClearRatio() {
	m.ratio = nil
	m.addratio = nil
	m.clearedFields[ordersales.FieldRatio] = struct{}{}
}

// RatioCleared returns if the "ratio" field was cleared in this mutation.
func (m *OrderSalesMutation) RatioCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldRatio]
	return ok
}

// ResetRatio resets all changes to the "ratio" field.
func (m *OrderSalesMutation) ResetRatio() {
	m.ratio = nil
	m.addratio = nil
	delete(m.clearedFields, ordersales.FieldRatio)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderSalesMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderSalesMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderSalesMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderSalesMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderSalesMutation builder.
func (m *OrderSalesMutation) Where(ps ...predicate.OrderSales) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderSalesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderSalesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderSales, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderSalesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderSalesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderSales).
func (m *OrderSalesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSalesMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, ordersales.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordersales.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, ordersales.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, ordersales.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m._order != nil {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.member_id != nil {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.sales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.ratio != nil {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSalesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.CreatedAt()
	case ordersales.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordersales.FieldDelete:
		return m.Delete()
	case ordersales.FieldCreatedID:
		return m.CreatedID()
	case ordersales.FieldStatus:
		return m.Status()
	case ordersales.FieldOrderID:
		return m.OrderID()
	case ordersales.FieldMemberID:
		return m.MemberID()
	case ordersales.FieldSalesID:
		return m.SalesID()
	case ordersales.FieldRatio:
		return m.Ratio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSalesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordersales.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordersales.FieldDelete:
		return m.OldDelete(ctx)
	case ordersales.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case ordersales.FieldStatus:
		return m.OldStatus(ctx)
	case ordersales.FieldOrderID:
		return m.OldOrderID(ctx)
	case ordersales.FieldMemberID:
		return m.OldMemberID(ctx)
	case ordersales.FieldSalesID:
		return m.OldSalesID(ctx)
	case ordersales.FieldRatio:
		return m.OldRatio(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSales field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordersales.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordersales.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case ordersales.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case ordersales.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ordersales.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case ordersales.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	case ordersales.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatio(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSalesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, ordersales.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, ordersales.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m.addmember_id != nil {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.addsales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.addratio != nil {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSalesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldDelete:
		return m.AddedDelete()
	case ordersales.FieldCreatedID:
		return m.AddedCreatedID()
	case ordersales.FieldStatus:
		return m.AddedStatus()
	case ordersales.FieldMemberID:
		return m.AddedMemberID()
	case ordersales.FieldSalesID:
		return m.AddedSalesID()
	case ordersales.FieldRatio:
		return m.AddedRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case ordersales.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case ordersales.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case ordersales.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesID(v)
		return nil
	case ordersales.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatio(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSalesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersales.FieldCreatedAt) {
		fields = append(fields, ordersales.FieldCreatedAt)
	}
	if m.FieldCleared(ordersales.FieldUpdatedAt) {
		fields = append(fields, ordersales.FieldUpdatedAt)
	}
	if m.FieldCleared(ordersales.FieldDelete) {
		fields = append(fields, ordersales.FieldDelete)
	}
	if m.FieldCleared(ordersales.FieldCreatedID) {
		fields = append(fields, ordersales.FieldCreatedID)
	}
	if m.FieldCleared(ordersales.FieldStatus) {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m.FieldCleared(ordersales.FieldOrderID) {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.FieldCleared(ordersales.FieldMemberID) {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.FieldCleared(ordersales.FieldSalesID) {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.FieldCleared(ordersales.FieldRatio) {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSalesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSalesMutation) ClearField(name string) error {
	switch name {
	case ordersales.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case ordersales.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case ordersales.FieldDelete:
		m.ClearDelete()
		return nil
	case ordersales.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case ordersales.FieldStatus:
		m.ClearStatus()
		return nil
	case ordersales.FieldOrderID:
		m.ClearOrderID()
		return nil
	case ordersales.FieldMemberID:
		m.ClearMemberID()
		return nil
	case ordersales.FieldSalesID:
		m.ClearSalesID()
		return nil
	case ordersales.FieldRatio:
		m.ClearRatio()
		return nil
	}
	return fmt.Errorf("unknown OrderSales nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSalesMutation) ResetField(name string) error {
	switch name {
	case ordersales.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordersales.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordersales.FieldDelete:
		m.ResetDelete()
		return nil
	case ordersales.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case ordersales.FieldStatus:
		m.ResetStatus()
		return nil
	case ordersales.FieldOrderID:
		m.ResetOrderID()
		return nil
	case ordersales.FieldMemberID:
		m.ResetMemberID()
		return nil
	case ordersales.FieldSalesID:
		m.ResetSalesID()
		return nil
	case ordersales.FieldRatio:
		m.ResetRatio()
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSalesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, ordersales.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSalesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersales.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSalesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSalesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSalesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, ordersales.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSalesMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersales.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSalesMutation) ClearEdge(name string) error {
	switch name {
	case ordersales.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSales unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSalesMutation) ResetEdge(name string) error {
	switch name {
	case ordersales.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSales edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	delete           *int64
	adddelete        *int64
	created_id       *int64
	addcreated_id    *int64
	status           *int64
	addstatus        *int64
	_type            *string
	sub_type         *string
	venue_id         *int64
	addvenue_id      *int64
	name             *string
	stock            *int64
	addstock         *int64
	deadline         *int64
	adddeadline      *int64
	duration         *int64
	addduration      *int64
	length           *int64
	addlength        *int64
	price            *float64
	addprice         *float64
	times            *int64
	addtimes         *int64
	is_lessons       *int64
	addis_lessons    *int64
	is_course        *int64
	addis_course     *int64
	sales            *[]*base.Sales
	appendsales      []*base.Sales
	is_sales         *int64
	addis_sales      *int64
	sign_sales_at    *time.Time
	end_sales_at     *time.Time
	pic              *string
	description      *string
	clearedFields    map[string]struct{}
	tags             map[int64]struct{}
	removedtags      map[int64]struct{}
	clearedtags      bool
	contracts        map[int64]struct{}
	removedcontracts map[int64]struct{}
	clearedcontracts bool
	courses          map[int64]struct{}
	removedcourses   map[int64]struct{}
	clearedcourses   bool
	lessons          map[int64]struct{}
	removedlessons   map[int64]struct{}
	clearedlessons   bool
	products         map[int64]struct{}
	removedproducts  map[int64]struct{}
	clearedproducts  bool
	done             bool
	oldValue         func(context.Context) (*Product, error)
	predicates       []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int64) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[product.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, product.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[product.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, product.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ProductMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ProductMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ProductMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ProductMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ProductMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[product.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ProductMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[product.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ProductMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, product.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ProductMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ProductMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ProductMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ProductMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ProductMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[product.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ProductMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ProductMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, product.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ProductMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[product.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProductMutation) StatusCleared() bool {
	_, ok := m.clearedFields[product.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, product.FieldStatus)
}

// SetType sets the "type" field.
func (m *ProductMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ProductMutation) ClearType() {
	m._type = nil
	m.clearedFields[product.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ProductMutation) TypeCleared() bool {
	_, ok := m.clearedFields[product.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ProductMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, product.FieldType)
}

// SetSubType sets the "sub_type" field.
func (m *ProductMutation) SetSubType(s string) {
	m.sub_type = &s
}

// SubType returns the value of the "sub_type" field in the mutation.
func (m *ProductMutation) SubType() (r string, exists bool) {
	v := m.sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubType returns the old "sub_type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubType: %w", err)
	}
	return oldValue.SubType, nil
}

// ClearSubType clears the value of the "sub_type" field.
func (m *ProductMutation) ClearSubType() {
	m.sub_type = nil
	m.clearedFields[product.FieldSubType] = struct{}{}
}

// SubTypeCleared returns if the "sub_type" field was cleared in this mutation.
func (m *ProductMutation) SubTypeCleared() bool {
	_, ok := m.clearedFields[product.FieldSubType]
	return ok
}

// ResetSubType resets all changes to the "sub_type" field.
func (m *ProductMutation) ResetSubType() {
	m.sub_type = nil
	delete(m.clearedFields, product.FieldSubType)
}

// SetVenueID sets the "venue_id" field.
func (m *ProductMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ProductMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ProductMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ProductMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ProductMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[product.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ProductMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[product.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ProductMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, product.FieldVenueID)
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[product.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[product.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, product.FieldName)
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(i int64) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r int64, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductMutation) AddStock(i int64) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r int64, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ClearStock clears the value of the "stock" field.
func (m *ProductMutation) ClearStock() {
	m.stock = nil
	m.addstock = nil
	m.clearedFields[product.FieldStock] = struct{}{}
}

// StockCleared returns if the "stock" field was cleared in this mutation.
func (m *ProductMutation) StockCleared() bool {
	_, ok := m.clearedFields[product.FieldStock]
	return ok
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
	delete(m.clearedFields, product.FieldStock)
}

// SetDeadline sets the "deadline" field.
func (m *ProductMutation) SetDeadline(i int64) {
	m.deadline = &i
	m.adddeadline = nil
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *ProductMutation) Deadline() (r int64, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeadline(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// AddDeadline adds i to the "deadline" field.
func (m *ProductMutation) AddDeadline(i int64) {
	if m.adddeadline != nil {
		*m.adddeadline += i
	} else {
		m.adddeadline = &i
	}
}

// AddedDeadline returns the value that was added to the "deadline" field in this mutation.
func (m *ProductMutation) AddedDeadline() (r int64, exists bool) {
	v := m.adddeadline
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeadline clears the value of the "deadline" field.
func (m *ProductMutation) ClearDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	m.clearedFields[product.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *ProductMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[product.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *ProductMutation) ResetDeadline() {
	m.deadline = nil
	m.adddeadline = nil
	delete(m.clearedFields, product.FieldDeadline)
}

// SetDuration sets the "duration" field.
func (m *ProductMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProductMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ProductMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ProductMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ProductMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[product.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ProductMutation) DurationCleared() bool {
	_, ok := m.clearedFields[product.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProductMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, product.FieldDuration)
}

// SetLength sets the "length" field.
func (m *ProductMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ProductMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *ProductMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ProductMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *ProductMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[product.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *ProductMutation) LengthCleared() bool {
	_, ok := m.clearedFields[product.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *ProductMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, product.FieldLength)
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ProductMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[product.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[product.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, product.FieldPrice)
}

// SetTimes sets the "times" field.
func (m *ProductMutation) SetTimes(i int64) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the value of the "times" field in the mutation.
func (m *ProductMutation) Times() (r int64, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old "times" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to the "times" field.
func (m *ProductMutation) AddTimes(i int64) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the "times" field in this mutation.
func (m *ProductMutation) AddedTimes() (r int64, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimes clears the value of the "times" field.
func (m *ProductMutation) ClearTimes() {
	m.times = nil
	m.addtimes = nil
	m.clearedFields[product.FieldTimes] = struct{}{}
}

// TimesCleared returns if the "times" field was cleared in this mutation.
func (m *ProductMutation) TimesCleared() bool {
	_, ok := m.clearedFields[product.FieldTimes]
	return ok
}

// ResetTimes resets all changes to the "times" field.
func (m *ProductMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
	delete(m.clearedFields, product.FieldTimes)
}

// SetIsLessons sets the "is_lessons" field.
func (m *ProductMutation) SetIsLessons(i int64) {
	m.is_lessons = &i
	m.addis_lessons = nil
}

// IsLessons returns the value of the "is_lessons" field in the mutation.
func (m *ProductMutation) IsLessons() (r int64, exists bool) {
	v := m.is_lessons
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLessons returns the old "is_lessons" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsLessons(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLessons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLessons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLessons: %w", err)
	}
	return oldValue.IsLessons, nil
}

// AddIsLessons adds i to the "is_lessons" field.
func (m *ProductMutation) AddIsLessons(i int64) {
	if m.addis_lessons != nil {
		*m.addis_lessons += i
	} else {
		m.addis_lessons = &i
	}
}

// AddedIsLessons returns the value that was added to the "is_lessons" field in this mutation.
func (m *ProductMutation) AddedIsLessons() (r int64, exists bool) {
	v := m.addis_lessons
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsLessons clears the value of the "is_lessons" field.
func (m *ProductMutation) ClearIsLessons() {
	m.is_lessons = nil
	m.addis_lessons = nil
	m.clearedFields[product.FieldIsLessons] = struct{}{}
}

// IsLessonsCleared returns if the "is_lessons" field was cleared in this mutation.
func (m *ProductMutation) IsLessonsCleared() bool {
	_, ok := m.clearedFields[product.FieldIsLessons]
	return ok
}

// ResetIsLessons resets all changes to the "is_lessons" field.
func (m *ProductMutation) ResetIsLessons() {
	m.is_lessons = nil
	m.addis_lessons = nil
	delete(m.clearedFields, product.FieldIsLessons)
}

// SetIsCourse sets the "is_course" field.
func (m *ProductMutation) SetIsCourse(i int64) {
	m.is_course = &i
	m.addis_course = nil
}

// IsCourse returns the value of the "is_course" field in the mutation.
func (m *ProductMutation) IsCourse() (r int64, exists bool) {
	v := m.is_course
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCourse returns the old "is_course" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsCourse(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCourse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCourse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCourse: %w", err)
	}
	return oldValue.IsCourse, nil
}

// AddIsCourse adds i to the "is_course" field.
func (m *ProductMutation) AddIsCourse(i int64) {
	if m.addis_course != nil {
		*m.addis_course += i
	} else {
		m.addis_course = &i
	}
}

// AddedIsCourse returns the value that was added to the "is_course" field in this mutation.
func (m *ProductMutation) AddedIsCourse() (r int64, exists bool) {
	v := m.addis_course
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsCourse clears the value of the "is_course" field.
func (m *ProductMutation) ClearIsCourse() {
	m.is_course = nil
	m.addis_course = nil
	m.clearedFields[product.FieldIsCourse] = struct{}{}
}

// IsCourseCleared returns if the "is_course" field was cleared in this mutation.
func (m *ProductMutation) IsCourseCleared() bool {
	_, ok := m.clearedFields[product.FieldIsCourse]
	return ok
}

// ResetIsCourse resets all changes to the "is_course" field.
func (m *ProductMutation) ResetIsCourse() {
	m.is_course = nil
	m.addis_course = nil
	delete(m.clearedFields, product.FieldIsCourse)
}

// SetSales sets the "sales" field.
func (m *ProductMutation) SetSales(b []*base.Sales) {
	m.sales = &b
	m.appendsales = nil
}

// Sales returns the value of the "sales" field in the mutation.
func (m *ProductMutation) Sales() (r []*base.Sales, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSales returns the old "sales" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSales(ctx context.Context) (v []*base.Sales, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSales is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSales requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSales: %w", err)
	}
	return oldValue.Sales, nil
}

// AppendSales adds b to the "sales" field.
func (m *ProductMutation) AppendSales(b []*base.Sales) {
	m.appendsales = append(m.appendsales, b...)
}

// AppendedSales returns the list of values that were appended to the "sales" field in this mutation.
func (m *ProductMutation) AppendedSales() ([]*base.Sales, bool) {
	if len(m.appendsales) == 0 {
		return nil, false
	}
	return m.appendsales, true
}

// ClearSales clears the value of the "sales" field.
func (m *ProductMutation) ClearSales() {
	m.sales = nil
	m.appendsales = nil
	m.clearedFields[product.FieldSales] = struct{}{}
}

// SalesCleared returns if the "sales" field was cleared in this mutation.
func (m *ProductMutation) SalesCleared() bool {
	_, ok := m.clearedFields[product.FieldSales]
	return ok
}

// ResetSales resets all changes to the "sales" field.
func (m *ProductMutation) ResetSales() {
	m.sales = nil
	m.appendsales = nil
	delete(m.clearedFields, product.FieldSales)
}

// SetIsSales sets the "is_sales" field.
func (m *ProductMutation) SetIsSales(i int64) {
	m.is_sales = &i
	m.addis_sales = nil
}

// IsSales returns the value of the "is_sales" field in the mutation.
func (m *ProductMutation) IsSales() (r int64, exists bool) {
	v := m.is_sales
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSales returns the old "is_sales" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsSales(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSales is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSales requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSales: %w", err)
	}
	return oldValue.IsSales, nil
}

// AddIsSales adds i to the "is_sales" field.
func (m *ProductMutation) AddIsSales(i int64) {
	if m.addis_sales != nil {
		*m.addis_sales += i
	} else {
		m.addis_sales = &i
	}
}

// AddedIsSales returns the value that was added to the "is_sales" field in this mutation.
func (m *ProductMutation) AddedIsSales() (r int64, exists bool) {
	v := m.addis_sales
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsSales clears the value of the "is_sales" field.
func (m *ProductMutation) ClearIsSales() {
	m.is_sales = nil
	m.addis_sales = nil
	m.clearedFields[product.FieldIsSales] = struct{}{}
}

// IsSalesCleared returns if the "is_sales" field was cleared in this mutation.
func (m *ProductMutation) IsSalesCleared() bool {
	_, ok := m.clearedFields[product.FieldIsSales]
	return ok
}

// ResetIsSales resets all changes to the "is_sales" field.
func (m *ProductMutation) ResetIsSales() {
	m.is_sales = nil
	m.addis_sales = nil
	delete(m.clearedFields, product.FieldIsSales)
}

// SetSignSalesAt sets the "sign_sales_at" field.
func (m *ProductMutation) SetSignSalesAt(t time.Time) {
	m.sign_sales_at = &t
}

// SignSalesAt returns the value of the "sign_sales_at" field in the mutation.
func (m *ProductMutation) SignSalesAt() (r time.Time, exists bool) {
	v := m.sign_sales_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignSalesAt returns the old "sign_sales_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSignSalesAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignSalesAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignSalesAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignSalesAt: %w", err)
	}
	return oldValue.SignSalesAt, nil
}

// ClearSignSalesAt clears the value of the "sign_sales_at" field.
func (m *ProductMutation) ClearSignSalesAt() {
	m.sign_sales_at = nil
	m.clearedFields[product.FieldSignSalesAt] = struct{}{}
}

// SignSalesAtCleared returns if the "sign_sales_at" field was cleared in this mutation.
func (m *ProductMutation) SignSalesAtCleared() bool {
	_, ok := m.clearedFields[product.FieldSignSalesAt]
	return ok
}

// ResetSignSalesAt resets all changes to the "sign_sales_at" field.
func (m *ProductMutation) ResetSignSalesAt() {
	m.sign_sales_at = nil
	delete(m.clearedFields, product.FieldSignSalesAt)
}

// SetEndSalesAt sets the "end_sales_at" field.
func (m *ProductMutation) SetEndSalesAt(t time.Time) {
	m.end_sales_at = &t
}

// EndSalesAt returns the value of the "end_sales_at" field in the mutation.
func (m *ProductMutation) EndSalesAt() (r time.Time, exists bool) {
	v := m.end_sales_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndSalesAt returns the old "end_sales_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldEndSalesAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndSalesAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndSalesAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndSalesAt: %w", err)
	}
	return oldValue.EndSalesAt, nil
}

// ClearEndSalesAt clears the value of the "end_sales_at" field.
func (m *ProductMutation) ClearEndSalesAt() {
	m.end_sales_at = nil
	m.clearedFields[product.FieldEndSalesAt] = struct{}{}
}

// EndSalesAtCleared returns if the "end_sales_at" field was cleared in this mutation.
func (m *ProductMutation) EndSalesAtCleared() bool {
	_, ok := m.clearedFields[product.FieldEndSalesAt]
	return ok
}

// ResetEndSalesAt resets all changes to the "end_sales_at" field.
func (m *ProductMutation) ResetEndSalesAt() {
	m.end_sales_at = nil
	delete(m.clearedFields, product.FieldEndSalesAt)
}

// SetPic sets the "pic" field.
func (m *ProductMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *ProductMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *ProductMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[product.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *ProductMutation) PicCleared() bool {
	_, ok := m.clearedFields[product.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *ProductMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, product.FieldPic)
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// AddTagIDs adds the "tags" edge to the DictionaryDetail entity by ids.
func (m *ProductMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the DictionaryDetail entity.
func (m *ProductMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the DictionaryDetail entity was cleared.
func (m *ProductMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the DictionaryDetail entity by IDs.
func (m *ProductMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the DictionaryDetail entity.
func (m *ProductMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProductMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProductMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddContractIDs adds the "contracts" edge to the Contract entity by ids.
func (m *ProductMutation) AddContractIDs(ids ...int64) {
	if m.contracts == nil {
		m.contracts = make(map[int64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the Contract entity.
func (m *ProductMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the Contract entity was cleared.
func (m *ProductMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the Contract entity by IDs.
func (m *ProductMutation) RemoveContractIDs(ids ...int64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the Contract entity.
func (m *ProductMutation) RemovedContractsIDs() (ids []int64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *ProductMutation) ContractsIDs() (ids []int64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *ProductMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddCourseIDs adds the "courses" edge to the ProductCourses entity by ids.
func (m *ProductMutation) AddCourseIDs(ids ...int64) {
	if m.courses == nil {
		m.courses = make(map[int64]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the ProductCourses entity.
func (m *ProductMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the ProductCourses entity was cleared.
func (m *ProductMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the ProductCourses entity by IDs.
func (m *ProductMutation) RemoveCourseIDs(ids ...int64) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the ProductCourses entity.
func (m *ProductMutation) RemovedCoursesIDs() (ids []int64) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *ProductMutation) CoursesIDs() (ids []int64) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *ProductMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// AddLessonIDs adds the "lessons" edge to the ProductCourses entity by ids.
func (m *ProductMutation) AddLessonIDs(ids ...int64) {
	if m.lessons == nil {
		m.lessons = make(map[int64]struct{})
	}
	for i := range ids {
		m.lessons[ids[i]] = struct{}{}
	}
}

// ClearLessons clears the "lessons" edge to the ProductCourses entity.
func (m *ProductMutation) ClearLessons() {
	m.clearedlessons = true
}

// LessonsCleared reports if the "lessons" edge to the ProductCourses entity was cleared.
func (m *ProductMutation) LessonsCleared() bool {
	return m.clearedlessons
}

// RemoveLessonIDs removes the "lessons" edge to the ProductCourses entity by IDs.
func (m *ProductMutation) RemoveLessonIDs(ids ...int64) {
	if m.removedlessons == nil {
		m.removedlessons = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.lessons, ids[i])
		m.removedlessons[ids[i]] = struct{}{}
	}
}

// RemovedLessons returns the removed IDs of the "lessons" edge to the ProductCourses entity.
func (m *ProductMutation) RemovedLessonsIDs() (ids []int64) {
	for id := range m.removedlessons {
		ids = append(ids, id)
	}
	return
}

// LessonsIDs returns the "lessons" edge IDs in the mutation.
func (m *ProductMutation) LessonsIDs() (ids []int64) {
	for id := range m.lessons {
		ids = append(ids, id)
	}
	return
}

// ResetLessons resets all changes to the "lessons" edge.
func (m *ProductMutation) ResetLessons() {
	m.lessons = nil
	m.clearedlessons = false
	m.removedlessons = nil
}

// AddProductIDs adds the "products" edge to the VenuePlace entity by ids.
func (m *ProductMutation) AddProductIDs(ids ...int64) {
	if m.products == nil {
		m.products = make(map[int64]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the VenuePlace entity.
func (m *ProductMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the VenuePlace entity was cleared.
func (m *ProductMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the VenuePlace entity by IDs.
func (m *ProductMutation) RemoveProductIDs(ids ...int64) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the VenuePlace entity.
func (m *ProductMutation) RemovedProductsIDs() (ids []int64) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductMutation) ProductsIDs() (ids []int64) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, product.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, product.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, product.FieldType)
	}
	if m.sub_type != nil {
		fields = append(fields, product.FieldSubType)
	}
	if m.venue_id != nil {
		fields = append(fields, product.FieldVenueID)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.deadline != nil {
		fields = append(fields, product.FieldDeadline)
	}
	if m.duration != nil {
		fields = append(fields, product.FieldDuration)
	}
	if m.length != nil {
		fields = append(fields, product.FieldLength)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.times != nil {
		fields = append(fields, product.FieldTimes)
	}
	if m.is_lessons != nil {
		fields = append(fields, product.FieldIsLessons)
	}
	if m.is_course != nil {
		fields = append(fields, product.FieldIsCourse)
	}
	if m.sales != nil {
		fields = append(fields, product.FieldSales)
	}
	if m.is_sales != nil {
		fields = append(fields, product.FieldIsSales)
	}
	if m.sign_sales_at != nil {
		fields = append(fields, product.FieldSignSalesAt)
	}
	if m.end_sales_at != nil {
		fields = append(fields, product.FieldEndSalesAt)
	}
	if m.pic != nil {
		fields = append(fields, product.FieldPic)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDelete:
		return m.Delete()
	case product.FieldCreatedID:
		return m.CreatedID()
	case product.FieldStatus:
		return m.Status()
	case product.FieldType:
		return m.GetType()
	case product.FieldSubType:
		return m.SubType()
	case product.FieldVenueID:
		return m.VenueID()
	case product.FieldName:
		return m.Name()
	case product.FieldStock:
		return m.Stock()
	case product.FieldDeadline:
		return m.Deadline()
	case product.FieldDuration:
		return m.Duration()
	case product.FieldLength:
		return m.Length()
	case product.FieldPrice:
		return m.Price()
	case product.FieldTimes:
		return m.Times()
	case product.FieldIsLessons:
		return m.IsLessons()
	case product.FieldIsCourse:
		return m.IsCourse()
	case product.FieldSales:
		return m.Sales()
	case product.FieldIsSales:
		return m.IsSales()
	case product.FieldSignSalesAt:
		return m.SignSalesAt()
	case product.FieldEndSalesAt:
		return m.EndSalesAt()
	case product.FieldPic:
		return m.Pic()
	case product.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDelete:
		return m.OldDelete(ctx)
	case product.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldType:
		return m.OldType(ctx)
	case product.FieldSubType:
		return m.OldSubType(ctx)
	case product.FieldVenueID:
		return m.OldVenueID(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	case product.FieldDeadline:
		return m.OldDeadline(ctx)
	case product.FieldDuration:
		return m.OldDuration(ctx)
	case product.FieldLength:
		return m.OldLength(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldTimes:
		return m.OldTimes(ctx)
	case product.FieldIsLessons:
		return m.OldIsLessons(ctx)
	case product.FieldIsCourse:
		return m.OldIsCourse(ctx)
	case product.FieldSales:
		return m.OldSales(ctx)
	case product.FieldIsSales:
		return m.OldIsSales(ctx)
	case product.FieldSignSalesAt:
		return m.OldSignSalesAt(ctx)
	case product.FieldEndSalesAt:
		return m.OldEndSalesAt(ctx)
	case product.FieldPic:
		return m.OldPic(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case product.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case product.FieldSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubType(v)
		return nil
	case product.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case product.FieldDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case product.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case product.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case product.FieldIsLessons:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLessons(v)
		return nil
	case product.FieldIsCourse:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCourse(v)
		return nil
	case product.FieldSales:
		v, ok := value.([]*base.Sales)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSales(v)
		return nil
	case product.FieldIsSales:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSales(v)
		return nil
	case product.FieldSignSalesAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignSalesAt(v)
		return nil
	case product.FieldEndSalesAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndSalesAt(v)
		return nil
	case product.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, product.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, product.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, product.FieldVenueID)
	}
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.adddeadline != nil {
		fields = append(fields, product.FieldDeadline)
	}
	if m.addduration != nil {
		fields = append(fields, product.FieldDuration)
	}
	if m.addlength != nil {
		fields = append(fields, product.FieldLength)
	}
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addtimes != nil {
		fields = append(fields, product.FieldTimes)
	}
	if m.addis_lessons != nil {
		fields = append(fields, product.FieldIsLessons)
	}
	if m.addis_course != nil {
		fields = append(fields, product.FieldIsCourse)
	}
	if m.addis_sales != nil {
		fields = append(fields, product.FieldIsSales)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldDelete:
		return m.AddedDelete()
	case product.FieldCreatedID:
		return m.AddedCreatedID()
	case product.FieldStatus:
		return m.AddedStatus()
	case product.FieldVenueID:
		return m.AddedVenueID()
	case product.FieldStock:
		return m.AddedStock()
	case product.FieldDeadline:
		return m.AddedDeadline()
	case product.FieldDuration:
		return m.AddedDuration()
	case product.FieldLength:
		return m.AddedLength()
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldTimes:
		return m.AddedTimes()
	case product.FieldIsLessons:
		return m.AddedIsLessons()
	case product.FieldIsCourse:
		return m.AddedIsCourse()
	case product.FieldIsSales:
		return m.AddedIsSales()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case product.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case product.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case product.FieldDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadline(v)
		return nil
	case product.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case product.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case product.FieldIsLessons:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsLessons(v)
		return nil
	case product.FieldIsCourse:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCourse(v)
		return nil
	case product.FieldIsSales:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsSales(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldCreatedAt) {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.FieldCleared(product.FieldUpdatedAt) {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.FieldCleared(product.FieldDelete) {
		fields = append(fields, product.FieldDelete)
	}
	if m.FieldCleared(product.FieldCreatedID) {
		fields = append(fields, product.FieldCreatedID)
	}
	if m.FieldCleared(product.FieldStatus) {
		fields = append(fields, product.FieldStatus)
	}
	if m.FieldCleared(product.FieldType) {
		fields = append(fields, product.FieldType)
	}
	if m.FieldCleared(product.FieldSubType) {
		fields = append(fields, product.FieldSubType)
	}
	if m.FieldCleared(product.FieldVenueID) {
		fields = append(fields, product.FieldVenueID)
	}
	if m.FieldCleared(product.FieldName) {
		fields = append(fields, product.FieldName)
	}
	if m.FieldCleared(product.FieldStock) {
		fields = append(fields, product.FieldStock)
	}
	if m.FieldCleared(product.FieldDeadline) {
		fields = append(fields, product.FieldDeadline)
	}
	if m.FieldCleared(product.FieldDuration) {
		fields = append(fields, product.FieldDuration)
	}
	if m.FieldCleared(product.FieldLength) {
		fields = append(fields, product.FieldLength)
	}
	if m.FieldCleared(product.FieldPrice) {
		fields = append(fields, product.FieldPrice)
	}
	if m.FieldCleared(product.FieldTimes) {
		fields = append(fields, product.FieldTimes)
	}
	if m.FieldCleared(product.FieldIsLessons) {
		fields = append(fields, product.FieldIsLessons)
	}
	if m.FieldCleared(product.FieldIsCourse) {
		fields = append(fields, product.FieldIsCourse)
	}
	if m.FieldCleared(product.FieldSales) {
		fields = append(fields, product.FieldSales)
	}
	if m.FieldCleared(product.FieldIsSales) {
		fields = append(fields, product.FieldIsSales)
	}
	if m.FieldCleared(product.FieldSignSalesAt) {
		fields = append(fields, product.FieldSignSalesAt)
	}
	if m.FieldCleared(product.FieldEndSalesAt) {
		fields = append(fields, product.FieldEndSalesAt)
	}
	if m.FieldCleared(product.FieldPic) {
		fields = append(fields, product.FieldPic)
	}
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case product.FieldDelete:
		m.ClearDelete()
		return nil
	case product.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case product.FieldStatus:
		m.ClearStatus()
		return nil
	case product.FieldType:
		m.ClearType()
		return nil
	case product.FieldSubType:
		m.ClearSubType()
		return nil
	case product.FieldVenueID:
		m.ClearVenueID()
		return nil
	case product.FieldName:
		m.ClearName()
		return nil
	case product.FieldStock:
		m.ClearStock()
		return nil
	case product.FieldDeadline:
		m.ClearDeadline()
		return nil
	case product.FieldDuration:
		m.ClearDuration()
		return nil
	case product.FieldLength:
		m.ClearLength()
		return nil
	case product.FieldPrice:
		m.ClearPrice()
		return nil
	case product.FieldTimes:
		m.ClearTimes()
		return nil
	case product.FieldIsLessons:
		m.ClearIsLessons()
		return nil
	case product.FieldIsCourse:
		m.ClearIsCourse()
		return nil
	case product.FieldSales:
		m.ClearSales()
		return nil
	case product.FieldIsSales:
		m.ClearIsSales()
		return nil
	case product.FieldSignSalesAt:
		m.ClearSignSalesAt()
		return nil
	case product.FieldEndSalesAt:
		m.ClearEndSalesAt()
		return nil
	case product.FieldPic:
		m.ClearPic()
		return nil
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDelete:
		m.ResetDelete()
		return nil
	case product.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldType:
		m.ResetType()
		return nil
	case product.FieldSubType:
		m.ResetSubType()
		return nil
	case product.FieldVenueID:
		m.ResetVenueID()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	case product.FieldDeadline:
		m.ResetDeadline()
		return nil
	case product.FieldDuration:
		m.ResetDuration()
		return nil
	case product.FieldLength:
		m.ResetLength()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldTimes:
		m.ResetTimes()
		return nil
	case product.FieldIsLessons:
		m.ResetIsLessons()
		return nil
	case product.FieldIsCourse:
		m.ResetIsCourse()
		return nil
	case product.FieldSales:
		m.ResetSales()
		return nil
	case product.FieldIsSales:
		m.ResetIsSales()
		return nil
	case product.FieldSignSalesAt:
		m.ResetSignSalesAt()
		return nil
	case product.FieldEndSalesAt:
		m.ResetEndSalesAt()
		return nil
	case product.FieldPic:
		m.ResetPic()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tags != nil {
		edges = append(edges, product.EdgeTags)
	}
	if m.contracts != nil {
		edges = append(edges, product.EdgeContracts)
	}
	if m.courses != nil {
		edges = append(edges, product.EdgeCourses)
	}
	if m.lessons != nil {
		edges = append(edges, product.EdgeLessons)
	}
	if m.products != nil {
		edges = append(edges, product.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.lessons))
		for id := range m.lessons {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtags != nil {
		edges = append(edges, product.EdgeTags)
	}
	if m.removedcontracts != nil {
		edges = append(edges, product.EdgeContracts)
	}
	if m.removedcourses != nil {
		edges = append(edges, product.EdgeCourses)
	}
	if m.removedlessons != nil {
		edges = append(edges, product.EdgeLessons)
	}
	if m.removedproducts != nil {
		edges = append(edges, product.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.removedlessons))
		for id := range m.removedlessons {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtags {
		edges = append(edges, product.EdgeTags)
	}
	if m.clearedcontracts {
		edges = append(edges, product.EdgeContracts)
	}
	if m.clearedcourses {
		edges = append(edges, product.EdgeCourses)
	}
	if m.clearedlessons {
		edges = append(edges, product.EdgeLessons)
	}
	if m.clearedproducts {
		edges = append(edges, product.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTags:
		return m.clearedtags
	case product.EdgeContracts:
		return m.clearedcontracts
	case product.EdgeCourses:
		return m.clearedcourses
	case product.EdgeLessons:
		return m.clearedlessons
	case product.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTags:
		m.ResetTags()
		return nil
	case product.EdgeContracts:
		m.ResetContracts()
		return nil
	case product.EdgeCourses:
		m.ResetCourses()
		return nil
	case product.EdgeLessons:
		m.ResetLessons()
		return nil
	case product.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductCoursesMutation represents an operation that mutates the ProductCourses nodes in the graph.
type ProductCoursesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	_type         *string
	name          *string
	number        *int64
	addnumber     *int64
	courses_id    *int64
	addcourses_id *int64
	clearedFields map[string]struct{}
	nodeC         *int64
	clearednodeC  bool
	nodeL         *int64
	clearednodeL  bool
	done          bool
	oldValue      func(context.Context) (*ProductCourses, error)
	predicates    []predicate.ProductCourses
}

var _ ent.Mutation = (*ProductCoursesMutation)(nil)

// productcoursesOption allows management of the mutation configuration using functional options.
type productcoursesOption func(*ProductCoursesMutation)

// newProductCoursesMutation creates new mutation for the ProductCourses entity.
func newProductCoursesMutation(c config, op Op, opts ...productcoursesOption) *ProductCoursesMutation {
	m := &ProductCoursesMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCourses,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCoursesID sets the ID field of the mutation.
func withProductCoursesID(id int64) productcoursesOption {
	return func(m *ProductCoursesMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCourses
		)
		m.oldValue = func(ctx context.Context) (*ProductCourses, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCourses.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCourses sets the old ProductCourses of the mutation.
func withProductCourses(node *ProductCourses) productcoursesOption {
	return func(m *ProductCoursesMutation) {
		m.oldValue = func(context.Context) (*ProductCourses, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCoursesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCoursesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductCourses entities.
func (m *ProductCoursesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCoursesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCoursesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCourses.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductCoursesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductCoursesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductCoursesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[productcourses.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductCoursesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductCoursesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, productcourses.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductCoursesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductCoursesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductCoursesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[productcourses.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductCoursesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductCoursesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, productcourses.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ProductCoursesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ProductCoursesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ProductCoursesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ProductCoursesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ProductCoursesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[productcourses.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ProductCoursesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ProductCoursesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, productcourses.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ProductCoursesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ProductCoursesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ProductCoursesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ProductCoursesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ProductCoursesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[productcourses.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ProductCoursesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ProductCoursesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, productcourses.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ProductCoursesMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductCoursesMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductCoursesMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductCoursesMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ProductCoursesMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[productcourses.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProductCoursesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductCoursesMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, productcourses.FieldStatus)
}

// SetType sets the "type" field.
func (m *ProductCoursesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductCoursesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ProductCoursesMutation) ClearType() {
	m._type = nil
	m.clearedFields[productcourses.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ProductCoursesMutation) TypeCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ProductCoursesMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, productcourses.FieldType)
}

// SetName sets the "name" field.
func (m *ProductCoursesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductCoursesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductCoursesMutation) ClearName() {
	m.name = nil
	m.clearedFields[productcourses.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductCoursesMutation) NameCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductCoursesMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, productcourses.FieldName)
}

// SetNumber sets the "number" field.
func (m *ProductCoursesMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *ProductCoursesMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *ProductCoursesMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *ProductCoursesMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *ProductCoursesMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[productcourses.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *ProductCoursesMutation) NumberCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *ProductCoursesMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, productcourses.FieldNumber)
}

// SetProductID sets the "product_id" field.
func (m *ProductCoursesMutation) SetProductID(i int64) {
	m.nodeL = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductCoursesMutation) ProductID() (r int64, exists bool) {
	v := m.nodeL
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductCoursesMutation) ClearProductID() {
	m.nodeL = nil
	m.clearedFields[productcourses.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductCoursesMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductCoursesMutation) ResetProductID() {
	m.nodeL = nil
	delete(m.clearedFields, productcourses.FieldProductID)
}

// SetCoursesID sets the "courses_id" field.
func (m *ProductCoursesMutation) SetCoursesID(i int64) {
	m.courses_id = &i
	m.addcourses_id = nil
}

// CoursesID returns the value of the "courses_id" field in the mutation.
func (m *ProductCoursesMutation) CoursesID() (r int64, exists bool) {
	v := m.courses_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursesID returns the old "courses_id" field's value of the ProductCourses entity.
// If the ProductCourses object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCoursesMutation) OldCoursesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoursesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoursesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursesID: %w", err)
	}
	return oldValue.CoursesID, nil
}

// AddCoursesID adds i to the "courses_id" field.
func (m *ProductCoursesMutation) AddCoursesID(i int64) {
	if m.addcourses_id != nil {
		*m.addcourses_id += i
	} else {
		m.addcourses_id = &i
	}
}

// AddedCoursesID returns the value that was added to the "courses_id" field in this mutation.
func (m *ProductCoursesMutation) AddedCoursesID() (r int64, exists bool) {
	v := m.addcourses_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoursesID clears the value of the "courses_id" field.
func (m *ProductCoursesMutation) ClearCoursesID() {
	m.courses_id = nil
	m.addcourses_id = nil
	m.clearedFields[productcourses.FieldCoursesID] = struct{}{}
}

// CoursesIDCleared returns if the "courses_id" field was cleared in this mutation.
func (m *ProductCoursesMutation) CoursesIDCleared() bool {
	_, ok := m.clearedFields[productcourses.FieldCoursesID]
	return ok
}

// ResetCoursesID resets all changes to the "courses_id" field.
func (m *ProductCoursesMutation) ResetCoursesID() {
	m.courses_id = nil
	m.addcourses_id = nil
	delete(m.clearedFields, productcourses.FieldCoursesID)
}

// SetNodeCID sets the "nodeC" edge to the Product entity by id.
func (m *ProductCoursesMutation) SetNodeCID(id int64) {
	m.nodeC = &id
}

// ClearNodeC clears the "nodeC" edge to the Product entity.
func (m *ProductCoursesMutation) ClearNodeC() {
	m.clearednodeC = true
	m.clearedFields[productcourses.FieldProductID] = struct{}{}
}

// NodeCCleared reports if the "nodeC" edge to the Product entity was cleared.
func (m *ProductCoursesMutation) NodeCCleared() bool {
	return m.ProductIDCleared() || m.clearednodeC
}

// NodeCID returns the "nodeC" edge ID in the mutation.
func (m *ProductCoursesMutation) NodeCID() (id int64, exists bool) {
	if m.nodeC != nil {
		return *m.nodeC, true
	}
	return
}

// NodeCIDs returns the "nodeC" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeCID instead. It exists only for internal usage by the builders.
func (m *ProductCoursesMutation) NodeCIDs() (ids []int64) {
	if id := m.nodeC; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodeC resets all changes to the "nodeC" edge.
func (m *ProductCoursesMutation) ResetNodeC() {
	m.nodeC = nil
	m.clearednodeC = false
}

// SetNodeLID sets the "nodeL" edge to the Product entity by id.
func (m *ProductCoursesMutation) SetNodeLID(id int64) {
	m.nodeL = &id
}

// ClearNodeL clears the "nodeL" edge to the Product entity.
func (m *ProductCoursesMutation) ClearNodeL() {
	m.clearednodeL = true
	m.clearedFields[productcourses.FieldProductID] = struct{}{}
}

// NodeLCleared reports if the "nodeL" edge to the Product entity was cleared.
func (m *ProductCoursesMutation) NodeLCleared() bool {
	return m.ProductIDCleared() || m.clearednodeL
}

// NodeLID returns the "nodeL" edge ID in the mutation.
func (m *ProductCoursesMutation) NodeLID() (id int64, exists bool) {
	if m.nodeL != nil {
		return *m.nodeL, true
	}
	return
}

// NodeLIDs returns the "nodeL" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeLID instead. It exists only for internal usage by the builders.
func (m *ProductCoursesMutation) NodeLIDs() (ids []int64) {
	if id := m.nodeL; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNodeL resets all changes to the "nodeL" edge.
func (m *ProductCoursesMutation) ResetNodeL() {
	m.nodeL = nil
	m.clearednodeL = false
}

// Where appends a list predicates to the ProductCoursesMutation builder.
func (m *ProductCoursesMutation) Where(ps ...predicate.ProductCourses) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductCoursesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductCoursesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductCourses, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductCoursesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductCoursesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductCourses).
func (m *ProductCoursesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCoursesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, productcourses.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productcourses.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, productcourses.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, productcourses.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, productcourses.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, productcourses.FieldType)
	}
	if m.name != nil {
		fields = append(fields, productcourses.FieldName)
	}
	if m.number != nil {
		fields = append(fields, productcourses.FieldNumber)
	}
	if m.nodeL != nil {
		fields = append(fields, productcourses.FieldProductID)
	}
	if m.courses_id != nil {
		fields = append(fields, productcourses.FieldCoursesID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCoursesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcourses.FieldCreatedAt:
		return m.CreatedAt()
	case productcourses.FieldUpdatedAt:
		return m.UpdatedAt()
	case productcourses.FieldDelete:
		return m.Delete()
	case productcourses.FieldCreatedID:
		return m.CreatedID()
	case productcourses.FieldStatus:
		return m.Status()
	case productcourses.FieldType:
		return m.GetType()
	case productcourses.FieldName:
		return m.Name()
	case productcourses.FieldNumber:
		return m.Number()
	case productcourses.FieldProductID:
		return m.ProductID()
	case productcourses.FieldCoursesID:
		return m.CoursesID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCoursesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcourses.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcourses.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productcourses.FieldDelete:
		return m.OldDelete(ctx)
	case productcourses.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case productcourses.FieldStatus:
		return m.OldStatus(ctx)
	case productcourses.FieldType:
		return m.OldType(ctx)
	case productcourses.FieldName:
		return m.OldName(ctx)
	case productcourses.FieldNumber:
		return m.OldNumber(ctx)
	case productcourses.FieldProductID:
		return m.OldProductID(ctx)
	case productcourses.FieldCoursesID:
		return m.OldCoursesID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCourses field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCoursesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcourses.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcourses.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productcourses.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case productcourses.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case productcourses.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case productcourses.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case productcourses.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productcourses.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case productcourses.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productcourses.FieldCoursesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursesID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCourses field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCoursesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, productcourses.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, productcourses.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, productcourses.FieldStatus)
	}
	if m.addnumber != nil {
		fields = append(fields, productcourses.FieldNumber)
	}
	if m.addcourses_id != nil {
		fields = append(fields, productcourses.FieldCoursesID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCoursesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productcourses.FieldDelete:
		return m.AddedDelete()
	case productcourses.FieldCreatedID:
		return m.AddedCreatedID()
	case productcourses.FieldStatus:
		return m.AddedStatus()
	case productcourses.FieldNumber:
		return m.AddedNumber()
	case productcourses.FieldCoursesID:
		return m.AddedCoursesID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCoursesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productcourses.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case productcourses.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case productcourses.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case productcourses.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case productcourses.FieldCoursesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoursesID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCourses numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCoursesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcourses.FieldCreatedAt) {
		fields = append(fields, productcourses.FieldCreatedAt)
	}
	if m.FieldCleared(productcourses.FieldUpdatedAt) {
		fields = append(fields, productcourses.FieldUpdatedAt)
	}
	if m.FieldCleared(productcourses.FieldDelete) {
		fields = append(fields, productcourses.FieldDelete)
	}
	if m.FieldCleared(productcourses.FieldCreatedID) {
		fields = append(fields, productcourses.FieldCreatedID)
	}
	if m.FieldCleared(productcourses.FieldStatus) {
		fields = append(fields, productcourses.FieldStatus)
	}
	if m.FieldCleared(productcourses.FieldType) {
		fields = append(fields, productcourses.FieldType)
	}
	if m.FieldCleared(productcourses.FieldName) {
		fields = append(fields, productcourses.FieldName)
	}
	if m.FieldCleared(productcourses.FieldNumber) {
		fields = append(fields, productcourses.FieldNumber)
	}
	if m.FieldCleared(productcourses.FieldProductID) {
		fields = append(fields, productcourses.FieldProductID)
	}
	if m.FieldCleared(productcourses.FieldCoursesID) {
		fields = append(fields, productcourses.FieldCoursesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCoursesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCoursesMutation) ClearField(name string) error {
	switch name {
	case productcourses.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case productcourses.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case productcourses.FieldDelete:
		m.ClearDelete()
		return nil
	case productcourses.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case productcourses.FieldStatus:
		m.ClearStatus()
		return nil
	case productcourses.FieldType:
		m.ClearType()
		return nil
	case productcourses.FieldName:
		m.ClearName()
		return nil
	case productcourses.FieldNumber:
		m.ClearNumber()
		return nil
	case productcourses.FieldProductID:
		m.ClearProductID()
		return nil
	case productcourses.FieldCoursesID:
		m.ClearCoursesID()
		return nil
	}
	return fmt.Errorf("unknown ProductCourses nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCoursesMutation) ResetField(name string) error {
	switch name {
	case productcourses.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcourses.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productcourses.FieldDelete:
		m.ResetDelete()
		return nil
	case productcourses.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case productcourses.FieldStatus:
		m.ResetStatus()
		return nil
	case productcourses.FieldType:
		m.ResetType()
		return nil
	case productcourses.FieldName:
		m.ResetName()
		return nil
	case productcourses.FieldNumber:
		m.ResetNumber()
		return nil
	case productcourses.FieldProductID:
		m.ResetProductID()
		return nil
	case productcourses.FieldCoursesID:
		m.ResetCoursesID()
		return nil
	}
	return fmt.Errorf("unknown ProductCourses field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCoursesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nodeC != nil {
		edges = append(edges, productcourses.EdgeNodeC)
	}
	if m.nodeL != nil {
		edges = append(edges, productcourses.EdgeNodeL)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCoursesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcourses.EdgeNodeC:
		if id := m.nodeC; id != nil {
			return []ent.Value{*id}
		}
	case productcourses.EdgeNodeL:
		if id := m.nodeL; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCoursesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCoursesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCoursesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednodeC {
		edges = append(edges, productcourses.EdgeNodeC)
	}
	if m.clearednodeL {
		edges = append(edges, productcourses.EdgeNodeL)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCoursesMutation) EdgeCleared(name string) bool {
	switch name {
	case productcourses.EdgeNodeC:
		return m.clearednodeC
	case productcourses.EdgeNodeL:
		return m.clearednodeL
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCoursesMutation) ClearEdge(name string) error {
	switch name {
	case productcourses.EdgeNodeC:
		m.ClearNodeC()
		return nil
	case productcourses.EdgeNodeL:
		m.ClearNodeL()
		return nil
	}
	return fmt.Errorf("unknown ProductCourses unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCoursesMutation) ResetEdge(name string) error {
	switch name {
	case productcourses.EdgeNodeC:
		m.ResetNodeC()
		return nil
	case productcourses.EdgeNodeL:
		m.ResetNodeL()
		return nil
	}
	return fmt.Errorf("unknown ProductCourses edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	name           *string
	value          *string
	default_router *string
	remark         *string
	order_no       *int64
	addorder_no    *int64
	apis           *[]int
	appendapis     []int
	venue_id       *int64
	addvenue_id    *int64
	clearedFields  map[string]struct{}
	menus          map[int64]struct{}
	removedmenus   map[int64]struct{}
	clearedmenus   bool
	users          map[int64]struct{}
	removedusers   map[int64]struct{}
	clearedusers   bool
	venues         map[int64]struct{}
	removedvenues  map[int64]struct{}
	clearedvenues  bool
	done           bool
	oldValue       func(context.Context) (*Role, error)
	predicates     []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[role.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, role.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[role.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, role.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *RoleMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *RoleMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *RoleMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *RoleMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *RoleMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[role.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *RoleMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[role.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *RoleMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, role.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *RoleMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *RoleMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *RoleMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *RoleMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *RoleMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[role.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *RoleMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *RoleMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, role.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RoleMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RoleMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RoleMutation) ResetValue() {
	m.value = nil
}

// SetDefaultRouter sets the "default_router" field.
func (m *RoleMutation) SetDefaultRouter(s string) {
	m.default_router = &s
}

// DefaultRouter returns the value of the "default_router" field in the mutation.
func (m *RoleMutation) DefaultRouter() (r string, exists bool) {
	v := m.default_router
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRouter returns the old "default_router" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDefaultRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRouter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRouter: %w", err)
	}
	return oldValue.DefaultRouter, nil
}

// ResetDefaultRouter resets all changes to the "default_router" field.
func (m *RoleMutation) ResetDefaultRouter() {
	m.default_router = nil
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
}

// SetOrderNo sets the "order_no" field.
func (m *RoleMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RoleMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *RoleMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *RoleMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RoleMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetApis sets the "apis" field.
func (m *RoleMutation) SetApis(i []int) {
	m.apis = &i
	m.appendapis = nil
}

// Apis returns the value of the "apis" field in the mutation.
func (m *RoleMutation) Apis() (r []int, exists bool) {
	v := m.apis
	if v == nil {
		return
	}
	return *v, true
}

// OldApis returns the old "apis" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApis(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApis: %w", err)
	}
	return oldValue.Apis, nil
}

// AppendApis adds i to the "apis" field.
func (m *RoleMutation) AppendApis(i []int) {
	m.appendapis = append(m.appendapis, i...)
}

// AppendedApis returns the list of values that were appended to the "apis" field in this mutation.
func (m *RoleMutation) AppendedApis() ([]int, bool) {
	if len(m.appendapis) == 0 {
		return nil, false
	}
	return m.appendapis, true
}

// ResetApis resets all changes to the "apis" field.
func (m *RoleMutation) ResetApis() {
	m.apis = nil
	m.appendapis = nil
}

// SetVenueID sets the "venue_id" field.
func (m *RoleMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *RoleMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *RoleMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *RoleMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *RoleMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddVenueIDs adds the "venues" edge to the Venue entity by ids.
func (m *RoleMutation) AddVenueIDs(ids ...int64) {
	if m.venues == nil {
		m.venues = make(map[int64]struct{})
	}
	for i := range ids {
		m.venues[ids[i]] = struct{}{}
	}
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *RoleMutation) ClearVenues() {
	m.clearedvenues = true
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *RoleMutation) VenuesCleared() bool {
	return m.clearedvenues
}

// RemoveVenueIDs removes the "venues" edge to the Venue entity by IDs.
func (m *RoleMutation) RemoveVenueIDs(ids ...int64) {
	if m.removedvenues == nil {
		m.removedvenues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venues, ids[i])
		m.removedvenues[ids[i]] = struct{}{}
	}
}

// RemovedVenues returns the removed IDs of the "venues" edge to the Venue entity.
func (m *RoleMutation) RemovedVenuesIDs() (ids []int64) {
	for id := range m.removedvenues {
		ids = append(ids, id)
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
func (m *RoleMutation) VenuesIDs() (ids []int64) {
	for id := range m.venues {
		ids = append(ids, id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *RoleMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
	m.removedvenues = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.value != nil {
		fields = append(fields, role.FieldValue)
	}
	if m.default_router != nil {
		fields = append(fields, role.FieldDefaultRouter)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.order_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.apis != nil {
		fields = append(fields, role.FieldApis)
	}
	if m.venue_id != nil {
		fields = append(fields, role.FieldVenueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDelete:
		return m.Delete()
	case role.FieldCreatedID:
		return m.CreatedID()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldValue:
		return m.Value()
	case role.FieldDefaultRouter:
		return m.DefaultRouter()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldOrderNo:
		return m.OrderNo()
	case role.FieldApis:
		return m.Apis()
	case role.FieldVenueID:
		return m.VenueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDelete:
		return m.OldDelete(ctx)
	case role.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldValue:
		return m.OldValue(ctx)
	case role.FieldDefaultRouter:
		return m.OldDefaultRouter(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case role.FieldApis:
		return m.OldApis(ctx)
	case role.FieldVenueID:
		return m.OldVenueID(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case role.FieldDefaultRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRouter(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case role.FieldApis:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApis(v)
		return nil
	case role.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.addvenue_id != nil {
		fields = append(fields, role.FieldVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDelete:
		return m.AddedDelete()
	case role.FieldCreatedID:
		return m.AddedCreatedID()
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldOrderNo:
		return m.AddedOrderNo()
	case role.FieldVenueID:
		return m.AddedVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	case role.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldCreatedAt) {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.FieldCleared(role.FieldUpdatedAt) {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.FieldCleared(role.FieldDelete) {
		fields = append(fields, role.FieldDelete)
	}
	if m.FieldCleared(role.FieldCreatedID) {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ClearDelete()
		return nil
	case role.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ResetDelete()
		return nil
	case role.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldValue:
		m.ResetValue()
		return nil
	case role.FieldDefaultRouter:
		m.ResetDefaultRouter()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case role.FieldApis:
		m.ResetApis()
		return nil
	case role.FieldVenueID:
		m.ResetVenueID()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.venues != nil {
		edges = append(edges, role.EdgeVenues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.venues))
		for id := range m.venues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedvenues != nil {
		edges = append(edges, role.EdgeVenues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.removedvenues))
		for id := range m.removedvenues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedvenues {
		edges = append(edges, role.EdgeVenues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgeVenues:
		return m.clearedvenues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgeVenues:
		m.ResetVenues()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	_type          *string
	name           *string
	venue_id       *int64
	addvenue_id    *int64
	product_id     *int64
	addproduct_id  *int64
	length         *int64
	addlength      *int64
	place_id       *int64
	addplace_id    *int64
	num            *int64
	addnum         *int64
	num_surplus    *int64
	addnum_surplus *int64
	date           *string
	start_time     *time.Time
	end_time       *time.Time
	price          *float64
	addprice       *float64
	remark         *string
	venue_name     *string
	place_name     *string
	clearedFields  map[string]struct{}
	members        map[int64]struct{}
	removedmembers map[int64]struct{}
	clearedmembers bool
	coachs         map[int64]struct{}
	removedcoachs  map[int64]struct{}
	clearedcoachs  bool
	done           bool
	oldValue       func(context.Context) (*Schedule, error)
	predicates     []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id int64) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Schedule entities.
func (m *ScheduleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Schedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ScheduleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[schedule.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ScheduleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[schedule.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, schedule.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ScheduleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[schedule.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ScheduleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[schedule.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, schedule.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ScheduleMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ScheduleMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ScheduleMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ScheduleMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ScheduleMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[schedule.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ScheduleMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[schedule.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ScheduleMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, schedule.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ScheduleMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ScheduleMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ScheduleMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ScheduleMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ScheduleMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[schedule.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ScheduleMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[schedule.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ScheduleMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, schedule.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ScheduleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScheduleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScheduleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScheduleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ScheduleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[schedule.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ScheduleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[schedule.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ScheduleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, schedule.FieldStatus)
}

// SetType sets the "type" field.
func (m *ScheduleMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduleMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ScheduleMutation) ClearType() {
	m._type = nil
	m.clearedFields[schedule.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ScheduleMutation) TypeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ScheduleMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, schedule.FieldType)
}

// SetName sets the "name" field.
func (m *ScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ScheduleMutation) ClearName() {
	m.name = nil
	m.clearedFields[schedule.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ScheduleMutation) NameCleared() bool {
	_, ok := m.clearedFields[schedule.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ScheduleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, schedule.FieldName)
}

// SetVenueID sets the "venue_id" field.
func (m *ScheduleMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ScheduleMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ScheduleMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ScheduleMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ScheduleMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[schedule.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ScheduleMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[schedule.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ScheduleMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, schedule.FieldVenueID)
}

// SetProductID sets the "product_id" field.
func (m *ScheduleMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ScheduleMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ScheduleMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ScheduleMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ScheduleMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[schedule.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ScheduleMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[schedule.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ScheduleMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, schedule.FieldProductID)
}

// SetLength sets the "length" field.
func (m *ScheduleMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ScheduleMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *ScheduleMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ScheduleMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *ScheduleMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[schedule.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *ScheduleMutation) LengthCleared() bool {
	_, ok := m.clearedFields[schedule.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *ScheduleMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, schedule.FieldLength)
}

// SetPlaceID sets the "place_id" field.
func (m *ScheduleMutation) SetPlaceID(i int64) {
	m.place_id = &i
	m.addplace_id = nil
}

// PlaceID returns the value of the "place_id" field in the mutation.
func (m *ScheduleMutation) PlaceID() (r int64, exists bool) {
	v := m.place_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceID returns the old "place_id" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldPlaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceID: %w", err)
	}
	return oldValue.PlaceID, nil
}

// AddPlaceID adds i to the "place_id" field.
func (m *ScheduleMutation) AddPlaceID(i int64) {
	if m.addplace_id != nil {
		*m.addplace_id += i
	} else {
		m.addplace_id = &i
	}
}

// AddedPlaceID returns the value that was added to the "place_id" field in this mutation.
func (m *ScheduleMutation) AddedPlaceID() (r int64, exists bool) {
	v := m.addplace_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlaceID clears the value of the "place_id" field.
func (m *ScheduleMutation) ClearPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	m.clearedFields[schedule.FieldPlaceID] = struct{}{}
}

// PlaceIDCleared returns if the "place_id" field was cleared in this mutation.
func (m *ScheduleMutation) PlaceIDCleared() bool {
	_, ok := m.clearedFields[schedule.FieldPlaceID]
	return ok
}

// ResetPlaceID resets all changes to the "place_id" field.
func (m *ScheduleMutation) ResetPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	delete(m.clearedFields, schedule.FieldPlaceID)
}

// SetNum sets the "num" field.
func (m *ScheduleMutation) SetNum(i int64) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *ScheduleMutation) Num() (r int64, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *ScheduleMutation) AddNum(i int64) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *ScheduleMutation) AddedNum() (r int64, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ClearNum clears the value of the "num" field.
func (m *ScheduleMutation) ClearNum() {
	m.num = nil
	m.addnum = nil
	m.clearedFields[schedule.FieldNum] = struct{}{}
}

// NumCleared returns if the "num" field was cleared in this mutation.
func (m *ScheduleMutation) NumCleared() bool {
	_, ok := m.clearedFields[schedule.FieldNum]
	return ok
}

// ResetNum resets all changes to the "num" field.
func (m *ScheduleMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
	delete(m.clearedFields, schedule.FieldNum)
}

// SetNumSurplus sets the "num_surplus" field.
func (m *ScheduleMutation) SetNumSurplus(i int64) {
	m.num_surplus = &i
	m.addnum_surplus = nil
}

// NumSurplus returns the value of the "num_surplus" field in the mutation.
func (m *ScheduleMutation) NumSurplus() (r int64, exists bool) {
	v := m.num_surplus
	if v == nil {
		return
	}
	return *v, true
}

// OldNumSurplus returns the old "num_surplus" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldNumSurplus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumSurplus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumSurplus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumSurplus: %w", err)
	}
	return oldValue.NumSurplus, nil
}

// AddNumSurplus adds i to the "num_surplus" field.
func (m *ScheduleMutation) AddNumSurplus(i int64) {
	if m.addnum_surplus != nil {
		*m.addnum_surplus += i
	} else {
		m.addnum_surplus = &i
	}
}

// AddedNumSurplus returns the value that was added to the "num_surplus" field in this mutation.
func (m *ScheduleMutation) AddedNumSurplus() (r int64, exists bool) {
	v := m.addnum_surplus
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumSurplus clears the value of the "num_surplus" field.
func (m *ScheduleMutation) ClearNumSurplus() {
	m.num_surplus = nil
	m.addnum_surplus = nil
	m.clearedFields[schedule.FieldNumSurplus] = struct{}{}
}

// NumSurplusCleared returns if the "num_surplus" field was cleared in this mutation.
func (m *ScheduleMutation) NumSurplusCleared() bool {
	_, ok := m.clearedFields[schedule.FieldNumSurplus]
	return ok
}

// ResetNumSurplus resets all changes to the "num_surplus" field.
func (m *ScheduleMutation) ResetNumSurplus() {
	m.num_surplus = nil
	m.addnum_surplus = nil
	delete(m.clearedFields, schedule.FieldNumSurplus)
}

// SetDate sets the "date" field.
func (m *ScheduleMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *ScheduleMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *ScheduleMutation) ClearDate() {
	m.date = nil
	m.clearedFields[schedule.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *ScheduleMutation) DateCleared() bool {
	_, ok := m.clearedFields[schedule.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *ScheduleMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, schedule.FieldDate)
}

// SetStartTime sets the "start_time" field.
func (m *ScheduleMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ScheduleMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ScheduleMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[schedule.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ScheduleMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ScheduleMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, schedule.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ScheduleMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ScheduleMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ScheduleMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[schedule.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ScheduleMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ScheduleMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, schedule.FieldEndTime)
}

// SetPrice sets the "price" field.
func (m *ScheduleMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ScheduleMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ScheduleMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ScheduleMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ScheduleMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[schedule.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ScheduleMutation) PriceCleared() bool {
	_, ok := m.clearedFields[schedule.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ScheduleMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, schedule.FieldPrice)
}

// SetRemark sets the "remark" field.
func (m *ScheduleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ScheduleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ScheduleMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[schedule.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ScheduleMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[schedule.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ScheduleMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, schedule.FieldRemark)
}

// SetVenueName sets the "venue_name" field.
func (m *ScheduleMutation) SetVenueName(s string) {
	m.venue_name = &s
}

// VenueName returns the value of the "venue_name" field in the mutation.
func (m *ScheduleMutation) VenueName() (r string, exists bool) {
	v := m.venue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueName returns the old "venue_name" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldVenueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueName: %w", err)
	}
	return oldValue.VenueName, nil
}

// ClearVenueName clears the value of the "venue_name" field.
func (m *ScheduleMutation) ClearVenueName() {
	m.venue_name = nil
	m.clearedFields[schedule.FieldVenueName] = struct{}{}
}

// VenueNameCleared returns if the "venue_name" field was cleared in this mutation.
func (m *ScheduleMutation) VenueNameCleared() bool {
	_, ok := m.clearedFields[schedule.FieldVenueName]
	return ok
}

// ResetVenueName resets all changes to the "venue_name" field.
func (m *ScheduleMutation) ResetVenueName() {
	m.venue_name = nil
	delete(m.clearedFields, schedule.FieldVenueName)
}

// SetPlaceName sets the "place_name" field.
func (m *ScheduleMutation) SetPlaceName(s string) {
	m.place_name = &s
}

// PlaceName returns the value of the "place_name" field in the mutation.
func (m *ScheduleMutation) PlaceName() (r string, exists bool) {
	v := m.place_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceName returns the old "place_name" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldPlaceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceName: %w", err)
	}
	return oldValue.PlaceName, nil
}

// ClearPlaceName clears the value of the "place_name" field.
func (m *ScheduleMutation) ClearPlaceName() {
	m.place_name = nil
	m.clearedFields[schedule.FieldPlaceName] = struct{}{}
}

// PlaceNameCleared returns if the "place_name" field was cleared in this mutation.
func (m *ScheduleMutation) PlaceNameCleared() bool {
	_, ok := m.clearedFields[schedule.FieldPlaceName]
	return ok
}

// ResetPlaceName resets all changes to the "place_name" field.
func (m *ScheduleMutation) ResetPlaceName() {
	m.place_name = nil
	delete(m.clearedFields, schedule.FieldPlaceName)
}

// AddMemberIDs adds the "members" edge to the ScheduleMember entity by ids.
func (m *ScheduleMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the ScheduleMember entity.
func (m *ScheduleMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the ScheduleMember entity was cleared.
func (m *ScheduleMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the ScheduleMember entity by IDs.
func (m *ScheduleMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the ScheduleMember entity.
func (m *ScheduleMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ScheduleMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ScheduleMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddCoachIDs adds the "coachs" edge to the ScheduleCoach entity by ids.
func (m *ScheduleMutation) AddCoachIDs(ids ...int64) {
	if m.coachs == nil {
		m.coachs = make(map[int64]struct{})
	}
	for i := range ids {
		m.coachs[ids[i]] = struct{}{}
	}
}

// ClearCoachs clears the "coachs" edge to the ScheduleCoach entity.
func (m *ScheduleMutation) ClearCoachs() {
	m.clearedcoachs = true
}

// CoachsCleared reports if the "coachs" edge to the ScheduleCoach entity was cleared.
func (m *ScheduleMutation) CoachsCleared() bool {
	return m.clearedcoachs
}

// RemoveCoachIDs removes the "coachs" edge to the ScheduleCoach entity by IDs.
func (m *ScheduleMutation) RemoveCoachIDs(ids ...int64) {
	if m.removedcoachs == nil {
		m.removedcoachs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.coachs, ids[i])
		m.removedcoachs[ids[i]] = struct{}{}
	}
}

// RemovedCoachs returns the removed IDs of the "coachs" edge to the ScheduleCoach entity.
func (m *ScheduleMutation) RemovedCoachsIDs() (ids []int64) {
	for id := range m.removedcoachs {
		ids = append(ids, id)
	}
	return
}

// CoachsIDs returns the "coachs" edge IDs in the mutation.
func (m *ScheduleMutation) CoachsIDs() (ids []int64) {
	for id := range m.coachs {
		ids = append(ids, id)
	}
	return
}

// ResetCoachs resets all changes to the "coachs" edge.
func (m *ScheduleMutation) ResetCoachs() {
	m.coachs = nil
	m.clearedcoachs = false
	m.removedcoachs = nil
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Schedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, schedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, schedule.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, schedule.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, schedule.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, schedule.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, schedule.FieldType)
	}
	if m.name != nil {
		fields = append(fields, schedule.FieldName)
	}
	if m.venue_id != nil {
		fields = append(fields, schedule.FieldVenueID)
	}
	if m.product_id != nil {
		fields = append(fields, schedule.FieldProductID)
	}
	if m.length != nil {
		fields = append(fields, schedule.FieldLength)
	}
	if m.place_id != nil {
		fields = append(fields, schedule.FieldPlaceID)
	}
	if m.num != nil {
		fields = append(fields, schedule.FieldNum)
	}
	if m.num_surplus != nil {
		fields = append(fields, schedule.FieldNumSurplus)
	}
	if m.date != nil {
		fields = append(fields, schedule.FieldDate)
	}
	if m.start_time != nil {
		fields = append(fields, schedule.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, schedule.FieldEndTime)
	}
	if m.price != nil {
		fields = append(fields, schedule.FieldPrice)
	}
	if m.remark != nil {
		fields = append(fields, schedule.FieldRemark)
	}
	if m.venue_name != nil {
		fields = append(fields, schedule.FieldVenueName)
	}
	if m.place_name != nil {
		fields = append(fields, schedule.FieldPlaceName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldCreatedAt:
		return m.CreatedAt()
	case schedule.FieldUpdatedAt:
		return m.UpdatedAt()
	case schedule.FieldDelete:
		return m.Delete()
	case schedule.FieldCreatedID:
		return m.CreatedID()
	case schedule.FieldStatus:
		return m.Status()
	case schedule.FieldType:
		return m.GetType()
	case schedule.FieldName:
		return m.Name()
	case schedule.FieldVenueID:
		return m.VenueID()
	case schedule.FieldProductID:
		return m.ProductID()
	case schedule.FieldLength:
		return m.Length()
	case schedule.FieldPlaceID:
		return m.PlaceID()
	case schedule.FieldNum:
		return m.Num()
	case schedule.FieldNumSurplus:
		return m.NumSurplus()
	case schedule.FieldDate:
		return m.Date()
	case schedule.FieldStartTime:
		return m.StartTime()
	case schedule.FieldEndTime:
		return m.EndTime()
	case schedule.FieldPrice:
		return m.Price()
	case schedule.FieldRemark:
		return m.Remark()
	case schedule.FieldVenueName:
		return m.VenueName()
	case schedule.FieldPlaceName:
		return m.PlaceName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case schedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case schedule.FieldDelete:
		return m.OldDelete(ctx)
	case schedule.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case schedule.FieldStatus:
		return m.OldStatus(ctx)
	case schedule.FieldType:
		return m.OldType(ctx)
	case schedule.FieldName:
		return m.OldName(ctx)
	case schedule.FieldVenueID:
		return m.OldVenueID(ctx)
	case schedule.FieldProductID:
		return m.OldProductID(ctx)
	case schedule.FieldLength:
		return m.OldLength(ctx)
	case schedule.FieldPlaceID:
		return m.OldPlaceID(ctx)
	case schedule.FieldNum:
		return m.OldNum(ctx)
	case schedule.FieldNumSurplus:
		return m.OldNumSurplus(ctx)
	case schedule.FieldDate:
		return m.OldDate(ctx)
	case schedule.FieldStartTime:
		return m.OldStartTime(ctx)
	case schedule.FieldEndTime:
		return m.OldEndTime(ctx)
	case schedule.FieldPrice:
		return m.OldPrice(ctx)
	case schedule.FieldRemark:
		return m.OldRemark(ctx)
	case schedule.FieldVenueName:
		return m.OldVenueName(ctx)
	case schedule.FieldPlaceName:
		return m.OldPlaceName(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case schedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case schedule.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case schedule.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case schedule.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case schedule.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case schedule.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case schedule.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case schedule.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case schedule.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceID(v)
		return nil
	case schedule.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case schedule.FieldNumSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumSurplus(v)
		return nil
	case schedule.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case schedule.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case schedule.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case schedule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case schedule.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case schedule.FieldVenueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueName(v)
		return nil
	case schedule.FieldPlaceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceName(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, schedule.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, schedule.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, schedule.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, schedule.FieldVenueID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, schedule.FieldProductID)
	}
	if m.addlength != nil {
		fields = append(fields, schedule.FieldLength)
	}
	if m.addplace_id != nil {
		fields = append(fields, schedule.FieldPlaceID)
	}
	if m.addnum != nil {
		fields = append(fields, schedule.FieldNum)
	}
	if m.addnum_surplus != nil {
		fields = append(fields, schedule.FieldNumSurplus)
	}
	if m.addprice != nil {
		fields = append(fields, schedule.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldDelete:
		return m.AddedDelete()
	case schedule.FieldCreatedID:
		return m.AddedCreatedID()
	case schedule.FieldStatus:
		return m.AddedStatus()
	case schedule.FieldVenueID:
		return m.AddedVenueID()
	case schedule.FieldProductID:
		return m.AddedProductID()
	case schedule.FieldLength:
		return m.AddedLength()
	case schedule.FieldPlaceID:
		return m.AddedPlaceID()
	case schedule.FieldNum:
		return m.AddedNum()
	case schedule.FieldNumSurplus:
		return m.AddedNumSurplus()
	case schedule.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case schedule.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case schedule.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case schedule.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case schedule.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case schedule.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case schedule.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlaceID(v)
		return nil
	case schedule.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case schedule.FieldNumSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumSurplus(v)
		return nil
	case schedule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedule.FieldCreatedAt) {
		fields = append(fields, schedule.FieldCreatedAt)
	}
	if m.FieldCleared(schedule.FieldUpdatedAt) {
		fields = append(fields, schedule.FieldUpdatedAt)
	}
	if m.FieldCleared(schedule.FieldDelete) {
		fields = append(fields, schedule.FieldDelete)
	}
	if m.FieldCleared(schedule.FieldCreatedID) {
		fields = append(fields, schedule.FieldCreatedID)
	}
	if m.FieldCleared(schedule.FieldStatus) {
		fields = append(fields, schedule.FieldStatus)
	}
	if m.FieldCleared(schedule.FieldType) {
		fields = append(fields, schedule.FieldType)
	}
	if m.FieldCleared(schedule.FieldName) {
		fields = append(fields, schedule.FieldName)
	}
	if m.FieldCleared(schedule.FieldVenueID) {
		fields = append(fields, schedule.FieldVenueID)
	}
	if m.FieldCleared(schedule.FieldProductID) {
		fields = append(fields, schedule.FieldProductID)
	}
	if m.FieldCleared(schedule.FieldLength) {
		fields = append(fields, schedule.FieldLength)
	}
	if m.FieldCleared(schedule.FieldPlaceID) {
		fields = append(fields, schedule.FieldPlaceID)
	}
	if m.FieldCleared(schedule.FieldNum) {
		fields = append(fields, schedule.FieldNum)
	}
	if m.FieldCleared(schedule.FieldNumSurplus) {
		fields = append(fields, schedule.FieldNumSurplus)
	}
	if m.FieldCleared(schedule.FieldDate) {
		fields = append(fields, schedule.FieldDate)
	}
	if m.FieldCleared(schedule.FieldStartTime) {
		fields = append(fields, schedule.FieldStartTime)
	}
	if m.FieldCleared(schedule.FieldEndTime) {
		fields = append(fields, schedule.FieldEndTime)
	}
	if m.FieldCleared(schedule.FieldPrice) {
		fields = append(fields, schedule.FieldPrice)
	}
	if m.FieldCleared(schedule.FieldRemark) {
		fields = append(fields, schedule.FieldRemark)
	}
	if m.FieldCleared(schedule.FieldVenueName) {
		fields = append(fields, schedule.FieldVenueName)
	}
	if m.FieldCleared(schedule.FieldPlaceName) {
		fields = append(fields, schedule.FieldPlaceName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	switch name {
	case schedule.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case schedule.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case schedule.FieldDelete:
		m.ClearDelete()
		return nil
	case schedule.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case schedule.FieldStatus:
		m.ClearStatus()
		return nil
	case schedule.FieldType:
		m.ClearType()
		return nil
	case schedule.FieldName:
		m.ClearName()
		return nil
	case schedule.FieldVenueID:
		m.ClearVenueID()
		return nil
	case schedule.FieldProductID:
		m.ClearProductID()
		return nil
	case schedule.FieldLength:
		m.ClearLength()
		return nil
	case schedule.FieldPlaceID:
		m.ClearPlaceID()
		return nil
	case schedule.FieldNum:
		m.ClearNum()
		return nil
	case schedule.FieldNumSurplus:
		m.ClearNumSurplus()
		return nil
	case schedule.FieldDate:
		m.ClearDate()
		return nil
	case schedule.FieldStartTime:
		m.ClearStartTime()
		return nil
	case schedule.FieldEndTime:
		m.ClearEndTime()
		return nil
	case schedule.FieldPrice:
		m.ClearPrice()
		return nil
	case schedule.FieldRemark:
		m.ClearRemark()
		return nil
	case schedule.FieldVenueName:
		m.ClearVenueName()
		return nil
	case schedule.FieldPlaceName:
		m.ClearPlaceName()
		return nil
	}
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case schedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case schedule.FieldDelete:
		m.ResetDelete()
		return nil
	case schedule.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case schedule.FieldStatus:
		m.ResetStatus()
		return nil
	case schedule.FieldType:
		m.ResetType()
		return nil
	case schedule.FieldName:
		m.ResetName()
		return nil
	case schedule.FieldVenueID:
		m.ResetVenueID()
		return nil
	case schedule.FieldProductID:
		m.ResetProductID()
		return nil
	case schedule.FieldLength:
		m.ResetLength()
		return nil
	case schedule.FieldPlaceID:
		m.ResetPlaceID()
		return nil
	case schedule.FieldNum:
		m.ResetNum()
		return nil
	case schedule.FieldNumSurplus:
		m.ResetNumSurplus()
		return nil
	case schedule.FieldDate:
		m.ResetDate()
		return nil
	case schedule.FieldStartTime:
		m.ResetStartTime()
		return nil
	case schedule.FieldEndTime:
		m.ResetEndTime()
		return nil
	case schedule.FieldPrice:
		m.ResetPrice()
		return nil
	case schedule.FieldRemark:
		m.ResetRemark()
		return nil
	case schedule.FieldVenueName:
		m.ResetVenueName()
		return nil
	case schedule.FieldPlaceName:
		m.ResetPlaceName()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.members != nil {
		edges = append(edges, schedule.EdgeMembers)
	}
	if m.coachs != nil {
		edges = append(edges, schedule.EdgeCoachs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case schedule.EdgeCoachs:
		ids := make([]ent.Value, 0, len(m.coachs))
		for id := range m.coachs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, schedule.EdgeMembers)
	}
	if m.removedcoachs != nil {
		edges = append(edges, schedule.EdgeCoachs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case schedule.EdgeCoachs:
		ids := make([]ent.Value, 0, len(m.removedcoachs))
		for id := range m.removedcoachs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmembers {
		edges = append(edges, schedule.EdgeMembers)
	}
	if m.clearedcoachs {
		edges = append(edges, schedule.EdgeCoachs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeMembers:
		return m.clearedmembers
	case schedule.EdgeCoachs:
		return m.clearedcoachs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeMembers:
		m.ResetMembers()
		return nil
	case schedule.EdgeCoachs:
		m.ResetCoachs()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// ScheduleCoachMutation represents an operation that mutates the ScheduleCoach nodes in the graph.
type ScheduleCoachMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	venue_id        *int64
	addvenue_id     *int64
	coach_id        *int64
	addcoach_id     *int64
	place_id        *int64
	addplace_id     *int64
	product_id      *int64
	addproduct_id   *int64
	schedule_name   *string
	_type           *string
	start_time      *time.Time
	end_time        *time.Time
	sign_start_time *time.Time
	sign_end_time   *time.Time
	coach_name      *string
	clearedFields   map[string]struct{}
	schedule        *int64
	clearedschedule bool
	done            bool
	oldValue        func(context.Context) (*ScheduleCoach, error)
	predicates      []predicate.ScheduleCoach
}

var _ ent.Mutation = (*ScheduleCoachMutation)(nil)

// schedulecoachOption allows management of the mutation configuration using functional options.
type schedulecoachOption func(*ScheduleCoachMutation)

// newScheduleCoachMutation creates new mutation for the ScheduleCoach entity.
func newScheduleCoachMutation(c config, op Op, opts ...schedulecoachOption) *ScheduleCoachMutation {
	m := &ScheduleCoachMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduleCoach,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleCoachID sets the ID field of the mutation.
func withScheduleCoachID(id int64) schedulecoachOption {
	return func(m *ScheduleCoachMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduleCoach
		)
		m.oldValue = func(ctx context.Context) (*ScheduleCoach, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduleCoach.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduleCoach sets the old ScheduleCoach of the mutation.
func withScheduleCoach(node *ScheduleCoach) schedulecoachOption {
	return func(m *ScheduleCoachMutation) {
		m.oldValue = func(context.Context) (*ScheduleCoach, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleCoachMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleCoachMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheduleCoach entities.
func (m *ScheduleCoachMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleCoachMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleCoachMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduleCoach.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduleCoachMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduleCoachMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ScheduleCoachMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[schedulecoach.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ScheduleCoachMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduleCoachMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, schedulecoach.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduleCoachMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduleCoachMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ScheduleCoachMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[schedulecoach.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ScheduleCoachMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduleCoachMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, schedulecoach.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ScheduleCoachMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ScheduleCoachMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ScheduleCoachMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ScheduleCoachMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ScheduleCoachMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[schedulecoach.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ScheduleCoachMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ScheduleCoachMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, schedulecoach.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ScheduleCoachMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ScheduleCoachMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ScheduleCoachMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ScheduleCoachMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ScheduleCoachMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[schedulecoach.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ScheduleCoachMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, schedulecoach.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ScheduleCoachMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScheduleCoachMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScheduleCoachMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScheduleCoachMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ScheduleCoachMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[schedulecoach.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ScheduleCoachMutation) StatusCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ScheduleCoachMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, schedulecoach.FieldStatus)
}

// SetVenueID sets the "venue_id" field.
func (m *ScheduleCoachMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ScheduleCoachMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ScheduleCoachMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ScheduleCoachMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ScheduleCoachMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[schedulecoach.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ScheduleCoachMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, schedulecoach.FieldVenueID)
}

// SetCoachID sets the "coach_id" field.
func (m *ScheduleCoachMutation) SetCoachID(i int64) {
	m.coach_id = &i
	m.addcoach_id = nil
}

// CoachID returns the value of the "coach_id" field in the mutation.
func (m *ScheduleCoachMutation) CoachID() (r int64, exists bool) {
	v := m.coach_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoachID returns the old "coach_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldCoachID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoachID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoachID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoachID: %w", err)
	}
	return oldValue.CoachID, nil
}

// AddCoachID adds i to the "coach_id" field.
func (m *ScheduleCoachMutation) AddCoachID(i int64) {
	if m.addcoach_id != nil {
		*m.addcoach_id += i
	} else {
		m.addcoach_id = &i
	}
}

// AddedCoachID returns the value that was added to the "coach_id" field in this mutation.
func (m *ScheduleCoachMutation) AddedCoachID() (r int64, exists bool) {
	v := m.addcoach_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoachID clears the value of the "coach_id" field.
func (m *ScheduleCoachMutation) ClearCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	m.clearedFields[schedulecoach.FieldCoachID] = struct{}{}
}

// CoachIDCleared returns if the "coach_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) CoachIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldCoachID]
	return ok
}

// ResetCoachID resets all changes to the "coach_id" field.
func (m *ScheduleCoachMutation) ResetCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	delete(m.clearedFields, schedulecoach.FieldCoachID)
}

// SetPlaceID sets the "place_id" field.
func (m *ScheduleCoachMutation) SetPlaceID(i int64) {
	m.place_id = &i
	m.addplace_id = nil
}

// PlaceID returns the value of the "place_id" field in the mutation.
func (m *ScheduleCoachMutation) PlaceID() (r int64, exists bool) {
	v := m.place_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceID returns the old "place_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldPlaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceID: %w", err)
	}
	return oldValue.PlaceID, nil
}

// AddPlaceID adds i to the "place_id" field.
func (m *ScheduleCoachMutation) AddPlaceID(i int64) {
	if m.addplace_id != nil {
		*m.addplace_id += i
	} else {
		m.addplace_id = &i
	}
}

// AddedPlaceID returns the value that was added to the "place_id" field in this mutation.
func (m *ScheduleCoachMutation) AddedPlaceID() (r int64, exists bool) {
	v := m.addplace_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlaceID clears the value of the "place_id" field.
func (m *ScheduleCoachMutation) ClearPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	m.clearedFields[schedulecoach.FieldPlaceID] = struct{}{}
}

// PlaceIDCleared returns if the "place_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) PlaceIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldPlaceID]
	return ok
}

// ResetPlaceID resets all changes to the "place_id" field.
func (m *ScheduleCoachMutation) ResetPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	delete(m.clearedFields, schedulecoach.FieldPlaceID)
}

// SetScheduleID sets the "schedule_id" field.
func (m *ScheduleCoachMutation) SetScheduleID(i int64) {
	m.schedule = &i
}

// ScheduleID returns the value of the "schedule_id" field in the mutation.
func (m *ScheduleCoachMutation) ScheduleID() (r int64, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleID returns the old "schedule_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldScheduleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleID: %w", err)
	}
	return oldValue.ScheduleID, nil
}

// ClearScheduleID clears the value of the "schedule_id" field.
func (m *ScheduleCoachMutation) ClearScheduleID() {
	m.schedule = nil
	m.clearedFields[schedulecoach.FieldScheduleID] = struct{}{}
}

// ScheduleIDCleared returns if the "schedule_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) ScheduleIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldScheduleID]
	return ok
}

// ResetScheduleID resets all changes to the "schedule_id" field.
func (m *ScheduleCoachMutation) ResetScheduleID() {
	m.schedule = nil
	delete(m.clearedFields, schedulecoach.FieldScheduleID)
}

// SetProductID sets the "product_id" field.
func (m *ScheduleCoachMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ScheduleCoachMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ScheduleCoachMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ScheduleCoachMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ScheduleCoachMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[schedulecoach.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ScheduleCoachMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, schedulecoach.FieldProductID)
}

// SetScheduleName sets the "schedule_name" field.
func (m *ScheduleCoachMutation) SetScheduleName(s string) {
	m.schedule_name = &s
}

// ScheduleName returns the value of the "schedule_name" field in the mutation.
func (m *ScheduleCoachMutation) ScheduleName() (r string, exists bool) {
	v := m.schedule_name
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleName returns the old "schedule_name" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldScheduleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleName: %w", err)
	}
	return oldValue.ScheduleName, nil
}

// ClearScheduleName clears the value of the "schedule_name" field.
func (m *ScheduleCoachMutation) ClearScheduleName() {
	m.schedule_name = nil
	m.clearedFields[schedulecoach.FieldScheduleName] = struct{}{}
}

// ScheduleNameCleared returns if the "schedule_name" field was cleared in this mutation.
func (m *ScheduleCoachMutation) ScheduleNameCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldScheduleName]
	return ok
}

// ResetScheduleName resets all changes to the "schedule_name" field.
func (m *ScheduleCoachMutation) ResetScheduleName() {
	m.schedule_name = nil
	delete(m.clearedFields, schedulecoach.FieldScheduleName)
}

// SetType sets the "type" field.
func (m *ScheduleCoachMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduleCoachMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ScheduleCoachMutation) ClearType() {
	m._type = nil
	m.clearedFields[schedulecoach.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ScheduleCoachMutation) TypeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ScheduleCoachMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, schedulecoach.FieldType)
}

// SetStartTime sets the "start_time" field.
func (m *ScheduleCoachMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ScheduleCoachMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ScheduleCoachMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[schedulecoach.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ScheduleCoachMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, schedulecoach.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ScheduleCoachMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ScheduleCoachMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ScheduleCoachMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[schedulecoach.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ScheduleCoachMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, schedulecoach.FieldEndTime)
}

// SetSignStartTime sets the "sign_start_time" field.
func (m *ScheduleCoachMutation) SetSignStartTime(t time.Time) {
	m.sign_start_time = &t
}

// SignStartTime returns the value of the "sign_start_time" field in the mutation.
func (m *ScheduleCoachMutation) SignStartTime() (r time.Time, exists bool) {
	v := m.sign_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartTime returns the old "sign_start_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldSignStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartTime: %w", err)
	}
	return oldValue.SignStartTime, nil
}

// ClearSignStartTime clears the value of the "sign_start_time" field.
func (m *ScheduleCoachMutation) ClearSignStartTime() {
	m.sign_start_time = nil
	m.clearedFields[schedulecoach.FieldSignStartTime] = struct{}{}
}

// SignStartTimeCleared returns if the "sign_start_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) SignStartTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldSignStartTime]
	return ok
}

// ResetSignStartTime resets all changes to the "sign_start_time" field.
func (m *ScheduleCoachMutation) ResetSignStartTime() {
	m.sign_start_time = nil
	delete(m.clearedFields, schedulecoach.FieldSignStartTime)
}

// SetSignEndTime sets the "sign_end_time" field.
func (m *ScheduleCoachMutation) SetSignEndTime(t time.Time) {
	m.sign_end_time = &t
}

// SignEndTime returns the value of the "sign_end_time" field in the mutation.
func (m *ScheduleCoachMutation) SignEndTime() (r time.Time, exists bool) {
	v := m.sign_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndTime returns the old "sign_end_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldSignEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndTime: %w", err)
	}
	return oldValue.SignEndTime, nil
}

// ClearSignEndTime clears the value of the "sign_end_time" field.
func (m *ScheduleCoachMutation) ClearSignEndTime() {
	m.sign_end_time = nil
	m.clearedFields[schedulecoach.FieldSignEndTime] = struct{}{}
}

// SignEndTimeCleared returns if the "sign_end_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) SignEndTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldSignEndTime]
	return ok
}

// ResetSignEndTime resets all changes to the "sign_end_time" field.
func (m *ScheduleCoachMutation) ResetSignEndTime() {
	m.sign_end_time = nil
	delete(m.clearedFields, schedulecoach.FieldSignEndTime)
}

// SetCoachName sets the "coach_name" field.
func (m *ScheduleCoachMutation) SetCoachName(s string) {
	m.coach_name = &s
}

// CoachName returns the value of the "coach_name" field in the mutation.
func (m *ScheduleCoachMutation) CoachName() (r string, exists bool) {
	v := m.coach_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCoachName returns the old "coach_name" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldCoachName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoachName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoachName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoachName: %w", err)
	}
	return oldValue.CoachName, nil
}

// ClearCoachName clears the value of the "coach_name" field.
func (m *ScheduleCoachMutation) ClearCoachName() {
	m.coach_name = nil
	m.clearedFields[schedulecoach.FieldCoachName] = struct{}{}
}

// CoachNameCleared returns if the "coach_name" field was cleared in this mutation.
func (m *ScheduleCoachMutation) CoachNameCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldCoachName]
	return ok
}

// ResetCoachName resets all changes to the "coach_name" field.
func (m *ScheduleCoachMutation) ResetCoachName() {
	m.coach_name = nil
	delete(m.clearedFields, schedulecoach.FieldCoachName)
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *ScheduleCoachMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[schedulecoach.FieldScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *ScheduleCoachMutation) ScheduleCleared() bool {
	return m.ScheduleIDCleared() || m.clearedschedule
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ScheduleCoachMutation) ScheduleIDs() (ids []int64) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ScheduleCoachMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the ScheduleCoachMutation builder.
func (m *ScheduleCoachMutation) Where(ps ...predicate.ScheduleCoach) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleCoachMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleCoachMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheduleCoach, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleCoachMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleCoachMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheduleCoach).
func (m *ScheduleCoachMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleCoachMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, schedulecoach.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, schedulecoach.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, schedulecoach.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, schedulecoach.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, schedulecoach.FieldStatus)
	}
	if m.venue_id != nil {
		fields = append(fields, schedulecoach.FieldVenueID)
	}
	if m.coach_id != nil {
		fields = append(fields, schedulecoach.FieldCoachID)
	}
	if m.place_id != nil {
		fields = append(fields, schedulecoach.FieldPlaceID)
	}
	if m.schedule != nil {
		fields = append(fields, schedulecoach.FieldScheduleID)
	}
	if m.product_id != nil {
		fields = append(fields, schedulecoach.FieldProductID)
	}
	if m.schedule_name != nil {
		fields = append(fields, schedulecoach.FieldScheduleName)
	}
	if m._type != nil {
		fields = append(fields, schedulecoach.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, schedulecoach.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, schedulecoach.FieldEndTime)
	}
	if m.sign_start_time != nil {
		fields = append(fields, schedulecoach.FieldSignStartTime)
	}
	if m.sign_end_time != nil {
		fields = append(fields, schedulecoach.FieldSignEndTime)
	}
	if m.coach_name != nil {
		fields = append(fields, schedulecoach.FieldCoachName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleCoachMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedulecoach.FieldCreatedAt:
		return m.CreatedAt()
	case schedulecoach.FieldUpdatedAt:
		return m.UpdatedAt()
	case schedulecoach.FieldDelete:
		return m.Delete()
	case schedulecoach.FieldCreatedID:
		return m.CreatedID()
	case schedulecoach.FieldStatus:
		return m.Status()
	case schedulecoach.FieldVenueID:
		return m.VenueID()
	case schedulecoach.FieldCoachID:
		return m.CoachID()
	case schedulecoach.FieldPlaceID:
		return m.PlaceID()
	case schedulecoach.FieldScheduleID:
		return m.ScheduleID()
	case schedulecoach.FieldProductID:
		return m.ProductID()
	case schedulecoach.FieldScheduleName:
		return m.ScheduleName()
	case schedulecoach.FieldType:
		return m.GetType()
	case schedulecoach.FieldStartTime:
		return m.StartTime()
	case schedulecoach.FieldEndTime:
		return m.EndTime()
	case schedulecoach.FieldSignStartTime:
		return m.SignStartTime()
	case schedulecoach.FieldSignEndTime:
		return m.SignEndTime()
	case schedulecoach.FieldCoachName:
		return m.CoachName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleCoachMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedulecoach.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case schedulecoach.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case schedulecoach.FieldDelete:
		return m.OldDelete(ctx)
	case schedulecoach.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case schedulecoach.FieldStatus:
		return m.OldStatus(ctx)
	case schedulecoach.FieldVenueID:
		return m.OldVenueID(ctx)
	case schedulecoach.FieldCoachID:
		return m.OldCoachID(ctx)
	case schedulecoach.FieldPlaceID:
		return m.OldPlaceID(ctx)
	case schedulecoach.FieldScheduleID:
		return m.OldScheduleID(ctx)
	case schedulecoach.FieldProductID:
		return m.OldProductID(ctx)
	case schedulecoach.FieldScheduleName:
		return m.OldScheduleName(ctx)
	case schedulecoach.FieldType:
		return m.OldType(ctx)
	case schedulecoach.FieldStartTime:
		return m.OldStartTime(ctx)
	case schedulecoach.FieldEndTime:
		return m.OldEndTime(ctx)
	case schedulecoach.FieldSignStartTime:
		return m.OldSignStartTime(ctx)
	case schedulecoach.FieldSignEndTime:
		return m.OldSignEndTime(ctx)
	case schedulecoach.FieldCoachName:
		return m.OldCoachName(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduleCoach field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleCoachMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedulecoach.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case schedulecoach.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case schedulecoach.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case schedulecoach.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case schedulecoach.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case schedulecoach.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case schedulecoach.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoachID(v)
		return nil
	case schedulecoach.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceID(v)
		return nil
	case schedulecoach.FieldScheduleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleID(v)
		return nil
	case schedulecoach.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case schedulecoach.FieldScheduleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleName(v)
		return nil
	case schedulecoach.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schedulecoach.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case schedulecoach.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case schedulecoach.FieldSignStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartTime(v)
		return nil
	case schedulecoach.FieldSignEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndTime(v)
		return nil
	case schedulecoach.FieldCoachName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoachName(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleCoachMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, schedulecoach.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, schedulecoach.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, schedulecoach.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, schedulecoach.FieldVenueID)
	}
	if m.addcoach_id != nil {
		fields = append(fields, schedulecoach.FieldCoachID)
	}
	if m.addplace_id != nil {
		fields = append(fields, schedulecoach.FieldPlaceID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, schedulecoach.FieldProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleCoachMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedulecoach.FieldDelete:
		return m.AddedDelete()
	case schedulecoach.FieldCreatedID:
		return m.AddedCreatedID()
	case schedulecoach.FieldStatus:
		return m.AddedStatus()
	case schedulecoach.FieldVenueID:
		return m.AddedVenueID()
	case schedulecoach.FieldCoachID:
		return m.AddedCoachID()
	case schedulecoach.FieldPlaceID:
		return m.AddedPlaceID()
	case schedulecoach.FieldProductID:
		return m.AddedProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleCoachMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedulecoach.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case schedulecoach.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case schedulecoach.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case schedulecoach.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case schedulecoach.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoachID(v)
		return nil
	case schedulecoach.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlaceID(v)
		return nil
	case schedulecoach.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleCoachMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedulecoach.FieldCreatedAt) {
		fields = append(fields, schedulecoach.FieldCreatedAt)
	}
	if m.FieldCleared(schedulecoach.FieldUpdatedAt) {
		fields = append(fields, schedulecoach.FieldUpdatedAt)
	}
	if m.FieldCleared(schedulecoach.FieldDelete) {
		fields = append(fields, schedulecoach.FieldDelete)
	}
	if m.FieldCleared(schedulecoach.FieldCreatedID) {
		fields = append(fields, schedulecoach.FieldCreatedID)
	}
	if m.FieldCleared(schedulecoach.FieldStatus) {
		fields = append(fields, schedulecoach.FieldStatus)
	}
	if m.FieldCleared(schedulecoach.FieldVenueID) {
		fields = append(fields, schedulecoach.FieldVenueID)
	}
	if m.FieldCleared(schedulecoach.FieldCoachID) {
		fields = append(fields, schedulecoach.FieldCoachID)
	}
	if m.FieldCleared(schedulecoach.FieldPlaceID) {
		fields = append(fields, schedulecoach.FieldPlaceID)
	}
	if m.FieldCleared(schedulecoach.FieldScheduleID) {
		fields = append(fields, schedulecoach.FieldScheduleID)
	}
	if m.FieldCleared(schedulecoach.FieldProductID) {
		fields = append(fields, schedulecoach.FieldProductID)
	}
	if m.FieldCleared(schedulecoach.FieldScheduleName) {
		fields = append(fields, schedulecoach.FieldScheduleName)
	}
	if m.FieldCleared(schedulecoach.FieldType) {
		fields = append(fields, schedulecoach.FieldType)
	}
	if m.FieldCleared(schedulecoach.FieldStartTime) {
		fields = append(fields, schedulecoach.FieldStartTime)
	}
	if m.FieldCleared(schedulecoach.FieldEndTime) {
		fields = append(fields, schedulecoach.FieldEndTime)
	}
	if m.FieldCleared(schedulecoach.FieldSignStartTime) {
		fields = append(fields, schedulecoach.FieldSignStartTime)
	}
	if m.FieldCleared(schedulecoach.FieldSignEndTime) {
		fields = append(fields, schedulecoach.FieldSignEndTime)
	}
	if m.FieldCleared(schedulecoach.FieldCoachName) {
		fields = append(fields, schedulecoach.FieldCoachName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleCoachMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleCoachMutation) ClearField(name string) error {
	switch name {
	case schedulecoach.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case schedulecoach.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case schedulecoach.FieldDelete:
		m.ClearDelete()
		return nil
	case schedulecoach.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case schedulecoach.FieldStatus:
		m.ClearStatus()
		return nil
	case schedulecoach.FieldVenueID:
		m.ClearVenueID()
		return nil
	case schedulecoach.FieldCoachID:
		m.ClearCoachID()
		return nil
	case schedulecoach.FieldPlaceID:
		m.ClearPlaceID()
		return nil
	case schedulecoach.FieldScheduleID:
		m.ClearScheduleID()
		return nil
	case schedulecoach.FieldProductID:
		m.ClearProductID()
		return nil
	case schedulecoach.FieldScheduleName:
		m.ClearScheduleName()
		return nil
	case schedulecoach.FieldType:
		m.ClearType()
		return nil
	case schedulecoach.FieldStartTime:
		m.ClearStartTime()
		return nil
	case schedulecoach.FieldEndTime:
		m.ClearEndTime()
		return nil
	case schedulecoach.FieldSignStartTime:
		m.ClearSignStartTime()
		return nil
	case schedulecoach.FieldSignEndTime:
		m.ClearSignEndTime()
		return nil
	case schedulecoach.FieldCoachName:
		m.ClearCoachName()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleCoachMutation) ResetField(name string) error {
	switch name {
	case schedulecoach.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case schedulecoach.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case schedulecoach.FieldDelete:
		m.ResetDelete()
		return nil
	case schedulecoach.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case schedulecoach.FieldStatus:
		m.ResetStatus()
		return nil
	case schedulecoach.FieldVenueID:
		m.ResetVenueID()
		return nil
	case schedulecoach.FieldCoachID:
		m.ResetCoachID()
		return nil
	case schedulecoach.FieldPlaceID:
		m.ResetPlaceID()
		return nil
	case schedulecoach.FieldScheduleID:
		m.ResetScheduleID()
		return nil
	case schedulecoach.FieldProductID:
		m.ResetProductID()
		return nil
	case schedulecoach.FieldScheduleName:
		m.ResetScheduleName()
		return nil
	case schedulecoach.FieldType:
		m.ResetType()
		return nil
	case schedulecoach.FieldStartTime:
		m.ResetStartTime()
		return nil
	case schedulecoach.FieldEndTime:
		m.ResetEndTime()
		return nil
	case schedulecoach.FieldSignStartTime:
		m.ResetSignStartTime()
		return nil
	case schedulecoach.FieldSignEndTime:
		m.ResetSignEndTime()
		return nil
	case schedulecoach.FieldCoachName:
		m.ResetCoachName()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleCoachMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.schedule != nil {
		edges = append(edges, schedulecoach.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleCoachMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedulecoach.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleCoachMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleCoachMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleCoachMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedschedule {
		edges = append(edges, schedulecoach.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleCoachMutation) EdgeCleared(name string) bool {
	switch name {
	case schedulecoach.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleCoachMutation) ClearEdge(name string) error {
	switch name {
	case schedulecoach.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleCoachMutation) ResetEdge(name string) error {
	switch name {
	case schedulecoach.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach edge %s", name)
}

// ScheduleMemberMutation represents an operation that mutates the ScheduleMember nodes in the graph.
type ScheduleMemberMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	delete               *int64
	adddelete            *int64
	created_id           *int64
	addcreated_id        *int64
	status               *int64
	addstatus            *int64
	venue_id             *int64
	addvenue_id          *int64
	place_id             *int64
	addplace_id          *int64
	schedule_name        *string
	member_id            *int64
	addmember_id         *int64
	member_product_id    *int64
	addmember_product_id *int64
	_type                *string
	start_time           *time.Time
	end_time             *time.Time
	sign_start_time      *time.Time
	sign_end_time        *time.Time
	seat                 *base.Seat
	member_name          *string
	member_product_name  *string
	remark               *string
	clearedFields        map[string]struct{}
	schedule             *int64
	clearedschedule      bool
	done                 bool
	oldValue             func(context.Context) (*ScheduleMember, error)
	predicates           []predicate.ScheduleMember
}

var _ ent.Mutation = (*ScheduleMemberMutation)(nil)

// schedulememberOption allows management of the mutation configuration using functional options.
type schedulememberOption func(*ScheduleMemberMutation)

// newScheduleMemberMutation creates new mutation for the ScheduleMember entity.
func newScheduleMemberMutation(c config, op Op, opts ...schedulememberOption) *ScheduleMemberMutation {
	m := &ScheduleMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduleMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleMemberID sets the ID field of the mutation.
func withScheduleMemberID(id int64) schedulememberOption {
	return func(m *ScheduleMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduleMember
		)
		m.oldValue = func(ctx context.Context) (*ScheduleMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduleMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduleMember sets the old ScheduleMember of the mutation.
func withScheduleMember(node *ScheduleMember) schedulememberOption {
	return func(m *ScheduleMemberMutation) {
		m.oldValue = func(context.Context) (*ScheduleMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheduleMember entities.
func (m *ScheduleMemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduleMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduleMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduleMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ScheduleMemberMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[schedulemember.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ScheduleMemberMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduleMemberMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, schedulemember.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduleMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduleMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ScheduleMemberMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[schedulemember.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ScheduleMemberMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduleMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, schedulemember.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ScheduleMemberMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ScheduleMemberMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ScheduleMemberMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ScheduleMemberMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ScheduleMemberMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[schedulemember.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ScheduleMemberMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ScheduleMemberMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, schedulemember.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ScheduleMemberMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ScheduleMemberMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ScheduleMemberMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ScheduleMemberMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[schedulemember.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ScheduleMemberMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, schedulemember.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ScheduleMemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScheduleMemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScheduleMemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScheduleMemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ScheduleMemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[schedulemember.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ScheduleMemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ScheduleMemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, schedulemember.FieldStatus)
}

// SetVenueID sets the "venue_id" field.
func (m *ScheduleMemberMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ScheduleMemberMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ScheduleMemberMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ScheduleMemberMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[schedulemember.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ScheduleMemberMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, schedulemember.FieldVenueID)
}

// SetPlaceID sets the "place_id" field.
func (m *ScheduleMemberMutation) SetPlaceID(i int64) {
	m.place_id = &i
	m.addplace_id = nil
}

// PlaceID returns the value of the "place_id" field in the mutation.
func (m *ScheduleMemberMutation) PlaceID() (r int64, exists bool) {
	v := m.place_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceID returns the old "place_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldPlaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceID: %w", err)
	}
	return oldValue.PlaceID, nil
}

// AddPlaceID adds i to the "place_id" field.
func (m *ScheduleMemberMutation) AddPlaceID(i int64) {
	if m.addplace_id != nil {
		*m.addplace_id += i
	} else {
		m.addplace_id = &i
	}
}

// AddedPlaceID returns the value that was added to the "place_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedPlaceID() (r int64, exists bool) {
	v := m.addplace_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlaceID clears the value of the "place_id" field.
func (m *ScheduleMemberMutation) ClearPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	m.clearedFields[schedulemember.FieldPlaceID] = struct{}{}
}

// PlaceIDCleared returns if the "place_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) PlaceIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldPlaceID]
	return ok
}

// ResetPlaceID resets all changes to the "place_id" field.
func (m *ScheduleMemberMutation) ResetPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	delete(m.clearedFields, schedulemember.FieldPlaceID)
}

// SetScheduleID sets the "schedule_id" field.
func (m *ScheduleMemberMutation) SetScheduleID(i int64) {
	m.schedule = &i
}

// ScheduleID returns the value of the "schedule_id" field in the mutation.
func (m *ScheduleMemberMutation) ScheduleID() (r int64, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleID returns the old "schedule_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldScheduleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleID: %w", err)
	}
	return oldValue.ScheduleID, nil
}

// ClearScheduleID clears the value of the "schedule_id" field.
func (m *ScheduleMemberMutation) ClearScheduleID() {
	m.schedule = nil
	m.clearedFields[schedulemember.FieldScheduleID] = struct{}{}
}

// ScheduleIDCleared returns if the "schedule_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) ScheduleIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldScheduleID]
	return ok
}

// ResetScheduleID resets all changes to the "schedule_id" field.
func (m *ScheduleMemberMutation) ResetScheduleID() {
	m.schedule = nil
	delete(m.clearedFields, schedulemember.FieldScheduleID)
}

// SetScheduleName sets the "schedule_name" field.
func (m *ScheduleMemberMutation) SetScheduleName(s string) {
	m.schedule_name = &s
}

// ScheduleName returns the value of the "schedule_name" field in the mutation.
func (m *ScheduleMemberMutation) ScheduleName() (r string, exists bool) {
	v := m.schedule_name
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleName returns the old "schedule_name" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldScheduleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleName: %w", err)
	}
	return oldValue.ScheduleName, nil
}

// ClearScheduleName clears the value of the "schedule_name" field.
func (m *ScheduleMemberMutation) ClearScheduleName() {
	m.schedule_name = nil
	m.clearedFields[schedulemember.FieldScheduleName] = struct{}{}
}

// ScheduleNameCleared returns if the "schedule_name" field was cleared in this mutation.
func (m *ScheduleMemberMutation) ScheduleNameCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldScheduleName]
	return ok
}

// ResetScheduleName resets all changes to the "schedule_name" field.
func (m *ScheduleMemberMutation) ResetScheduleName() {
	m.schedule_name = nil
	delete(m.clearedFields, schedulemember.FieldScheduleName)
}

// SetMemberID sets the "member_id" field.
func (m *ScheduleMemberMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *ScheduleMemberMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *ScheduleMemberMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *ScheduleMemberMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[schedulemember.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *ScheduleMemberMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, schedulemember.FieldMemberID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *ScheduleMemberMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *ScheduleMemberMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *ScheduleMemberMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *ScheduleMemberMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[schedulemember.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *ScheduleMemberMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, schedulemember.FieldMemberProductID)
}

// SetType sets the "type" field.
func (m *ScheduleMemberMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduleMemberMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ScheduleMemberMutation) ClearType() {
	m._type = nil
	m.clearedFields[schedulemember.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ScheduleMemberMutation) TypeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ScheduleMemberMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, schedulemember.FieldType)
}

// SetStartTime sets the "start_time" field.
func (m *ScheduleMemberMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ScheduleMemberMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ScheduleMemberMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[schedulemember.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ScheduleMemberMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, schedulemember.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ScheduleMemberMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ScheduleMemberMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ScheduleMemberMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[schedulemember.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ScheduleMemberMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, schedulemember.FieldEndTime)
}

// SetSignStartTime sets the "sign_start_time" field.
func (m *ScheduleMemberMutation) SetSignStartTime(t time.Time) {
	m.sign_start_time = &t
}

// SignStartTime returns the value of the "sign_start_time" field in the mutation.
func (m *ScheduleMemberMutation) SignStartTime() (r time.Time, exists bool) {
	v := m.sign_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartTime returns the old "sign_start_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldSignStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartTime: %w", err)
	}
	return oldValue.SignStartTime, nil
}

// ClearSignStartTime clears the value of the "sign_start_time" field.
func (m *ScheduleMemberMutation) ClearSignStartTime() {
	m.sign_start_time = nil
	m.clearedFields[schedulemember.FieldSignStartTime] = struct{}{}
}

// SignStartTimeCleared returns if the "sign_start_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) SignStartTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldSignStartTime]
	return ok
}

// ResetSignStartTime resets all changes to the "sign_start_time" field.
func (m *ScheduleMemberMutation) ResetSignStartTime() {
	m.sign_start_time = nil
	delete(m.clearedFields, schedulemember.FieldSignStartTime)
}

// SetSignEndTime sets the "sign_end_time" field.
func (m *ScheduleMemberMutation) SetSignEndTime(t time.Time) {
	m.sign_end_time = &t
}

// SignEndTime returns the value of the "sign_end_time" field in the mutation.
func (m *ScheduleMemberMutation) SignEndTime() (r time.Time, exists bool) {
	v := m.sign_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndTime returns the old "sign_end_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldSignEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndTime: %w", err)
	}
	return oldValue.SignEndTime, nil
}

// ClearSignEndTime clears the value of the "sign_end_time" field.
func (m *ScheduleMemberMutation) ClearSignEndTime() {
	m.sign_end_time = nil
	m.clearedFields[schedulemember.FieldSignEndTime] = struct{}{}
}

// SignEndTimeCleared returns if the "sign_end_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) SignEndTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldSignEndTime]
	return ok
}

// ResetSignEndTime resets all changes to the "sign_end_time" field.
func (m *ScheduleMemberMutation) ResetSignEndTime() {
	m.sign_end_time = nil
	delete(m.clearedFields, schedulemember.FieldSignEndTime)
}

// SetSeat sets the "seat" field.
func (m *ScheduleMemberMutation) SetSeat(b base.Seat) {
	m.seat = &b
}

// Seat returns the value of the "seat" field in the mutation.
func (m *ScheduleMemberMutation) Seat() (r base.Seat, exists bool) {
	v := m.seat
	if v == nil {
		return
	}
	return *v, true
}

// OldSeat returns the old "seat" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldSeat(ctx context.Context) (v base.Seat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeat: %w", err)
	}
	return oldValue.Seat, nil
}

// ClearSeat clears the value of the "seat" field.
func (m *ScheduleMemberMutation) ClearSeat() {
	m.seat = nil
	m.clearedFields[schedulemember.FieldSeat] = struct{}{}
}

// SeatCleared returns if the "seat" field was cleared in this mutation.
func (m *ScheduleMemberMutation) SeatCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldSeat]
	return ok
}

// ResetSeat resets all changes to the "seat" field.
func (m *ScheduleMemberMutation) ResetSeat() {
	m.seat = nil
	delete(m.clearedFields, schedulemember.FieldSeat)
}

// SetMemberName sets the "member_name" field.
func (m *ScheduleMemberMutation) SetMemberName(s string) {
	m.member_name = &s
}

// MemberName returns the value of the "member_name" field in the mutation.
func (m *ScheduleMemberMutation) MemberName() (r string, exists bool) {
	v := m.member_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberName returns the old "member_name" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldMemberName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberName: %w", err)
	}
	return oldValue.MemberName, nil
}

// ClearMemberName clears the value of the "member_name" field.
func (m *ScheduleMemberMutation) ClearMemberName() {
	m.member_name = nil
	m.clearedFields[schedulemember.FieldMemberName] = struct{}{}
}

// MemberNameCleared returns if the "member_name" field was cleared in this mutation.
func (m *ScheduleMemberMutation) MemberNameCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldMemberName]
	return ok
}

// ResetMemberName resets all changes to the "member_name" field.
func (m *ScheduleMemberMutation) ResetMemberName() {
	m.member_name = nil
	delete(m.clearedFields, schedulemember.FieldMemberName)
}

// SetMemberProductName sets the "member_product_name" field.
func (m *ScheduleMemberMutation) SetMemberProductName(s string) {
	m.member_product_name = &s
}

// MemberProductName returns the value of the "member_product_name" field in the mutation.
func (m *ScheduleMemberMutation) MemberProductName() (r string, exists bool) {
	v := m.member_product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductName returns the old "member_product_name" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldMemberProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductName: %w", err)
	}
	return oldValue.MemberProductName, nil
}

// ClearMemberProductName clears the value of the "member_product_name" field.
func (m *ScheduleMemberMutation) ClearMemberProductName() {
	m.member_product_name = nil
	m.clearedFields[schedulemember.FieldMemberProductName] = struct{}{}
}

// MemberProductNameCleared returns if the "member_product_name" field was cleared in this mutation.
func (m *ScheduleMemberMutation) MemberProductNameCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldMemberProductName]
	return ok
}

// ResetMemberProductName resets all changes to the "member_product_name" field.
func (m *ScheduleMemberMutation) ResetMemberProductName() {
	m.member_product_name = nil
	delete(m.clearedFields, schedulemember.FieldMemberProductName)
}

// SetRemark sets the "remark" field.
func (m *ScheduleMemberMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ScheduleMemberMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ScheduleMemberMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[schedulemember.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ScheduleMemberMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ScheduleMemberMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, schedulemember.FieldRemark)
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *ScheduleMemberMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[schedulemember.FieldScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *ScheduleMemberMutation) ScheduleCleared() bool {
	return m.ScheduleIDCleared() || m.clearedschedule
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ScheduleMemberMutation) ScheduleIDs() (ids []int64) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ScheduleMemberMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the ScheduleMemberMutation builder.
func (m *ScheduleMemberMutation) Where(ps ...predicate.ScheduleMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheduleMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheduleMember).
func (m *ScheduleMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMemberMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, schedulemember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, schedulemember.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, schedulemember.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, schedulemember.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, schedulemember.FieldStatus)
	}
	if m.venue_id != nil {
		fields = append(fields, schedulemember.FieldVenueID)
	}
	if m.place_id != nil {
		fields = append(fields, schedulemember.FieldPlaceID)
	}
	if m.schedule != nil {
		fields = append(fields, schedulemember.FieldScheduleID)
	}
	if m.schedule_name != nil {
		fields = append(fields, schedulemember.FieldScheduleName)
	}
	if m.member_id != nil {
		fields = append(fields, schedulemember.FieldMemberID)
	}
	if m.member_product_id != nil {
		fields = append(fields, schedulemember.FieldMemberProductID)
	}
	if m._type != nil {
		fields = append(fields, schedulemember.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, schedulemember.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, schedulemember.FieldEndTime)
	}
	if m.sign_start_time != nil {
		fields = append(fields, schedulemember.FieldSignStartTime)
	}
	if m.sign_end_time != nil {
		fields = append(fields, schedulemember.FieldSignEndTime)
	}
	if m.seat != nil {
		fields = append(fields, schedulemember.FieldSeat)
	}
	if m.member_name != nil {
		fields = append(fields, schedulemember.FieldMemberName)
	}
	if m.member_product_name != nil {
		fields = append(fields, schedulemember.FieldMemberProductName)
	}
	if m.remark != nil {
		fields = append(fields, schedulemember.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedulemember.FieldCreatedAt:
		return m.CreatedAt()
	case schedulemember.FieldUpdatedAt:
		return m.UpdatedAt()
	case schedulemember.FieldDelete:
		return m.Delete()
	case schedulemember.FieldCreatedID:
		return m.CreatedID()
	case schedulemember.FieldStatus:
		return m.Status()
	case schedulemember.FieldVenueID:
		return m.VenueID()
	case schedulemember.FieldPlaceID:
		return m.PlaceID()
	case schedulemember.FieldScheduleID:
		return m.ScheduleID()
	case schedulemember.FieldScheduleName:
		return m.ScheduleName()
	case schedulemember.FieldMemberID:
		return m.MemberID()
	case schedulemember.FieldMemberProductID:
		return m.MemberProductID()
	case schedulemember.FieldType:
		return m.GetType()
	case schedulemember.FieldStartTime:
		return m.StartTime()
	case schedulemember.FieldEndTime:
		return m.EndTime()
	case schedulemember.FieldSignStartTime:
		return m.SignStartTime()
	case schedulemember.FieldSignEndTime:
		return m.SignEndTime()
	case schedulemember.FieldSeat:
		return m.Seat()
	case schedulemember.FieldMemberName:
		return m.MemberName()
	case schedulemember.FieldMemberProductName:
		return m.MemberProductName()
	case schedulemember.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedulemember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case schedulemember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case schedulemember.FieldDelete:
		return m.OldDelete(ctx)
	case schedulemember.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case schedulemember.FieldStatus:
		return m.OldStatus(ctx)
	case schedulemember.FieldVenueID:
		return m.OldVenueID(ctx)
	case schedulemember.FieldPlaceID:
		return m.OldPlaceID(ctx)
	case schedulemember.FieldScheduleID:
		return m.OldScheduleID(ctx)
	case schedulemember.FieldScheduleName:
		return m.OldScheduleName(ctx)
	case schedulemember.FieldMemberID:
		return m.OldMemberID(ctx)
	case schedulemember.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case schedulemember.FieldType:
		return m.OldType(ctx)
	case schedulemember.FieldStartTime:
		return m.OldStartTime(ctx)
	case schedulemember.FieldEndTime:
		return m.OldEndTime(ctx)
	case schedulemember.FieldSignStartTime:
		return m.OldSignStartTime(ctx)
	case schedulemember.FieldSignEndTime:
		return m.OldSignEndTime(ctx)
	case schedulemember.FieldSeat:
		return m.OldSeat(ctx)
	case schedulemember.FieldMemberName:
		return m.OldMemberName(ctx)
	case schedulemember.FieldMemberProductName:
		return m.OldMemberProductName(ctx)
	case schedulemember.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduleMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedulemember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case schedulemember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case schedulemember.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case schedulemember.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case schedulemember.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case schedulemember.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case schedulemember.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceID(v)
		return nil
	case schedulemember.FieldScheduleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleID(v)
		return nil
	case schedulemember.FieldScheduleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleName(v)
		return nil
	case schedulemember.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case schedulemember.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case schedulemember.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schedulemember.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case schedulemember.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case schedulemember.FieldSignStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartTime(v)
		return nil
	case schedulemember.FieldSignEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndTime(v)
		return nil
	case schedulemember.FieldSeat:
		v, ok := value.(base.Seat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeat(v)
		return nil
	case schedulemember.FieldMemberName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberName(v)
		return nil
	case schedulemember.FieldMemberProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductName(v)
		return nil
	case schedulemember.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMemberMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, schedulemember.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, schedulemember.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, schedulemember.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, schedulemember.FieldVenueID)
	}
	if m.addplace_id != nil {
		fields = append(fields, schedulemember.FieldPlaceID)
	}
	if m.addmember_id != nil {
		fields = append(fields, schedulemember.FieldMemberID)
	}
	if m.addmember_product_id != nil {
		fields = append(fields, schedulemember.FieldMemberProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedulemember.FieldDelete:
		return m.AddedDelete()
	case schedulemember.FieldCreatedID:
		return m.AddedCreatedID()
	case schedulemember.FieldStatus:
		return m.AddedStatus()
	case schedulemember.FieldVenueID:
		return m.AddedVenueID()
	case schedulemember.FieldPlaceID:
		return m.AddedPlaceID()
	case schedulemember.FieldMemberID:
		return m.AddedMemberID()
	case schedulemember.FieldMemberProductID:
		return m.AddedMemberProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedulemember.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case schedulemember.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case schedulemember.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case schedulemember.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case schedulemember.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlaceID(v)
		return nil
	case schedulemember.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case schedulemember.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedulemember.FieldCreatedAt) {
		fields = append(fields, schedulemember.FieldCreatedAt)
	}
	if m.FieldCleared(schedulemember.FieldUpdatedAt) {
		fields = append(fields, schedulemember.FieldUpdatedAt)
	}
	if m.FieldCleared(schedulemember.FieldDelete) {
		fields = append(fields, schedulemember.FieldDelete)
	}
	if m.FieldCleared(schedulemember.FieldCreatedID) {
		fields = append(fields, schedulemember.FieldCreatedID)
	}
	if m.FieldCleared(schedulemember.FieldStatus) {
		fields = append(fields, schedulemember.FieldStatus)
	}
	if m.FieldCleared(schedulemember.FieldVenueID) {
		fields = append(fields, schedulemember.FieldVenueID)
	}
	if m.FieldCleared(schedulemember.FieldPlaceID) {
		fields = append(fields, schedulemember.FieldPlaceID)
	}
	if m.FieldCleared(schedulemember.FieldScheduleID) {
		fields = append(fields, schedulemember.FieldScheduleID)
	}
	if m.FieldCleared(schedulemember.FieldScheduleName) {
		fields = append(fields, schedulemember.FieldScheduleName)
	}
	if m.FieldCleared(schedulemember.FieldMemberID) {
		fields = append(fields, schedulemember.FieldMemberID)
	}
	if m.FieldCleared(schedulemember.FieldMemberProductID) {
		fields = append(fields, schedulemember.FieldMemberProductID)
	}
	if m.FieldCleared(schedulemember.FieldType) {
		fields = append(fields, schedulemember.FieldType)
	}
	if m.FieldCleared(schedulemember.FieldStartTime) {
		fields = append(fields, schedulemember.FieldStartTime)
	}
	if m.FieldCleared(schedulemember.FieldEndTime) {
		fields = append(fields, schedulemember.FieldEndTime)
	}
	if m.FieldCleared(schedulemember.FieldSignStartTime) {
		fields = append(fields, schedulemember.FieldSignStartTime)
	}
	if m.FieldCleared(schedulemember.FieldSignEndTime) {
		fields = append(fields, schedulemember.FieldSignEndTime)
	}
	if m.FieldCleared(schedulemember.FieldSeat) {
		fields = append(fields, schedulemember.FieldSeat)
	}
	if m.FieldCleared(schedulemember.FieldMemberName) {
		fields = append(fields, schedulemember.FieldMemberName)
	}
	if m.FieldCleared(schedulemember.FieldMemberProductName) {
		fields = append(fields, schedulemember.FieldMemberProductName)
	}
	if m.FieldCleared(schedulemember.FieldRemark) {
		fields = append(fields, schedulemember.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMemberMutation) ClearField(name string) error {
	switch name {
	case schedulemember.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case schedulemember.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case schedulemember.FieldDelete:
		m.ClearDelete()
		return nil
	case schedulemember.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case schedulemember.FieldStatus:
		m.ClearStatus()
		return nil
	case schedulemember.FieldVenueID:
		m.ClearVenueID()
		return nil
	case schedulemember.FieldPlaceID:
		m.ClearPlaceID()
		return nil
	case schedulemember.FieldScheduleID:
		m.ClearScheduleID()
		return nil
	case schedulemember.FieldScheduleName:
		m.ClearScheduleName()
		return nil
	case schedulemember.FieldMemberID:
		m.ClearMemberID()
		return nil
	case schedulemember.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case schedulemember.FieldType:
		m.ClearType()
		return nil
	case schedulemember.FieldStartTime:
		m.ClearStartTime()
		return nil
	case schedulemember.FieldEndTime:
		m.ClearEndTime()
		return nil
	case schedulemember.FieldSignStartTime:
		m.ClearSignStartTime()
		return nil
	case schedulemember.FieldSignEndTime:
		m.ClearSignEndTime()
		return nil
	case schedulemember.FieldSeat:
		m.ClearSeat()
		return nil
	case schedulemember.FieldMemberName:
		m.ClearMemberName()
		return nil
	case schedulemember.FieldMemberProductName:
		m.ClearMemberProductName()
		return nil
	case schedulemember.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMemberMutation) ResetField(name string) error {
	switch name {
	case schedulemember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case schedulemember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case schedulemember.FieldDelete:
		m.ResetDelete()
		return nil
	case schedulemember.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case schedulemember.FieldStatus:
		m.ResetStatus()
		return nil
	case schedulemember.FieldVenueID:
		m.ResetVenueID()
		return nil
	case schedulemember.FieldPlaceID:
		m.ResetPlaceID()
		return nil
	case schedulemember.FieldScheduleID:
		m.ResetScheduleID()
		return nil
	case schedulemember.FieldScheduleName:
		m.ResetScheduleName()
		return nil
	case schedulemember.FieldMemberID:
		m.ResetMemberID()
		return nil
	case schedulemember.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case schedulemember.FieldType:
		m.ResetType()
		return nil
	case schedulemember.FieldStartTime:
		m.ResetStartTime()
		return nil
	case schedulemember.FieldEndTime:
		m.ResetEndTime()
		return nil
	case schedulemember.FieldSignStartTime:
		m.ResetSignStartTime()
		return nil
	case schedulemember.FieldSignEndTime:
		m.ResetSignEndTime()
		return nil
	case schedulemember.FieldSeat:
		m.ResetSeat()
		return nil
	case schedulemember.FieldMemberName:
		m.ResetMemberName()
		return nil
	case schedulemember.FieldMemberProductName:
		m.ResetMemberProductName()
		return nil
	case schedulemember.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.schedule != nil {
		edges = append(edges, schedulemember.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedulemember.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedschedule {
		edges = append(edges, schedulemember.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case schedulemember.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMemberMutation) ClearEdge(name string) error {
	switch name {
	case schedulemember.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMemberMutation) ResetEdge(name string) error {
	switch name {
	case schedulemember.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	user_id       *int64
	adduser_id    *int64
	token         *string
	source        *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int64) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[token.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, token.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TokenMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[token.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TokenMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, token.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *TokenMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *TokenMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *TokenMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *TokenMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *TokenMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[token.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *TokenMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[token.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *TokenMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, token.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *TokenMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *TokenMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *TokenMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *TokenMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *TokenMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[token.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *TokenMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[token.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *TokenMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, token.FieldCreatedID)
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TokenMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TokenMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetSource sets the "source" field.
func (m *TokenMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TokenMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TokenMutation) ResetSource() {
	m.source = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TokenMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TokenMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, token.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, token.FieldCreatedID)
	}
	if m.user_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.source != nil {
		fields = append(fields, token.FieldSource)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldDelete:
		return m.Delete()
	case token.FieldCreatedID:
		return m.CreatedID()
	case token.FieldUserID:
		return m.UserID()
	case token.FieldToken:
		return m.Token()
	case token.FieldSource:
		return m.Source()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldDelete:
		return m.OldDelete(ctx)
	case token.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldSource:
		return m.OldSource(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case token.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, token.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, token.FieldCreatedID)
	}
	if m.adduser_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldDelete:
		return m.AddedDelete()
	case token.FieldCreatedID:
		return m.AddedCreatedID()
	case token.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case token.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldCreatedAt) {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.FieldCleared(token.FieldUpdatedAt) {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.FieldCleared(token.FieldDelete) {
		fields = append(fields, token.FieldDelete)
	}
	if m.FieldCleared(token.FieldCreatedID) {
		fields = append(fields, token.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case token.FieldDelete:
		m.ClearDelete()
		return nil
	case token.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldDelete:
		m.ResetDelete()
		return nil
	case token.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldSource:
		m.ResetSource()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_at              *time.Time
	updated_at              *time.Time
	delete                  *int64
	adddelete               *int64
	created_id              *int64
	addcreated_id           *int64
	status                  *int64
	addstatus               *int64
	mobile                  *string
	name                    *string
	gender                  *int64
	addgender               *int64
	username                *string
	password                *string
	functions               *[]string
	appendfunctions         []string
	_type                   *int64
	add_type                *int64
	job_time                *int64
	addjob_time             *int64
	default_venue_id        *int64
	adddefault_venue_id     *int64
	avatar                  *string
	detail                  *string
	clearedFields           map[string]struct{}
	token                   *int64
	clearedtoken            bool
	tags                    map[int64]struct{}
	removedtags             map[int64]struct{}
	clearedtags             bool
	created_orders          map[int64]struct{}
	removedcreated_orders   map[int64]struct{}
	clearedcreated_orders   bool
	user_entry              map[int64]struct{}
	removeduser_entry       map[int64]struct{}
	cleareduser_entry       bool
	venues                  map[int64]struct{}
	removedvenues           map[int64]struct{}
	clearedvenues           bool
	roles                   map[int64]struct{}
	removedroles            map[int64]struct{}
	clearedroles            bool
	user_time_period        map[int64]struct{}
	removeduser_time_period map[int64]struct{}
	cleareduser_time_period bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *UserMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *UserMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *UserMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *UserMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *UserMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[user.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *UserMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[user.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *UserMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, user.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *UserMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *UserMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *UserMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *UserMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *UserMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[user.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *UserMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *UserMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, user.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *UserMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *UserMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFunctions sets the "functions" field.
func (m *UserMutation) SetFunctions(s []string) {
	m.functions = &s
	m.appendfunctions = nil
}

// Functions returns the value of the "functions" field in the mutation.
func (m *UserMutation) Functions() (r []string, exists bool) {
	v := m.functions
	if v == nil {
		return
	}
	return *v, true
}

// OldFunctions returns the old "functions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFunctions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunctions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunctions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunctions: %w", err)
	}
	return oldValue.Functions, nil
}

// AppendFunctions adds s to the "functions" field.
func (m *UserMutation) AppendFunctions(s []string) {
	m.appendfunctions = append(m.appendfunctions, s...)
}

// AppendedFunctions returns the list of values that were appended to the "functions" field in this mutation.
func (m *UserMutation) AppendedFunctions() ([]string, bool) {
	if len(m.appendfunctions) == 0 {
		return nil, false
	}
	return m.appendfunctions, true
}

// ResetFunctions resets all changes to the "functions" field.
func (m *UserMutation) ResetFunctions() {
	m.functions = nil
	m.appendfunctions = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *UserMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *UserMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *UserMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[user.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *UserMutation) TypeCleared() bool {
	_, ok := m.clearedFields[user.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, user.FieldType)
}

// SetJobTime sets the "job_time" field.
func (m *UserMutation) SetJobTime(i int64) {
	m.job_time = &i
	m.addjob_time = nil
}

// JobTime returns the value of the "job_time" field in the mutation.
func (m *UserMutation) JobTime() (r int64, exists bool) {
	v := m.job_time
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTime returns the old "job_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJobTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTime: %w", err)
	}
	return oldValue.JobTime, nil
}

// AddJobTime adds i to the "job_time" field.
func (m *UserMutation) AddJobTime(i int64) {
	if m.addjob_time != nil {
		*m.addjob_time += i
	} else {
		m.addjob_time = &i
	}
}

// AddedJobTime returns the value that was added to the "job_time" field in this mutation.
func (m *UserMutation) AddedJobTime() (r int64, exists bool) {
	v := m.addjob_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearJobTime clears the value of the "job_time" field.
func (m *UserMutation) ClearJobTime() {
	m.job_time = nil
	m.addjob_time = nil
	m.clearedFields[user.FieldJobTime] = struct{}{}
}

// JobTimeCleared returns if the "job_time" field was cleared in this mutation.
func (m *UserMutation) JobTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldJobTime]
	return ok
}

// ResetJobTime resets all changes to the "job_time" field.
func (m *UserMutation) ResetJobTime() {
	m.job_time = nil
	m.addjob_time = nil
	delete(m.clearedFields, user.FieldJobTime)
}

// SetDefaultVenueID sets the "default_venue_id" field.
func (m *UserMutation) SetDefaultVenueID(i int64) {
	m.default_venue_id = &i
	m.adddefault_venue_id = nil
}

// DefaultVenueID returns the value of the "default_venue_id" field in the mutation.
func (m *UserMutation) DefaultVenueID() (r int64, exists bool) {
	v := m.default_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultVenueID returns the old "default_venue_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDefaultVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultVenueID: %w", err)
	}
	return oldValue.DefaultVenueID, nil
}

// AddDefaultVenueID adds i to the "default_venue_id" field.
func (m *UserMutation) AddDefaultVenueID(i int64) {
	if m.adddefault_venue_id != nil {
		*m.adddefault_venue_id += i
	} else {
		m.adddefault_venue_id = &i
	}
}

// AddedDefaultVenueID returns the value that was added to the "default_venue_id" field in this mutation.
func (m *UserMutation) AddedDefaultVenueID() (r int64, exists bool) {
	v := m.adddefault_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultVenueID clears the value of the "default_venue_id" field.
func (m *UserMutation) ClearDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	m.clearedFields[user.FieldDefaultVenueID] = struct{}{}
}

// DefaultVenueIDCleared returns if the "default_venue_id" field was cleared in this mutation.
func (m *UserMutation) DefaultVenueIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDefaultVenueID]
	return ok
}

// ResetDefaultVenueID resets all changes to the "default_venue_id" field.
func (m *UserMutation) ResetDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	delete(m.clearedFields, user.FieldDefaultVenueID)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetDetail sets the "detail" field.
func (m *UserMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *UserMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *UserMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[user.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *UserMutation) DetailCleared() bool {
	_, ok := m.clearedFields[user.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *UserMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, user.FieldDetail)
}

// SetTokenID sets the "token" edge to the Token entity by id.
func (m *UserMutation) SetTokenID(id int64) {
	m.token = &id
}

// ClearToken clears the "token" edge to the Token entity.
func (m *UserMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the Token entity was cleared.
func (m *UserMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the "token" edge ID in the mutation.
func (m *UserMutation) TokenID() (id int64, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TokenIDs() (ids []int64) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *UserMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// AddTagIDs adds the "tags" edge to the DictionaryDetail entity by ids.
func (m *UserMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the DictionaryDetail entity.
func (m *UserMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the DictionaryDetail entity was cleared.
func (m *UserMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the DictionaryDetail entity by IDs.
func (m *UserMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the DictionaryDetail entity.
func (m *UserMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *UserMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *UserMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddCreatedOrderIDs adds the "created_orders" edge to the Order entity by ids.
func (m *UserMutation) AddCreatedOrderIDs(ids ...int64) {
	if m.created_orders == nil {
		m.created_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.created_orders[ids[i]] = struct{}{}
	}
}

// ClearCreatedOrders clears the "created_orders" edge to the Order entity.
func (m *UserMutation) ClearCreatedOrders() {
	m.clearedcreated_orders = true
}

// CreatedOrdersCleared reports if the "created_orders" edge to the Order entity was cleared.
func (m *UserMutation) CreatedOrdersCleared() bool {
	return m.clearedcreated_orders
}

// RemoveCreatedOrderIDs removes the "created_orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveCreatedOrderIDs(ids ...int64) {
	if m.removedcreated_orders == nil {
		m.removedcreated_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.created_orders, ids[i])
		m.removedcreated_orders[ids[i]] = struct{}{}
	}
}

// RemovedCreatedOrders returns the removed IDs of the "created_orders" edge to the Order entity.
func (m *UserMutation) RemovedCreatedOrdersIDs() (ids []int64) {
	for id := range m.removedcreated_orders {
		ids = append(ids, id)
	}
	return
}

// CreatedOrdersIDs returns the "created_orders" edge IDs in the mutation.
func (m *UserMutation) CreatedOrdersIDs() (ids []int64) {
	for id := range m.created_orders {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedOrders resets all changes to the "created_orders" edge.
func (m *UserMutation) ResetCreatedOrders() {
	m.created_orders = nil
	m.clearedcreated_orders = false
	m.removedcreated_orders = nil
}

// AddUserEntryIDs adds the "user_entry" edge to the EntryLogs entity by ids.
func (m *UserMutation) AddUserEntryIDs(ids ...int64) {
	if m.user_entry == nil {
		m.user_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_entry[ids[i]] = struct{}{}
	}
}

// ClearUserEntry clears the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) ClearUserEntry() {
	m.cleareduser_entry = true
}

// UserEntryCleared reports if the "user_entry" edge to the EntryLogs entity was cleared.
func (m *UserMutation) UserEntryCleared() bool {
	return m.cleareduser_entry
}

// RemoveUserEntryIDs removes the "user_entry" edge to the EntryLogs entity by IDs.
func (m *UserMutation) RemoveUserEntryIDs(ids ...int64) {
	if m.removeduser_entry == nil {
		m.removeduser_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_entry, ids[i])
		m.removeduser_entry[ids[i]] = struct{}{}
	}
}

// RemovedUserEntry returns the removed IDs of the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) RemovedUserEntryIDs() (ids []int64) {
	for id := range m.removeduser_entry {
		ids = append(ids, id)
	}
	return
}

// UserEntryIDs returns the "user_entry" edge IDs in the mutation.
func (m *UserMutation) UserEntryIDs() (ids []int64) {
	for id := range m.user_entry {
		ids = append(ids, id)
	}
	return
}

// ResetUserEntry resets all changes to the "user_entry" edge.
func (m *UserMutation) ResetUserEntry() {
	m.user_entry = nil
	m.cleareduser_entry = false
	m.removeduser_entry = nil
}

// AddVenueIDs adds the "venues" edge to the Venue entity by ids.
func (m *UserMutation) AddVenueIDs(ids ...int64) {
	if m.venues == nil {
		m.venues = make(map[int64]struct{})
	}
	for i := range ids {
		m.venues[ids[i]] = struct{}{}
	}
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *UserMutation) ClearVenues() {
	m.clearedvenues = true
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *UserMutation) VenuesCleared() bool {
	return m.clearedvenues
}

// RemoveVenueIDs removes the "venues" edge to the Venue entity by IDs.
func (m *UserMutation) RemoveVenueIDs(ids ...int64) {
	if m.removedvenues == nil {
		m.removedvenues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venues, ids[i])
		m.removedvenues[ids[i]] = struct{}{}
	}
}

// RemovedVenues returns the removed IDs of the "venues" edge to the Venue entity.
func (m *UserMutation) RemovedVenuesIDs() (ids []int64) {
	for id := range m.removedvenues {
		ids = append(ids, id)
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
func (m *UserMutation) VenuesIDs() (ids []int64) {
	for id := range m.venues {
		ids = append(ids, id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *UserMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
	m.removedvenues = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddUserTimePeriodIDs adds the "user_time_period" edge to the UserTimePeriod entity by ids.
func (m *UserMutation) AddUserTimePeriodIDs(ids ...int64) {
	if m.user_time_period == nil {
		m.user_time_period = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_time_period[ids[i]] = struct{}{}
	}
}

// ClearUserTimePeriod clears the "user_time_period" edge to the UserTimePeriod entity.
func (m *UserMutation) ClearUserTimePeriod() {
	m.cleareduser_time_period = true
}

// UserTimePeriodCleared reports if the "user_time_period" edge to the UserTimePeriod entity was cleared.
func (m *UserMutation) UserTimePeriodCleared() bool {
	return m.cleareduser_time_period
}

// RemoveUserTimePeriodIDs removes the "user_time_period" edge to the UserTimePeriod entity by IDs.
func (m *UserMutation) RemoveUserTimePeriodIDs(ids ...int64) {
	if m.removeduser_time_period == nil {
		m.removeduser_time_period = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_time_period, ids[i])
		m.removeduser_time_period[ids[i]] = struct{}{}
	}
}

// RemovedUserTimePeriod returns the removed IDs of the "user_time_period" edge to the UserTimePeriod entity.
func (m *UserMutation) RemovedUserTimePeriodIDs() (ids []int64) {
	for id := range m.removeduser_time_period {
		ids = append(ids, id)
	}
	return
}

// UserTimePeriodIDs returns the "user_time_period" edge IDs in the mutation.
func (m *UserMutation) UserTimePeriodIDs() (ids []int64) {
	for id := range m.user_time_period {
		ids = append(ids, id)
	}
	return
}

// ResetUserTimePeriod resets all changes to the "user_time_period" edge.
func (m *UserMutation) ResetUserTimePeriod() {
	m.user_time_period = nil
	m.cleareduser_time_period = false
	m.removeduser_time_period = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, user.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.functions != nil {
		fields = append(fields, user.FieldFunctions)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.job_time != nil {
		fields = append(fields, user.FieldJobTime)
	}
	if m.default_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.detail != nil {
		fields = append(fields, user.FieldDetail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDelete:
		return m.Delete()
	case user.FieldCreatedID:
		return m.CreatedID()
	case user.FieldStatus:
		return m.Status()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldName:
		return m.Name()
	case user.FieldGender:
		return m.Gender()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFunctions:
		return m.Functions()
	case user.FieldType:
		return m.GetType()
	case user.FieldJobTime:
		return m.JobTime()
	case user.FieldDefaultVenueID:
		return m.DefaultVenueID()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldDetail:
		return m.Detail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDelete:
		return m.OldDelete(ctx)
	case user.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFunctions:
		return m.OldFunctions(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	case user.FieldJobTime:
		return m.OldJobTime(ctx)
	case user.FieldDefaultVenueID:
		return m.OldDefaultVenueID(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldDetail:
		return m.OldDetail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case user.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFunctions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunctions(v)
		return nil
	case user.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldJobTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTime(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultVenueID(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, user.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.add_type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.addjob_time != nil {
		fields = append(fields, user.FieldJobTime)
	}
	if m.adddefault_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDelete:
		return m.AddedDelete()
	case user.FieldCreatedID:
		return m.AddedCreatedID()
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldGender:
		return m.AddedGender()
	case user.FieldType:
		return m.AddedType()
	case user.FieldJobTime:
		return m.AddedJobTime()
	case user.FieldDefaultVenueID:
		return m.AddedDefaultVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case user.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case user.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case user.FieldJobTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJobTime(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDelete) {
		fields = append(fields, user.FieldDelete)
	}
	if m.FieldCleared(user.FieldCreatedID) {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldType) {
		fields = append(fields, user.FieldType)
	}
	if m.FieldCleared(user.FieldJobTime) {
		fields = append(fields, user.FieldJobTime)
	}
	if m.FieldCleared(user.FieldDefaultVenueID) {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldDetail) {
		fields = append(fields, user.FieldDetail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDelete:
		m.ClearDelete()
		return nil
	case user.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldType:
		m.ClearType()
		return nil
	case user.FieldJobTime:
		m.ClearJobTime()
		return nil
	case user.FieldDefaultVenueID:
		m.ClearDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldDetail:
		m.ClearDetail()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDelete:
		m.ResetDelete()
		return nil
	case user.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFunctions:
		m.ResetFunctions()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldJobTime:
		m.ResetJobTime()
		return nil
	case user.FieldDefaultVenueID:
		m.ResetDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldDetail:
		m.ResetDetail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.token != nil {
		edges = append(edges, user.EdgeToken)
	}
	if m.tags != nil {
		edges = append(edges, user.EdgeTags)
	}
	if m.created_orders != nil {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.user_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	if m.venues != nil {
		edges = append(edges, user.EdgeVenues)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.user_time_period != nil {
		edges = append(edges, user.EdgeUserTimePeriod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedOrders:
		ids := make([]ent.Value, 0, len(m.created_orders))
		for id := range m.created_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.user_entry))
		for id := range m.user_entry {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.venues))
		for id := range m.venues {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserTimePeriod:
		ids := make([]ent.Value, 0, len(m.user_time_period))
		for id := range m.user_time_period {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedtags != nil {
		edges = append(edges, user.EdgeTags)
	}
	if m.removedcreated_orders != nil {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.removeduser_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	if m.removedvenues != nil {
		edges = append(edges, user.EdgeVenues)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removeduser_time_period != nil {
		edges = append(edges, user.EdgeUserTimePeriod)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedOrders:
		ids := make([]ent.Value, 0, len(m.removedcreated_orders))
		for id := range m.removedcreated_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.removeduser_entry))
		for id := range m.removeduser_entry {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.removedvenues))
		for id := range m.removedvenues {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserTimePeriod:
		ids := make([]ent.Value, 0, len(m.removeduser_time_period))
		for id := range m.removeduser_time_period {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedtoken {
		edges = append(edges, user.EdgeToken)
	}
	if m.clearedtags {
		edges = append(edges, user.EdgeTags)
	}
	if m.clearedcreated_orders {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.cleareduser_entry {
		edges = append(edges, user.EdgeUserEntry)
	}
	if m.clearedvenues {
		edges = append(edges, user.EdgeVenues)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.cleareduser_time_period {
		edges = append(edges, user.EdgeUserTimePeriod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeToken:
		return m.clearedtoken
	case user.EdgeTags:
		return m.clearedtags
	case user.EdgeCreatedOrders:
		return m.clearedcreated_orders
	case user.EdgeUserEntry:
		return m.cleareduser_entry
	case user.EdgeVenues:
		return m.clearedvenues
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeUserTimePeriod:
		return m.cleareduser_time_period
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ResetToken()
		return nil
	case user.EdgeTags:
		m.ResetTags()
		return nil
	case user.EdgeCreatedOrders:
		m.ResetCreatedOrders()
		return nil
	case user.EdgeUserEntry:
		m.ResetUserEntry()
		return nil
	case user.EdgeVenues:
		m.ResetVenues()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeUserTimePeriod:
		m.ResetUserTimePeriod()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserTimePeriodMutation represents an operation that mutates the UserTimePeriod nodes in the graph.
type UserTimePeriodMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	date          *time.Time
	period        *base.Period
	venue_id      *int64
	addvenue_id   *int64
	clearedFields map[string]struct{}
	users         *int64
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*UserTimePeriod, error)
	predicates    []predicate.UserTimePeriod
}

var _ ent.Mutation = (*UserTimePeriodMutation)(nil)

// usertimeperiodOption allows management of the mutation configuration using functional options.
type usertimeperiodOption func(*UserTimePeriodMutation)

// newUserTimePeriodMutation creates new mutation for the UserTimePeriod entity.
func newUserTimePeriodMutation(c config, op Op, opts ...usertimeperiodOption) *UserTimePeriodMutation {
	m := &UserTimePeriodMutation{
		config:        c,
		op:            op,
		typ:           TypeUserTimePeriod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserTimePeriodID sets the ID field of the mutation.
func withUserTimePeriodID(id int64) usertimeperiodOption {
	return func(m *UserTimePeriodMutation) {
		var (
			err   error
			once  sync.Once
			value *UserTimePeriod
		)
		m.oldValue = func(ctx context.Context) (*UserTimePeriod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserTimePeriod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserTimePeriod sets the old UserTimePeriod of the mutation.
func withUserTimePeriod(node *UserTimePeriod) usertimeperiodOption {
	return func(m *UserTimePeriodMutation) {
		m.oldValue = func(context.Context) (*UserTimePeriod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTimePeriodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTimePeriodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserTimePeriod entities.
func (m *UserTimePeriodMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserTimePeriodMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserTimePeriodMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserTimePeriod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserTimePeriodMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserTimePeriodMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserTimePeriodMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usertimeperiod.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserTimePeriodMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserTimePeriodMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usertimeperiod.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserTimePeriodMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserTimePeriodMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserTimePeriodMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usertimeperiod.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserTimePeriodMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserTimePeriodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usertimeperiod.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *UserTimePeriodMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *UserTimePeriodMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *UserTimePeriodMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *UserTimePeriodMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *UserTimePeriodMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[usertimeperiod.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *UserTimePeriodMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *UserTimePeriodMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, usertimeperiod.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *UserTimePeriodMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *UserTimePeriodMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *UserTimePeriodMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *UserTimePeriodMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *UserTimePeriodMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[usertimeperiod.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *UserTimePeriodMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *UserTimePeriodMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, usertimeperiod.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *UserTimePeriodMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserTimePeriodMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserTimePeriodMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserTimePeriodMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserTimePeriodMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[usertimeperiod.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserTimePeriodMutation) StatusCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserTimePeriodMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, usertimeperiod.FieldStatus)
}

// SetDate sets the "date" field.
func (m *UserTimePeriodMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *UserTimePeriodMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *UserTimePeriodMutation) ClearDate() {
	m.date = nil
	m.clearedFields[usertimeperiod.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *UserTimePeriodMutation) DateCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *UserTimePeriodMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, usertimeperiod.FieldDate)
}

// SetPeriod sets the "period" field.
func (m *UserTimePeriodMutation) SetPeriod(b base.Period) {
	m.period = &b
}

// Period returns the value of the "period" field in the mutation.
func (m *UserTimePeriodMutation) Period() (r base.Period, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldPeriod(ctx context.Context) (v base.Period, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// ClearPeriod clears the value of the "period" field.
func (m *UserTimePeriodMutation) ClearPeriod() {
	m.period = nil
	m.clearedFields[usertimeperiod.FieldPeriod] = struct{}{}
}

// PeriodCleared returns if the "period" field was cleared in this mutation.
func (m *UserTimePeriodMutation) PeriodCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldPeriod]
	return ok
}

// ResetPeriod resets all changes to the "period" field.
func (m *UserTimePeriodMutation) ResetPeriod() {
	m.period = nil
	delete(m.clearedFields, usertimeperiod.FieldPeriod)
}

// SetUserID sets the "user_id" field.
func (m *UserTimePeriodMutation) SetUserID(i int64) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserTimePeriodMutation) UserID() (r int64, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserTimePeriodMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[usertimeperiod.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserTimePeriodMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserTimePeriodMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, usertimeperiod.FieldUserID)
}

// SetVenueID sets the "venue_id" field.
func (m *UserTimePeriodMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *UserTimePeriodMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the UserTimePeriod entity.
// If the UserTimePeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTimePeriodMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *UserTimePeriodMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *UserTimePeriodMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *UserTimePeriodMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[usertimeperiod.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *UserTimePeriodMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[usertimeperiod.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *UserTimePeriodMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, usertimeperiod.FieldVenueID)
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *UserTimePeriodMutation) SetUsersID(id int64) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserTimePeriodMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[usertimeperiod.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserTimePeriodMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *UserTimePeriodMutation) UsersID() (id int64, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *UserTimePeriodMutation) UsersIDs() (ids []int64) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserTimePeriodMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the UserTimePeriodMutation builder.
func (m *UserTimePeriodMutation) Where(ps ...predicate.UserTimePeriod) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTimePeriodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTimePeriodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserTimePeriod, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTimePeriodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTimePeriodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserTimePeriod).
func (m *UserTimePeriodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTimePeriodMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, usertimeperiod.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usertimeperiod.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, usertimeperiod.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, usertimeperiod.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, usertimeperiod.FieldStatus)
	}
	if m.date != nil {
		fields = append(fields, usertimeperiod.FieldDate)
	}
	if m.period != nil {
		fields = append(fields, usertimeperiod.FieldPeriod)
	}
	if m.users != nil {
		fields = append(fields, usertimeperiod.FieldUserID)
	}
	if m.venue_id != nil {
		fields = append(fields, usertimeperiod.FieldVenueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTimePeriodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertimeperiod.FieldCreatedAt:
		return m.CreatedAt()
	case usertimeperiod.FieldUpdatedAt:
		return m.UpdatedAt()
	case usertimeperiod.FieldDelete:
		return m.Delete()
	case usertimeperiod.FieldCreatedID:
		return m.CreatedID()
	case usertimeperiod.FieldStatus:
		return m.Status()
	case usertimeperiod.FieldDate:
		return m.Date()
	case usertimeperiod.FieldPeriod:
		return m.Period()
	case usertimeperiod.FieldUserID:
		return m.UserID()
	case usertimeperiod.FieldVenueID:
		return m.VenueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTimePeriodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertimeperiod.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usertimeperiod.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usertimeperiod.FieldDelete:
		return m.OldDelete(ctx)
	case usertimeperiod.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case usertimeperiod.FieldStatus:
		return m.OldStatus(ctx)
	case usertimeperiod.FieldDate:
		return m.OldDate(ctx)
	case usertimeperiod.FieldPeriod:
		return m.OldPeriod(ctx)
	case usertimeperiod.FieldUserID:
		return m.OldUserID(ctx)
	case usertimeperiod.FieldVenueID:
		return m.OldVenueID(ctx)
	}
	return nil, fmt.Errorf("unknown UserTimePeriod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTimePeriodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertimeperiod.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usertimeperiod.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usertimeperiod.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case usertimeperiod.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case usertimeperiod.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usertimeperiod.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case usertimeperiod.FieldPeriod:
		v, ok := value.(base.Period)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case usertimeperiod.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usertimeperiod.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown UserTimePeriod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTimePeriodMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, usertimeperiod.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, usertimeperiod.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, usertimeperiod.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, usertimeperiod.FieldVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTimePeriodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usertimeperiod.FieldDelete:
		return m.AddedDelete()
	case usertimeperiod.FieldCreatedID:
		return m.AddedCreatedID()
	case usertimeperiod.FieldStatus:
		return m.AddedStatus()
	case usertimeperiod.FieldVenueID:
		return m.AddedVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTimePeriodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usertimeperiod.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case usertimeperiod.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case usertimeperiod.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case usertimeperiod.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown UserTimePeriod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTimePeriodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usertimeperiod.FieldCreatedAt) {
		fields = append(fields, usertimeperiod.FieldCreatedAt)
	}
	if m.FieldCleared(usertimeperiod.FieldUpdatedAt) {
		fields = append(fields, usertimeperiod.FieldUpdatedAt)
	}
	if m.FieldCleared(usertimeperiod.FieldDelete) {
		fields = append(fields, usertimeperiod.FieldDelete)
	}
	if m.FieldCleared(usertimeperiod.FieldCreatedID) {
		fields = append(fields, usertimeperiod.FieldCreatedID)
	}
	if m.FieldCleared(usertimeperiod.FieldStatus) {
		fields = append(fields, usertimeperiod.FieldStatus)
	}
	if m.FieldCleared(usertimeperiod.FieldDate) {
		fields = append(fields, usertimeperiod.FieldDate)
	}
	if m.FieldCleared(usertimeperiod.FieldPeriod) {
		fields = append(fields, usertimeperiod.FieldPeriod)
	}
	if m.FieldCleared(usertimeperiod.FieldUserID) {
		fields = append(fields, usertimeperiod.FieldUserID)
	}
	if m.FieldCleared(usertimeperiod.FieldVenueID) {
		fields = append(fields, usertimeperiod.FieldVenueID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTimePeriodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTimePeriodMutation) ClearField(name string) error {
	switch name {
	case usertimeperiod.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usertimeperiod.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case usertimeperiod.FieldDelete:
		m.ClearDelete()
		return nil
	case usertimeperiod.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case usertimeperiod.FieldStatus:
		m.ClearStatus()
		return nil
	case usertimeperiod.FieldDate:
		m.ClearDate()
		return nil
	case usertimeperiod.FieldPeriod:
		m.ClearPeriod()
		return nil
	case usertimeperiod.FieldUserID:
		m.ClearUserID()
		return nil
	case usertimeperiod.FieldVenueID:
		m.ClearVenueID()
		return nil
	}
	return fmt.Errorf("unknown UserTimePeriod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTimePeriodMutation) ResetField(name string) error {
	switch name {
	case usertimeperiod.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usertimeperiod.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usertimeperiod.FieldDelete:
		m.ResetDelete()
		return nil
	case usertimeperiod.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case usertimeperiod.FieldStatus:
		m.ResetStatus()
		return nil
	case usertimeperiod.FieldDate:
		m.ResetDate()
		return nil
	case usertimeperiod.FieldPeriod:
		m.ResetPeriod()
		return nil
	case usertimeperiod.FieldUserID:
		m.ResetUserID()
		return nil
	case usertimeperiod.FieldVenueID:
		m.ResetVenueID()
		return nil
	}
	return fmt.Errorf("unknown UserTimePeriod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTimePeriodMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, usertimeperiod.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTimePeriodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usertimeperiod.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTimePeriodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTimePeriodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTimePeriodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, usertimeperiod.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTimePeriodMutation) EdgeCleared(name string) bool {
	switch name {
	case usertimeperiod.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTimePeriodMutation) ClearEdge(name string) error {
	switch name {
	case usertimeperiod.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown UserTimePeriod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTimePeriodMutation) ResetEdge(name string) error {
	switch name {
	case usertimeperiod.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserTimePeriod edge %s", name)
}

// VenueMutation represents an operation that mutates the Venue nodes in the graph.
type VenueMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete              *int64
	adddelete           *int64
	created_id          *int64
	addcreated_id       *int64
	status              *int64
	addstatus           *int64
	name                *string
	_type               *string
	classify            *[]int64
	appendclassify      []int64
	address             *string
	address_detail      *string
	latitude            *string
	longitude           *string
	mobile              *string
	email               *string
	pic                 *string
	seal                *string
	information         *string
	clearedFields       map[string]struct{}
	places              map[int64]struct{}
	removedplaces       map[int64]struct{}
	clearedplaces       bool
	venue_orders        map[int64]struct{}
	removedvenue_orders map[int64]struct{}
	clearedvenue_orders bool
	venue_entry         map[int64]struct{}
	removedvenue_entry  map[int64]struct{}
	clearedvenue_entry  bool
	users               map[int64]struct{}
	removedusers        map[int64]struct{}
	clearedusers        bool
	sms                 map[int64]struct{}
	removedsms          map[int64]struct{}
	clearedsms          bool
	smslog              map[int64]struct{}
	removedsmslog       map[int64]struct{}
	clearedsmslog       bool
	roles               map[int64]struct{}
	removedroles        map[int64]struct{}
	clearedroles        bool
	done                bool
	oldValue            func(context.Context) (*Venue, error)
	predicates          []predicate.Venue
}

var _ ent.Mutation = (*VenueMutation)(nil)

// venueOption allows management of the mutation configuration using functional options.
type venueOption func(*VenueMutation)

// newVenueMutation creates new mutation for the Venue entity.
func newVenueMutation(c config, op Op, opts ...venueOption) *VenueMutation {
	m := &VenueMutation{
		config:        c,
		op:            op,
		typ:           TypeVenue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueID sets the ID field of the mutation.
func withVenueID(id int64) venueOption {
	return func(m *VenueMutation) {
		var (
			err   error
			once  sync.Once
			value *Venue
		)
		m.oldValue = func(ctx context.Context) (*Venue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Venue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenue sets the old Venue of the mutation.
func withVenue(node *Venue) venueOption {
	return func(m *VenueMutation) {
		m.oldValue = func(context.Context) (*Venue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Venue entities.
func (m *VenueMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Venue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VenueMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[venue.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VenueMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[venue.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, venue.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VenueMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[venue.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VenueMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[venue.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, venue.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *VenueMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *VenueMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *VenueMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *VenueMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *VenueMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[venue.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *VenueMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[venue.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *VenueMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, venue.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *VenueMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *VenueMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *VenueMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *VenueMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *VenueMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[venue.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *VenueMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[venue.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *VenueMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, venue.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *VenueMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenueMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenueMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenueMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenueMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venue.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenueMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venue.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenueMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venue.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenueMutation) ClearName() {
	m.name = nil
	m.clearedFields[venue.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenueMutation) NameCleared() bool {
	_, ok := m.clearedFields[venue.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenueMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venue.FieldName)
}

// SetType sets the "type" field.
func (m *VenueMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *VenueMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *VenueMutation) ClearType() {
	m._type = nil
	m.clearedFields[venue.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *VenueMutation) TypeCleared() bool {
	_, ok := m.clearedFields[venue.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *VenueMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, venue.FieldType)
}

// SetClassify sets the "classify" field.
func (m *VenueMutation) SetClassify(i []int64) {
	m.classify = &i
	m.appendclassify = nil
}

// Classify returns the value of the "classify" field in the mutation.
func (m *VenueMutation) Classify() (r []int64, exists bool) {
	v := m.classify
	if v == nil {
		return
	}
	return *v, true
}

// OldClassify returns the old "classify" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldClassify(ctx context.Context) (v []int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassify: %w", err)
	}
	return oldValue.Classify, nil
}

// AppendClassify adds i to the "classify" field.
func (m *VenueMutation) AppendClassify(i []int64) {
	m.appendclassify = append(m.appendclassify, i...)
}

// AppendedClassify returns the list of values that were appended to the "classify" field in this mutation.
func (m *VenueMutation) AppendedClassify() ([]int64, bool) {
	if len(m.appendclassify) == 0 {
		return nil, false
	}
	return m.appendclassify, true
}

// ClearClassify clears the value of the "classify" field.
func (m *VenueMutation) ClearClassify() {
	m.classify = nil
	m.appendclassify = nil
	m.clearedFields[venue.FieldClassify] = struct{}{}
}

// ClassifyCleared returns if the "classify" field was cleared in this mutation.
func (m *VenueMutation) ClassifyCleared() bool {
	_, ok := m.clearedFields[venue.FieldClassify]
	return ok
}

// ResetClassify resets all changes to the "classify" field.
func (m *VenueMutation) ResetClassify() {
	m.classify = nil
	m.appendclassify = nil
	delete(m.clearedFields, venue.FieldClassify)
}

// SetAddress sets the "address" field.
func (m *VenueMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VenueMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VenueMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[venue.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VenueMutation) AddressCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VenueMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, venue.FieldAddress)
}

// SetAddressDetail sets the "address_detail" field.
func (m *VenueMutation) SetAddressDetail(s string) {
	m.address_detail = &s
}

// AddressDetail returns the value of the "address_detail" field in the mutation.
func (m *VenueMutation) AddressDetail() (r string, exists bool) {
	v := m.address_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "address_detail" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddressDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "address_detail" field.
func (m *VenueMutation) ClearAddressDetail() {
	m.address_detail = nil
	m.clearedFields[venue.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "address_detail" field was cleared in this mutation.
func (m *VenueMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "address_detail" field.
func (m *VenueMutation) ResetAddressDetail() {
	m.address_detail = nil
	delete(m.clearedFields, venue.FieldAddressDetail)
}

// SetLatitude sets the "latitude" field.
func (m *VenueMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *VenueMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *VenueMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[venue.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *VenueMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *VenueMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, venue.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *VenueMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *VenueMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *VenueMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[venue.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *VenueMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *VenueMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, venue.FieldLongitude)
}

// SetMobile sets the "mobile" field.
func (m *VenueMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *VenueMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *VenueMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[venue.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *VenueMutation) MobileCleared() bool {
	_, ok := m.clearedFields[venue.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *VenueMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, venue.FieldMobile)
}

// SetEmail sets the "email" field.
func (m *VenueMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *VenueMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *VenueMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[venue.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *VenueMutation) EmailCleared() bool {
	_, ok := m.clearedFields[venue.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *VenueMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, venue.FieldEmail)
}

// SetPic sets the "pic" field.
func (m *VenueMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenueMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenueMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venue.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenueMutation) PicCleared() bool {
	_, ok := m.clearedFields[venue.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenueMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venue.FieldPic)
}

// SetSeal sets the "seal" field.
func (m *VenueMutation) SetSeal(s string) {
	m.seal = &s
}

// Seal returns the value of the "seal" field in the mutation.
func (m *VenueMutation) Seal() (r string, exists bool) {
	v := m.seal
	if v == nil {
		return
	}
	return *v, true
}

// OldSeal returns the old "seal" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldSeal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeal: %w", err)
	}
	return oldValue.Seal, nil
}

// ClearSeal clears the value of the "seal" field.
func (m *VenueMutation) ClearSeal() {
	m.seal = nil
	m.clearedFields[venue.FieldSeal] = struct{}{}
}

// SealCleared returns if the "seal" field was cleared in this mutation.
func (m *VenueMutation) SealCleared() bool {
	_, ok := m.clearedFields[venue.FieldSeal]
	return ok
}

// ResetSeal resets all changes to the "seal" field.
func (m *VenueMutation) ResetSeal() {
	m.seal = nil
	delete(m.clearedFields, venue.FieldSeal)
}

// SetInformation sets the "information" field.
func (m *VenueMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the value of the "information" field in the mutation.
func (m *VenueMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old "information" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ClearInformation clears the value of the "information" field.
func (m *VenueMutation) ClearInformation() {
	m.information = nil
	m.clearedFields[venue.FieldInformation] = struct{}{}
}

// InformationCleared returns if the "information" field was cleared in this mutation.
func (m *VenueMutation) InformationCleared() bool {
	_, ok := m.clearedFields[venue.FieldInformation]
	return ok
}

// ResetInformation resets all changes to the "information" field.
func (m *VenueMutation) ResetInformation() {
	m.information = nil
	delete(m.clearedFields, venue.FieldInformation)
}

// AddPlaceIDs adds the "places" edge to the VenuePlace entity by ids.
func (m *VenueMutation) AddPlaceIDs(ids ...int64) {
	if m.places == nil {
		m.places = make(map[int64]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the VenuePlace entity.
func (m *VenueMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the VenuePlace entity was cleared.
func (m *VenueMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the VenuePlace entity by IDs.
func (m *VenueMutation) RemovePlaceIDs(ids ...int64) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the VenuePlace entity.
func (m *VenueMutation) RemovedPlacesIDs() (ids []int64) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *VenueMutation) PlacesIDs() (ids []int64) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *VenueMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddVenueOrderIDs adds the "venue_orders" edge to the Order entity by ids.
func (m *VenueMutation) AddVenueOrderIDs(ids ...int64) {
	if m.venue_orders == nil {
		m.venue_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.venue_orders[ids[i]] = struct{}{}
	}
}

// ClearVenueOrders clears the "venue_orders" edge to the Order entity.
func (m *VenueMutation) ClearVenueOrders() {
	m.clearedvenue_orders = true
}

// VenueOrdersCleared reports if the "venue_orders" edge to the Order entity was cleared.
func (m *VenueMutation) VenueOrdersCleared() bool {
	return m.clearedvenue_orders
}

// RemoveVenueOrderIDs removes the "venue_orders" edge to the Order entity by IDs.
func (m *VenueMutation) RemoveVenueOrderIDs(ids ...int64) {
	if m.removedvenue_orders == nil {
		m.removedvenue_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venue_orders, ids[i])
		m.removedvenue_orders[ids[i]] = struct{}{}
	}
}

// RemovedVenueOrders returns the removed IDs of the "venue_orders" edge to the Order entity.
func (m *VenueMutation) RemovedVenueOrdersIDs() (ids []int64) {
	for id := range m.removedvenue_orders {
		ids = append(ids, id)
	}
	return
}

// VenueOrdersIDs returns the "venue_orders" edge IDs in the mutation.
func (m *VenueMutation) VenueOrdersIDs() (ids []int64) {
	for id := range m.venue_orders {
		ids = append(ids, id)
	}
	return
}

// ResetVenueOrders resets all changes to the "venue_orders" edge.
func (m *VenueMutation) ResetVenueOrders() {
	m.venue_orders = nil
	m.clearedvenue_orders = false
	m.removedvenue_orders = nil
}

// AddVenueEntryIDs adds the "venue_entry" edge to the EntryLogs entity by ids.
func (m *VenueMutation) AddVenueEntryIDs(ids ...int64) {
	if m.venue_entry == nil {
		m.venue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.venue_entry[ids[i]] = struct{}{}
	}
}

// ClearVenueEntry clears the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) ClearVenueEntry() {
	m.clearedvenue_entry = true
}

// VenueEntryCleared reports if the "venue_entry" edge to the EntryLogs entity was cleared.
func (m *VenueMutation) VenueEntryCleared() bool {
	return m.clearedvenue_entry
}

// RemoveVenueEntryIDs removes the "venue_entry" edge to the EntryLogs entity by IDs.
func (m *VenueMutation) RemoveVenueEntryIDs(ids ...int64) {
	if m.removedvenue_entry == nil {
		m.removedvenue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venue_entry, ids[i])
		m.removedvenue_entry[ids[i]] = struct{}{}
	}
}

// RemovedVenueEntry returns the removed IDs of the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) RemovedVenueEntryIDs() (ids []int64) {
	for id := range m.removedvenue_entry {
		ids = append(ids, id)
	}
	return
}

// VenueEntryIDs returns the "venue_entry" edge IDs in the mutation.
func (m *VenueMutation) VenueEntryIDs() (ids []int64) {
	for id := range m.venue_entry {
		ids = append(ids, id)
	}
	return
}

// ResetVenueEntry resets all changes to the "venue_entry" edge.
func (m *VenueMutation) ResetVenueEntry() {
	m.venue_entry = nil
	m.clearedvenue_entry = false
	m.removedvenue_entry = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *VenueMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *VenueMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *VenueMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *VenueMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *VenueMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *VenueMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *VenueMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddSmIDs adds the "sms" edge to the VenueSms entity by ids.
func (m *VenueMutation) AddSmIDs(ids ...int64) {
	if m.sms == nil {
		m.sms = make(map[int64]struct{})
	}
	for i := range ids {
		m.sms[ids[i]] = struct{}{}
	}
}

// ClearSms clears the "sms" edge to the VenueSms entity.
func (m *VenueMutation) ClearSms() {
	m.clearedsms = true
}

// SmsCleared reports if the "sms" edge to the VenueSms entity was cleared.
func (m *VenueMutation) SmsCleared() bool {
	return m.clearedsms
}

// RemoveSmIDs removes the "sms" edge to the VenueSms entity by IDs.
func (m *VenueMutation) RemoveSmIDs(ids ...int64) {
	if m.removedsms == nil {
		m.removedsms = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sms, ids[i])
		m.removedsms[ids[i]] = struct{}{}
	}
}

// RemovedSms returns the removed IDs of the "sms" edge to the VenueSms entity.
func (m *VenueMutation) RemovedSmsIDs() (ids []int64) {
	for id := range m.removedsms {
		ids = append(ids, id)
	}
	return
}

// SmsIDs returns the "sms" edge IDs in the mutation.
func (m *VenueMutation) SmsIDs() (ids []int64) {
	for id := range m.sms {
		ids = append(ids, id)
	}
	return
}

// ResetSms resets all changes to the "sms" edge.
func (m *VenueMutation) ResetSms() {
	m.sms = nil
	m.clearedsms = false
	m.removedsms = nil
}

// AddSmslogIDs adds the "smslog" edge to the VenueSmsLog entity by ids.
func (m *VenueMutation) AddSmslogIDs(ids ...int64) {
	if m.smslog == nil {
		m.smslog = make(map[int64]struct{})
	}
	for i := range ids {
		m.smslog[ids[i]] = struct{}{}
	}
}

// ClearSmslog clears the "smslog" edge to the VenueSmsLog entity.
func (m *VenueMutation) ClearSmslog() {
	m.clearedsmslog = true
}

// SmslogCleared reports if the "smslog" edge to the VenueSmsLog entity was cleared.
func (m *VenueMutation) SmslogCleared() bool {
	return m.clearedsmslog
}

// RemoveSmslogIDs removes the "smslog" edge to the VenueSmsLog entity by IDs.
func (m *VenueMutation) RemoveSmslogIDs(ids ...int64) {
	if m.removedsmslog == nil {
		m.removedsmslog = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.smslog, ids[i])
		m.removedsmslog[ids[i]] = struct{}{}
	}
}

// RemovedSmslog returns the removed IDs of the "smslog" edge to the VenueSmsLog entity.
func (m *VenueMutation) RemovedSmslogIDs() (ids []int64) {
	for id := range m.removedsmslog {
		ids = append(ids, id)
	}
	return
}

// SmslogIDs returns the "smslog" edge IDs in the mutation.
func (m *VenueMutation) SmslogIDs() (ids []int64) {
	for id := range m.smslog {
		ids = append(ids, id)
	}
	return
}

// ResetSmslog resets all changes to the "smslog" edge.
func (m *VenueMutation) ResetSmslog() {
	m.smslog = nil
	m.clearedsmslog = false
	m.removedsmslog = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *VenueMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *VenueMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *VenueMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *VenueMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *VenueMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *VenueMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *VenueMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the VenueMutation builder.
func (m *VenueMutation) Where(ps ...predicate.Venue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Venue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Venue).
func (m *VenueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, venue.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, venue.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, venue.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venue.FieldName)
	}
	if m._type != nil {
		fields = append(fields, venue.FieldType)
	}
	if m.classify != nil {
		fields = append(fields, venue.FieldClassify)
	}
	if m.address != nil {
		fields = append(fields, venue.FieldAddress)
	}
	if m.address_detail != nil {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.latitude != nil {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.mobile != nil {
		fields = append(fields, venue.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, venue.FieldEmail)
	}
	if m.pic != nil {
		fields = append(fields, venue.FieldPic)
	}
	if m.seal != nil {
		fields = append(fields, venue.FieldSeal)
	}
	if m.information != nil {
		fields = append(fields, venue.FieldInformation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldCreatedAt:
		return m.CreatedAt()
	case venue.FieldUpdatedAt:
		return m.UpdatedAt()
	case venue.FieldDelete:
		return m.Delete()
	case venue.FieldCreatedID:
		return m.CreatedID()
	case venue.FieldStatus:
		return m.Status()
	case venue.FieldName:
		return m.Name()
	case venue.FieldType:
		return m.GetType()
	case venue.FieldClassify:
		return m.Classify()
	case venue.FieldAddress:
		return m.Address()
	case venue.FieldAddressDetail:
		return m.AddressDetail()
	case venue.FieldLatitude:
		return m.Latitude()
	case venue.FieldLongitude:
		return m.Longitude()
	case venue.FieldMobile:
		return m.Mobile()
	case venue.FieldEmail:
		return m.Email()
	case venue.FieldPic:
		return m.Pic()
	case venue.FieldSeal:
		return m.Seal()
	case venue.FieldInformation:
		return m.Information()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venue.FieldDelete:
		return m.OldDelete(ctx)
	case venue.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case venue.FieldStatus:
		return m.OldStatus(ctx)
	case venue.FieldName:
		return m.OldName(ctx)
	case venue.FieldType:
		return m.OldType(ctx)
	case venue.FieldClassify:
		return m.OldClassify(ctx)
	case venue.FieldAddress:
		return m.OldAddress(ctx)
	case venue.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case venue.FieldLatitude:
		return m.OldLatitude(ctx)
	case venue.FieldLongitude:
		return m.OldLongitude(ctx)
	case venue.FieldMobile:
		return m.OldMobile(ctx)
	case venue.FieldEmail:
		return m.OldEmail(ctx)
	case venue.FieldPic:
		return m.OldPic(ctx)
	case venue.FieldSeal:
		return m.OldSeal(ctx)
	case venue.FieldInformation:
		return m.OldInformation(ctx)
	}
	return nil, fmt.Errorf("unknown Venue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venue.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case venue.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venue.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case venue.FieldClassify:
		v, ok := value.([]int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassify(v)
		return nil
	case venue.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case venue.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case venue.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case venue.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case venue.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case venue.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case venue.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venue.FieldSeal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeal(v)
		return nil
	case venue.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, venue.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, venue.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, venue.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldDelete:
		return m.AddedDelete()
	case venue.FieldCreatedID:
		return m.AddedCreatedID()
	case venue.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venue.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case venue.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Venue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venue.FieldCreatedAt) {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.FieldCleared(venue.FieldUpdatedAt) {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.FieldCleared(venue.FieldDelete) {
		fields = append(fields, venue.FieldDelete)
	}
	if m.FieldCleared(venue.FieldCreatedID) {
		fields = append(fields, venue.FieldCreatedID)
	}
	if m.FieldCleared(venue.FieldStatus) {
		fields = append(fields, venue.FieldStatus)
	}
	if m.FieldCleared(venue.FieldName) {
		fields = append(fields, venue.FieldName)
	}
	if m.FieldCleared(venue.FieldType) {
		fields = append(fields, venue.FieldType)
	}
	if m.FieldCleared(venue.FieldClassify) {
		fields = append(fields, venue.FieldClassify)
	}
	if m.FieldCleared(venue.FieldAddress) {
		fields = append(fields, venue.FieldAddress)
	}
	if m.FieldCleared(venue.FieldAddressDetail) {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.FieldCleared(venue.FieldLatitude) {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.FieldCleared(venue.FieldLongitude) {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.FieldCleared(venue.FieldMobile) {
		fields = append(fields, venue.FieldMobile)
	}
	if m.FieldCleared(venue.FieldEmail) {
		fields = append(fields, venue.FieldEmail)
	}
	if m.FieldCleared(venue.FieldPic) {
		fields = append(fields, venue.FieldPic)
	}
	if m.FieldCleared(venue.FieldSeal) {
		fields = append(fields, venue.FieldSeal)
	}
	if m.FieldCleared(venue.FieldInformation) {
		fields = append(fields, venue.FieldInformation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueMutation) ClearField(name string) error {
	switch name {
	case venue.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case venue.FieldDelete:
		m.ClearDelete()
		return nil
	case venue.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case venue.FieldStatus:
		m.ClearStatus()
		return nil
	case venue.FieldName:
		m.ClearName()
		return nil
	case venue.FieldType:
		m.ClearType()
		return nil
	case venue.FieldClassify:
		m.ClearClassify()
		return nil
	case venue.FieldAddress:
		m.ClearAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ClearLatitude()
		return nil
	case venue.FieldLongitude:
		m.ClearLongitude()
		return nil
	case venue.FieldMobile:
		m.ClearMobile()
		return nil
	case venue.FieldEmail:
		m.ClearEmail()
		return nil
	case venue.FieldPic:
		m.ClearPic()
		return nil
	case venue.FieldSeal:
		m.ClearSeal()
		return nil
	case venue.FieldInformation:
		m.ClearInformation()
		return nil
	}
	return fmt.Errorf("unknown Venue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueMutation) ResetField(name string) error {
	switch name {
	case venue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venue.FieldDelete:
		m.ResetDelete()
		return nil
	case venue.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case venue.FieldStatus:
		m.ResetStatus()
		return nil
	case venue.FieldName:
		m.ResetName()
		return nil
	case venue.FieldType:
		m.ResetType()
		return nil
	case venue.FieldClassify:
		m.ResetClassify()
		return nil
	case venue.FieldAddress:
		m.ResetAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ResetLatitude()
		return nil
	case venue.FieldLongitude:
		m.ResetLongitude()
		return nil
	case venue.FieldMobile:
		m.ResetMobile()
		return nil
	case venue.FieldEmail:
		m.ResetEmail()
		return nil
	case venue.FieldPic:
		m.ResetPic()
		return nil
	case venue.FieldSeal:
		m.ResetSeal()
		return nil
	case venue.FieldInformation:
		m.ResetInformation()
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.places != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.venue_orders != nil {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.venue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	if m.users != nil {
		edges = append(edges, venue.EdgeUsers)
	}
	if m.sms != nil {
		edges = append(edges, venue.EdgeSms)
	}
	if m.smslog != nil {
		edges = append(edges, venue.EdgeSmslog)
	}
	if m.roles != nil {
		edges = append(edges, venue.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueOrders:
		ids := make([]ent.Value, 0, len(m.venue_orders))
		for id := range m.venue_orders {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.venue_entry))
		for id := range m.venue_entry {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeSms:
		ids := make([]ent.Value, 0, len(m.sms))
		for id := range m.sms {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeSmslog:
		ids := make([]ent.Value, 0, len(m.smslog))
		for id := range m.smslog {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedplaces != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.removedvenue_orders != nil {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.removedvenue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	if m.removedusers != nil {
		edges = append(edges, venue.EdgeUsers)
	}
	if m.removedsms != nil {
		edges = append(edges, venue.EdgeSms)
	}
	if m.removedsmslog != nil {
		edges = append(edges, venue.EdgeSmslog)
	}
	if m.removedroles != nil {
		edges = append(edges, venue.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueOrders:
		ids := make([]ent.Value, 0, len(m.removedvenue_orders))
		for id := range m.removedvenue_orders {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.removedvenue_entry))
		for id := range m.removedvenue_entry {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeSms:
		ids := make([]ent.Value, 0, len(m.removedsms))
		for id := range m.removedsms {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeSmslog:
		ids := make([]ent.Value, 0, len(m.removedsmslog))
		for id := range m.removedsmslog {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedplaces {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.clearedvenue_orders {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.clearedvenue_entry {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	if m.clearedusers {
		edges = append(edges, venue.EdgeUsers)
	}
	if m.clearedsms {
		edges = append(edges, venue.EdgeSms)
	}
	if m.clearedsmslog {
		edges = append(edges, venue.EdgeSmslog)
	}
	if m.clearedroles {
		edges = append(edges, venue.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueMutation) EdgeCleared(name string) bool {
	switch name {
	case venue.EdgePlaces:
		return m.clearedplaces
	case venue.EdgeVenueOrders:
		return m.clearedvenue_orders
	case venue.EdgeVenueEntry:
		return m.clearedvenue_entry
	case venue.EdgeUsers:
		return m.clearedusers
	case venue.EdgeSms:
		return m.clearedsms
	case venue.EdgeSmslog:
		return m.clearedsmslog
	case venue.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Venue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueMutation) ResetEdge(name string) error {
	switch name {
	case venue.EdgePlaces:
		m.ResetPlaces()
		return nil
	case venue.EdgeVenueOrders:
		m.ResetVenueOrders()
		return nil
	case venue.EdgeVenueEntry:
		m.ResetVenueEntry()
		return nil
	case venue.EdgeUsers:
		m.ResetUsers()
		return nil
	case venue.EdgeSms:
		m.ResetSms()
		return nil
	case venue.EdgeSmslog:
		m.ResetSmslog()
		return nil
	case venue.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Venue edge %s", name)
}

// VenuePlaceMutation represents an operation that mutates the VenuePlace nodes in the graph.
type VenuePlaceMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	delete           *int64
	adddelete        *int64
	created_id       *int64
	addcreated_id    *int64
	status           *int64
	addstatus        *int64
	name             *string
	classify         *int64
	addclassify      *int64
	pic              *string
	number           *int64
	addnumber        *int64
	_type            *int64
	add_type         *int64
	is_show          *int64
	addis_show       *int64
	is_accessible    *int64
	addis_accessible *int64
	is_booking       *int64
	addis_booking    *int64
	information      *string
	seat             *[][]*base.Seat
	appendseat       [][]*base.Seat
	clearedFields    map[string]struct{}
	venue            *int64
	clearedvenue     bool
	products         map[int64]struct{}
	removedproducts  map[int64]struct{}
	clearedproducts  bool
	done             bool
	oldValue         func(context.Context) (*VenuePlace, error)
	predicates       []predicate.VenuePlace
}

var _ ent.Mutation = (*VenuePlaceMutation)(nil)

// venueplaceOption allows management of the mutation configuration using functional options.
type venueplaceOption func(*VenuePlaceMutation)

// newVenuePlaceMutation creates new mutation for the VenuePlace entity.
func newVenuePlaceMutation(c config, op Op, opts ...venueplaceOption) *VenuePlaceMutation {
	m := &VenuePlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeVenuePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenuePlaceID sets the ID field of the mutation.
func withVenuePlaceID(id int64) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *VenuePlace
		)
		m.oldValue = func(ctx context.Context) (*VenuePlace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VenuePlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenuePlace sets the old VenuePlace of the mutation.
func withVenuePlace(node *VenuePlace) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		m.oldValue = func(context.Context) (*VenuePlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenuePlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenuePlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VenuePlace entities.
func (m *VenuePlaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenuePlaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenuePlaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VenuePlace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenuePlaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenuePlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VenuePlaceMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[venueplace.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VenuePlaceMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenuePlaceMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, venueplace.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenuePlaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenuePlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VenuePlaceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[venueplace.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VenuePlaceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenuePlaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, venueplace.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *VenuePlaceMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *VenuePlaceMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *VenuePlaceMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *VenuePlaceMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *VenuePlaceMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[venueplace.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *VenuePlaceMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *VenuePlaceMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, venueplace.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *VenuePlaceMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *VenuePlaceMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *VenuePlaceMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *VenuePlaceMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *VenuePlaceMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[venueplace.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *VenuePlaceMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *VenuePlaceMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, venueplace.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *VenuePlaceMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenuePlaceMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenuePlaceMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenuePlaceMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenuePlaceMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venueplace.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenuePlaceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenuePlaceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venueplace.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenuePlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenuePlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenuePlaceMutation) ClearName() {
	m.name = nil
	m.clearedFields[venueplace.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenuePlaceMutation) NameCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenuePlaceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venueplace.FieldName)
}

// SetClassify sets the "classify" field.
func (m *VenuePlaceMutation) SetClassify(i int64) {
	m.classify = &i
	m.addclassify = nil
}

// Classify returns the value of the "classify" field in the mutation.
func (m *VenuePlaceMutation) Classify() (r int64, exists bool) {
	v := m.classify
	if v == nil {
		return
	}
	return *v, true
}

// OldClassify returns the old "classify" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldClassify(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassify: %w", err)
	}
	return oldValue.Classify, nil
}

// AddClassify adds i to the "classify" field.
func (m *VenuePlaceMutation) AddClassify(i int64) {
	if m.addclassify != nil {
		*m.addclassify += i
	} else {
		m.addclassify = &i
	}
}

// AddedClassify returns the value that was added to the "classify" field in this mutation.
func (m *VenuePlaceMutation) AddedClassify() (r int64, exists bool) {
	v := m.addclassify
	if v == nil {
		return
	}
	return *v, true
}

// ClearClassify clears the value of the "classify" field.
func (m *VenuePlaceMutation) ClearClassify() {
	m.classify = nil
	m.addclassify = nil
	m.clearedFields[venueplace.FieldClassify] = struct{}{}
}

// ClassifyCleared returns if the "classify" field was cleared in this mutation.
func (m *VenuePlaceMutation) ClassifyCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldClassify]
	return ok
}

// ResetClassify resets all changes to the "classify" field.
func (m *VenuePlaceMutation) ResetClassify() {
	m.classify = nil
	m.addclassify = nil
	delete(m.clearedFields, venueplace.FieldClassify)
}

// SetPic sets the "pic" field.
func (m *VenuePlaceMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenuePlaceMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenuePlaceMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venueplace.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenuePlaceMutation) PicCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenuePlaceMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venueplace.FieldPic)
}

// SetVenueID sets the "venue_id" field.
func (m *VenuePlaceMutation) SetVenueID(i int64) {
	m.venue = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenuePlaceMutation) VenueID() (r int64, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *VenuePlaceMutation) ClearVenueID() {
	m.venue = nil
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *VenuePlaceMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenuePlaceMutation) ResetVenueID() {
	m.venue = nil
	delete(m.clearedFields, venueplace.FieldVenueID)
}

// SetNumber sets the "number" field.
func (m *VenuePlaceMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *VenuePlaceMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *VenuePlaceMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *VenuePlaceMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *VenuePlaceMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[venueplace.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *VenuePlaceMutation) NumberCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *VenuePlaceMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, venueplace.FieldNumber)
}

// SetType sets the "type" field.
func (m *VenuePlaceMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *VenuePlaceMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *VenuePlaceMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *VenuePlaceMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *VenuePlaceMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[venueplace.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *VenuePlaceMutation) TypeCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *VenuePlaceMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, venueplace.FieldType)
}

// SetIsShow sets the "is_show" field.
func (m *VenuePlaceMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *VenuePlaceMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *VenuePlaceMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *VenuePlaceMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *VenuePlaceMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[venueplace.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *VenuePlaceMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *VenuePlaceMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, venueplace.FieldIsShow)
}

// SetIsAccessible sets the "is_accessible" field.
func (m *VenuePlaceMutation) SetIsAccessible(i int64) {
	m.is_accessible = &i
	m.addis_accessible = nil
}

// IsAccessible returns the value of the "is_accessible" field in the mutation.
func (m *VenuePlaceMutation) IsAccessible() (r int64, exists bool) {
	v := m.is_accessible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAccessible returns the old "is_accessible" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldIsAccessible(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAccessible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAccessible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAccessible: %w", err)
	}
	return oldValue.IsAccessible, nil
}

// AddIsAccessible adds i to the "is_accessible" field.
func (m *VenuePlaceMutation) AddIsAccessible(i int64) {
	if m.addis_accessible != nil {
		*m.addis_accessible += i
	} else {
		m.addis_accessible = &i
	}
}

// AddedIsAccessible returns the value that was added to the "is_accessible" field in this mutation.
func (m *VenuePlaceMutation) AddedIsAccessible() (r int64, exists bool) {
	v := m.addis_accessible
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsAccessible clears the value of the "is_accessible" field.
func (m *VenuePlaceMutation) ClearIsAccessible() {
	m.is_accessible = nil
	m.addis_accessible = nil
	m.clearedFields[venueplace.FieldIsAccessible] = struct{}{}
}

// IsAccessibleCleared returns if the "is_accessible" field was cleared in this mutation.
func (m *VenuePlaceMutation) IsAccessibleCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldIsAccessible]
	return ok
}

// ResetIsAccessible resets all changes to the "is_accessible" field.
func (m *VenuePlaceMutation) ResetIsAccessible() {
	m.is_accessible = nil
	m.addis_accessible = nil
	delete(m.clearedFields, venueplace.FieldIsAccessible)
}

// SetIsBooking sets the "is_booking" field.
func (m *VenuePlaceMutation) SetIsBooking(i int64) {
	m.is_booking = &i
	m.addis_booking = nil
}

// IsBooking returns the value of the "is_booking" field in the mutation.
func (m *VenuePlaceMutation) IsBooking() (r int64, exists bool) {
	v := m.is_booking
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBooking returns the old "is_booking" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldIsBooking(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBooking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBooking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBooking: %w", err)
	}
	return oldValue.IsBooking, nil
}

// AddIsBooking adds i to the "is_booking" field.
func (m *VenuePlaceMutation) AddIsBooking(i int64) {
	if m.addis_booking != nil {
		*m.addis_booking += i
	} else {
		m.addis_booking = &i
	}
}

// AddedIsBooking returns the value that was added to the "is_booking" field in this mutation.
func (m *VenuePlaceMutation) AddedIsBooking() (r int64, exists bool) {
	v := m.addis_booking
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsBooking clears the value of the "is_booking" field.
func (m *VenuePlaceMutation) ClearIsBooking() {
	m.is_booking = nil
	m.addis_booking = nil
	m.clearedFields[venueplace.FieldIsBooking] = struct{}{}
}

// IsBookingCleared returns if the "is_booking" field was cleared in this mutation.
func (m *VenuePlaceMutation) IsBookingCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldIsBooking]
	return ok
}

// ResetIsBooking resets all changes to the "is_booking" field.
func (m *VenuePlaceMutation) ResetIsBooking() {
	m.is_booking = nil
	m.addis_booking = nil
	delete(m.clearedFields, venueplace.FieldIsBooking)
}

// SetInformation sets the "information" field.
func (m *VenuePlaceMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the value of the "information" field in the mutation.
func (m *VenuePlaceMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old "information" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ClearInformation clears the value of the "information" field.
func (m *VenuePlaceMutation) ClearInformation() {
	m.information = nil
	m.clearedFields[venueplace.FieldInformation] = struct{}{}
}

// InformationCleared returns if the "information" field was cleared in this mutation.
func (m *VenuePlaceMutation) InformationCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldInformation]
	return ok
}

// ResetInformation resets all changes to the "information" field.
func (m *VenuePlaceMutation) ResetInformation() {
	m.information = nil
	delete(m.clearedFields, venueplace.FieldInformation)
}

// SetSeat sets the "seat" field.
func (m *VenuePlaceMutation) SetSeat(b [][]*base.Seat) {
	m.seat = &b
	m.appendseat = nil
}

// Seat returns the value of the "seat" field in the mutation.
func (m *VenuePlaceMutation) Seat() (r [][]*base.Seat, exists bool) {
	v := m.seat
	if v == nil {
		return
	}
	return *v, true
}

// OldSeat returns the old "seat" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldSeat(ctx context.Context) (v [][]*base.Seat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeat: %w", err)
	}
	return oldValue.Seat, nil
}

// AppendSeat adds b to the "seat" field.
func (m *VenuePlaceMutation) AppendSeat(b [][]*base.Seat) {
	m.appendseat = append(m.appendseat, b...)
}

// AppendedSeat returns the list of values that were appended to the "seat" field in this mutation.
func (m *VenuePlaceMutation) AppendedSeat() ([][]*base.Seat, bool) {
	if len(m.appendseat) == 0 {
		return nil, false
	}
	return m.appendseat, true
}

// ClearSeat clears the value of the "seat" field.
func (m *VenuePlaceMutation) ClearSeat() {
	m.seat = nil
	m.appendseat = nil
	m.clearedFields[venueplace.FieldSeat] = struct{}{}
}

// SeatCleared returns if the "seat" field was cleared in this mutation.
func (m *VenuePlaceMutation) SeatCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldSeat]
	return ok
}

// ResetSeat resets all changes to the "seat" field.
func (m *VenuePlaceMutation) ResetSeat() {
	m.seat = nil
	m.appendseat = nil
	delete(m.clearedFields, venueplace.FieldSeat)
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *VenuePlaceMutation) ClearVenue() {
	m.clearedvenue = true
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *VenuePlaceMutation) VenueCleared() bool {
	return m.VenueIDCleared() || m.clearedvenue
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *VenuePlaceMutation) VenueIDs() (ids []int64) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *VenuePlaceMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *VenuePlaceMutation) AddProductIDs(ids ...int64) {
	if m.products == nil {
		m.products = make(map[int64]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *VenuePlaceMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *VenuePlaceMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *VenuePlaceMutation) RemoveProductIDs(ids ...int64) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *VenuePlaceMutation) RemovedProductsIDs() (ids []int64) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *VenuePlaceMutation) ProductsIDs() (ids []int64) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *VenuePlaceMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the VenuePlaceMutation builder.
func (m *VenuePlaceMutation) Where(ps ...predicate.VenuePlace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenuePlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenuePlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VenuePlace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenuePlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenuePlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VenuePlace).
func (m *VenuePlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenuePlaceMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, venueplace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venueplace.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, venueplace.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, venueplace.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venueplace.FieldName)
	}
	if m.classify != nil {
		fields = append(fields, venueplace.FieldClassify)
	}
	if m.pic != nil {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.venue != nil {
		fields = append(fields, venueplace.FieldVenueID)
	}
	if m.number != nil {
		fields = append(fields, venueplace.FieldNumber)
	}
	if m._type != nil {
		fields = append(fields, venueplace.FieldType)
	}
	if m.is_show != nil {
		fields = append(fields, venueplace.FieldIsShow)
	}
	if m.is_accessible != nil {
		fields = append(fields, venueplace.FieldIsAccessible)
	}
	if m.is_booking != nil {
		fields = append(fields, venueplace.FieldIsBooking)
	}
	if m.information != nil {
		fields = append(fields, venueplace.FieldInformation)
	}
	if m.seat != nil {
		fields = append(fields, venueplace.FieldSeat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenuePlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.CreatedAt()
	case venueplace.FieldUpdatedAt:
		return m.UpdatedAt()
	case venueplace.FieldDelete:
		return m.Delete()
	case venueplace.FieldCreatedID:
		return m.CreatedID()
	case venueplace.FieldStatus:
		return m.Status()
	case venueplace.FieldName:
		return m.Name()
	case venueplace.FieldClassify:
		return m.Classify()
	case venueplace.FieldPic:
		return m.Pic()
	case venueplace.FieldVenueID:
		return m.VenueID()
	case venueplace.FieldNumber:
		return m.Number()
	case venueplace.FieldType:
		return m.GetType()
	case venueplace.FieldIsShow:
		return m.IsShow()
	case venueplace.FieldIsAccessible:
		return m.IsAccessible()
	case venueplace.FieldIsBooking:
		return m.IsBooking()
	case venueplace.FieldInformation:
		return m.Information()
	case venueplace.FieldSeat:
		return m.Seat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenuePlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venueplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venueplace.FieldDelete:
		return m.OldDelete(ctx)
	case venueplace.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case venueplace.FieldStatus:
		return m.OldStatus(ctx)
	case venueplace.FieldName:
		return m.OldName(ctx)
	case venueplace.FieldClassify:
		return m.OldClassify(ctx)
	case venueplace.FieldPic:
		return m.OldPic(ctx)
	case venueplace.FieldVenueID:
		return m.OldVenueID(ctx)
	case venueplace.FieldNumber:
		return m.OldNumber(ctx)
	case venueplace.FieldType:
		return m.OldType(ctx)
	case venueplace.FieldIsShow:
		return m.OldIsShow(ctx)
	case venueplace.FieldIsAccessible:
		return m.OldIsAccessible(ctx)
	case venueplace.FieldIsBooking:
		return m.OldIsBooking(ctx)
	case venueplace.FieldInformation:
		return m.OldInformation(ctx)
	case venueplace.FieldSeat:
		return m.OldSeat(ctx)
	}
	return nil, fmt.Errorf("unknown VenuePlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venueplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venueplace.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case venueplace.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venueplace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venueplace.FieldClassify:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassify(v)
		return nil
	case venueplace.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venueplace.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case venueplace.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case venueplace.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case venueplace.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case venueplace.FieldIsAccessible:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAccessible(v)
		return nil
	case venueplace.FieldIsBooking:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBooking(v)
		return nil
	case venueplace.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	case venueplace.FieldSeat:
		v, ok := value.([][]*base.Seat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeat(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenuePlaceMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, venueplace.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, venueplace.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.addclassify != nil {
		fields = append(fields, venueplace.FieldClassify)
	}
	if m.addnumber != nil {
		fields = append(fields, venueplace.FieldNumber)
	}
	if m.add_type != nil {
		fields = append(fields, venueplace.FieldType)
	}
	if m.addis_show != nil {
		fields = append(fields, venueplace.FieldIsShow)
	}
	if m.addis_accessible != nil {
		fields = append(fields, venueplace.FieldIsAccessible)
	}
	if m.addis_booking != nil {
		fields = append(fields, venueplace.FieldIsBooking)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenuePlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldDelete:
		return m.AddedDelete()
	case venueplace.FieldCreatedID:
		return m.AddedCreatedID()
	case venueplace.FieldStatus:
		return m.AddedStatus()
	case venueplace.FieldClassify:
		return m.AddedClassify()
	case venueplace.FieldNumber:
		return m.AddedNumber()
	case venueplace.FieldType:
		return m.AddedType()
	case venueplace.FieldIsShow:
		return m.AddedIsShow()
	case venueplace.FieldIsAccessible:
		return m.AddedIsAccessible()
	case venueplace.FieldIsBooking:
		return m.AddedIsBooking()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case venueplace.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case venueplace.FieldClassify:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassify(v)
		return nil
	case venueplace.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case venueplace.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case venueplace.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	case venueplace.FieldIsAccessible:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsAccessible(v)
		return nil
	case venueplace.FieldIsBooking:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsBooking(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenuePlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venueplace.FieldCreatedAt) {
		fields = append(fields, venueplace.FieldCreatedAt)
	}
	if m.FieldCleared(venueplace.FieldUpdatedAt) {
		fields = append(fields, venueplace.FieldUpdatedAt)
	}
	if m.FieldCleared(venueplace.FieldDelete) {
		fields = append(fields, venueplace.FieldDelete)
	}
	if m.FieldCleared(venueplace.FieldCreatedID) {
		fields = append(fields, venueplace.FieldCreatedID)
	}
	if m.FieldCleared(venueplace.FieldStatus) {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.FieldCleared(venueplace.FieldName) {
		fields = append(fields, venueplace.FieldName)
	}
	if m.FieldCleared(venueplace.FieldClassify) {
		fields = append(fields, venueplace.FieldClassify)
	}
	if m.FieldCleared(venueplace.FieldPic) {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.FieldCleared(venueplace.FieldVenueID) {
		fields = append(fields, venueplace.FieldVenueID)
	}
	if m.FieldCleared(venueplace.FieldNumber) {
		fields = append(fields, venueplace.FieldNumber)
	}
	if m.FieldCleared(venueplace.FieldType) {
		fields = append(fields, venueplace.FieldType)
	}
	if m.FieldCleared(venueplace.FieldIsShow) {
		fields = append(fields, venueplace.FieldIsShow)
	}
	if m.FieldCleared(venueplace.FieldIsAccessible) {
		fields = append(fields, venueplace.FieldIsAccessible)
	}
	if m.FieldCleared(venueplace.FieldIsBooking) {
		fields = append(fields, venueplace.FieldIsBooking)
	}
	if m.FieldCleared(venueplace.FieldInformation) {
		fields = append(fields, venueplace.FieldInformation)
	}
	if m.FieldCleared(venueplace.FieldSeat) {
		fields = append(fields, venueplace.FieldSeat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenuePlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ClearField(name string) error {
	switch name {
	case venueplace.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case venueplace.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case venueplace.FieldDelete:
		m.ClearDelete()
		return nil
	case venueplace.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case venueplace.FieldStatus:
		m.ClearStatus()
		return nil
	case venueplace.FieldName:
		m.ClearName()
		return nil
	case venueplace.FieldClassify:
		m.ClearClassify()
		return nil
	case venueplace.FieldPic:
		m.ClearPic()
		return nil
	case venueplace.FieldVenueID:
		m.ClearVenueID()
		return nil
	case venueplace.FieldNumber:
		m.ClearNumber()
		return nil
	case venueplace.FieldType:
		m.ClearType()
		return nil
	case venueplace.FieldIsShow:
		m.ClearIsShow()
		return nil
	case venueplace.FieldIsAccessible:
		m.ClearIsAccessible()
		return nil
	case venueplace.FieldIsBooking:
		m.ClearIsBooking()
		return nil
	case venueplace.FieldInformation:
		m.ClearInformation()
		return nil
	case venueplace.FieldSeat:
		m.ClearSeat()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ResetField(name string) error {
	switch name {
	case venueplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venueplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venueplace.FieldDelete:
		m.ResetDelete()
		return nil
	case venueplace.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case venueplace.FieldStatus:
		m.ResetStatus()
		return nil
	case venueplace.FieldName:
		m.ResetName()
		return nil
	case venueplace.FieldClassify:
		m.ResetClassify()
		return nil
	case venueplace.FieldPic:
		m.ResetPic()
		return nil
	case venueplace.FieldVenueID:
		m.ResetVenueID()
		return nil
	case venueplace.FieldNumber:
		m.ResetNumber()
		return nil
	case venueplace.FieldType:
		m.ResetType()
		return nil
	case venueplace.FieldIsShow:
		m.ResetIsShow()
		return nil
	case venueplace.FieldIsAccessible:
		m.ResetIsAccessible()
		return nil
	case venueplace.FieldIsBooking:
		m.ResetIsBooking()
		return nil
	case venueplace.FieldInformation:
		m.ResetInformation()
		return nil
	case venueplace.FieldSeat:
		m.ResetSeat()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenuePlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.venue != nil {
		edges = append(edges, venueplace.EdgeVenue)
	}
	if m.products != nil {
		edges = append(edges, venueplace.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenuePlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venueplace.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	case venueplace.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenuePlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, venueplace.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenuePlaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case venueplace.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenuePlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvenue {
		edges = append(edges, venueplace.EdgeVenue)
	}
	if m.clearedproducts {
		edges = append(edges, venueplace.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenuePlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case venueplace.EdgeVenue:
		return m.clearedvenue
	case venueplace.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenuePlaceMutation) ClearEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenuePlaceMutation) ResetEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ResetVenue()
		return nil
	case venueplace.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace edge %s", name)
}

// VenueSmsMutation represents an operation that mutates the VenueSms nodes in the graph.
type VenueSmsMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	notice_count    *int64
	addnotice_count *int64
	used_notice     *int64
	addused_notice  *int64
	clearedFields   map[string]struct{}
	venue           *int64
	clearedvenue    bool
	done            bool
	oldValue        func(context.Context) (*VenueSms, error)
	predicates      []predicate.VenueSms
}

var _ ent.Mutation = (*VenueSmsMutation)(nil)

// venuesmsOption allows management of the mutation configuration using functional options.
type venuesmsOption func(*VenueSmsMutation)

// newVenueSmsMutation creates new mutation for the VenueSms entity.
func newVenueSmsMutation(c config, op Op, opts ...venuesmsOption) *VenueSmsMutation {
	m := &VenueSmsMutation{
		config:        c,
		op:            op,
		typ:           TypeVenueSms,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueSmsID sets the ID field of the mutation.
func withVenueSmsID(id int64) venuesmsOption {
	return func(m *VenueSmsMutation) {
		var (
			err   error
			once  sync.Once
			value *VenueSms
		)
		m.oldValue = func(ctx context.Context) (*VenueSms, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VenueSms.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenueSms sets the old VenueSms of the mutation.
func withVenueSms(node *VenueSms) venuesmsOption {
	return func(m *VenueSmsMutation) {
		m.oldValue = func(context.Context) (*VenueSms, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueSmsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueSmsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VenueSms entities.
func (m *VenueSmsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueSmsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueSmsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VenueSms.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueSmsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueSmsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VenueSms entity.
// If the VenueSms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VenueSmsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[venuesms.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VenueSmsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[venuesms.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueSmsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, venuesms.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueSmsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueSmsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VenueSms entity.
// If the VenueSms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VenueSmsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[venuesms.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VenueSmsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[venuesms.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueSmsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, venuesms.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *VenueSmsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *VenueSmsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the VenueSms entity.
// If the VenueSms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *VenueSmsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *VenueSmsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *VenueSmsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[venuesms.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *VenueSmsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[venuesms.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *VenueSmsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, venuesms.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *VenueSmsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *VenueSmsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the VenueSms entity.
// If the VenueSms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *VenueSmsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *VenueSmsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *VenueSmsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[venuesms.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *VenueSmsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[venuesms.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *VenueSmsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, venuesms.FieldCreatedID)
}

// SetVenueID sets the "venue_id" field.
func (m *VenueSmsMutation) SetVenueID(i int64) {
	m.venue = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenueSmsMutation) VenueID() (r int64, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the VenueSms entity.
// If the VenueSms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *VenueSmsMutation) ClearVenueID() {
	m.venue = nil
	m.clearedFields[venuesms.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *VenueSmsMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[venuesms.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenueSmsMutation) ResetVenueID() {
	m.venue = nil
	delete(m.clearedFields, venuesms.FieldVenueID)
}

// SetNoticeCount sets the "notice_count" field.
func (m *VenueSmsMutation) SetNoticeCount(i int64) {
	m.notice_count = &i
	m.addnotice_count = nil
}

// NoticeCount returns the value of the "notice_count" field in the mutation.
func (m *VenueSmsMutation) NoticeCount() (r int64, exists bool) {
	v := m.notice_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeCount returns the old "notice_count" field's value of the VenueSms entity.
// If the VenueSms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsMutation) OldNoticeCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeCount: %w", err)
	}
	return oldValue.NoticeCount, nil
}

// AddNoticeCount adds i to the "notice_count" field.
func (m *VenueSmsMutation) AddNoticeCount(i int64) {
	if m.addnotice_count != nil {
		*m.addnotice_count += i
	} else {
		m.addnotice_count = &i
	}
}

// AddedNoticeCount returns the value that was added to the "notice_count" field in this mutation.
func (m *VenueSmsMutation) AddedNoticeCount() (r int64, exists bool) {
	v := m.addnotice_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNoticeCount resets all changes to the "notice_count" field.
func (m *VenueSmsMutation) ResetNoticeCount() {
	m.notice_count = nil
	m.addnotice_count = nil
}

// SetUsedNotice sets the "used_notice" field.
func (m *VenueSmsMutation) SetUsedNotice(i int64) {
	m.used_notice = &i
	m.addused_notice = nil
}

// UsedNotice returns the value of the "used_notice" field in the mutation.
func (m *VenueSmsMutation) UsedNotice() (r int64, exists bool) {
	v := m.used_notice
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedNotice returns the old "used_notice" field's value of the VenueSms entity.
// If the VenueSms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsMutation) OldUsedNotice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedNotice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedNotice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedNotice: %w", err)
	}
	return oldValue.UsedNotice, nil
}

// AddUsedNotice adds i to the "used_notice" field.
func (m *VenueSmsMutation) AddUsedNotice(i int64) {
	if m.addused_notice != nil {
		*m.addused_notice += i
	} else {
		m.addused_notice = &i
	}
}

// AddedUsedNotice returns the value that was added to the "used_notice" field in this mutation.
func (m *VenueSmsMutation) AddedUsedNotice() (r int64, exists bool) {
	v := m.addused_notice
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedNotice resets all changes to the "used_notice" field.
func (m *VenueSmsMutation) ResetUsedNotice() {
	m.used_notice = nil
	m.addused_notice = nil
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *VenueSmsMutation) ClearVenue() {
	m.clearedvenue = true
	m.clearedFields[venuesms.FieldVenueID] = struct{}{}
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *VenueSmsMutation) VenueCleared() bool {
	return m.VenueIDCleared() || m.clearedvenue
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *VenueSmsMutation) VenueIDs() (ids []int64) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *VenueSmsMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// Where appends a list predicates to the VenueSmsMutation builder.
func (m *VenueSmsMutation) Where(ps ...predicate.VenueSms) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueSmsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueSmsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VenueSms, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueSmsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueSmsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VenueSms).
func (m *VenueSmsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueSmsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, venuesms.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venuesms.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, venuesms.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, venuesms.FieldCreatedID)
	}
	if m.venue != nil {
		fields = append(fields, venuesms.FieldVenueID)
	}
	if m.notice_count != nil {
		fields = append(fields, venuesms.FieldNoticeCount)
	}
	if m.used_notice != nil {
		fields = append(fields, venuesms.FieldUsedNotice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueSmsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venuesms.FieldCreatedAt:
		return m.CreatedAt()
	case venuesms.FieldUpdatedAt:
		return m.UpdatedAt()
	case venuesms.FieldDelete:
		return m.Delete()
	case venuesms.FieldCreatedID:
		return m.CreatedID()
	case venuesms.FieldVenueID:
		return m.VenueID()
	case venuesms.FieldNoticeCount:
		return m.NoticeCount()
	case venuesms.FieldUsedNotice:
		return m.UsedNotice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueSmsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venuesms.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venuesms.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venuesms.FieldDelete:
		return m.OldDelete(ctx)
	case venuesms.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case venuesms.FieldVenueID:
		return m.OldVenueID(ctx)
	case venuesms.FieldNoticeCount:
		return m.OldNoticeCount(ctx)
	case venuesms.FieldUsedNotice:
		return m.OldUsedNotice(ctx)
	}
	return nil, fmt.Errorf("unknown VenueSms field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueSmsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venuesms.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venuesms.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venuesms.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case venuesms.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case venuesms.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case venuesms.FieldNoticeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeCount(v)
		return nil
	case venuesms.FieldUsedNotice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedNotice(v)
		return nil
	}
	return fmt.Errorf("unknown VenueSms field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueSmsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, venuesms.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, venuesms.FieldCreatedID)
	}
	if m.addnotice_count != nil {
		fields = append(fields, venuesms.FieldNoticeCount)
	}
	if m.addused_notice != nil {
		fields = append(fields, venuesms.FieldUsedNotice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueSmsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venuesms.FieldDelete:
		return m.AddedDelete()
	case venuesms.FieldCreatedID:
		return m.AddedCreatedID()
	case venuesms.FieldNoticeCount:
		return m.AddedNoticeCount()
	case venuesms.FieldUsedNotice:
		return m.AddedUsedNotice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueSmsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venuesms.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case venuesms.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case venuesms.FieldNoticeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoticeCount(v)
		return nil
	case venuesms.FieldUsedNotice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedNotice(v)
		return nil
	}
	return fmt.Errorf("unknown VenueSms numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueSmsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venuesms.FieldCreatedAt) {
		fields = append(fields, venuesms.FieldCreatedAt)
	}
	if m.FieldCleared(venuesms.FieldUpdatedAt) {
		fields = append(fields, venuesms.FieldUpdatedAt)
	}
	if m.FieldCleared(venuesms.FieldDelete) {
		fields = append(fields, venuesms.FieldDelete)
	}
	if m.FieldCleared(venuesms.FieldCreatedID) {
		fields = append(fields, venuesms.FieldCreatedID)
	}
	if m.FieldCleared(venuesms.FieldVenueID) {
		fields = append(fields, venuesms.FieldVenueID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueSmsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueSmsMutation) ClearField(name string) error {
	switch name {
	case venuesms.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case venuesms.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case venuesms.FieldDelete:
		m.ClearDelete()
		return nil
	case venuesms.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case venuesms.FieldVenueID:
		m.ClearVenueID()
		return nil
	}
	return fmt.Errorf("unknown VenueSms nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueSmsMutation) ResetField(name string) error {
	switch name {
	case venuesms.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venuesms.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venuesms.FieldDelete:
		m.ResetDelete()
		return nil
	case venuesms.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case venuesms.FieldVenueID:
		m.ResetVenueID()
		return nil
	case venuesms.FieldNoticeCount:
		m.ResetNoticeCount()
		return nil
	case venuesms.FieldUsedNotice:
		m.ResetUsedNotice()
		return nil
	}
	return fmt.Errorf("unknown VenueSms field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueSmsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.venue != nil {
		edges = append(edges, venuesms.EdgeVenue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueSmsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venuesms.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueSmsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueSmsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueSmsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvenue {
		edges = append(edges, venuesms.EdgeVenue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueSmsMutation) EdgeCleared(name string) bool {
	switch name {
	case venuesms.EdgeVenue:
		return m.clearedvenue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueSmsMutation) ClearEdge(name string) error {
	switch name {
	case venuesms.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown VenueSms unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueSmsMutation) ResetEdge(name string) error {
	switch name {
	case venuesms.EdgeVenue:
		m.ResetVenue()
		return nil
	}
	return fmt.Errorf("unknown VenueSms edge %s", name)
}

// VenueSmsLogMutation represents an operation that mutates the VenueSmsLog nodes in the graph.
type VenueSmsLogMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	mobile         *string
	biz_id         *string
	code           *string
	content        *string
	notify_type    *int64
	addnotify_type *int64
	template       *string
	clearedFields  map[string]struct{}
	venue          *int64
	clearedvenue   bool
	done           bool
	oldValue       func(context.Context) (*VenueSmsLog, error)
	predicates     []predicate.VenueSmsLog
}

var _ ent.Mutation = (*VenueSmsLogMutation)(nil)

// venuesmslogOption allows management of the mutation configuration using functional options.
type venuesmslogOption func(*VenueSmsLogMutation)

// newVenueSmsLogMutation creates new mutation for the VenueSmsLog entity.
func newVenueSmsLogMutation(c config, op Op, opts ...venuesmslogOption) *VenueSmsLogMutation {
	m := &VenueSmsLogMutation{
		config:        c,
		op:            op,
		typ:           TypeVenueSmsLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueSmsLogID sets the ID field of the mutation.
func withVenueSmsLogID(id int64) venuesmslogOption {
	return func(m *VenueSmsLogMutation) {
		var (
			err   error
			once  sync.Once
			value *VenueSmsLog
		)
		m.oldValue = func(ctx context.Context) (*VenueSmsLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VenueSmsLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenueSmsLog sets the old VenueSmsLog of the mutation.
func withVenueSmsLog(node *VenueSmsLog) venuesmslogOption {
	return func(m *VenueSmsLogMutation) {
		m.oldValue = func(context.Context) (*VenueSmsLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueSmsLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueSmsLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VenueSmsLog entities.
func (m *VenueSmsLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueSmsLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueSmsLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VenueSmsLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueSmsLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueSmsLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VenueSmsLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[venuesmslog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VenueSmsLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[venuesmslog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueSmsLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, venuesmslog.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueSmsLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueSmsLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VenueSmsLogMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[venuesmslog.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VenueSmsLogMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[venuesmslog.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueSmsLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, venuesmslog.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *VenueSmsLogMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *VenueSmsLogMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *VenueSmsLogMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *VenueSmsLogMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *VenueSmsLogMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[venuesmslog.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *VenueSmsLogMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[venuesmslog.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *VenueSmsLogMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, venuesmslog.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *VenueSmsLogMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *VenueSmsLogMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *VenueSmsLogMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *VenueSmsLogMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *VenueSmsLogMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[venuesmslog.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *VenueSmsLogMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[venuesmslog.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *VenueSmsLogMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, venuesmslog.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *VenueSmsLogMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenueSmsLogMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenueSmsLogMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenueSmsLogMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenueSmsLogMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venuesmslog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenueSmsLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venuesmslog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenueSmsLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venuesmslog.FieldStatus)
}

// SetVenueID sets the "venue_id" field.
func (m *VenueSmsLogMutation) SetVenueID(i int64) {
	m.venue = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenueSmsLogMutation) VenueID() (r int64, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *VenueSmsLogMutation) ClearVenueID() {
	m.venue = nil
	m.clearedFields[venuesmslog.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *VenueSmsLogMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[venuesmslog.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenueSmsLogMutation) ResetVenueID() {
	m.venue = nil
	delete(m.clearedFields, venuesmslog.FieldVenueID)
}

// SetMobile sets the "mobile" field.
func (m *VenueSmsLogMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *VenueSmsLogMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *VenueSmsLogMutation) ResetMobile() {
	m.mobile = nil
}

// SetBizID sets the "biz_id" field.
func (m *VenueSmsLogMutation) SetBizID(s string) {
	m.biz_id = &s
}

// BizID returns the value of the "biz_id" field in the mutation.
func (m *VenueSmsLogMutation) BizID() (r string, exists bool) {
	v := m.biz_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBizID returns the old "biz_id" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldBizID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizID: %w", err)
	}
	return oldValue.BizID, nil
}

// ResetBizID resets all changes to the "biz_id" field.
func (m *VenueSmsLogMutation) ResetBizID() {
	m.biz_id = nil
}

// SetCode sets the "code" field.
func (m *VenueSmsLogMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *VenueSmsLogMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *VenueSmsLogMutation) ResetCode() {
	m.code = nil
}

// SetContent sets the "content" field.
func (m *VenueSmsLogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *VenueSmsLogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *VenueSmsLogMutation) ResetContent() {
	m.content = nil
}

// SetNotifyType sets the "notify_type" field.
func (m *VenueSmsLogMutation) SetNotifyType(i int64) {
	m.notify_type = &i
	m.addnotify_type = nil
}

// NotifyType returns the value of the "notify_type" field in the mutation.
func (m *VenueSmsLogMutation) NotifyType() (r int64, exists bool) {
	v := m.notify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyType returns the old "notify_type" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldNotifyType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyType: %w", err)
	}
	return oldValue.NotifyType, nil
}

// AddNotifyType adds i to the "notify_type" field.
func (m *VenueSmsLogMutation) AddNotifyType(i int64) {
	if m.addnotify_type != nil {
		*m.addnotify_type += i
	} else {
		m.addnotify_type = &i
	}
}

// AddedNotifyType returns the value that was added to the "notify_type" field in this mutation.
func (m *VenueSmsLogMutation) AddedNotifyType() (r int64, exists bool) {
	v := m.addnotify_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotifyType clears the value of the "notify_type" field.
func (m *VenueSmsLogMutation) ClearNotifyType() {
	m.notify_type = nil
	m.addnotify_type = nil
	m.clearedFields[venuesmslog.FieldNotifyType] = struct{}{}
}

// NotifyTypeCleared returns if the "notify_type" field was cleared in this mutation.
func (m *VenueSmsLogMutation) NotifyTypeCleared() bool {
	_, ok := m.clearedFields[venuesmslog.FieldNotifyType]
	return ok
}

// ResetNotifyType resets all changes to the "notify_type" field.
func (m *VenueSmsLogMutation) ResetNotifyType() {
	m.notify_type = nil
	m.addnotify_type = nil
	delete(m.clearedFields, venuesmslog.FieldNotifyType)
}

// SetTemplate sets the "template" field.
func (m *VenueSmsLogMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *VenueSmsLogMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the VenueSmsLog entity.
// If the VenueSmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueSmsLogMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *VenueSmsLogMutation) ResetTemplate() {
	m.template = nil
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *VenueSmsLogMutation) ClearVenue() {
	m.clearedvenue = true
	m.clearedFields[venuesmslog.FieldVenueID] = struct{}{}
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *VenueSmsLogMutation) VenueCleared() bool {
	return m.VenueIDCleared() || m.clearedvenue
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *VenueSmsLogMutation) VenueIDs() (ids []int64) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *VenueSmsLogMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// Where appends a list predicates to the VenueSmsLogMutation builder.
func (m *VenueSmsLogMutation) Where(ps ...predicate.VenueSmsLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueSmsLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueSmsLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VenueSmsLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueSmsLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueSmsLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VenueSmsLog).
func (m *VenueSmsLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueSmsLogMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, venuesmslog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venuesmslog.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, venuesmslog.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, venuesmslog.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, venuesmslog.FieldStatus)
	}
	if m.venue != nil {
		fields = append(fields, venuesmslog.FieldVenueID)
	}
	if m.mobile != nil {
		fields = append(fields, venuesmslog.FieldMobile)
	}
	if m.biz_id != nil {
		fields = append(fields, venuesmslog.FieldBizID)
	}
	if m.code != nil {
		fields = append(fields, venuesmslog.FieldCode)
	}
	if m.content != nil {
		fields = append(fields, venuesmslog.FieldContent)
	}
	if m.notify_type != nil {
		fields = append(fields, venuesmslog.FieldNotifyType)
	}
	if m.template != nil {
		fields = append(fields, venuesmslog.FieldTemplate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueSmsLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venuesmslog.FieldCreatedAt:
		return m.CreatedAt()
	case venuesmslog.FieldUpdatedAt:
		return m.UpdatedAt()
	case venuesmslog.FieldDelete:
		return m.Delete()
	case venuesmslog.FieldCreatedID:
		return m.CreatedID()
	case venuesmslog.FieldStatus:
		return m.Status()
	case venuesmslog.FieldVenueID:
		return m.VenueID()
	case venuesmslog.FieldMobile:
		return m.Mobile()
	case venuesmslog.FieldBizID:
		return m.BizID()
	case venuesmslog.FieldCode:
		return m.Code()
	case venuesmslog.FieldContent:
		return m.Content()
	case venuesmslog.FieldNotifyType:
		return m.NotifyType()
	case venuesmslog.FieldTemplate:
		return m.Template()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueSmsLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venuesmslog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venuesmslog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venuesmslog.FieldDelete:
		return m.OldDelete(ctx)
	case venuesmslog.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case venuesmslog.FieldStatus:
		return m.OldStatus(ctx)
	case venuesmslog.FieldVenueID:
		return m.OldVenueID(ctx)
	case venuesmslog.FieldMobile:
		return m.OldMobile(ctx)
	case venuesmslog.FieldBizID:
		return m.OldBizID(ctx)
	case venuesmslog.FieldCode:
		return m.OldCode(ctx)
	case venuesmslog.FieldContent:
		return m.OldContent(ctx)
	case venuesmslog.FieldNotifyType:
		return m.OldNotifyType(ctx)
	case venuesmslog.FieldTemplate:
		return m.OldTemplate(ctx)
	}
	return nil, fmt.Errorf("unknown VenueSmsLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueSmsLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venuesmslog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venuesmslog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venuesmslog.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case venuesmslog.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case venuesmslog.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venuesmslog.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case venuesmslog.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case venuesmslog.FieldBizID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizID(v)
		return nil
	case venuesmslog.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case venuesmslog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case venuesmslog.FieldNotifyType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyType(v)
		return nil
	case venuesmslog.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	}
	return fmt.Errorf("unknown VenueSmsLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueSmsLogMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, venuesmslog.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, venuesmslog.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, venuesmslog.FieldStatus)
	}
	if m.addnotify_type != nil {
		fields = append(fields, venuesmslog.FieldNotifyType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueSmsLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venuesmslog.FieldDelete:
		return m.AddedDelete()
	case venuesmslog.FieldCreatedID:
		return m.AddedCreatedID()
	case venuesmslog.FieldStatus:
		return m.AddedStatus()
	case venuesmslog.FieldNotifyType:
		return m.AddedNotifyType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueSmsLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venuesmslog.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case venuesmslog.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case venuesmslog.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case venuesmslog.FieldNotifyType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyType(v)
		return nil
	}
	return fmt.Errorf("unknown VenueSmsLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueSmsLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venuesmslog.FieldCreatedAt) {
		fields = append(fields, venuesmslog.FieldCreatedAt)
	}
	if m.FieldCleared(venuesmslog.FieldUpdatedAt) {
		fields = append(fields, venuesmslog.FieldUpdatedAt)
	}
	if m.FieldCleared(venuesmslog.FieldDelete) {
		fields = append(fields, venuesmslog.FieldDelete)
	}
	if m.FieldCleared(venuesmslog.FieldCreatedID) {
		fields = append(fields, venuesmslog.FieldCreatedID)
	}
	if m.FieldCleared(venuesmslog.FieldStatus) {
		fields = append(fields, venuesmslog.FieldStatus)
	}
	if m.FieldCleared(venuesmslog.FieldVenueID) {
		fields = append(fields, venuesmslog.FieldVenueID)
	}
	if m.FieldCleared(venuesmslog.FieldNotifyType) {
		fields = append(fields, venuesmslog.FieldNotifyType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueSmsLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueSmsLogMutation) ClearField(name string) error {
	switch name {
	case venuesmslog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case venuesmslog.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case venuesmslog.FieldDelete:
		m.ClearDelete()
		return nil
	case venuesmslog.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case venuesmslog.FieldStatus:
		m.ClearStatus()
		return nil
	case venuesmslog.FieldVenueID:
		m.ClearVenueID()
		return nil
	case venuesmslog.FieldNotifyType:
		m.ClearNotifyType()
		return nil
	}
	return fmt.Errorf("unknown VenueSmsLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueSmsLogMutation) ResetField(name string) error {
	switch name {
	case venuesmslog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venuesmslog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venuesmslog.FieldDelete:
		m.ResetDelete()
		return nil
	case venuesmslog.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case venuesmslog.FieldStatus:
		m.ResetStatus()
		return nil
	case venuesmslog.FieldVenueID:
		m.ResetVenueID()
		return nil
	case venuesmslog.FieldMobile:
		m.ResetMobile()
		return nil
	case venuesmslog.FieldBizID:
		m.ResetBizID()
		return nil
	case venuesmslog.FieldCode:
		m.ResetCode()
		return nil
	case venuesmslog.FieldContent:
		m.ResetContent()
		return nil
	case venuesmslog.FieldNotifyType:
		m.ResetNotifyType()
		return nil
	case venuesmslog.FieldTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown VenueSmsLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueSmsLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.venue != nil {
		edges = append(edges, venuesmslog.EdgeVenue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueSmsLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venuesmslog.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueSmsLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueSmsLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueSmsLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvenue {
		edges = append(edges, venuesmslog.EdgeVenue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueSmsLogMutation) EdgeCleared(name string) bool {
	switch name {
	case venuesmslog.EdgeVenue:
		return m.clearedvenue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueSmsLogMutation) ClearEdge(name string) error {
	switch name {
	case venuesmslog.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown VenueSmsLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueSmsLogMutation) ResetEdge(name string) error {
	switch name {
	case venuesmslog.EdgeVenue:
		m.ResetVenue()
		return nil
	}
	return fmt.Errorf("unknown VenueSmsLog edge %s", name)
}
