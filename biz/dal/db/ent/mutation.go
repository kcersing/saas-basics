// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"saas/biz/dal/db/ent/api"
	"saas/biz/dal/db/ent/banner"
	"saas/biz/dal/db/ent/bootcamp"
	"saas/biz/dal/db/ent/bootcampparticipant"
	"saas/biz/dal/db/ent/contest"
	"saas/biz/dal/db/ent/contestparticipant"
	"saas/biz/dal/db/ent/contract"
	"saas/biz/dal/db/ent/dictionary"
	"saas/biz/dal/db/ent/dictionarydetail"
	"saas/biz/dal/db/ent/entrylogs"
	"saas/biz/dal/db/ent/logs"
	"saas/biz/dal/db/ent/member"
	"saas/biz/dal/db/ent/membercontract"
	"saas/biz/dal/db/ent/membercontractcontent"
	"saas/biz/dal/db/ent/memberdetails"
	"saas/biz/dal/db/ent/membernote"
	"saas/biz/dal/db/ent/menu"
	"saas/biz/dal/db/ent/menuparam"
	"saas/biz/dal/db/ent/messages"
	"saas/biz/dal/db/ent/order"
	"saas/biz/dal/db/ent/orderamount"
	"saas/biz/dal/db/ent/orderitem"
	"saas/biz/dal/db/ent/orderpay"
	"saas/biz/dal/db/ent/ordersales"
	"saas/biz/dal/db/ent/predicate"
	"saas/biz/dal/db/ent/role"
	"saas/biz/dal/db/ent/token"
	"saas/biz/dal/db/ent/user"
	"saas/biz/dal/db/ent/venue"
	"saas/biz/dal/db/ent/venueplace"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI                   = "API"
	TypeBanner                = "Banner"
	TypeBootcamp              = "Bootcamp"
	TypeBootcampParticipant   = "BootcampParticipant"
	TypeContest               = "Contest"
	TypeContestParticipant    = "ContestParticipant"
	TypeContract              = "Contract"
	TypeDictionary            = "Dictionary"
	TypeDictionaryDetail      = "DictionaryDetail"
	TypeEntryLogs             = "EntryLogs"
	TypeLogs                  = "Logs"
	TypeMember                = "Member"
	TypeMemberContract        = "MemberContract"
	TypeMemberContractContent = "MemberContractContent"
	TypeMemberDetails         = "MemberDetails"
	TypeMemberNote            = "MemberNote"
	TypeMenu                  = "Menu"
	TypeMenuParam             = "MenuParam"
	TypeMessages              = "Messages"
	TypeOrder                 = "Order"
	TypeOrderAmount           = "OrderAmount"
	TypeOrderItem             = "OrderItem"
	TypeOrderPay              = "OrderPay"
	TypeOrderSales            = "OrderSales"
	TypeRole                  = "Role"
	TypeToken                 = "Token"
	TypeUser                  = "User"
	TypeVenue                 = "Venue"
	TypeVenuePlace            = "VenuePlace"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_path         *string
	title         *string
	description   *string
	api_group     *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *APIMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[api.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *APIMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, api.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *APIMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[api.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *APIMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, api.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *APIMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *APIMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *APIMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *APIMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *APIMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[api.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *APIMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[api.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *APIMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, api.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *APIMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *APIMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *APIMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *APIMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *APIMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[api.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *APIMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *APIMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, api.FieldCreatedID)
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetTitle sets the "title" field.
func (m *APIMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *APIMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *APIMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.title != nil {
		fields = append(fields, api.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldDelete:
		return m.Delete()
	case api.FieldCreatedID:
		return m.CreatedID()
	case api.FieldPath:
		return m.Path()
	case api.FieldTitle:
		return m.Title()
	case api.FieldDescription:
		return m.Description()
	case api.FieldAPIGroup:
		return m.APIGroup()
	case api.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldDelete:
		return m.OldDelete(ctx)
	case api.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldTitle:
		return m.OldTitle(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldDelete:
		return m.AddedDelete()
	case api.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldCreatedAt) {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.FieldCleared(api.FieldUpdatedAt) {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.FieldCleared(api.FieldDelete) {
		fields = append(fields, api.FieldDelete)
	}
	if m.FieldCleared(api.FieldCreatedID) {
		fields = append(fields, api.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ClearDelete()
		return nil
	case api.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ResetDelete()
		return nil
	case api.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldTitle:
		m.ResetTitle()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	name          *string
	pic           *string
	link          *string
	is_show       *int64
	addis_show    *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Banner, error)
	predicates    []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id int64) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Banner entities.
func (m *BannerMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Banner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BannerMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[banner.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BannerMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[banner.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, banner.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BannerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[banner.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BannerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[banner.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, banner.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *BannerMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *BannerMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *BannerMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *BannerMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *BannerMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[banner.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *BannerMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[banner.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *BannerMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, banner.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *BannerMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *BannerMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *BannerMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *BannerMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *BannerMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[banner.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *BannerMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[banner.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *BannerMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, banner.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *BannerMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BannerMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BannerMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BannerMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BannerMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[banner.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BannerMutation) StatusCleared() bool {
	_, ok := m.clearedFields[banner.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BannerMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, banner.FieldStatus)
}

// SetName sets the "name" field.
func (m *BannerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerMutation) ResetName() {
	m.name = nil
}

// SetPic sets the "pic" field.
func (m *BannerMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *BannerMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ResetPic resets all changes to the "pic" field.
func (m *BannerMutation) ResetPic() {
	m.pic = nil
}

// SetLink sets the "link" field.
func (m *BannerMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *BannerMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *BannerMutation) ResetLink() {
	m.link = nil
}

// SetIsShow sets the "is_show" field.
func (m *BannerMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *BannerMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *BannerMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *BannerMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *BannerMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[banner.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *BannerMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[banner.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *BannerMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, banner.FieldIsShow)
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Banner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, banner.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, banner.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, banner.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, banner.FieldPic)
	}
	if m.link != nil {
		fields = append(fields, banner.FieldLink)
	}
	if m.is_show != nil {
		fields = append(fields, banner.FieldIsShow)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldCreatedAt:
		return m.CreatedAt()
	case banner.FieldUpdatedAt:
		return m.UpdatedAt()
	case banner.FieldDelete:
		return m.Delete()
	case banner.FieldCreatedID:
		return m.CreatedID()
	case banner.FieldStatus:
		return m.Status()
	case banner.FieldName:
		return m.Name()
	case banner.FieldPic:
		return m.Pic()
	case banner.FieldLink:
		return m.Link()
	case banner.FieldIsShow:
		return m.IsShow()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banner.FieldDelete:
		return m.OldDelete(ctx)
	case banner.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case banner.FieldStatus:
		return m.OldStatus(ctx)
	case banner.FieldName:
		return m.OldName(ctx)
	case banner.FieldPic:
		return m.OldPic(ctx)
	case banner.FieldLink:
		return m.OldLink(ctx)
	case banner.FieldIsShow:
		return m.OldIsShow(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banner.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case banner.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case banner.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case banner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case banner.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case banner.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case banner.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, banner.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, banner.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.addis_show != nil {
		fields = append(fields, banner.FieldIsShow)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldDelete:
		return m.AddedDelete()
	case banner.FieldCreatedID:
		return m.AddedCreatedID()
	case banner.FieldStatus:
		return m.AddedStatus()
	case banner.FieldIsShow:
		return m.AddedIsShow()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banner.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case banner.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case banner.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case banner.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banner.FieldCreatedAt) {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.FieldCleared(banner.FieldUpdatedAt) {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	if m.FieldCleared(banner.FieldDelete) {
		fields = append(fields, banner.FieldDelete)
	}
	if m.FieldCleared(banner.FieldCreatedID) {
		fields = append(fields, banner.FieldCreatedID)
	}
	if m.FieldCleared(banner.FieldStatus) {
		fields = append(fields, banner.FieldStatus)
	}
	if m.FieldCleared(banner.FieldIsShow) {
		fields = append(fields, banner.FieldIsShow)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	switch name {
	case banner.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case banner.FieldDelete:
		m.ClearDelete()
		return nil
	case banner.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case banner.FieldStatus:
		m.ClearStatus()
		return nil
	case banner.FieldIsShow:
		m.ClearIsShow()
		return nil
	}
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banner.FieldDelete:
		m.ResetDelete()
		return nil
	case banner.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case banner.FieldStatus:
		m.ResetStatus()
		return nil
	case banner.FieldName:
		m.ResetName()
		return nil
	case banner.FieldPic:
		m.ResetPic()
		return nil
	case banner.FieldLink:
		m.ResetLink()
		return nil
	case banner.FieldIsShow:
		m.ResetIsShow()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Banner edge %s", name)
}

// BootcampMutation represents an operation that mutates the Bootcamp nodes in the graph.
type BootcampMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	delete                       *int64
	adddelete                    *int64
	created_id                   *int64
	addcreated_id                *int64
	status                       *int64
	addstatus                    *int64
	name                         *string
	sign_number                  *int64
	addsign_number               *int64
	sign_start_at                *time.Time
	sign_end_at                  *time.Time
	start_at                     *time.Time
	end_at                       *time.Time
	pic                          *string
	fee                          *float64
	addfee                       *float64
	is_fee                       *int64
	addis_fee                    *int64
	is_show                      *int64
	addis_show                   *int64
	is_cancel                    *int64
	addis_cancel                 *int64
	cancel_time                  *int64
	addcancel_time               *int64
	detail                       *string
	sign_fields                  *string
	condition                    *int64
	addcondition                 *int64
	clearedFields                map[string]struct{}
	bootcamp_participants        map[int64]struct{}
	removedbootcamp_participants map[int64]struct{}
	clearedbootcamp_participants bool
	done                         bool
	oldValue                     func(context.Context) (*Bootcamp, error)
	predicates                   []predicate.Bootcamp
}

var _ ent.Mutation = (*BootcampMutation)(nil)

// bootcampOption allows management of the mutation configuration using functional options.
type bootcampOption func(*BootcampMutation)

// newBootcampMutation creates new mutation for the Bootcamp entity.
func newBootcampMutation(c config, op Op, opts ...bootcampOption) *BootcampMutation {
	m := &BootcampMutation{
		config:        c,
		op:            op,
		typ:           TypeBootcamp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBootcampID sets the ID field of the mutation.
func withBootcampID(id int64) bootcampOption {
	return func(m *BootcampMutation) {
		var (
			err   error
			once  sync.Once
			value *Bootcamp
		)
		m.oldValue = func(ctx context.Context) (*Bootcamp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bootcamp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBootcamp sets the old Bootcamp of the mutation.
func withBootcamp(node *Bootcamp) bootcampOption {
	return func(m *BootcampMutation) {
		m.oldValue = func(context.Context) (*Bootcamp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BootcampMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BootcampMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bootcamp entities.
func (m *BootcampMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BootcampMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BootcampMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bootcamp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BootcampMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BootcampMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BootcampMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[bootcamp.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BootcampMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BootcampMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, bootcamp.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BootcampMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BootcampMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BootcampMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[bootcamp.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BootcampMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BootcampMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, bootcamp.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *BootcampMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *BootcampMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *BootcampMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *BootcampMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *BootcampMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[bootcamp.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *BootcampMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *BootcampMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, bootcamp.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *BootcampMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *BootcampMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *BootcampMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *BootcampMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *BootcampMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[bootcamp.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *BootcampMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *BootcampMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, bootcamp.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *BootcampMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BootcampMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BootcampMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BootcampMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BootcampMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[bootcamp.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BootcampMutation) StatusCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BootcampMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, bootcamp.FieldStatus)
}

// SetName sets the "name" field.
func (m *BootcampMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BootcampMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *BootcampMutation) ClearName() {
	m.name = nil
	m.clearedFields[bootcamp.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *BootcampMutation) NameCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *BootcampMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, bootcamp.FieldName)
}

// SetSignNumber sets the "sign_number" field.
func (m *BootcampMutation) SetSignNumber(i int64) {
	m.sign_number = &i
	m.addsign_number = nil
}

// SignNumber returns the value of the "sign_number" field in the mutation.
func (m *BootcampMutation) SignNumber() (r int64, exists bool) {
	v := m.sign_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSignNumber returns the old "sign_number" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignNumber: %w", err)
	}
	return oldValue.SignNumber, nil
}

// AddSignNumber adds i to the "sign_number" field.
func (m *BootcampMutation) AddSignNumber(i int64) {
	if m.addsign_number != nil {
		*m.addsign_number += i
	} else {
		m.addsign_number = &i
	}
}

// AddedSignNumber returns the value that was added to the "sign_number" field in this mutation.
func (m *BootcampMutation) AddedSignNumber() (r int64, exists bool) {
	v := m.addsign_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearSignNumber clears the value of the "sign_number" field.
func (m *BootcampMutation) ClearSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	m.clearedFields[bootcamp.FieldSignNumber] = struct{}{}
}

// SignNumberCleared returns if the "sign_number" field was cleared in this mutation.
func (m *BootcampMutation) SignNumberCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignNumber]
	return ok
}

// ResetSignNumber resets all changes to the "sign_number" field.
func (m *BootcampMutation) ResetSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	delete(m.clearedFields, bootcamp.FieldSignNumber)
}

// SetSignStartAt sets the "sign_start_at" field.
func (m *BootcampMutation) SetSignStartAt(t time.Time) {
	m.sign_start_at = &t
}

// SignStartAt returns the value of the "sign_start_at" field in the mutation.
func (m *BootcampMutation) SignStartAt() (r time.Time, exists bool) {
	v := m.sign_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartAt returns the old "sign_start_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartAt: %w", err)
	}
	return oldValue.SignStartAt, nil
}

// ClearSignStartAt clears the value of the "sign_start_at" field.
func (m *BootcampMutation) ClearSignStartAt() {
	m.sign_start_at = nil
	m.clearedFields[bootcamp.FieldSignStartAt] = struct{}{}
}

// SignStartAtCleared returns if the "sign_start_at" field was cleared in this mutation.
func (m *BootcampMutation) SignStartAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignStartAt]
	return ok
}

// ResetSignStartAt resets all changes to the "sign_start_at" field.
func (m *BootcampMutation) ResetSignStartAt() {
	m.sign_start_at = nil
	delete(m.clearedFields, bootcamp.FieldSignStartAt)
}

// SetSignEndAt sets the "sign_end_at" field.
func (m *BootcampMutation) SetSignEndAt(t time.Time) {
	m.sign_end_at = &t
}

// SignEndAt returns the value of the "sign_end_at" field in the mutation.
func (m *BootcampMutation) SignEndAt() (r time.Time, exists bool) {
	v := m.sign_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndAt returns the old "sign_end_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndAt: %w", err)
	}
	return oldValue.SignEndAt, nil
}

// ClearSignEndAt clears the value of the "sign_end_at" field.
func (m *BootcampMutation) ClearSignEndAt() {
	m.sign_end_at = nil
	m.clearedFields[bootcamp.FieldSignEndAt] = struct{}{}
}

// SignEndAtCleared returns if the "sign_end_at" field was cleared in this mutation.
func (m *BootcampMutation) SignEndAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignEndAt]
	return ok
}

// ResetSignEndAt resets all changes to the "sign_end_at" field.
func (m *BootcampMutation) ResetSignEndAt() {
	m.sign_end_at = nil
	delete(m.clearedFields, bootcamp.FieldSignEndAt)
}

// SetStartAt sets the "start_at" field.
func (m *BootcampMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *BootcampMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *BootcampMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[bootcamp.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *BootcampMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *BootcampMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, bootcamp.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *BootcampMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *BootcampMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *BootcampMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[bootcamp.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *BootcampMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *BootcampMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, bootcamp.FieldEndAt)
}

// SetPic sets the "pic" field.
func (m *BootcampMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *BootcampMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *BootcampMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[bootcamp.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *BootcampMutation) PicCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *BootcampMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, bootcamp.FieldPic)
}

// SetFee sets the "fee" field.
func (m *BootcampMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *BootcampMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *BootcampMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *BootcampMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *BootcampMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[bootcamp.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *BootcampMutation) FeeCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *BootcampMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, bootcamp.FieldFee)
}

// SetIsFee sets the "is_fee" field.
func (m *BootcampMutation) SetIsFee(i int64) {
	m.is_fee = &i
	m.addis_fee = nil
}

// IsFee returns the value of the "is_fee" field in the mutation.
func (m *BootcampMutation) IsFee() (r int64, exists bool) {
	v := m.is_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFee returns the old "is_fee" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldIsFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFee: %w", err)
	}
	return oldValue.IsFee, nil
}

// AddIsFee adds i to the "is_fee" field.
func (m *BootcampMutation) AddIsFee(i int64) {
	if m.addis_fee != nil {
		*m.addis_fee += i
	} else {
		m.addis_fee = &i
	}
}

// AddedIsFee returns the value that was added to the "is_fee" field in this mutation.
func (m *BootcampMutation) AddedIsFee() (r int64, exists bool) {
	v := m.addis_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsFee clears the value of the "is_fee" field.
func (m *BootcampMutation) ClearIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	m.clearedFields[bootcamp.FieldIsFee] = struct{}{}
}

// IsFeeCleared returns if the "is_fee" field was cleared in this mutation.
func (m *BootcampMutation) IsFeeCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldIsFee]
	return ok
}

// ResetIsFee resets all changes to the "is_fee" field.
func (m *BootcampMutation) ResetIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	delete(m.clearedFields, bootcamp.FieldIsFee)
}

// SetIsShow sets the "is_show" field.
func (m *BootcampMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *BootcampMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *BootcampMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *BootcampMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *BootcampMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[bootcamp.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *BootcampMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *BootcampMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, bootcamp.FieldIsShow)
}

// SetIsCancel sets the "is_cancel" field.
func (m *BootcampMutation) SetIsCancel(i int64) {
	m.is_cancel = &i
	m.addis_cancel = nil
}

// IsCancel returns the value of the "is_cancel" field in the mutation.
func (m *BootcampMutation) IsCancel() (r int64, exists bool) {
	v := m.is_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCancel returns the old "is_cancel" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldIsCancel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCancel: %w", err)
	}
	return oldValue.IsCancel, nil
}

// AddIsCancel adds i to the "is_cancel" field.
func (m *BootcampMutation) AddIsCancel(i int64) {
	if m.addis_cancel != nil {
		*m.addis_cancel += i
	} else {
		m.addis_cancel = &i
	}
}

// AddedIsCancel returns the value that was added to the "is_cancel" field in this mutation.
func (m *BootcampMutation) AddedIsCancel() (r int64, exists bool) {
	v := m.addis_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsCancel clears the value of the "is_cancel" field.
func (m *BootcampMutation) ClearIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	m.clearedFields[bootcamp.FieldIsCancel] = struct{}{}
}

// IsCancelCleared returns if the "is_cancel" field was cleared in this mutation.
func (m *BootcampMutation) IsCancelCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldIsCancel]
	return ok
}

// ResetIsCancel resets all changes to the "is_cancel" field.
func (m *BootcampMutation) ResetIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	delete(m.clearedFields, bootcamp.FieldIsCancel)
}

// SetCancelTime sets the "cancel_time" field.
func (m *BootcampMutation) SetCancelTime(i int64) {
	m.cancel_time = &i
	m.addcancel_time = nil
}

// CancelTime returns the value of the "cancel_time" field in the mutation.
func (m *BootcampMutation) CancelTime() (r int64, exists bool) {
	v := m.cancel_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelTime returns the old "cancel_time" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCancelTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelTime: %w", err)
	}
	return oldValue.CancelTime, nil
}

// AddCancelTime adds i to the "cancel_time" field.
func (m *BootcampMutation) AddCancelTime(i int64) {
	if m.addcancel_time != nil {
		*m.addcancel_time += i
	} else {
		m.addcancel_time = &i
	}
}

// AddedCancelTime returns the value that was added to the "cancel_time" field in this mutation.
func (m *BootcampMutation) AddedCancelTime() (r int64, exists bool) {
	v := m.addcancel_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelTime clears the value of the "cancel_time" field.
func (m *BootcampMutation) ClearCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	m.clearedFields[bootcamp.FieldCancelTime] = struct{}{}
}

// CancelTimeCleared returns if the "cancel_time" field was cleared in this mutation.
func (m *BootcampMutation) CancelTimeCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCancelTime]
	return ok
}

// ResetCancelTime resets all changes to the "cancel_time" field.
func (m *BootcampMutation) ResetCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	delete(m.clearedFields, bootcamp.FieldCancelTime)
}

// SetDetail sets the "detail" field.
func (m *BootcampMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *BootcampMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *BootcampMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[bootcamp.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *BootcampMutation) DetailCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *BootcampMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, bootcamp.FieldDetail)
}

// SetSignFields sets the "sign_fields" field.
func (m *BootcampMutation) SetSignFields(s string) {
	m.sign_fields = &s
}

// SignFields returns the value of the "sign_fields" field in the mutation.
func (m *BootcampMutation) SignFields() (r string, exists bool) {
	v := m.sign_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldSignFields returns the old "sign_fields" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldSignFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignFields: %w", err)
	}
	return oldValue.SignFields, nil
}

// ClearSignFields clears the value of the "sign_fields" field.
func (m *BootcampMutation) ClearSignFields() {
	m.sign_fields = nil
	m.clearedFields[bootcamp.FieldSignFields] = struct{}{}
}

// SignFieldsCleared returns if the "sign_fields" field was cleared in this mutation.
func (m *BootcampMutation) SignFieldsCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldSignFields]
	return ok
}

// ResetSignFields resets all changes to the "sign_fields" field.
func (m *BootcampMutation) ResetSignFields() {
	m.sign_fields = nil
	delete(m.clearedFields, bootcamp.FieldSignFields)
}

// SetCondition sets the "condition" field.
func (m *BootcampMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *BootcampMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Bootcamp entity.
// If the Bootcamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *BootcampMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *BootcampMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *BootcampMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[bootcamp.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *BootcampMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[bootcamp.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *BootcampMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, bootcamp.FieldCondition)
}

// AddBootcampParticipantIDs adds the "bootcamp_participants" edge to the BootcampParticipant entity by ids.
func (m *BootcampMutation) AddBootcampParticipantIDs(ids ...int64) {
	if m.bootcamp_participants == nil {
		m.bootcamp_participants = make(map[int64]struct{})
	}
	for i := range ids {
		m.bootcamp_participants[ids[i]] = struct{}{}
	}
}

// ClearBootcampParticipants clears the "bootcamp_participants" edge to the BootcampParticipant entity.
func (m *BootcampMutation) ClearBootcampParticipants() {
	m.clearedbootcamp_participants = true
}

// BootcampParticipantsCleared reports if the "bootcamp_participants" edge to the BootcampParticipant entity was cleared.
func (m *BootcampMutation) BootcampParticipantsCleared() bool {
	return m.clearedbootcamp_participants
}

// RemoveBootcampParticipantIDs removes the "bootcamp_participants" edge to the BootcampParticipant entity by IDs.
func (m *BootcampMutation) RemoveBootcampParticipantIDs(ids ...int64) {
	if m.removedbootcamp_participants == nil {
		m.removedbootcamp_participants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bootcamp_participants, ids[i])
		m.removedbootcamp_participants[ids[i]] = struct{}{}
	}
}

// RemovedBootcampParticipants returns the removed IDs of the "bootcamp_participants" edge to the BootcampParticipant entity.
func (m *BootcampMutation) RemovedBootcampParticipantsIDs() (ids []int64) {
	for id := range m.removedbootcamp_participants {
		ids = append(ids, id)
	}
	return
}

// BootcampParticipantsIDs returns the "bootcamp_participants" edge IDs in the mutation.
func (m *BootcampMutation) BootcampParticipantsIDs() (ids []int64) {
	for id := range m.bootcamp_participants {
		ids = append(ids, id)
	}
	return
}

// ResetBootcampParticipants resets all changes to the "bootcamp_participants" edge.
func (m *BootcampMutation) ResetBootcampParticipants() {
	m.bootcamp_participants = nil
	m.clearedbootcamp_participants = false
	m.removedbootcamp_participants = nil
}

// Where appends a list predicates to the BootcampMutation builder.
func (m *BootcampMutation) Where(ps ...predicate.Bootcamp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BootcampMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BootcampMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bootcamp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BootcampMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BootcampMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bootcamp).
func (m *BootcampMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BootcampMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, bootcamp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bootcamp.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, bootcamp.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, bootcamp.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, bootcamp.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, bootcamp.FieldName)
	}
	if m.sign_number != nil {
		fields = append(fields, bootcamp.FieldSignNumber)
	}
	if m.sign_start_at != nil {
		fields = append(fields, bootcamp.FieldSignStartAt)
	}
	if m.sign_end_at != nil {
		fields = append(fields, bootcamp.FieldSignEndAt)
	}
	if m.start_at != nil {
		fields = append(fields, bootcamp.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, bootcamp.FieldEndAt)
	}
	if m.pic != nil {
		fields = append(fields, bootcamp.FieldPic)
	}
	if m.fee != nil {
		fields = append(fields, bootcamp.FieldFee)
	}
	if m.is_fee != nil {
		fields = append(fields, bootcamp.FieldIsFee)
	}
	if m.is_show != nil {
		fields = append(fields, bootcamp.FieldIsShow)
	}
	if m.is_cancel != nil {
		fields = append(fields, bootcamp.FieldIsCancel)
	}
	if m.cancel_time != nil {
		fields = append(fields, bootcamp.FieldCancelTime)
	}
	if m.detail != nil {
		fields = append(fields, bootcamp.FieldDetail)
	}
	if m.sign_fields != nil {
		fields = append(fields, bootcamp.FieldSignFields)
	}
	if m.condition != nil {
		fields = append(fields, bootcamp.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BootcampMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bootcamp.FieldCreatedAt:
		return m.CreatedAt()
	case bootcamp.FieldUpdatedAt:
		return m.UpdatedAt()
	case bootcamp.FieldDelete:
		return m.Delete()
	case bootcamp.FieldCreatedID:
		return m.CreatedID()
	case bootcamp.FieldStatus:
		return m.Status()
	case bootcamp.FieldName:
		return m.Name()
	case bootcamp.FieldSignNumber:
		return m.SignNumber()
	case bootcamp.FieldSignStartAt:
		return m.SignStartAt()
	case bootcamp.FieldSignEndAt:
		return m.SignEndAt()
	case bootcamp.FieldStartAt:
		return m.StartAt()
	case bootcamp.FieldEndAt:
		return m.EndAt()
	case bootcamp.FieldPic:
		return m.Pic()
	case bootcamp.FieldFee:
		return m.Fee()
	case bootcamp.FieldIsFee:
		return m.IsFee()
	case bootcamp.FieldIsShow:
		return m.IsShow()
	case bootcamp.FieldIsCancel:
		return m.IsCancel()
	case bootcamp.FieldCancelTime:
		return m.CancelTime()
	case bootcamp.FieldDetail:
		return m.Detail()
	case bootcamp.FieldSignFields:
		return m.SignFields()
	case bootcamp.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BootcampMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bootcamp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bootcamp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bootcamp.FieldDelete:
		return m.OldDelete(ctx)
	case bootcamp.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case bootcamp.FieldStatus:
		return m.OldStatus(ctx)
	case bootcamp.FieldName:
		return m.OldName(ctx)
	case bootcamp.FieldSignNumber:
		return m.OldSignNumber(ctx)
	case bootcamp.FieldSignStartAt:
		return m.OldSignStartAt(ctx)
	case bootcamp.FieldSignEndAt:
		return m.OldSignEndAt(ctx)
	case bootcamp.FieldStartAt:
		return m.OldStartAt(ctx)
	case bootcamp.FieldEndAt:
		return m.OldEndAt(ctx)
	case bootcamp.FieldPic:
		return m.OldPic(ctx)
	case bootcamp.FieldFee:
		return m.OldFee(ctx)
	case bootcamp.FieldIsFee:
		return m.OldIsFee(ctx)
	case bootcamp.FieldIsShow:
		return m.OldIsShow(ctx)
	case bootcamp.FieldIsCancel:
		return m.OldIsCancel(ctx)
	case bootcamp.FieldCancelTime:
		return m.OldCancelTime(ctx)
	case bootcamp.FieldDetail:
		return m.OldDetail(ctx)
	case bootcamp.FieldSignFields:
		return m.OldSignFields(ctx)
	case bootcamp.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Bootcamp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bootcamp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bootcamp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bootcamp.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case bootcamp.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case bootcamp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bootcamp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bootcamp.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignNumber(v)
		return nil
	case bootcamp.FieldSignStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartAt(v)
		return nil
	case bootcamp.FieldSignEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndAt(v)
		return nil
	case bootcamp.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case bootcamp.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case bootcamp.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case bootcamp.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case bootcamp.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFee(v)
		return nil
	case bootcamp.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case bootcamp.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCancel(v)
		return nil
	case bootcamp.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelTime(v)
		return nil
	case bootcamp.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case bootcamp.FieldSignFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignFields(v)
		return nil
	case bootcamp.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Bootcamp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BootcampMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, bootcamp.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, bootcamp.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, bootcamp.FieldStatus)
	}
	if m.addsign_number != nil {
		fields = append(fields, bootcamp.FieldSignNumber)
	}
	if m.addfee != nil {
		fields = append(fields, bootcamp.FieldFee)
	}
	if m.addis_fee != nil {
		fields = append(fields, bootcamp.FieldIsFee)
	}
	if m.addis_show != nil {
		fields = append(fields, bootcamp.FieldIsShow)
	}
	if m.addis_cancel != nil {
		fields = append(fields, bootcamp.FieldIsCancel)
	}
	if m.addcancel_time != nil {
		fields = append(fields, bootcamp.FieldCancelTime)
	}
	if m.addcondition != nil {
		fields = append(fields, bootcamp.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BootcampMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bootcamp.FieldDelete:
		return m.AddedDelete()
	case bootcamp.FieldCreatedID:
		return m.AddedCreatedID()
	case bootcamp.FieldStatus:
		return m.AddedStatus()
	case bootcamp.FieldSignNumber:
		return m.AddedSignNumber()
	case bootcamp.FieldFee:
		return m.AddedFee()
	case bootcamp.FieldIsFee:
		return m.AddedIsFee()
	case bootcamp.FieldIsShow:
		return m.AddedIsShow()
	case bootcamp.FieldIsCancel:
		return m.AddedIsCancel()
	case bootcamp.FieldCancelTime:
		return m.AddedCancelTime()
	case bootcamp.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bootcamp.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case bootcamp.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case bootcamp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case bootcamp.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignNumber(v)
		return nil
	case bootcamp.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case bootcamp.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFee(v)
		return nil
	case bootcamp.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	case bootcamp.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCancel(v)
		return nil
	case bootcamp.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelTime(v)
		return nil
	case bootcamp.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Bootcamp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BootcampMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bootcamp.FieldCreatedAt) {
		fields = append(fields, bootcamp.FieldCreatedAt)
	}
	if m.FieldCleared(bootcamp.FieldUpdatedAt) {
		fields = append(fields, bootcamp.FieldUpdatedAt)
	}
	if m.FieldCleared(bootcamp.FieldDelete) {
		fields = append(fields, bootcamp.FieldDelete)
	}
	if m.FieldCleared(bootcamp.FieldCreatedID) {
		fields = append(fields, bootcamp.FieldCreatedID)
	}
	if m.FieldCleared(bootcamp.FieldStatus) {
		fields = append(fields, bootcamp.FieldStatus)
	}
	if m.FieldCleared(bootcamp.FieldName) {
		fields = append(fields, bootcamp.FieldName)
	}
	if m.FieldCleared(bootcamp.FieldSignNumber) {
		fields = append(fields, bootcamp.FieldSignNumber)
	}
	if m.FieldCleared(bootcamp.FieldSignStartAt) {
		fields = append(fields, bootcamp.FieldSignStartAt)
	}
	if m.FieldCleared(bootcamp.FieldSignEndAt) {
		fields = append(fields, bootcamp.FieldSignEndAt)
	}
	if m.FieldCleared(bootcamp.FieldStartAt) {
		fields = append(fields, bootcamp.FieldStartAt)
	}
	if m.FieldCleared(bootcamp.FieldEndAt) {
		fields = append(fields, bootcamp.FieldEndAt)
	}
	if m.FieldCleared(bootcamp.FieldPic) {
		fields = append(fields, bootcamp.FieldPic)
	}
	if m.FieldCleared(bootcamp.FieldFee) {
		fields = append(fields, bootcamp.FieldFee)
	}
	if m.FieldCleared(bootcamp.FieldIsFee) {
		fields = append(fields, bootcamp.FieldIsFee)
	}
	if m.FieldCleared(bootcamp.FieldIsShow) {
		fields = append(fields, bootcamp.FieldIsShow)
	}
	if m.FieldCleared(bootcamp.FieldIsCancel) {
		fields = append(fields, bootcamp.FieldIsCancel)
	}
	if m.FieldCleared(bootcamp.FieldCancelTime) {
		fields = append(fields, bootcamp.FieldCancelTime)
	}
	if m.FieldCleared(bootcamp.FieldDetail) {
		fields = append(fields, bootcamp.FieldDetail)
	}
	if m.FieldCleared(bootcamp.FieldSignFields) {
		fields = append(fields, bootcamp.FieldSignFields)
	}
	if m.FieldCleared(bootcamp.FieldCondition) {
		fields = append(fields, bootcamp.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BootcampMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BootcampMutation) ClearField(name string) error {
	switch name {
	case bootcamp.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case bootcamp.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case bootcamp.FieldDelete:
		m.ClearDelete()
		return nil
	case bootcamp.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case bootcamp.FieldStatus:
		m.ClearStatus()
		return nil
	case bootcamp.FieldName:
		m.ClearName()
		return nil
	case bootcamp.FieldSignNumber:
		m.ClearSignNumber()
		return nil
	case bootcamp.FieldSignStartAt:
		m.ClearSignStartAt()
		return nil
	case bootcamp.FieldSignEndAt:
		m.ClearSignEndAt()
		return nil
	case bootcamp.FieldStartAt:
		m.ClearStartAt()
		return nil
	case bootcamp.FieldEndAt:
		m.ClearEndAt()
		return nil
	case bootcamp.FieldPic:
		m.ClearPic()
		return nil
	case bootcamp.FieldFee:
		m.ClearFee()
		return nil
	case bootcamp.FieldIsFee:
		m.ClearIsFee()
		return nil
	case bootcamp.FieldIsShow:
		m.ClearIsShow()
		return nil
	case bootcamp.FieldIsCancel:
		m.ClearIsCancel()
		return nil
	case bootcamp.FieldCancelTime:
		m.ClearCancelTime()
		return nil
	case bootcamp.FieldDetail:
		m.ClearDetail()
		return nil
	case bootcamp.FieldSignFields:
		m.ClearSignFields()
		return nil
	case bootcamp.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Bootcamp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BootcampMutation) ResetField(name string) error {
	switch name {
	case bootcamp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bootcamp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bootcamp.FieldDelete:
		m.ResetDelete()
		return nil
	case bootcamp.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case bootcamp.FieldStatus:
		m.ResetStatus()
		return nil
	case bootcamp.FieldName:
		m.ResetName()
		return nil
	case bootcamp.FieldSignNumber:
		m.ResetSignNumber()
		return nil
	case bootcamp.FieldSignStartAt:
		m.ResetSignStartAt()
		return nil
	case bootcamp.FieldSignEndAt:
		m.ResetSignEndAt()
		return nil
	case bootcamp.FieldStartAt:
		m.ResetStartAt()
		return nil
	case bootcamp.FieldEndAt:
		m.ResetEndAt()
		return nil
	case bootcamp.FieldPic:
		m.ResetPic()
		return nil
	case bootcamp.FieldFee:
		m.ResetFee()
		return nil
	case bootcamp.FieldIsFee:
		m.ResetIsFee()
		return nil
	case bootcamp.FieldIsShow:
		m.ResetIsShow()
		return nil
	case bootcamp.FieldIsCancel:
		m.ResetIsCancel()
		return nil
	case bootcamp.FieldCancelTime:
		m.ResetCancelTime()
		return nil
	case bootcamp.FieldDetail:
		m.ResetDetail()
		return nil
	case bootcamp.FieldSignFields:
		m.ResetSignFields()
		return nil
	case bootcamp.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Bootcamp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BootcampMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bootcamp_participants != nil {
		edges = append(edges, bootcamp.EdgeBootcampParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BootcampMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		ids := make([]ent.Value, 0, len(m.bootcamp_participants))
		for id := range m.bootcamp_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BootcampMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbootcamp_participants != nil {
		edges = append(edges, bootcamp.EdgeBootcampParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BootcampMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		ids := make([]ent.Value, 0, len(m.removedbootcamp_participants))
		for id := range m.removedbootcamp_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BootcampMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbootcamp_participants {
		edges = append(edges, bootcamp.EdgeBootcampParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BootcampMutation) EdgeCleared(name string) bool {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		return m.clearedbootcamp_participants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BootcampMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bootcamp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BootcampMutation) ResetEdge(name string) error {
	switch name {
	case bootcamp.EdgeBootcampParticipants:
		m.ResetBootcampParticipants()
		return nil
	}
	return fmt.Errorf("unknown Bootcamp edge %s", name)
}

// BootcampParticipantMutation represents an operation that mutates the BootcampParticipant nodes in the graph.
type BootcampParticipantMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	delete           *int64
	adddelete        *int64
	created_id       *int64
	addcreated_id    *int64
	status           *int64
	addstatus        *int64
	name             *string
	mobile           *string
	fields           *string
	order_id         *int64
	addorder_id      *int64
	order_sn         *string
	fee              *float64
	addfee           *float64
	member_id        *int64
	addmember_id     *int64
	clearedFields    map[string]struct{}
	bootcamps        *int64
	clearedbootcamps bool
	members          map[int64]struct{}
	removedmembers   map[int64]struct{}
	clearedmembers   bool
	done             bool
	oldValue         func(context.Context) (*BootcampParticipant, error)
	predicates       []predicate.BootcampParticipant
}

var _ ent.Mutation = (*BootcampParticipantMutation)(nil)

// bootcampparticipantOption allows management of the mutation configuration using functional options.
type bootcampparticipantOption func(*BootcampParticipantMutation)

// newBootcampParticipantMutation creates new mutation for the BootcampParticipant entity.
func newBootcampParticipantMutation(c config, op Op, opts ...bootcampparticipantOption) *BootcampParticipantMutation {
	m := &BootcampParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeBootcampParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBootcampParticipantID sets the ID field of the mutation.
func withBootcampParticipantID(id int64) bootcampparticipantOption {
	return func(m *BootcampParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *BootcampParticipant
		)
		m.oldValue = func(ctx context.Context) (*BootcampParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BootcampParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBootcampParticipant sets the old BootcampParticipant of the mutation.
func withBootcampParticipant(node *BootcampParticipant) bootcampparticipantOption {
	return func(m *BootcampParticipantMutation) {
		m.oldValue = func(context.Context) (*BootcampParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BootcampParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BootcampParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BootcampParticipant entities.
func (m *BootcampParticipantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BootcampParticipantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BootcampParticipantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BootcampParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BootcampParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BootcampParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BootcampParticipantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[bootcampparticipant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BootcampParticipantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BootcampParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, bootcampparticipant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BootcampParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BootcampParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BootcampParticipantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[bootcampparticipant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BootcampParticipantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BootcampParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, bootcampparticipant.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *BootcampParticipantMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *BootcampParticipantMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *BootcampParticipantMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *BootcampParticipantMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *BootcampParticipantMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[bootcampparticipant.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *BootcampParticipantMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *BootcampParticipantMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, bootcampparticipant.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *BootcampParticipantMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *BootcampParticipantMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *BootcampParticipantMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *BootcampParticipantMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *BootcampParticipantMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[bootcampparticipant.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *BootcampParticipantMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, bootcampparticipant.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *BootcampParticipantMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BootcampParticipantMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BootcampParticipantMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BootcampParticipantMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BootcampParticipantMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[bootcampparticipant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BootcampParticipantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BootcampParticipantMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, bootcampparticipant.FieldStatus)
}

// SetBootcampID sets the "bootcamp_id" field.
func (m *BootcampParticipantMutation) SetBootcampID(i int64) {
	m.bootcamps = &i
}

// BootcampID returns the value of the "bootcamp_id" field in the mutation.
func (m *BootcampParticipantMutation) BootcampID() (r int64, exists bool) {
	v := m.bootcamps
	if v == nil {
		return
	}
	return *v, true
}

// OldBootcampID returns the old "bootcamp_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldBootcampID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBootcampID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBootcampID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBootcampID: %w", err)
	}
	return oldValue.BootcampID, nil
}

// ClearBootcampID clears the value of the "bootcamp_id" field.
func (m *BootcampParticipantMutation) ClearBootcampID() {
	m.bootcamps = nil
	m.clearedFields[bootcampparticipant.FieldBootcampID] = struct{}{}
}

// BootcampIDCleared returns if the "bootcamp_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) BootcampIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldBootcampID]
	return ok
}

// ResetBootcampID resets all changes to the "bootcamp_id" field.
func (m *BootcampParticipantMutation) ResetBootcampID() {
	m.bootcamps = nil
	delete(m.clearedFields, bootcampparticipant.FieldBootcampID)
}

// SetName sets the "name" field.
func (m *BootcampParticipantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BootcampParticipantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *BootcampParticipantMutation) ClearName() {
	m.name = nil
	m.clearedFields[bootcampparticipant.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *BootcampParticipantMutation) NameCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *BootcampParticipantMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, bootcampparticipant.FieldName)
}

// SetMobile sets the "mobile" field.
func (m *BootcampParticipantMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *BootcampParticipantMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *BootcampParticipantMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[bootcampparticipant.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *BootcampParticipantMutation) MobileCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *BootcampParticipantMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, bootcampparticipant.FieldMobile)
}

// SetFields sets the "fields" field.
func (m *BootcampParticipantMutation) SetFields(s string) {
	m.fields = &s
}

// GetFields returns the value of the "fields" field in the mutation.
func (m *BootcampParticipantMutation) GetFields() (r string, exists bool) {
	v := m.fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFields returns the old "fields" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFields: %w", err)
	}
	return oldValue.Fields, nil
}

// ClearFields clears the value of the "fields" field.
func (m *BootcampParticipantMutation) ClearFields() {
	m.fields = nil
	m.clearedFields[bootcampparticipant.FieldFields] = struct{}{}
}

// FieldsCleared returns if the "fields" field was cleared in this mutation.
func (m *BootcampParticipantMutation) FieldsCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldFields]
	return ok
}

// ResetFields resets all changes to the "fields" field.
func (m *BootcampParticipantMutation) ResetFields() {
	m.fields = nil
	delete(m.clearedFields, bootcampparticipant.FieldFields)
}

// SetOrderID sets the "order_id" field.
func (m *BootcampParticipantMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *BootcampParticipantMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *BootcampParticipantMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *BootcampParticipantMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *BootcampParticipantMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[bootcampparticipant.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *BootcampParticipantMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, bootcampparticipant.FieldOrderID)
}

// SetOrderSn sets the "order_sn" field.
func (m *BootcampParticipantMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *BootcampParticipantMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *BootcampParticipantMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[bootcampparticipant.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *BootcampParticipantMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *BootcampParticipantMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, bootcampparticipant.FieldOrderSn)
}

// SetFee sets the "fee" field.
func (m *BootcampParticipantMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *BootcampParticipantMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *BootcampParticipantMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *BootcampParticipantMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *BootcampParticipantMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[bootcampparticipant.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *BootcampParticipantMutation) FeeCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *BootcampParticipantMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, bootcampparticipant.FieldFee)
}

// SetMemberID sets the "member_id" field.
func (m *BootcampParticipantMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *BootcampParticipantMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the BootcampParticipant entity.
// If the BootcampParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BootcampParticipantMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *BootcampParticipantMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *BootcampParticipantMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *BootcampParticipantMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[bootcampparticipant.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *BootcampParticipantMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[bootcampparticipant.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *BootcampParticipantMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, bootcampparticipant.FieldMemberID)
}

// SetBootcampsID sets the "bootcamps" edge to the Bootcamp entity by id.
func (m *BootcampParticipantMutation) SetBootcampsID(id int64) {
	m.bootcamps = &id
}

// ClearBootcamps clears the "bootcamps" edge to the Bootcamp entity.
func (m *BootcampParticipantMutation) ClearBootcamps() {
	m.clearedbootcamps = true
	m.clearedFields[bootcampparticipant.FieldBootcampID] = struct{}{}
}

// BootcampsCleared reports if the "bootcamps" edge to the Bootcamp entity was cleared.
func (m *BootcampParticipantMutation) BootcampsCleared() bool {
	return m.BootcampIDCleared() || m.clearedbootcamps
}

// BootcampsID returns the "bootcamps" edge ID in the mutation.
func (m *BootcampParticipantMutation) BootcampsID() (id int64, exists bool) {
	if m.bootcamps != nil {
		return *m.bootcamps, true
	}
	return
}

// BootcampsIDs returns the "bootcamps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BootcampsID instead. It exists only for internal usage by the builders.
func (m *BootcampParticipantMutation) BootcampsIDs() (ids []int64) {
	if id := m.bootcamps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBootcamps resets all changes to the "bootcamps" edge.
func (m *BootcampParticipantMutation) ResetBootcamps() {
	m.bootcamps = nil
	m.clearedbootcamps = false
}

// AddMemberIDs adds the "members" edge to the Member entity by ids.
func (m *BootcampParticipantMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *BootcampParticipantMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *BootcampParticipantMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Member entity by IDs.
func (m *BootcampParticipantMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Member entity.
func (m *BootcampParticipantMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *BootcampParticipantMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *BootcampParticipantMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the BootcampParticipantMutation builder.
func (m *BootcampParticipantMutation) Where(ps ...predicate.BootcampParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BootcampParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BootcampParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BootcampParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BootcampParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BootcampParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BootcampParticipant).
func (m *BootcampParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BootcampParticipantMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, bootcampparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bootcampparticipant.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, bootcampparticipant.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, bootcampparticipant.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, bootcampparticipant.FieldStatus)
	}
	if m.bootcamps != nil {
		fields = append(fields, bootcampparticipant.FieldBootcampID)
	}
	if m.name != nil {
		fields = append(fields, bootcampparticipant.FieldName)
	}
	if m.mobile != nil {
		fields = append(fields, bootcampparticipant.FieldMobile)
	}
	if m.fields != nil {
		fields = append(fields, bootcampparticipant.FieldFields)
	}
	if m.order_id != nil {
		fields = append(fields, bootcampparticipant.FieldOrderID)
	}
	if m.order_sn != nil {
		fields = append(fields, bootcampparticipant.FieldOrderSn)
	}
	if m.fee != nil {
		fields = append(fields, bootcampparticipant.FieldFee)
	}
	if m.member_id != nil {
		fields = append(fields, bootcampparticipant.FieldMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BootcampParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case bootcampparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	case bootcampparticipant.FieldDelete:
		return m.Delete()
	case bootcampparticipant.FieldCreatedID:
		return m.CreatedID()
	case bootcampparticipant.FieldStatus:
		return m.Status()
	case bootcampparticipant.FieldBootcampID:
		return m.BootcampID()
	case bootcampparticipant.FieldName:
		return m.Name()
	case bootcampparticipant.FieldMobile:
		return m.Mobile()
	case bootcampparticipant.FieldFields:
		return m.GetFields()
	case bootcampparticipant.FieldOrderID:
		return m.OrderID()
	case bootcampparticipant.FieldOrderSn:
		return m.OrderSn()
	case bootcampparticipant.FieldFee:
		return m.Fee()
	case bootcampparticipant.FieldMemberID:
		return m.MemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BootcampParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bootcampparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bootcampparticipant.FieldDelete:
		return m.OldDelete(ctx)
	case bootcampparticipant.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case bootcampparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case bootcampparticipant.FieldBootcampID:
		return m.OldBootcampID(ctx)
	case bootcampparticipant.FieldName:
		return m.OldName(ctx)
	case bootcampparticipant.FieldMobile:
		return m.OldMobile(ctx)
	case bootcampparticipant.FieldFields:
		return m.OldFields(ctx)
	case bootcampparticipant.FieldOrderID:
		return m.OldOrderID(ctx)
	case bootcampparticipant.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case bootcampparticipant.FieldFee:
		return m.OldFee(ctx)
	case bootcampparticipant.FieldMemberID:
		return m.OldMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown BootcampParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bootcampparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bootcampparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case bootcampparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case bootcampparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bootcampparticipant.FieldBootcampID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBootcampID(v)
		return nil
	case bootcampparticipant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bootcampparticipant.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case bootcampparticipant.FieldFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFields(v)
		return nil
	case bootcampparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case bootcampparticipant.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case bootcampparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case bootcampparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BootcampParticipantMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, bootcampparticipant.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, bootcampparticipant.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, bootcampparticipant.FieldStatus)
	}
	if m.addorder_id != nil {
		fields = append(fields, bootcampparticipant.FieldOrderID)
	}
	if m.addfee != nil {
		fields = append(fields, bootcampparticipant.FieldFee)
	}
	if m.addmember_id != nil {
		fields = append(fields, bootcampparticipant.FieldMemberID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BootcampParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bootcampparticipant.FieldDelete:
		return m.AddedDelete()
	case bootcampparticipant.FieldCreatedID:
		return m.AddedCreatedID()
	case bootcampparticipant.FieldStatus:
		return m.AddedStatus()
	case bootcampparticipant.FieldOrderID:
		return m.AddedOrderID()
	case bootcampparticipant.FieldFee:
		return m.AddedFee()
	case bootcampparticipant.FieldMemberID:
		return m.AddedMemberID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BootcampParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bootcampparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case bootcampparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case bootcampparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case bootcampparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case bootcampparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case bootcampparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BootcampParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bootcampparticipant.FieldCreatedAt) {
		fields = append(fields, bootcampparticipant.FieldCreatedAt)
	}
	if m.FieldCleared(bootcampparticipant.FieldUpdatedAt) {
		fields = append(fields, bootcampparticipant.FieldUpdatedAt)
	}
	if m.FieldCleared(bootcampparticipant.FieldDelete) {
		fields = append(fields, bootcampparticipant.FieldDelete)
	}
	if m.FieldCleared(bootcampparticipant.FieldCreatedID) {
		fields = append(fields, bootcampparticipant.FieldCreatedID)
	}
	if m.FieldCleared(bootcampparticipant.FieldStatus) {
		fields = append(fields, bootcampparticipant.FieldStatus)
	}
	if m.FieldCleared(bootcampparticipant.FieldBootcampID) {
		fields = append(fields, bootcampparticipant.FieldBootcampID)
	}
	if m.FieldCleared(bootcampparticipant.FieldName) {
		fields = append(fields, bootcampparticipant.FieldName)
	}
	if m.FieldCleared(bootcampparticipant.FieldMobile) {
		fields = append(fields, bootcampparticipant.FieldMobile)
	}
	if m.FieldCleared(bootcampparticipant.FieldFields) {
		fields = append(fields, bootcampparticipant.FieldFields)
	}
	if m.FieldCleared(bootcampparticipant.FieldOrderID) {
		fields = append(fields, bootcampparticipant.FieldOrderID)
	}
	if m.FieldCleared(bootcampparticipant.FieldOrderSn) {
		fields = append(fields, bootcampparticipant.FieldOrderSn)
	}
	if m.FieldCleared(bootcampparticipant.FieldFee) {
		fields = append(fields, bootcampparticipant.FieldFee)
	}
	if m.FieldCleared(bootcampparticipant.FieldMemberID) {
		fields = append(fields, bootcampparticipant.FieldMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BootcampParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BootcampParticipantMutation) ClearField(name string) error {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case bootcampparticipant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case bootcampparticipant.FieldDelete:
		m.ClearDelete()
		return nil
	case bootcampparticipant.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case bootcampparticipant.FieldStatus:
		m.ClearStatus()
		return nil
	case bootcampparticipant.FieldBootcampID:
		m.ClearBootcampID()
		return nil
	case bootcampparticipant.FieldName:
		m.ClearName()
		return nil
	case bootcampparticipant.FieldMobile:
		m.ClearMobile()
		return nil
	case bootcampparticipant.FieldFields:
		m.ClearFields()
		return nil
	case bootcampparticipant.FieldOrderID:
		m.ClearOrderID()
		return nil
	case bootcampparticipant.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case bootcampparticipant.FieldFee:
		m.ClearFee()
		return nil
	case bootcampparticipant.FieldMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BootcampParticipantMutation) ResetField(name string) error {
	switch name {
	case bootcampparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bootcampparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bootcampparticipant.FieldDelete:
		m.ResetDelete()
		return nil
	case bootcampparticipant.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case bootcampparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case bootcampparticipant.FieldBootcampID:
		m.ResetBootcampID()
		return nil
	case bootcampparticipant.FieldName:
		m.ResetName()
		return nil
	case bootcampparticipant.FieldMobile:
		m.ResetMobile()
		return nil
	case bootcampparticipant.FieldFields:
		m.ResetFields()
		return nil
	case bootcampparticipant.FieldOrderID:
		m.ResetOrderID()
		return nil
	case bootcampparticipant.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case bootcampparticipant.FieldFee:
		m.ResetFee()
		return nil
	case bootcampparticipant.FieldMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BootcampParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bootcamps != nil {
		edges = append(edges, bootcampparticipant.EdgeBootcamps)
	}
	if m.members != nil {
		edges = append(edges, bootcampparticipant.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BootcampParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		if id := m.bootcamps; id != nil {
			return []ent.Value{*id}
		}
	case bootcampparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BootcampParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, bootcampparticipant.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BootcampParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bootcampparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BootcampParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbootcamps {
		edges = append(edges, bootcampparticipant.EdgeBootcamps)
	}
	if m.clearedmembers {
		edges = append(edges, bootcampparticipant.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BootcampParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		return m.clearedbootcamps
	case bootcampparticipant.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BootcampParticipantMutation) ClearEdge(name string) error {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		m.ClearBootcamps()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BootcampParticipantMutation) ResetEdge(name string) error {
	switch name {
	case bootcampparticipant.EdgeBootcamps:
		m.ResetBootcamps()
		return nil
	case bootcampparticipant.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown BootcampParticipant edge %s", name)
}

// ContestMutation represents an operation that mutates the Contest nodes in the graph.
type ContestMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	created_at                  *time.Time
	updated_at                  *time.Time
	delete                      *int64
	adddelete                   *int64
	created_id                  *int64
	addcreated_id               *int64
	status                      *int64
	addstatus                   *int64
	name                        *string
	sign_number                 *int64
	addsign_number              *int64
	sign_start_at               *time.Time
	sign_end_at                 *time.Time
	number                      *int64
	addnumber                   *int64
	start_at                    *time.Time
	end_at                      *time.Time
	pic                         *string
	sponsor                     *string
	fee                         *float64
	addfee                      *float64
	is_fee                      *int64
	addis_fee                   *int64
	is_show                     *int64
	addis_show                  *int64
	is_cancel                   *int64
	addis_cancel                *int64
	cancel_time                 *int64
	addcancel_time              *int64
	detail                      *string
	sign_fields                 *string
	condition                   *int64
	addcondition                *int64
	clearedFields               map[string]struct{}
	contest_participants        map[int64]struct{}
	removedcontest_participants map[int64]struct{}
	clearedcontest_participants bool
	done                        bool
	oldValue                    func(context.Context) (*Contest, error)
	predicates                  []predicate.Contest
}

var _ ent.Mutation = (*ContestMutation)(nil)

// contestOption allows management of the mutation configuration using functional options.
type contestOption func(*ContestMutation)

// newContestMutation creates new mutation for the Contest entity.
func newContestMutation(c config, op Op, opts ...contestOption) *ContestMutation {
	m := &ContestMutation{
		config:        c,
		op:            op,
		typ:           TypeContest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestID sets the ID field of the mutation.
func withContestID(id int64) contestOption {
	return func(m *ContestMutation) {
		var (
			err   error
			once  sync.Once
			value *Contest
		)
		m.oldValue = func(ctx context.Context) (*Contest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContest sets the old Contest of the mutation.
func withContest(node *Contest) contestOption {
	return func(m *ContestMutation) {
		m.oldValue = func(context.Context) (*Contest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contest entities.
func (m *ContestMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContestMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contest.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContestMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContestMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contest.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContestMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contest.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContestMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContestMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contest.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ContestMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ContestMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ContestMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ContestMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ContestMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[contest.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ContestMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[contest.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ContestMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, contest.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ContestMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ContestMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ContestMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ContestMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ContestMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[contest.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ContestMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[contest.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ContestMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, contest.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ContestMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContestMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContestMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContestMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContestMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contest.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContestMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contest.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContestMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contest.FieldStatus)
}

// SetName sets the "name" field.
func (m *ContestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContestMutation) ClearName() {
	m.name = nil
	m.clearedFields[contest.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContestMutation) NameCleared() bool {
	_, ok := m.clearedFields[contest.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContestMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contest.FieldName)
}

// SetSignNumber sets the "sign_number" field.
func (m *ContestMutation) SetSignNumber(i int64) {
	m.sign_number = &i
	m.addsign_number = nil
}

// SignNumber returns the value of the "sign_number" field in the mutation.
func (m *ContestMutation) SignNumber() (r int64, exists bool) {
	v := m.sign_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSignNumber returns the old "sign_number" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignNumber: %w", err)
	}
	return oldValue.SignNumber, nil
}

// AddSignNumber adds i to the "sign_number" field.
func (m *ContestMutation) AddSignNumber(i int64) {
	if m.addsign_number != nil {
		*m.addsign_number += i
	} else {
		m.addsign_number = &i
	}
}

// AddedSignNumber returns the value that was added to the "sign_number" field in this mutation.
func (m *ContestMutation) AddedSignNumber() (r int64, exists bool) {
	v := m.addsign_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearSignNumber clears the value of the "sign_number" field.
func (m *ContestMutation) ClearSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	m.clearedFields[contest.FieldSignNumber] = struct{}{}
}

// SignNumberCleared returns if the "sign_number" field was cleared in this mutation.
func (m *ContestMutation) SignNumberCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignNumber]
	return ok
}

// ResetSignNumber resets all changes to the "sign_number" field.
func (m *ContestMutation) ResetSignNumber() {
	m.sign_number = nil
	m.addsign_number = nil
	delete(m.clearedFields, contest.FieldSignNumber)
}

// SetSignStartAt sets the "sign_start_at" field.
func (m *ContestMutation) SetSignStartAt(t time.Time) {
	m.sign_start_at = &t
}

// SignStartAt returns the value of the "sign_start_at" field in the mutation.
func (m *ContestMutation) SignStartAt() (r time.Time, exists bool) {
	v := m.sign_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartAt returns the old "sign_start_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartAt: %w", err)
	}
	return oldValue.SignStartAt, nil
}

// ClearSignStartAt clears the value of the "sign_start_at" field.
func (m *ContestMutation) ClearSignStartAt() {
	m.sign_start_at = nil
	m.clearedFields[contest.FieldSignStartAt] = struct{}{}
}

// SignStartAtCleared returns if the "sign_start_at" field was cleared in this mutation.
func (m *ContestMutation) SignStartAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignStartAt]
	return ok
}

// ResetSignStartAt resets all changes to the "sign_start_at" field.
func (m *ContestMutation) ResetSignStartAt() {
	m.sign_start_at = nil
	delete(m.clearedFields, contest.FieldSignStartAt)
}

// SetSignEndAt sets the "sign_end_at" field.
func (m *ContestMutation) SetSignEndAt(t time.Time) {
	m.sign_end_at = &t
}

// SignEndAt returns the value of the "sign_end_at" field in the mutation.
func (m *ContestMutation) SignEndAt() (r time.Time, exists bool) {
	v := m.sign_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndAt returns the old "sign_end_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndAt: %w", err)
	}
	return oldValue.SignEndAt, nil
}

// ClearSignEndAt clears the value of the "sign_end_at" field.
func (m *ContestMutation) ClearSignEndAt() {
	m.sign_end_at = nil
	m.clearedFields[contest.FieldSignEndAt] = struct{}{}
}

// SignEndAtCleared returns if the "sign_end_at" field was cleared in this mutation.
func (m *ContestMutation) SignEndAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignEndAt]
	return ok
}

// ResetSignEndAt resets all changes to the "sign_end_at" field.
func (m *ContestMutation) ResetSignEndAt() {
	m.sign_end_at = nil
	delete(m.clearedFields, contest.FieldSignEndAt)
}

// SetNumber sets the "number" field.
func (m *ContestMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *ContestMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *ContestMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *ContestMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *ContestMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[contest.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *ContestMutation) NumberCleared() bool {
	_, ok := m.clearedFields[contest.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *ContestMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, contest.FieldNumber)
}

// SetStartAt sets the "start_at" field.
func (m *ContestMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *ContestMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *ContestMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[contest.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *ContestMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *ContestMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, contest.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *ContestMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *ContestMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *ContestMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[contest.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *ContestMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[contest.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *ContestMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, contest.FieldEndAt)
}

// SetPic sets the "pic" field.
func (m *ContestMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *ContestMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *ContestMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[contest.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *ContestMutation) PicCleared() bool {
	_, ok := m.clearedFields[contest.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *ContestMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, contest.FieldPic)
}

// SetSponsor sets the "sponsor" field.
func (m *ContestMutation) SetSponsor(s string) {
	m.sponsor = &s
}

// Sponsor returns the value of the "sponsor" field in the mutation.
func (m *ContestMutation) Sponsor() (r string, exists bool) {
	v := m.sponsor
	if v == nil {
		return
	}
	return *v, true
}

// OldSponsor returns the old "sponsor" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSponsor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSponsor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSponsor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSponsor: %w", err)
	}
	return oldValue.Sponsor, nil
}

// ClearSponsor clears the value of the "sponsor" field.
func (m *ContestMutation) ClearSponsor() {
	m.sponsor = nil
	m.clearedFields[contest.FieldSponsor] = struct{}{}
}

// SponsorCleared returns if the "sponsor" field was cleared in this mutation.
func (m *ContestMutation) SponsorCleared() bool {
	_, ok := m.clearedFields[contest.FieldSponsor]
	return ok
}

// ResetSponsor resets all changes to the "sponsor" field.
func (m *ContestMutation) ResetSponsor() {
	m.sponsor = nil
	delete(m.clearedFields, contest.FieldSponsor)
}

// SetFee sets the "fee" field.
func (m *ContestMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *ContestMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *ContestMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *ContestMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *ContestMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[contest.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *ContestMutation) FeeCleared() bool {
	_, ok := m.clearedFields[contest.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *ContestMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, contest.FieldFee)
}

// SetIsFee sets the "is_fee" field.
func (m *ContestMutation) SetIsFee(i int64) {
	m.is_fee = &i
	m.addis_fee = nil
}

// IsFee returns the value of the "is_fee" field in the mutation.
func (m *ContestMutation) IsFee() (r int64, exists bool) {
	v := m.is_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFee returns the old "is_fee" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldIsFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFee: %w", err)
	}
	return oldValue.IsFee, nil
}

// AddIsFee adds i to the "is_fee" field.
func (m *ContestMutation) AddIsFee(i int64) {
	if m.addis_fee != nil {
		*m.addis_fee += i
	} else {
		m.addis_fee = &i
	}
}

// AddedIsFee returns the value that was added to the "is_fee" field in this mutation.
func (m *ContestMutation) AddedIsFee() (r int64, exists bool) {
	v := m.addis_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsFee clears the value of the "is_fee" field.
func (m *ContestMutation) ClearIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	m.clearedFields[contest.FieldIsFee] = struct{}{}
}

// IsFeeCleared returns if the "is_fee" field was cleared in this mutation.
func (m *ContestMutation) IsFeeCleared() bool {
	_, ok := m.clearedFields[contest.FieldIsFee]
	return ok
}

// ResetIsFee resets all changes to the "is_fee" field.
func (m *ContestMutation) ResetIsFee() {
	m.is_fee = nil
	m.addis_fee = nil
	delete(m.clearedFields, contest.FieldIsFee)
}

// SetIsShow sets the "is_show" field.
func (m *ContestMutation) SetIsShow(i int64) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *ContestMutation) IsShow() (r int64, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldIsShow(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *ContestMutation) AddIsShow(i int64) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *ContestMutation) AddedIsShow() (r int64, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsShow clears the value of the "is_show" field.
func (m *ContestMutation) ClearIsShow() {
	m.is_show = nil
	m.addis_show = nil
	m.clearedFields[contest.FieldIsShow] = struct{}{}
}

// IsShowCleared returns if the "is_show" field was cleared in this mutation.
func (m *ContestMutation) IsShowCleared() bool {
	_, ok := m.clearedFields[contest.FieldIsShow]
	return ok
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *ContestMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
	delete(m.clearedFields, contest.FieldIsShow)
}

// SetIsCancel sets the "is_cancel" field.
func (m *ContestMutation) SetIsCancel(i int64) {
	m.is_cancel = &i
	m.addis_cancel = nil
}

// IsCancel returns the value of the "is_cancel" field in the mutation.
func (m *ContestMutation) IsCancel() (r int64, exists bool) {
	v := m.is_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCancel returns the old "is_cancel" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldIsCancel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCancel: %w", err)
	}
	return oldValue.IsCancel, nil
}

// AddIsCancel adds i to the "is_cancel" field.
func (m *ContestMutation) AddIsCancel(i int64) {
	if m.addis_cancel != nil {
		*m.addis_cancel += i
	} else {
		m.addis_cancel = &i
	}
}

// AddedIsCancel returns the value that was added to the "is_cancel" field in this mutation.
func (m *ContestMutation) AddedIsCancel() (r int64, exists bool) {
	v := m.addis_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsCancel clears the value of the "is_cancel" field.
func (m *ContestMutation) ClearIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	m.clearedFields[contest.FieldIsCancel] = struct{}{}
}

// IsCancelCleared returns if the "is_cancel" field was cleared in this mutation.
func (m *ContestMutation) IsCancelCleared() bool {
	_, ok := m.clearedFields[contest.FieldIsCancel]
	return ok
}

// ResetIsCancel resets all changes to the "is_cancel" field.
func (m *ContestMutation) ResetIsCancel() {
	m.is_cancel = nil
	m.addis_cancel = nil
	delete(m.clearedFields, contest.FieldIsCancel)
}

// SetCancelTime sets the "cancel_time" field.
func (m *ContestMutation) SetCancelTime(i int64) {
	m.cancel_time = &i
	m.addcancel_time = nil
}

// CancelTime returns the value of the "cancel_time" field in the mutation.
func (m *ContestMutation) CancelTime() (r int64, exists bool) {
	v := m.cancel_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelTime returns the old "cancel_time" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCancelTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelTime: %w", err)
	}
	return oldValue.CancelTime, nil
}

// AddCancelTime adds i to the "cancel_time" field.
func (m *ContestMutation) AddCancelTime(i int64) {
	if m.addcancel_time != nil {
		*m.addcancel_time += i
	} else {
		m.addcancel_time = &i
	}
}

// AddedCancelTime returns the value that was added to the "cancel_time" field in this mutation.
func (m *ContestMutation) AddedCancelTime() (r int64, exists bool) {
	v := m.addcancel_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelTime clears the value of the "cancel_time" field.
func (m *ContestMutation) ClearCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	m.clearedFields[contest.FieldCancelTime] = struct{}{}
}

// CancelTimeCleared returns if the "cancel_time" field was cleared in this mutation.
func (m *ContestMutation) CancelTimeCleared() bool {
	_, ok := m.clearedFields[contest.FieldCancelTime]
	return ok
}

// ResetCancelTime resets all changes to the "cancel_time" field.
func (m *ContestMutation) ResetCancelTime() {
	m.cancel_time = nil
	m.addcancel_time = nil
	delete(m.clearedFields, contest.FieldCancelTime)
}

// SetDetail sets the "detail" field.
func (m *ContestMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ContestMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *ContestMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[contest.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *ContestMutation) DetailCleared() bool {
	_, ok := m.clearedFields[contest.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *ContestMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, contest.FieldDetail)
}

// SetSignFields sets the "sign_fields" field.
func (m *ContestMutation) SetSignFields(s string) {
	m.sign_fields = &s
}

// SignFields returns the value of the "sign_fields" field in the mutation.
func (m *ContestMutation) SignFields() (r string, exists bool) {
	v := m.sign_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldSignFields returns the old "sign_fields" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldSignFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignFields: %w", err)
	}
	return oldValue.SignFields, nil
}

// ClearSignFields clears the value of the "sign_fields" field.
func (m *ContestMutation) ClearSignFields() {
	m.sign_fields = nil
	m.clearedFields[contest.FieldSignFields] = struct{}{}
}

// SignFieldsCleared returns if the "sign_fields" field was cleared in this mutation.
func (m *ContestMutation) SignFieldsCleared() bool {
	_, ok := m.clearedFields[contest.FieldSignFields]
	return ok
}

// ResetSignFields resets all changes to the "sign_fields" field.
func (m *ContestMutation) ResetSignFields() {
	m.sign_fields = nil
	delete(m.clearedFields, contest.FieldSignFields)
}

// SetCondition sets the "condition" field.
func (m *ContestMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *ContestMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *ContestMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *ContestMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *ContestMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[contest.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *ContestMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[contest.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *ContestMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, contest.FieldCondition)
}

// AddContestParticipantIDs adds the "contest_participants" edge to the ContestParticipant entity by ids.
func (m *ContestMutation) AddContestParticipantIDs(ids ...int64) {
	if m.contest_participants == nil {
		m.contest_participants = make(map[int64]struct{})
	}
	for i := range ids {
		m.contest_participants[ids[i]] = struct{}{}
	}
}

// ClearContestParticipants clears the "contest_participants" edge to the ContestParticipant entity.
func (m *ContestMutation) ClearContestParticipants() {
	m.clearedcontest_participants = true
}

// ContestParticipantsCleared reports if the "contest_participants" edge to the ContestParticipant entity was cleared.
func (m *ContestMutation) ContestParticipantsCleared() bool {
	return m.clearedcontest_participants
}

// RemoveContestParticipantIDs removes the "contest_participants" edge to the ContestParticipant entity by IDs.
func (m *ContestMutation) RemoveContestParticipantIDs(ids ...int64) {
	if m.removedcontest_participants == nil {
		m.removedcontest_participants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.contest_participants, ids[i])
		m.removedcontest_participants[ids[i]] = struct{}{}
	}
}

// RemovedContestParticipants returns the removed IDs of the "contest_participants" edge to the ContestParticipant entity.
func (m *ContestMutation) RemovedContestParticipantsIDs() (ids []int64) {
	for id := range m.removedcontest_participants {
		ids = append(ids, id)
	}
	return
}

// ContestParticipantsIDs returns the "contest_participants" edge IDs in the mutation.
func (m *ContestMutation) ContestParticipantsIDs() (ids []int64) {
	for id := range m.contest_participants {
		ids = append(ids, id)
	}
	return
}

// ResetContestParticipants resets all changes to the "contest_participants" edge.
func (m *ContestMutation) ResetContestParticipants() {
	m.contest_participants = nil
	m.clearedcontest_participants = false
	m.removedcontest_participants = nil
}

// Where appends a list predicates to the ContestMutation builder.
func (m *ContestMutation) Where(ps ...predicate.Contest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contest).
func (m *ContestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, contest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contest.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, contest.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, contest.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, contest.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, contest.FieldName)
	}
	if m.sign_number != nil {
		fields = append(fields, contest.FieldSignNumber)
	}
	if m.sign_start_at != nil {
		fields = append(fields, contest.FieldSignStartAt)
	}
	if m.sign_end_at != nil {
		fields = append(fields, contest.FieldSignEndAt)
	}
	if m.number != nil {
		fields = append(fields, contest.FieldNumber)
	}
	if m.start_at != nil {
		fields = append(fields, contest.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, contest.FieldEndAt)
	}
	if m.pic != nil {
		fields = append(fields, contest.FieldPic)
	}
	if m.sponsor != nil {
		fields = append(fields, contest.FieldSponsor)
	}
	if m.fee != nil {
		fields = append(fields, contest.FieldFee)
	}
	if m.is_fee != nil {
		fields = append(fields, contest.FieldIsFee)
	}
	if m.is_show != nil {
		fields = append(fields, contest.FieldIsShow)
	}
	if m.is_cancel != nil {
		fields = append(fields, contest.FieldIsCancel)
	}
	if m.cancel_time != nil {
		fields = append(fields, contest.FieldCancelTime)
	}
	if m.detail != nil {
		fields = append(fields, contest.FieldDetail)
	}
	if m.sign_fields != nil {
		fields = append(fields, contest.FieldSignFields)
	}
	if m.condition != nil {
		fields = append(fields, contest.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldCreatedAt:
		return m.CreatedAt()
	case contest.FieldUpdatedAt:
		return m.UpdatedAt()
	case contest.FieldDelete:
		return m.Delete()
	case contest.FieldCreatedID:
		return m.CreatedID()
	case contest.FieldStatus:
		return m.Status()
	case contest.FieldName:
		return m.Name()
	case contest.FieldSignNumber:
		return m.SignNumber()
	case contest.FieldSignStartAt:
		return m.SignStartAt()
	case contest.FieldSignEndAt:
		return m.SignEndAt()
	case contest.FieldNumber:
		return m.Number()
	case contest.FieldStartAt:
		return m.StartAt()
	case contest.FieldEndAt:
		return m.EndAt()
	case contest.FieldPic:
		return m.Pic()
	case contest.FieldSponsor:
		return m.Sponsor()
	case contest.FieldFee:
		return m.Fee()
	case contest.FieldIsFee:
		return m.IsFee()
	case contest.FieldIsShow:
		return m.IsShow()
	case contest.FieldIsCancel:
		return m.IsCancel()
	case contest.FieldCancelTime:
		return m.CancelTime()
	case contest.FieldDetail:
		return m.Detail()
	case contest.FieldSignFields:
		return m.SignFields()
	case contest.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contest.FieldDelete:
		return m.OldDelete(ctx)
	case contest.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case contest.FieldStatus:
		return m.OldStatus(ctx)
	case contest.FieldName:
		return m.OldName(ctx)
	case contest.FieldSignNumber:
		return m.OldSignNumber(ctx)
	case contest.FieldSignStartAt:
		return m.OldSignStartAt(ctx)
	case contest.FieldSignEndAt:
		return m.OldSignEndAt(ctx)
	case contest.FieldNumber:
		return m.OldNumber(ctx)
	case contest.FieldStartAt:
		return m.OldStartAt(ctx)
	case contest.FieldEndAt:
		return m.OldEndAt(ctx)
	case contest.FieldPic:
		return m.OldPic(ctx)
	case contest.FieldSponsor:
		return m.OldSponsor(ctx)
	case contest.FieldFee:
		return m.OldFee(ctx)
	case contest.FieldIsFee:
		return m.OldIsFee(ctx)
	case contest.FieldIsShow:
		return m.OldIsShow(ctx)
	case contest.FieldIsCancel:
		return m.OldIsCancel(ctx)
	case contest.FieldCancelTime:
		return m.OldCancelTime(ctx)
	case contest.FieldDetail:
		return m.OldDetail(ctx)
	case contest.FieldSignFields:
		return m.OldSignFields(ctx)
	case contest.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Contest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contest.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case contest.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case contest.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contest.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignNumber(v)
		return nil
	case contest.FieldSignStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartAt(v)
		return nil
	case contest.FieldSignEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndAt(v)
		return nil
	case contest.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case contest.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case contest.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case contest.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case contest.FieldSponsor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSponsor(v)
		return nil
	case contest.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case contest.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFee(v)
		return nil
	case contest.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case contest.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCancel(v)
		return nil
	case contest.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelTime(v)
		return nil
	case contest.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case contest.FieldSignFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignFields(v)
		return nil
	case contest.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, contest.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, contest.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, contest.FieldStatus)
	}
	if m.addsign_number != nil {
		fields = append(fields, contest.FieldSignNumber)
	}
	if m.addnumber != nil {
		fields = append(fields, contest.FieldNumber)
	}
	if m.addfee != nil {
		fields = append(fields, contest.FieldFee)
	}
	if m.addis_fee != nil {
		fields = append(fields, contest.FieldIsFee)
	}
	if m.addis_show != nil {
		fields = append(fields, contest.FieldIsShow)
	}
	if m.addis_cancel != nil {
		fields = append(fields, contest.FieldIsCancel)
	}
	if m.addcancel_time != nil {
		fields = append(fields, contest.FieldCancelTime)
	}
	if m.addcondition != nil {
		fields = append(fields, contest.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldDelete:
		return m.AddedDelete()
	case contest.FieldCreatedID:
		return m.AddedCreatedID()
	case contest.FieldStatus:
		return m.AddedStatus()
	case contest.FieldSignNumber:
		return m.AddedSignNumber()
	case contest.FieldNumber:
		return m.AddedNumber()
	case contest.FieldFee:
		return m.AddedFee()
	case contest.FieldIsFee:
		return m.AddedIsFee()
	case contest.FieldIsShow:
		return m.AddedIsShow()
	case contest.FieldIsCancel:
		return m.AddedIsCancel()
	case contest.FieldCancelTime:
		return m.AddedCancelTime()
	case contest.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contest.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case contest.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case contest.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case contest.FieldSignNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignNumber(v)
		return nil
	case contest.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case contest.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case contest.FieldIsFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFee(v)
		return nil
	case contest.FieldIsShow:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	case contest.FieldIsCancel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCancel(v)
		return nil
	case contest.FieldCancelTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelTime(v)
		return nil
	case contest.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Contest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contest.FieldCreatedAt) {
		fields = append(fields, contest.FieldCreatedAt)
	}
	if m.FieldCleared(contest.FieldUpdatedAt) {
		fields = append(fields, contest.FieldUpdatedAt)
	}
	if m.FieldCleared(contest.FieldDelete) {
		fields = append(fields, contest.FieldDelete)
	}
	if m.FieldCleared(contest.FieldCreatedID) {
		fields = append(fields, contest.FieldCreatedID)
	}
	if m.FieldCleared(contest.FieldStatus) {
		fields = append(fields, contest.FieldStatus)
	}
	if m.FieldCleared(contest.FieldName) {
		fields = append(fields, contest.FieldName)
	}
	if m.FieldCleared(contest.FieldSignNumber) {
		fields = append(fields, contest.FieldSignNumber)
	}
	if m.FieldCleared(contest.FieldSignStartAt) {
		fields = append(fields, contest.FieldSignStartAt)
	}
	if m.FieldCleared(contest.FieldSignEndAt) {
		fields = append(fields, contest.FieldSignEndAt)
	}
	if m.FieldCleared(contest.FieldNumber) {
		fields = append(fields, contest.FieldNumber)
	}
	if m.FieldCleared(contest.FieldStartAt) {
		fields = append(fields, contest.FieldStartAt)
	}
	if m.FieldCleared(contest.FieldEndAt) {
		fields = append(fields, contest.FieldEndAt)
	}
	if m.FieldCleared(contest.FieldPic) {
		fields = append(fields, contest.FieldPic)
	}
	if m.FieldCleared(contest.FieldSponsor) {
		fields = append(fields, contest.FieldSponsor)
	}
	if m.FieldCleared(contest.FieldFee) {
		fields = append(fields, contest.FieldFee)
	}
	if m.FieldCleared(contest.FieldIsFee) {
		fields = append(fields, contest.FieldIsFee)
	}
	if m.FieldCleared(contest.FieldIsShow) {
		fields = append(fields, contest.FieldIsShow)
	}
	if m.FieldCleared(contest.FieldIsCancel) {
		fields = append(fields, contest.FieldIsCancel)
	}
	if m.FieldCleared(contest.FieldCancelTime) {
		fields = append(fields, contest.FieldCancelTime)
	}
	if m.FieldCleared(contest.FieldDetail) {
		fields = append(fields, contest.FieldDetail)
	}
	if m.FieldCleared(contest.FieldSignFields) {
		fields = append(fields, contest.FieldSignFields)
	}
	if m.FieldCleared(contest.FieldCondition) {
		fields = append(fields, contest.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestMutation) ClearField(name string) error {
	switch name {
	case contest.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contest.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contest.FieldDelete:
		m.ClearDelete()
		return nil
	case contest.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case contest.FieldStatus:
		m.ClearStatus()
		return nil
	case contest.FieldName:
		m.ClearName()
		return nil
	case contest.FieldSignNumber:
		m.ClearSignNumber()
		return nil
	case contest.FieldSignStartAt:
		m.ClearSignStartAt()
		return nil
	case contest.FieldSignEndAt:
		m.ClearSignEndAt()
		return nil
	case contest.FieldNumber:
		m.ClearNumber()
		return nil
	case contest.FieldStartAt:
		m.ClearStartAt()
		return nil
	case contest.FieldEndAt:
		m.ClearEndAt()
		return nil
	case contest.FieldPic:
		m.ClearPic()
		return nil
	case contest.FieldSponsor:
		m.ClearSponsor()
		return nil
	case contest.FieldFee:
		m.ClearFee()
		return nil
	case contest.FieldIsFee:
		m.ClearIsFee()
		return nil
	case contest.FieldIsShow:
		m.ClearIsShow()
		return nil
	case contest.FieldIsCancel:
		m.ClearIsCancel()
		return nil
	case contest.FieldCancelTime:
		m.ClearCancelTime()
		return nil
	case contest.FieldDetail:
		m.ClearDetail()
		return nil
	case contest.FieldSignFields:
		m.ClearSignFields()
		return nil
	case contest.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Contest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestMutation) ResetField(name string) error {
	switch name {
	case contest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contest.FieldDelete:
		m.ResetDelete()
		return nil
	case contest.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case contest.FieldStatus:
		m.ResetStatus()
		return nil
	case contest.FieldName:
		m.ResetName()
		return nil
	case contest.FieldSignNumber:
		m.ResetSignNumber()
		return nil
	case contest.FieldSignStartAt:
		m.ResetSignStartAt()
		return nil
	case contest.FieldSignEndAt:
		m.ResetSignEndAt()
		return nil
	case contest.FieldNumber:
		m.ResetNumber()
		return nil
	case contest.FieldStartAt:
		m.ResetStartAt()
		return nil
	case contest.FieldEndAt:
		m.ResetEndAt()
		return nil
	case contest.FieldPic:
		m.ResetPic()
		return nil
	case contest.FieldSponsor:
		m.ResetSponsor()
		return nil
	case contest.FieldFee:
		m.ResetFee()
		return nil
	case contest.FieldIsFee:
		m.ResetIsFee()
		return nil
	case contest.FieldIsShow:
		m.ResetIsShow()
		return nil
	case contest.FieldIsCancel:
		m.ResetIsCancel()
		return nil
	case contest.FieldCancelTime:
		m.ResetCancelTime()
		return nil
	case contest.FieldDetail:
		m.ResetDetail()
		return nil
	case contest.FieldSignFields:
		m.ResetSignFields()
		return nil
	case contest.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contest_participants != nil {
		edges = append(edges, contest.EdgeContestParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgeContestParticipants:
		ids := make([]ent.Value, 0, len(m.contest_participants))
		for id := range m.contest_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcontest_participants != nil {
		edges = append(edges, contest.EdgeContestParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgeContestParticipants:
		ids := make([]ent.Value, 0, len(m.removedcontest_participants))
		for id := range m.removedcontest_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontest_participants {
		edges = append(edges, contest.EdgeContestParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestMutation) EdgeCleared(name string) bool {
	switch name {
	case contest.EdgeContestParticipants:
		return m.clearedcontest_participants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Contest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestMutation) ResetEdge(name string) error {
	switch name {
	case contest.EdgeContestParticipants:
		m.ResetContestParticipants()
		return nil
	}
	return fmt.Errorf("unknown Contest edge %s", name)
}

// ContestParticipantMutation represents an operation that mutates the ContestParticipant nodes in the graph.
type ContestParticipantMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	name           *string
	mobile         *string
	fields         *string
	order_id       *int64
	addorder_id    *int64
	order_sn       *string
	fee            *float64
	addfee         *float64
	member_id      *int64
	addmember_id   *int64
	clearedFields  map[string]struct{}
	contest        *int64
	clearedcontest bool
	members        map[int64]struct{}
	removedmembers map[int64]struct{}
	clearedmembers bool
	done           bool
	oldValue       func(context.Context) (*ContestParticipant, error)
	predicates     []predicate.ContestParticipant
}

var _ ent.Mutation = (*ContestParticipantMutation)(nil)

// contestparticipantOption allows management of the mutation configuration using functional options.
type contestparticipantOption func(*ContestParticipantMutation)

// newContestParticipantMutation creates new mutation for the ContestParticipant entity.
func newContestParticipantMutation(c config, op Op, opts ...contestparticipantOption) *ContestParticipantMutation {
	m := &ContestParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeContestParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestParticipantID sets the ID field of the mutation.
func withContestParticipantID(id int64) contestparticipantOption {
	return func(m *ContestParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *ContestParticipant
		)
		m.oldValue = func(ctx context.Context) (*ContestParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContestParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContestParticipant sets the old ContestParticipant of the mutation.
func withContestParticipant(node *ContestParticipant) contestparticipantOption {
	return func(m *ContestParticipantMutation) {
		m.oldValue = func(context.Context) (*ContestParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContestParticipant entities.
func (m *ContestParticipantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestParticipantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestParticipantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContestParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContestParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContestParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContestParticipantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contestparticipant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContestParticipantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContestParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contestparticipant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContestParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContestParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContestParticipantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contestparticipant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContestParticipantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContestParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contestparticipant.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ContestParticipantMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ContestParticipantMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ContestParticipantMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ContestParticipantMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ContestParticipantMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[contestparticipant.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ContestParticipantMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ContestParticipantMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, contestparticipant.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ContestParticipantMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ContestParticipantMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ContestParticipantMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ContestParticipantMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ContestParticipantMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[contestparticipant.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ContestParticipantMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, contestparticipant.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ContestParticipantMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContestParticipantMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContestParticipantMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContestParticipantMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContestParticipantMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contestparticipant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContestParticipantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContestParticipantMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contestparticipant.FieldStatus)
}

// SetContestID sets the "contest_id" field.
func (m *ContestParticipantMutation) SetContestID(i int64) {
	m.contest = &i
}

// ContestID returns the value of the "contest_id" field in the mutation.
func (m *ContestParticipantMutation) ContestID() (r int64, exists bool) {
	v := m.contest
	if v == nil {
		return
	}
	return *v, true
}

// OldContestID returns the old "contest_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldContestID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContestID: %w", err)
	}
	return oldValue.ContestID, nil
}

// ClearContestID clears the value of the "contest_id" field.
func (m *ContestParticipantMutation) ClearContestID() {
	m.contest = nil
	m.clearedFields[contestparticipant.FieldContestID] = struct{}{}
}

// ContestIDCleared returns if the "contest_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) ContestIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldContestID]
	return ok
}

// ResetContestID resets all changes to the "contest_id" field.
func (m *ContestParticipantMutation) ResetContestID() {
	m.contest = nil
	delete(m.clearedFields, contestparticipant.FieldContestID)
}

// SetName sets the "name" field.
func (m *ContestParticipantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContestParticipantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContestParticipantMutation) ClearName() {
	m.name = nil
	m.clearedFields[contestparticipant.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContestParticipantMutation) NameCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContestParticipantMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contestparticipant.FieldName)
}

// SetMobile sets the "mobile" field.
func (m *ContestParticipantMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *ContestParticipantMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *ContestParticipantMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[contestparticipant.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *ContestParticipantMutation) MobileCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *ContestParticipantMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, contestparticipant.FieldMobile)
}

// SetFields sets the "fields" field.
func (m *ContestParticipantMutation) SetFields(s string) {
	m.fields = &s
}

// GetFields returns the value of the "fields" field in the mutation.
func (m *ContestParticipantMutation) GetFields() (r string, exists bool) {
	v := m.fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFields returns the old "fields" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldFields(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFields: %w", err)
	}
	return oldValue.Fields, nil
}

// ClearFields clears the value of the "fields" field.
func (m *ContestParticipantMutation) ClearFields() {
	m.fields = nil
	m.clearedFields[contestparticipant.FieldFields] = struct{}{}
}

// FieldsCleared returns if the "fields" field was cleared in this mutation.
func (m *ContestParticipantMutation) FieldsCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldFields]
	return ok
}

// ResetFields resets all changes to the "fields" field.
func (m *ContestParticipantMutation) ResetFields() {
	m.fields = nil
	delete(m.clearedFields, contestparticipant.FieldFields)
}

// SetOrderID sets the "order_id" field.
func (m *ContestParticipantMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *ContestParticipantMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *ContestParticipantMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *ContestParticipantMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *ContestParticipantMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[contestparticipant.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *ContestParticipantMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, contestparticipant.FieldOrderID)
}

// SetOrderSn sets the "order_sn" field.
func (m *ContestParticipantMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *ContestParticipantMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *ContestParticipantMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[contestparticipant.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *ContestParticipantMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *ContestParticipantMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, contestparticipant.FieldOrderSn)
}

// SetFee sets the "fee" field.
func (m *ContestParticipantMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *ContestParticipantMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *ContestParticipantMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *ContestParticipantMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *ContestParticipantMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[contestparticipant.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *ContestParticipantMutation) FeeCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *ContestParticipantMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, contestparticipant.FieldFee)
}

// SetMemberID sets the "member_id" field.
func (m *ContestParticipantMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *ContestParticipantMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the ContestParticipant entity.
// If the ContestParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestParticipantMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *ContestParticipantMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *ContestParticipantMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *ContestParticipantMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[contestparticipant.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *ContestParticipantMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[contestparticipant.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *ContestParticipantMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, contestparticipant.FieldMemberID)
}

// ClearContest clears the "contest" edge to the Contest entity.
func (m *ContestParticipantMutation) ClearContest() {
	m.clearedcontest = true
	m.clearedFields[contestparticipant.FieldContestID] = struct{}{}
}

// ContestCleared reports if the "contest" edge to the Contest entity was cleared.
func (m *ContestParticipantMutation) ContestCleared() bool {
	return m.ContestIDCleared() || m.clearedcontest
}

// ContestIDs returns the "contest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContestID instead. It exists only for internal usage by the builders.
func (m *ContestParticipantMutation) ContestIDs() (ids []int64) {
	if id := m.contest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContest resets all changes to the "contest" edge.
func (m *ContestParticipantMutation) ResetContest() {
	m.contest = nil
	m.clearedcontest = false
}

// AddMemberIDs adds the "members" edge to the Member entity by ids.
func (m *ContestParticipantMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *ContestParticipantMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *ContestParticipantMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Member entity by IDs.
func (m *ContestParticipantMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Member entity.
func (m *ContestParticipantMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ContestParticipantMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ContestParticipantMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the ContestParticipantMutation builder.
func (m *ContestParticipantMutation) Where(ps ...predicate.ContestParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContestParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContestParticipant).
func (m *ContestParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestParticipantMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, contestparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contestparticipant.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, contestparticipant.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, contestparticipant.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, contestparticipant.FieldStatus)
	}
	if m.contest != nil {
		fields = append(fields, contestparticipant.FieldContestID)
	}
	if m.name != nil {
		fields = append(fields, contestparticipant.FieldName)
	}
	if m.mobile != nil {
		fields = append(fields, contestparticipant.FieldMobile)
	}
	if m.fields != nil {
		fields = append(fields, contestparticipant.FieldFields)
	}
	if m.order_id != nil {
		fields = append(fields, contestparticipant.FieldOrderID)
	}
	if m.order_sn != nil {
		fields = append(fields, contestparticipant.FieldOrderSn)
	}
	if m.fee != nil {
		fields = append(fields, contestparticipant.FieldFee)
	}
	if m.member_id != nil {
		fields = append(fields, contestparticipant.FieldMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contestparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case contestparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	case contestparticipant.FieldDelete:
		return m.Delete()
	case contestparticipant.FieldCreatedID:
		return m.CreatedID()
	case contestparticipant.FieldStatus:
		return m.Status()
	case contestparticipant.FieldContestID:
		return m.ContestID()
	case contestparticipant.FieldName:
		return m.Name()
	case contestparticipant.FieldMobile:
		return m.Mobile()
	case contestparticipant.FieldFields:
		return m.GetFields()
	case contestparticipant.FieldOrderID:
		return m.OrderID()
	case contestparticipant.FieldOrderSn:
		return m.OrderSn()
	case contestparticipant.FieldFee:
		return m.Fee()
	case contestparticipant.FieldMemberID:
		return m.MemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contestparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contestparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contestparticipant.FieldDelete:
		return m.OldDelete(ctx)
	case contestparticipant.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case contestparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case contestparticipant.FieldContestID:
		return m.OldContestID(ctx)
	case contestparticipant.FieldName:
		return m.OldName(ctx)
	case contestparticipant.FieldMobile:
		return m.OldMobile(ctx)
	case contestparticipant.FieldFields:
		return m.OldFields(ctx)
	case contestparticipant.FieldOrderID:
		return m.OldOrderID(ctx)
	case contestparticipant.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case contestparticipant.FieldFee:
		return m.OldFee(ctx)
	case contestparticipant.FieldMemberID:
		return m.OldMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown ContestParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contestparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contestparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contestparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case contestparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case contestparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contestparticipant.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContestID(v)
		return nil
	case contestparticipant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contestparticipant.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case contestparticipant.FieldFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFields(v)
		return nil
	case contestparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case contestparticipant.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case contestparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case contestparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestParticipantMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, contestparticipant.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, contestparticipant.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, contestparticipant.FieldStatus)
	}
	if m.addorder_id != nil {
		fields = append(fields, contestparticipant.FieldOrderID)
	}
	if m.addfee != nil {
		fields = append(fields, contestparticipant.FieldFee)
	}
	if m.addmember_id != nil {
		fields = append(fields, contestparticipant.FieldMemberID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contestparticipant.FieldDelete:
		return m.AddedDelete()
	case contestparticipant.FieldCreatedID:
		return m.AddedCreatedID()
	case contestparticipant.FieldStatus:
		return m.AddedStatus()
	case contestparticipant.FieldOrderID:
		return m.AddedOrderID()
	case contestparticipant.FieldFee:
		return m.AddedFee()
	case contestparticipant.FieldMemberID:
		return m.AddedMemberID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contestparticipant.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case contestparticipant.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case contestparticipant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case contestparticipant.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case contestparticipant.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case contestparticipant.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contestparticipant.FieldCreatedAt) {
		fields = append(fields, contestparticipant.FieldCreatedAt)
	}
	if m.FieldCleared(contestparticipant.FieldUpdatedAt) {
		fields = append(fields, contestparticipant.FieldUpdatedAt)
	}
	if m.FieldCleared(contestparticipant.FieldDelete) {
		fields = append(fields, contestparticipant.FieldDelete)
	}
	if m.FieldCleared(contestparticipant.FieldCreatedID) {
		fields = append(fields, contestparticipant.FieldCreatedID)
	}
	if m.FieldCleared(contestparticipant.FieldStatus) {
		fields = append(fields, contestparticipant.FieldStatus)
	}
	if m.FieldCleared(contestparticipant.FieldContestID) {
		fields = append(fields, contestparticipant.FieldContestID)
	}
	if m.FieldCleared(contestparticipant.FieldName) {
		fields = append(fields, contestparticipant.FieldName)
	}
	if m.FieldCleared(contestparticipant.FieldMobile) {
		fields = append(fields, contestparticipant.FieldMobile)
	}
	if m.FieldCleared(contestparticipant.FieldFields) {
		fields = append(fields, contestparticipant.FieldFields)
	}
	if m.FieldCleared(contestparticipant.FieldOrderID) {
		fields = append(fields, contestparticipant.FieldOrderID)
	}
	if m.FieldCleared(contestparticipant.FieldOrderSn) {
		fields = append(fields, contestparticipant.FieldOrderSn)
	}
	if m.FieldCleared(contestparticipant.FieldFee) {
		fields = append(fields, contestparticipant.FieldFee)
	}
	if m.FieldCleared(contestparticipant.FieldMemberID) {
		fields = append(fields, contestparticipant.FieldMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestParticipantMutation) ClearField(name string) error {
	switch name {
	case contestparticipant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contestparticipant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contestparticipant.FieldDelete:
		m.ClearDelete()
		return nil
	case contestparticipant.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case contestparticipant.FieldStatus:
		m.ClearStatus()
		return nil
	case contestparticipant.FieldContestID:
		m.ClearContestID()
		return nil
	case contestparticipant.FieldName:
		m.ClearName()
		return nil
	case contestparticipant.FieldMobile:
		m.ClearMobile()
		return nil
	case contestparticipant.FieldFields:
		m.ClearFields()
		return nil
	case contestparticipant.FieldOrderID:
		m.ClearOrderID()
		return nil
	case contestparticipant.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case contestparticipant.FieldFee:
		m.ClearFee()
		return nil
	case contestparticipant.FieldMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestParticipantMutation) ResetField(name string) error {
	switch name {
	case contestparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contestparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contestparticipant.FieldDelete:
		m.ResetDelete()
		return nil
	case contestparticipant.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case contestparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case contestparticipant.FieldContestID:
		m.ResetContestID()
		return nil
	case contestparticipant.FieldName:
		m.ResetName()
		return nil
	case contestparticipant.FieldMobile:
		m.ResetMobile()
		return nil
	case contestparticipant.FieldFields:
		m.ResetFields()
		return nil
	case contestparticipant.FieldOrderID:
		m.ResetOrderID()
		return nil
	case contestparticipant.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case contestparticipant.FieldFee:
		m.ResetFee()
		return nil
	case contestparticipant.FieldMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.contest != nil {
		edges = append(edges, contestparticipant.EdgeContest)
	}
	if m.members != nil {
		edges = append(edges, contestparticipant.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contestparticipant.EdgeContest:
		if id := m.contest; id != nil {
			return []ent.Value{*id}
		}
	case contestparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, contestparticipant.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contestparticipant.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontest {
		edges = append(edges, contestparticipant.EdgeContest)
	}
	if m.clearedmembers {
		edges = append(edges, contestparticipant.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case contestparticipant.EdgeContest:
		return m.clearedcontest
	case contestparticipant.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestParticipantMutation) ClearEdge(name string) error {
	switch name {
	case contestparticipant.EdgeContest:
		m.ClearContest()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestParticipantMutation) ResetEdge(name string) error {
	switch name {
	case contestparticipant.EdgeContest:
		m.ResetContest()
		return nil
	case contestparticipant.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown ContestParticipant edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	name          *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Contract, error)
	predicates    []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id int64) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contract entities.
func (m *ContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContractMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contract.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContractMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contract.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContractMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contract.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContractMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contract.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *ContractMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *ContractMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *ContractMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *ContractMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *ContractMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[contract.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *ContractMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[contract.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *ContractMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, contract.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *ContractMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *ContractMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *ContractMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *ContractMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *ContractMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[contract.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *ContractMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[contract.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *ContractMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, contract.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *ContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contract.FieldStatus)
}

// SetName sets the "name" field.
func (m *ContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[contract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[contract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contract.FieldName)
}

// SetContent sets the "content" field.
func (m *ContractMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ContractMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ContractMutation) ClearContent() {
	m.content = nil
	m.clearedFields[contract.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ContractMutation) ContentCleared() bool {
	_, ok := m.clearedFields[contract.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ContractMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, contract.FieldContent)
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, contract.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, contract.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, contract.FieldName)
	}
	if m.content != nil {
		fields = append(fields, contract.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldDelete:
		return m.Delete()
	case contract.FieldCreatedID:
		return m.CreatedID()
	case contract.FieldStatus:
		return m.Status()
	case contract.FieldName:
		return m.Name()
	case contract.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldDelete:
		return m.OldDelete(ctx)
	case contract.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case contract.FieldStatus:
		return m.OldStatus(ctx)
	case contract.FieldName:
		return m.OldName(ctx)
	case contract.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case contract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contract.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, contract.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, contract.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, contract.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldDelete:
		return m.AddedDelete()
	case contract.FieldCreatedID:
		return m.AddedCreatedID()
	case contract.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case contract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldCreatedAt) {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.FieldCleared(contract.FieldUpdatedAt) {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.FieldCleared(contract.FieldDelete) {
		fields = append(fields, contract.FieldDelete)
	}
	if m.FieldCleared(contract.FieldCreatedID) {
		fields = append(fields, contract.FieldCreatedID)
	}
	if m.FieldCleared(contract.FieldStatus) {
		fields = append(fields, contract.FieldStatus)
	}
	if m.FieldCleared(contract.FieldName) {
		fields = append(fields, contract.FieldName)
	}
	if m.FieldCleared(contract.FieldContent) {
		fields = append(fields, contract.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contract.FieldDelete:
		m.ClearDelete()
		return nil
	case contract.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case contract.FieldStatus:
		m.ClearStatus()
		return nil
	case contract.FieldName:
		m.ClearName()
		return nil
	case contract.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldDelete:
		m.ResetDelete()
		return nil
	case contract.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case contract.FieldStatus:
		m.ResetStatus()
		return nil
	case contract.FieldName:
		m.ResetName()
		return nil
	case contract.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Contract edge %s", name)
}

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	created_at                *time.Time
	updated_at                *time.Time
	delete                    *int64
	adddelete                 *int64
	created_id                *int64
	addcreated_id             *int64
	status                    *int64
	addstatus                 *int64
	title                     *string
	name                      *string
	description               *string
	clearedFields             map[string]struct{}
	dictionary_details        map[int64]struct{}
	removeddictionary_details map[int64]struct{}
	cleareddictionary_details bool
	done                      bool
	oldValue                  func(context.Context) (*Dictionary, error)
	predicates                []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id int64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictionaryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictionary.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictionaryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictionary.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictionaryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictionary.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictionaryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictionary.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DictionaryMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DictionaryMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DictionaryMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DictionaryMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DictionaryMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dictionary.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DictionaryMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DictionaryMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dictionary.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DictionaryMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DictionaryMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DictionaryMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DictionaryMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DictionaryMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dictionary.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DictionaryMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DictionaryMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dictionary.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DictionaryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictionaryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DictionaryMutation) ResetDescription() {
	m.description = nil
}

// AddDictionaryDetailIDs adds the "dictionary_details" edge to the DictionaryDetail entity by ids.
func (m *DictionaryMutation) AddDictionaryDetailIDs(ids ...int64) {
	if m.dictionary_details == nil {
		m.dictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.dictionary_details[ids[i]] = struct{}{}
	}
}

// ClearDictionaryDetails clears the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) ClearDictionaryDetails() {
	m.cleareddictionary_details = true
}

// DictionaryDetailsCleared reports if the "dictionary_details" edge to the DictionaryDetail entity was cleared.
func (m *DictionaryMutation) DictionaryDetailsCleared() bool {
	return m.cleareddictionary_details
}

// RemoveDictionaryDetailIDs removes the "dictionary_details" edge to the DictionaryDetail entity by IDs.
func (m *DictionaryMutation) RemoveDictionaryDetailIDs(ids ...int64) {
	if m.removeddictionary_details == nil {
		m.removeddictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.dictionary_details, ids[i])
		m.removeddictionary_details[ids[i]] = struct{}{}
	}
}

// RemovedDictionaryDetails returns the removed IDs of the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) RemovedDictionaryDetailsIDs() (ids []int64) {
	for id := range m.removeddictionary_details {
		ids = append(ids, id)
	}
	return
}

// DictionaryDetailsIDs returns the "dictionary_details" edge IDs in the mutation.
func (m *DictionaryMutation) DictionaryDetailsIDs() (ids []int64) {
	for id := range m.dictionary_details {
		ids = append(ids, id)
	}
	return
}

// ResetDictionaryDetails resets all changes to the "dictionary_details" edge.
func (m *DictionaryMutation) ResetDictionaryDetails() {
	m.dictionary_details = nil
	m.cleareddictionary_details = false
	m.removeddictionary_details = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionary.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dictionary.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldDelete:
		return m.Delete()
	case dictionary.FieldCreatedID:
		return m.CreatedID()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldTitle:
		return m.Title()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldDelete:
		return m.OldDelete(ctx)
	case dictionary.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldTitle:
		return m.OldTitle(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dictionary.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldDelete:
		return m.AddedDelete()
	case dictionary.FieldCreatedID:
		return m.AddedCreatedID()
	case dictionary.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dictionary.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldCreatedAt) {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.FieldCleared(dictionary.FieldUpdatedAt) {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.FieldCleared(dictionary.FieldDelete) {
		fields = append(fields, dictionary.FieldDelete)
	}
	if m.FieldCleared(dictionary.FieldCreatedID) {
		fields = append(fields, dictionary.FieldCreatedID)
	}
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictionary.FieldDelete:
		m.ClearDelete()
		return nil
	case dictionary.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldDelete:
		m.ResetDelete()
		return nil
	case dictionary.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.dictionary_details))
		for id := range m.dictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.removeddictionary_details))
		for id := range m.removeddictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary_details {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		return m.cleareddictionary_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		m.ResetDictionaryDetails()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryDetailMutation represents an operation that mutates the DictionaryDetail nodes in the graph.
type DictionaryDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	delete            *int64
	adddelete         *int64
	created_id        *int64
	addcreated_id     *int64
	status            *int64
	addstatus         *int64
	title             *string
	key               *string
	value             *string
	clearedFields     map[string]struct{}
	dictionary        *int64
	cleareddictionary bool
	users             map[int64]struct{}
	removedusers      map[int64]struct{}
	clearedusers      bool
	done              bool
	oldValue          func(context.Context) (*DictionaryDetail, error)
	predicates        []predicate.DictionaryDetail
}

var _ ent.Mutation = (*DictionaryDetailMutation)(nil)

// dictionarydetailOption allows management of the mutation configuration using functional options.
type dictionarydetailOption func(*DictionaryDetailMutation)

// newDictionaryDetailMutation creates new mutation for the DictionaryDetail entity.
func newDictionaryDetailMutation(c config, op Op, opts ...dictionarydetailOption) *DictionaryDetailMutation {
	m := &DictionaryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryDetailID sets the ID field of the mutation.
func withDictionaryDetailID(id int64) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DictionaryDetail
		)
		m.oldValue = func(ctx context.Context) (*DictionaryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictionaryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionaryDetail sets the old DictionaryDetail of the mutation.
func withDictionaryDetail(node *DictionaryDetail) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		m.oldValue = func(context.Context) (*DictionaryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictionaryDetail entities.
func (m *DictionaryDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictionaryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictionaryDetailMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictionarydetail.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictionaryDetailMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictionarydetail.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictionaryDetailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictionarydetail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictionaryDetailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictionarydetail.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DictionaryDetailMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DictionaryDetailMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DictionaryDetailMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DictionaryDetailMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DictionaryDetailMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dictionarydetail.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DictionaryDetailMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dictionarydetail.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DictionaryDetailMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DictionaryDetailMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DictionaryDetailMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DictionaryDetailMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DictionaryDetailMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dictionarydetail.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DictionaryDetailMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dictionarydetail.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DictionaryDetailMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryDetailMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryDetailMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryDetailMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryDetailMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionarydetail.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryDetailMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionarydetail.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetKey sets the "key" field.
func (m *DictionaryDetailMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DictionaryDetailMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DictionaryDetailMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DictionaryDetailMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryDetailMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryDetailMutation) ResetValue() {
	m.value = nil
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryDetailMutation) SetDictionaryID(i int64) {
	m.dictionary = &i
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryDetailMutation) DictionaryID() (r int64, exists bool) {
	v := m.dictionary
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDictionaryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ClearDictionaryID clears the value of the "dictionary_id" field.
func (m *DictionaryDetailMutation) ClearDictionaryID() {
	m.dictionary = nil
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryIDCleared returns if the "dictionary_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DictionaryIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDictionaryID]
	return ok
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryDetailMutation) ResetDictionaryID() {
	m.dictionary = nil
	delete(m.clearedFields, dictionarydetail.FieldDictionaryID)
}

// ClearDictionary clears the "dictionary" edge to the Dictionary entity.
func (m *DictionaryDetailMutation) ClearDictionary() {
	m.cleareddictionary = true
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryCleared reports if the "dictionary" edge to the Dictionary entity was cleared.
func (m *DictionaryDetailMutation) DictionaryCleared() bool {
	return m.DictionaryIDCleared() || m.cleareddictionary
}

// DictionaryIDs returns the "dictionary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionaryID instead. It exists only for internal usage by the builders.
func (m *DictionaryDetailMutation) DictionaryIDs() (ids []int64) {
	if id := m.dictionary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionary resets all changes to the "dictionary" edge.
func (m *DictionaryDetailMutation) ResetDictionary() {
	m.dictionary = nil
	m.cleareddictionary = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DictionaryDetailMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DictionaryDetailMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DictionaryDetailMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DictionaryDetailMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DictionaryDetailMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DictionaryDetailMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DictionaryDetailMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the DictionaryDetailMutation builder.
func (m *DictionaryDetailMutation) Where(ps ...predicate.DictionaryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictionaryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictionaryDetail).
func (m *DictionaryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryDetailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionarydetail.FieldTitle)
	}
	if m.key != nil {
		fields = append(fields, dictionarydetail.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dictionarydetail.FieldValue)
	}
	if m.dictionary != nil {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case dictionarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionarydetail.FieldDelete:
		return m.Delete()
	case dictionarydetail.FieldCreatedID:
		return m.CreatedID()
	case dictionarydetail.FieldStatus:
		return m.Status()
	case dictionarydetail.FieldTitle:
		return m.Title()
	case dictionarydetail.FieldKey:
		return m.Key()
	case dictionarydetail.FieldValue:
		return m.Value()
	case dictionarydetail.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionarydetail.FieldDelete:
		return m.OldDelete(ctx)
	case dictionarydetail.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dictionarydetail.FieldStatus:
		return m.OldStatus(ctx)
	case dictionarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case dictionarydetail.FieldKey:
		return m.OldKey(ctx)
	case dictionarydetail.FieldValue:
		return m.OldValue(ctx)
	case dictionarydetail.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionarydetail.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dictionarydetail.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionarydetail.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dictionarydetail.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionarydetail.FieldDictionaryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryDetailMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldDelete:
		return m.AddedDelete()
	case dictionarydetail.FieldCreatedID:
		return m.AddedCreatedID()
	case dictionarydetail.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dictionarydetail.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionarydetail.FieldCreatedAt) {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.FieldCleared(dictionarydetail.FieldUpdatedAt) {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.FieldCleared(dictionarydetail.FieldDelete) {
		fields = append(fields, dictionarydetail.FieldDelete)
	}
	if m.FieldCleared(dictionarydetail.FieldCreatedID) {
		fields = append(fields, dictionarydetail.FieldCreatedID)
	}
	if m.FieldCleared(dictionarydetail.FieldStatus) {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.FieldCleared(dictionarydetail.FieldDictionaryID) {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ClearField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictionarydetail.FieldDelete:
		m.ClearDelete()
		return nil
	case dictionarydetail.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dictionarydetail.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ClearDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ResetField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionarydetail.FieldDelete:
		m.ResetDelete()
		return nil
	case dictionarydetail.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dictionarydetail.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionarydetail.FieldKey:
		m.ResetKey()
		return nil
	case dictionarydetail.FieldValue:
		m.ResetValue()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.dictionary != nil {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	if m.users != nil {
		edges = append(edges, dictionarydetail.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeDictionary:
		if id := m.dictionary; id != nil {
			return []ent.Value{*id}
		}
	case dictionarydetail.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, dictionarydetail.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddictionary {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	if m.clearedusers {
		edges = append(edges, dictionarydetail.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionarydetail.EdgeDictionary:
		return m.cleareddictionary
	case dictionarydetail.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryDetailMutation) ClearEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ClearDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryDetailMutation) ResetEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ResetDictionary()
		return nil
	case dictionarydetail.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail edge %s", name)
}

// EntryLogsMutation represents an operation that mutates the EntryLogs nodes in the graph.
type EntryLogsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	delete                *int64
	adddelete             *int64
	created_id            *int64
	addcreated_id         *int64
	member_product_id     *int64
	addmember_product_id  *int64
	member_property_id    *int64
	addmember_property_id *int64
	entry_time            *time.Time
	leaving_time          *time.Time
	clearedFields         map[string]struct{}
	venues                *int64
	clearedvenues         bool
	members               *int64
	clearedmembers        bool
	users                 *int64
	clearedusers          bool
	done                  bool
	oldValue              func(context.Context) (*EntryLogs, error)
	predicates            []predicate.EntryLogs
}

var _ ent.Mutation = (*EntryLogsMutation)(nil)

// entrylogsOption allows management of the mutation configuration using functional options.
type entrylogsOption func(*EntryLogsMutation)

// newEntryLogsMutation creates new mutation for the EntryLogs entity.
func newEntryLogsMutation(c config, op Op, opts ...entrylogsOption) *EntryLogsMutation {
	m := &EntryLogsMutation{
		config:        c,
		op:            op,
		typ:           TypeEntryLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryLogsID sets the ID field of the mutation.
func withEntryLogsID(id int64) entrylogsOption {
	return func(m *EntryLogsMutation) {
		var (
			err   error
			once  sync.Once
			value *EntryLogs
		)
		m.oldValue = func(ctx context.Context) (*EntryLogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntryLogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntryLogs sets the old EntryLogs of the mutation.
func withEntryLogs(node *EntryLogs) entrylogsOption {
	return func(m *EntryLogsMutation) {
		m.oldValue = func(context.Context) (*EntryLogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryLogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryLogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntryLogs entities.
func (m *EntryLogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntryLogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntryLogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntryLogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntryLogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntryLogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntryLogsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entrylogs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntryLogsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntryLogsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entrylogs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntryLogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntryLogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntryLogsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entrylogs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntryLogsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntryLogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entrylogs.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *EntryLogsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *EntryLogsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *EntryLogsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *EntryLogsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *EntryLogsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[entrylogs.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *EntryLogsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *EntryLogsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, entrylogs.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *EntryLogsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *EntryLogsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *EntryLogsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *EntryLogsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *EntryLogsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[entrylogs.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *EntryLogsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *EntryLogsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, entrylogs.FieldCreatedID)
}

// SetMemberID sets the "member_id" field.
func (m *EntryLogsMutation) SetMemberID(i int64) {
	m.members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *EntryLogsMutation) MemberID() (r int64, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *EntryLogsMutation) ClearMemberID() {
	m.members = nil
	m.clearedFields[entrylogs.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *EntryLogsMutation) ResetMemberID() {
	m.members = nil
	delete(m.clearedFields, entrylogs.FieldMemberID)
}

// SetUserID sets the "user_id" field.
func (m *EntryLogsMutation) SetUserID(i int64) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EntryLogsMutation) UserID() (r int64, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *EntryLogsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[entrylogs.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *EntryLogsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EntryLogsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, entrylogs.FieldUserID)
}

// SetVenueID sets the "venue_id" field.
func (m *EntryLogsMutation) SetVenueID(i int64) {
	m.venues = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *EntryLogsMutation) VenueID() (r int64, exists bool) {
	v := m.venues
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *EntryLogsMutation) ClearVenueID() {
	m.venues = nil
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *EntryLogsMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *EntryLogsMutation) ResetVenueID() {
	m.venues = nil
	delete(m.clearedFields, entrylogs.FieldVenueID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *EntryLogsMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *EntryLogsMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *EntryLogsMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *EntryLogsMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *EntryLogsMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[entrylogs.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *EntryLogsMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, entrylogs.FieldMemberProductID)
}

// SetMemberPropertyID sets the "member_property_id" field.
func (m *EntryLogsMutation) SetMemberPropertyID(i int64) {
	m.member_property_id = &i
	m.addmember_property_id = nil
}

// MemberPropertyID returns the value of the "member_property_id" field in the mutation.
func (m *EntryLogsMutation) MemberPropertyID() (r int64, exists bool) {
	v := m.member_property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberPropertyID returns the old "member_property_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberPropertyID: %w", err)
	}
	return oldValue.MemberPropertyID, nil
}

// AddMemberPropertyID adds i to the "member_property_id" field.
func (m *EntryLogsMutation) AddMemberPropertyID(i int64) {
	if m.addmember_property_id != nil {
		*m.addmember_property_id += i
	} else {
		m.addmember_property_id = &i
	}
}

// AddedMemberPropertyID returns the value that was added to the "member_property_id" field in this mutation.
func (m *EntryLogsMutation) AddedMemberPropertyID() (r int64, exists bool) {
	v := m.addmember_property_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberPropertyID clears the value of the "member_property_id" field.
func (m *EntryLogsMutation) ClearMemberPropertyID() {
	m.member_property_id = nil
	m.addmember_property_id = nil
	m.clearedFields[entrylogs.FieldMemberPropertyID] = struct{}{}
}

// MemberPropertyIDCleared returns if the "member_property_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberPropertyIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberPropertyID]
	return ok
}

// ResetMemberPropertyID resets all changes to the "member_property_id" field.
func (m *EntryLogsMutation) ResetMemberPropertyID() {
	m.member_property_id = nil
	m.addmember_property_id = nil
	delete(m.clearedFields, entrylogs.FieldMemberPropertyID)
}

// SetEntryTime sets the "entry_time" field.
func (m *EntryLogsMutation) SetEntryTime(t time.Time) {
	m.entry_time = &t
}

// EntryTime returns the value of the "entry_time" field in the mutation.
func (m *EntryLogsMutation) EntryTime() (r time.Time, exists bool) {
	v := m.entry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryTime returns the old "entry_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldEntryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryTime: %w", err)
	}
	return oldValue.EntryTime, nil
}

// ClearEntryTime clears the value of the "entry_time" field.
func (m *EntryLogsMutation) ClearEntryTime() {
	m.entry_time = nil
	m.clearedFields[entrylogs.FieldEntryTime] = struct{}{}
}

// EntryTimeCleared returns if the "entry_time" field was cleared in this mutation.
func (m *EntryLogsMutation) EntryTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldEntryTime]
	return ok
}

// ResetEntryTime resets all changes to the "entry_time" field.
func (m *EntryLogsMutation) ResetEntryTime() {
	m.entry_time = nil
	delete(m.clearedFields, entrylogs.FieldEntryTime)
}

// SetLeavingTime sets the "leaving_time" field.
func (m *EntryLogsMutation) SetLeavingTime(t time.Time) {
	m.leaving_time = &t
}

// LeavingTime returns the value of the "leaving_time" field in the mutation.
func (m *EntryLogsMutation) LeavingTime() (r time.Time, exists bool) {
	v := m.leaving_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLeavingTime returns the old "leaving_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldLeavingTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeavingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeavingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeavingTime: %w", err)
	}
	return oldValue.LeavingTime, nil
}

// ClearLeavingTime clears the value of the "leaving_time" field.
func (m *EntryLogsMutation) ClearLeavingTime() {
	m.leaving_time = nil
	m.clearedFields[entrylogs.FieldLeavingTime] = struct{}{}
}

// LeavingTimeCleared returns if the "leaving_time" field was cleared in this mutation.
func (m *EntryLogsMutation) LeavingTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldLeavingTime]
	return ok
}

// ResetLeavingTime resets all changes to the "leaving_time" field.
func (m *EntryLogsMutation) ResetLeavingTime() {
	m.leaving_time = nil
	delete(m.clearedFields, entrylogs.FieldLeavingTime)
}

// SetVenuesID sets the "venues" edge to the Venue entity by id.
func (m *EntryLogsMutation) SetVenuesID(id int64) {
	m.venues = &id
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *EntryLogsMutation) ClearVenues() {
	m.clearedvenues = true
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *EntryLogsMutation) VenuesCleared() bool {
	return m.VenueIDCleared() || m.clearedvenues
}

// VenuesID returns the "venues" edge ID in the mutation.
func (m *EntryLogsMutation) VenuesID() (id int64, exists bool) {
	if m.venues != nil {
		return *m.venues, true
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenuesID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) VenuesIDs() (ids []int64) {
	if id := m.venues; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *EntryLogsMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
}

// SetMembersID sets the "members" edge to the Member entity by id.
func (m *EntryLogsMutation) SetMembersID(id int64) {
	m.members = &id
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *EntryLogsMutation) ClearMembers() {
	m.clearedmembers = true
	m.clearedFields[entrylogs.FieldMemberID] = struct{}{}
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *EntryLogsMutation) MembersCleared() bool {
	return m.MemberIDCleared() || m.clearedmembers
}

// MembersID returns the "members" edge ID in the mutation.
func (m *EntryLogsMutation) MembersID() (id int64, exists bool) {
	if m.members != nil {
		return *m.members, true
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MembersID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) MembersIDs() (ids []int64) {
	if id := m.members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *EntryLogsMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *EntryLogsMutation) SetUsersID(id int64) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *EntryLogsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[entrylogs.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *EntryLogsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *EntryLogsMutation) UsersID() (id int64, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) UsersIDs() (ids []int64) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *EntryLogsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the EntryLogsMutation builder.
func (m *EntryLogsMutation) Where(ps ...predicate.EntryLogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntryLogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntryLogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntryLogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntryLogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntryLogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntryLogs).
func (m *EntryLogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryLogsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, entrylogs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entrylogs.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, entrylogs.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, entrylogs.FieldCreatedID)
	}
	if m.members != nil {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.users != nil {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.venues != nil {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.member_product_id != nil {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.member_property_id != nil {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	if m.entry_time != nil {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.leaving_time != nil {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryLogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.CreatedAt()
	case entrylogs.FieldUpdatedAt:
		return m.UpdatedAt()
	case entrylogs.FieldDelete:
		return m.Delete()
	case entrylogs.FieldCreatedID:
		return m.CreatedID()
	case entrylogs.FieldMemberID:
		return m.MemberID()
	case entrylogs.FieldUserID:
		return m.UserID()
	case entrylogs.FieldVenueID:
		return m.VenueID()
	case entrylogs.FieldMemberProductID:
		return m.MemberProductID()
	case entrylogs.FieldMemberPropertyID:
		return m.MemberPropertyID()
	case entrylogs.FieldEntryTime:
		return m.EntryTime()
	case entrylogs.FieldLeavingTime:
		return m.LeavingTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryLogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entrylogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entrylogs.FieldDelete:
		return m.OldDelete(ctx)
	case entrylogs.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case entrylogs.FieldMemberID:
		return m.OldMemberID(ctx)
	case entrylogs.FieldUserID:
		return m.OldUserID(ctx)
	case entrylogs.FieldVenueID:
		return m.OldVenueID(ctx)
	case entrylogs.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case entrylogs.FieldMemberPropertyID:
		return m.OldMemberPropertyID(ctx)
	case entrylogs.FieldEntryTime:
		return m.OldEntryTime(ctx)
	case entrylogs.FieldLeavingTime:
		return m.OldLeavingTime(ctx)
	}
	return nil, fmt.Errorf("unknown EntryLogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entrylogs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entrylogs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case entrylogs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case entrylogs.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case entrylogs.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case entrylogs.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case entrylogs.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case entrylogs.FieldMemberPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberPropertyID(v)
		return nil
	case entrylogs.FieldEntryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryTime(v)
		return nil
	case entrylogs.FieldLeavingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeavingTime(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryLogsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, entrylogs.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, entrylogs.FieldCreatedID)
	}
	if m.addmember_product_id != nil {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.addmember_property_id != nil {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryLogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldDelete:
		return m.AddedDelete()
	case entrylogs.FieldCreatedID:
		return m.AddedCreatedID()
	case entrylogs.FieldMemberProductID:
		return m.AddedMemberProductID()
	case entrylogs.FieldMemberPropertyID:
		return m.AddedMemberPropertyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case entrylogs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case entrylogs.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	case entrylogs.FieldMemberPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberPropertyID(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryLogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entrylogs.FieldCreatedAt) {
		fields = append(fields, entrylogs.FieldCreatedAt)
	}
	if m.FieldCleared(entrylogs.FieldUpdatedAt) {
		fields = append(fields, entrylogs.FieldUpdatedAt)
	}
	if m.FieldCleared(entrylogs.FieldDelete) {
		fields = append(fields, entrylogs.FieldDelete)
	}
	if m.FieldCleared(entrylogs.FieldCreatedID) {
		fields = append(fields, entrylogs.FieldCreatedID)
	}
	if m.FieldCleared(entrylogs.FieldMemberID) {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.FieldCleared(entrylogs.FieldUserID) {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.FieldCleared(entrylogs.FieldVenueID) {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.FieldCleared(entrylogs.FieldMemberProductID) {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.FieldCleared(entrylogs.FieldMemberPropertyID) {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	if m.FieldCleared(entrylogs.FieldEntryTime) {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.FieldCleared(entrylogs.FieldLeavingTime) {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryLogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryLogsMutation) ClearField(name string) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entrylogs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entrylogs.FieldDelete:
		m.ClearDelete()
		return nil
	case entrylogs.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case entrylogs.FieldMemberID:
		m.ClearMemberID()
		return nil
	case entrylogs.FieldUserID:
		m.ClearUserID()
		return nil
	case entrylogs.FieldVenueID:
		m.ClearVenueID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case entrylogs.FieldMemberPropertyID:
		m.ClearMemberPropertyID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ClearEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ClearLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryLogsMutation) ResetField(name string) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entrylogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entrylogs.FieldDelete:
		m.ResetDelete()
		return nil
	case entrylogs.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case entrylogs.FieldMemberID:
		m.ResetMemberID()
		return nil
	case entrylogs.FieldUserID:
		m.ResetUserID()
		return nil
	case entrylogs.FieldVenueID:
		m.ResetVenueID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case entrylogs.FieldMemberPropertyID:
		m.ResetMemberPropertyID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ResetEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ResetLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryLogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.venues != nil {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	if m.members != nil {
		edges = append(edges, entrylogs.EdgeMembers)
	}
	if m.users != nil {
		edges = append(edges, entrylogs.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryLogsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entrylogs.EdgeVenues:
		if id := m.venues; id != nil {
			return []ent.Value{*id}
		}
	case entrylogs.EdgeMembers:
		if id := m.members; id != nil {
			return []ent.Value{*id}
		}
	case entrylogs.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryLogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryLogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryLogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedvenues {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	if m.clearedmembers {
		edges = append(edges, entrylogs.EdgeMembers)
	}
	if m.clearedusers {
		edges = append(edges, entrylogs.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryLogsMutation) EdgeCleared(name string) bool {
	switch name {
	case entrylogs.EdgeVenues:
		return m.clearedvenues
	case entrylogs.EdgeMembers:
		return m.clearedmembers
	case entrylogs.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryLogsMutation) ClearEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ClearVenues()
		return nil
	case entrylogs.EdgeMembers:
		m.ClearMembers()
		return nil
	case entrylogs.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryLogsMutation) ResetEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ResetVenues()
		return nil
	case entrylogs.EdgeMembers:
		m.ResetMembers()
		return nil
	case entrylogs.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	method        *string
	api           *string
	success       *bool
	req_content   *string
	resp_content  *string
	ip            *string
	user_agent    *string
	operator      *string
	time          *int
	addtime       *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int64) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LogsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[logs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LogsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, logs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LogsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[logs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LogsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, logs.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *LogsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *LogsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *LogsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *LogsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *LogsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[logs.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *LogsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[logs.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *LogsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, logs.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *LogsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *LogsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *LogsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *LogsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *LogsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[logs.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *LogsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *LogsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, logs.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *LogsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LogsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LogsMutation) ResetType() {
	m._type = nil
}

// SetMethod sets the "method" field.
func (m *LogsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *LogsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *LogsMutation) ResetMethod() {
	m.method = nil
}

// SetAPI sets the "api" field.
func (m *LogsMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *LogsMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *LogsMutation) ResetAPI() {
	m.api = nil
}

// SetSuccess sets the "success" field.
func (m *LogsMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LogsMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LogsMutation) ResetSuccess() {
	m.success = nil
}

// SetReqContent sets the "req_content" field.
func (m *LogsMutation) SetReqContent(s string) {
	m.req_content = &s
}

// ReqContent returns the value of the "req_content" field in the mutation.
func (m *LogsMutation) ReqContent() (r string, exists bool) {
	v := m.req_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReqContent returns the old "req_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldReqContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqContent: %w", err)
	}
	return oldValue.ReqContent, nil
}

// ClearReqContent clears the value of the "req_content" field.
func (m *LogsMutation) ClearReqContent() {
	m.req_content = nil
	m.clearedFields[logs.FieldReqContent] = struct{}{}
}

// ReqContentCleared returns if the "req_content" field was cleared in this mutation.
func (m *LogsMutation) ReqContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldReqContent]
	return ok
}

// ResetReqContent resets all changes to the "req_content" field.
func (m *LogsMutation) ResetReqContent() {
	m.req_content = nil
	delete(m.clearedFields, logs.FieldReqContent)
}

// SetRespContent sets the "resp_content" field.
func (m *LogsMutation) SetRespContent(s string) {
	m.resp_content = &s
}

// RespContent returns the value of the "resp_content" field in the mutation.
func (m *LogsMutation) RespContent() (r string, exists bool) {
	v := m.resp_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRespContent returns the old "resp_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRespContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespContent: %w", err)
	}
	return oldValue.RespContent, nil
}

// ClearRespContent clears the value of the "resp_content" field.
func (m *LogsMutation) ClearRespContent() {
	m.resp_content = nil
	m.clearedFields[logs.FieldRespContent] = struct{}{}
}

// RespContentCleared returns if the "resp_content" field was cleared in this mutation.
func (m *LogsMutation) RespContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldRespContent]
	return ok
}

// ResetRespContent resets all changes to the "resp_content" field.
func (m *LogsMutation) ResetRespContent() {
	m.resp_content = nil
	delete(m.clearedFields, logs.FieldRespContent)
}

// SetIP sets the "ip" field.
func (m *LogsMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *LogsMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[logs.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *LogsMutation) IPCleared() bool {
	_, ok := m.clearedFields[logs.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *LogsMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, logs.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LogsMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LogsMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LogsMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[logs.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LogsMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LogsMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, logs.FieldUserAgent)
}

// SetOperator sets the "operator" field.
func (m *LogsMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the value of the "operator" field in the mutation.
func (m *LogsMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldOperator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ClearOperator clears the value of the "operator" field.
func (m *LogsMutation) ClearOperator() {
	m.operator = nil
	m.clearedFields[logs.FieldOperator] = struct{}{}
}

// OperatorCleared returns if the "operator" field was cleared in this mutation.
func (m *LogsMutation) OperatorCleared() bool {
	_, ok := m.clearedFields[logs.FieldOperator]
	return ok
}

// ResetOperator resets all changes to the "operator" field.
func (m *LogsMutation) ResetOperator() {
	m.operator = nil
	delete(m.clearedFields, logs.FieldOperator)
}

// SetTime sets the "time" field.
func (m *LogsMutation) SetTime(i int) {
	m.time = &i
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *LogsMutation) Time() (r int, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to the "time" field.
func (m *LogsMutation) AddTime(i int) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *LogsMutation) AddedTime() (r int, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *LogsMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[logs.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *LogsMutation) TimeCleared() bool {
	_, ok := m.clearedFields[logs.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *LogsMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, logs.FieldTime)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, logs.FieldType)
	}
	if m.method != nil {
		fields = append(fields, logs.FieldMethod)
	}
	if m.api != nil {
		fields = append(fields, logs.FieldAPI)
	}
	if m.success != nil {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.req_content != nil {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.resp_content != nil {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.ip != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.operator != nil {
		fields = append(fields, logs.FieldOperator)
	}
	if m.time != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldDelete:
		return m.Delete()
	case logs.FieldCreatedID:
		return m.CreatedID()
	case logs.FieldType:
		return m.GetType()
	case logs.FieldMethod:
		return m.Method()
	case logs.FieldAPI:
		return m.API()
	case logs.FieldSuccess:
		return m.Success()
	case logs.FieldReqContent:
		return m.ReqContent()
	case logs.FieldRespContent:
		return m.RespContent()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldUserAgent:
		return m.UserAgent()
	case logs.FieldOperator:
		return m.Operator()
	case logs.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldDelete:
		return m.OldDelete(ctx)
	case logs.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case logs.FieldType:
		return m.OldType(ctx)
	case logs.FieldMethod:
		return m.OldMethod(ctx)
	case logs.FieldAPI:
		return m.OldAPI(ctx)
	case logs.FieldSuccess:
		return m.OldSuccess(ctx)
	case logs.FieldReqContent:
		return m.OldReqContent(ctx)
	case logs.FieldRespContent:
		return m.OldRespContent(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case logs.FieldOperator:
		return m.OldOperator(ctx)
	case logs.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case logs.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case logs.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case logs.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case logs.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case logs.FieldReqContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqContent(v)
		return nil
	case logs.FieldRespContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespContent(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case logs.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.addtime != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldDelete:
		return m.AddedDelete()
	case logs.FieldCreatedID:
		return m.AddedCreatedID()
	case logs.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldCreatedAt) {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.FieldCleared(logs.FieldUpdatedAt) {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.FieldCleared(logs.FieldDelete) {
		fields = append(fields, logs.FieldDelete)
	}
	if m.FieldCleared(logs.FieldCreatedID) {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.FieldCleared(logs.FieldReqContent) {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.FieldCleared(logs.FieldRespContent) {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.FieldCleared(logs.FieldIP) {
		fields = append(fields, logs.FieldIP)
	}
	if m.FieldCleared(logs.FieldUserAgent) {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.FieldCleared(logs.FieldOperator) {
		fields = append(fields, logs.FieldOperator)
	}
	if m.FieldCleared(logs.FieldTime) {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ClearDelete()
		return nil
	case logs.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case logs.FieldReqContent:
		m.ClearReqContent()
		return nil
	case logs.FieldRespContent:
		m.ClearRespContent()
		return nil
	case logs.FieldIP:
		m.ClearIP()
		return nil
	case logs.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case logs.FieldOperator:
		m.ClearOperator()
		return nil
	case logs.FieldTime:
		m.ClearTime()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ResetDelete()
		return nil
	case logs.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case logs.FieldType:
		m.ResetType()
		return nil
	case logs.FieldMethod:
		m.ResetMethod()
		return nil
	case logs.FieldAPI:
		m.ResetAPI()
		return nil
	case logs.FieldSuccess:
		m.ResetSuccess()
		return nil
	case logs.FieldReqContent:
		m.ResetReqContent()
		return nil
	case logs.FieldRespContent:
		m.ResetRespContent()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case logs.FieldOperator:
		m.ResetOperator()
		return nil
	case logs.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	created_at                  *time.Time
	updated_at                  *time.Time
	delete                      *int64
	adddelete                   *int64
	created_id                  *int64
	addcreated_id               *int64
	status                      *int64
	addstatus                   *int64
	password                    *string
	name                        *string
	nickname                    *string
	mobile                      *string
	avatar                      *string
	condition                   *int64
	addcondition                *int64
	clearedFields               map[string]struct{}
	member_details              map[int64]struct{}
	removedmember_details       map[int64]struct{}
	clearedmember_details       bool
	member_notes                map[int64]struct{}
	removedmember_notes         map[int64]struct{}
	clearedmember_notes         bool
	member_orders               map[int64]struct{}
	removedmember_orders        map[int64]struct{}
	clearedmember_orders        bool
	member_entry                map[int64]struct{}
	removedmember_entry         map[int64]struct{}
	clearedmember_entry         bool
	member_contents             map[int64]struct{}
	removedmember_contents      map[int64]struct{}
	clearedmember_contents      bool
	contestParticipants         map[int64]struct{}
	removedcontestParticipants  map[int64]struct{}
	clearedcontestParticipants  bool
	bootcampParticipants        map[int64]struct{}
	removedbootcampParticipants map[int64]struct{}
	clearedbootcampParticipants bool
	done                        bool
	oldValue                    func(context.Context) (*Member, error)
	predicates                  []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int64) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[member.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[member.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, member.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[member.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[member.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, member.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[member.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[member.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, member.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[member.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[member.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, member.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[member.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[member.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, member.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *MemberMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[member.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *MemberMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[member.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, member.FieldPassword)
}

// SetName sets the "name" field.
func (m *MemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberMutation) ClearName() {
	m.name = nil
	m.clearedFields[member.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberMutation) NameCleared() bool {
	_, ok := m.clearedFields[member.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, member.FieldName)
}

// SetNickname sets the "nickname" field.
func (m *MemberMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *MemberMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *MemberMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[member.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *MemberMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[member.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *MemberMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, member.FieldNickname)
}

// SetMobile sets the "mobile" field.
func (m *MemberMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *MemberMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *MemberMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[member.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *MemberMutation) MobileCleared() bool {
	_, ok := m.clearedFields[member.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *MemberMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, member.FieldMobile)
}

// SetAvatar sets the "avatar" field.
func (m *MemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *MemberMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[member.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *MemberMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[member.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, member.FieldAvatar)
}

// SetCondition sets the "condition" field.
func (m *MemberMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *MemberMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *MemberMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *MemberMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *MemberMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[member.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *MemberMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[member.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *MemberMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, member.FieldCondition)
}

// AddMemberDetailIDs adds the "member_details" edge to the MemberDetails entity by ids.
func (m *MemberMutation) AddMemberDetailIDs(ids ...int64) {
	if m.member_details == nil {
		m.member_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_details[ids[i]] = struct{}{}
	}
}

// ClearMemberDetails clears the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) ClearMemberDetails() {
	m.clearedmember_details = true
}

// MemberDetailsCleared reports if the "member_details" edge to the MemberDetails entity was cleared.
func (m *MemberMutation) MemberDetailsCleared() bool {
	return m.clearedmember_details
}

// RemoveMemberDetailIDs removes the "member_details" edge to the MemberDetails entity by IDs.
func (m *MemberMutation) RemoveMemberDetailIDs(ids ...int64) {
	if m.removedmember_details == nil {
		m.removedmember_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_details, ids[i])
		m.removedmember_details[ids[i]] = struct{}{}
	}
}

// RemovedMemberDetails returns the removed IDs of the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) RemovedMemberDetailsIDs() (ids []int64) {
	for id := range m.removedmember_details {
		ids = append(ids, id)
	}
	return
}

// MemberDetailsIDs returns the "member_details" edge IDs in the mutation.
func (m *MemberMutation) MemberDetailsIDs() (ids []int64) {
	for id := range m.member_details {
		ids = append(ids, id)
	}
	return
}

// ResetMemberDetails resets all changes to the "member_details" edge.
func (m *MemberMutation) ResetMemberDetails() {
	m.member_details = nil
	m.clearedmember_details = false
	m.removedmember_details = nil
}

// AddMemberNoteIDs adds the "member_notes" edge to the MemberNote entity by ids.
func (m *MemberMutation) AddMemberNoteIDs(ids ...int64) {
	if m.member_notes == nil {
		m.member_notes = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_notes[ids[i]] = struct{}{}
	}
}

// ClearMemberNotes clears the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) ClearMemberNotes() {
	m.clearedmember_notes = true
}

// MemberNotesCleared reports if the "member_notes" edge to the MemberNote entity was cleared.
func (m *MemberMutation) MemberNotesCleared() bool {
	return m.clearedmember_notes
}

// RemoveMemberNoteIDs removes the "member_notes" edge to the MemberNote entity by IDs.
func (m *MemberMutation) RemoveMemberNoteIDs(ids ...int64) {
	if m.removedmember_notes == nil {
		m.removedmember_notes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_notes, ids[i])
		m.removedmember_notes[ids[i]] = struct{}{}
	}
}

// RemovedMemberNotes returns the removed IDs of the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) RemovedMemberNotesIDs() (ids []int64) {
	for id := range m.removedmember_notes {
		ids = append(ids, id)
	}
	return
}

// MemberNotesIDs returns the "member_notes" edge IDs in the mutation.
func (m *MemberMutation) MemberNotesIDs() (ids []int64) {
	for id := range m.member_notes {
		ids = append(ids, id)
	}
	return
}

// ResetMemberNotes resets all changes to the "member_notes" edge.
func (m *MemberMutation) ResetMemberNotes() {
	m.member_notes = nil
	m.clearedmember_notes = false
	m.removedmember_notes = nil
}

// AddMemberOrderIDs adds the "member_orders" edge to the Order entity by ids.
func (m *MemberMutation) AddMemberOrderIDs(ids ...int64) {
	if m.member_orders == nil {
		m.member_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_orders[ids[i]] = struct{}{}
	}
}

// ClearMemberOrders clears the "member_orders" edge to the Order entity.
func (m *MemberMutation) ClearMemberOrders() {
	m.clearedmember_orders = true
}

// MemberOrdersCleared reports if the "member_orders" edge to the Order entity was cleared.
func (m *MemberMutation) MemberOrdersCleared() bool {
	return m.clearedmember_orders
}

// RemoveMemberOrderIDs removes the "member_orders" edge to the Order entity by IDs.
func (m *MemberMutation) RemoveMemberOrderIDs(ids ...int64) {
	if m.removedmember_orders == nil {
		m.removedmember_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_orders, ids[i])
		m.removedmember_orders[ids[i]] = struct{}{}
	}
}

// RemovedMemberOrders returns the removed IDs of the "member_orders" edge to the Order entity.
func (m *MemberMutation) RemovedMemberOrdersIDs() (ids []int64) {
	for id := range m.removedmember_orders {
		ids = append(ids, id)
	}
	return
}

// MemberOrdersIDs returns the "member_orders" edge IDs in the mutation.
func (m *MemberMutation) MemberOrdersIDs() (ids []int64) {
	for id := range m.member_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMemberOrders resets all changes to the "member_orders" edge.
func (m *MemberMutation) ResetMemberOrders() {
	m.member_orders = nil
	m.clearedmember_orders = false
	m.removedmember_orders = nil
}

// AddMemberEntryIDs adds the "member_entry" edge to the EntryLogs entity by ids.
func (m *MemberMutation) AddMemberEntryIDs(ids ...int64) {
	if m.member_entry == nil {
		m.member_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_entry[ids[i]] = struct{}{}
	}
}

// ClearMemberEntry clears the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) ClearMemberEntry() {
	m.clearedmember_entry = true
}

// MemberEntryCleared reports if the "member_entry" edge to the EntryLogs entity was cleared.
func (m *MemberMutation) MemberEntryCleared() bool {
	return m.clearedmember_entry
}

// RemoveMemberEntryIDs removes the "member_entry" edge to the EntryLogs entity by IDs.
func (m *MemberMutation) RemoveMemberEntryIDs(ids ...int64) {
	if m.removedmember_entry == nil {
		m.removedmember_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_entry, ids[i])
		m.removedmember_entry[ids[i]] = struct{}{}
	}
}

// RemovedMemberEntry returns the removed IDs of the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) RemovedMemberEntryIDs() (ids []int64) {
	for id := range m.removedmember_entry {
		ids = append(ids, id)
	}
	return
}

// MemberEntryIDs returns the "member_entry" edge IDs in the mutation.
func (m *MemberMutation) MemberEntryIDs() (ids []int64) {
	for id := range m.member_entry {
		ids = append(ids, id)
	}
	return
}

// ResetMemberEntry resets all changes to the "member_entry" edge.
func (m *MemberMutation) ResetMemberEntry() {
	m.member_entry = nil
	m.clearedmember_entry = false
	m.removedmember_entry = nil
}

// AddMemberContentIDs adds the "member_contents" edge to the MemberContract entity by ids.
func (m *MemberMutation) AddMemberContentIDs(ids ...int64) {
	if m.member_contents == nil {
		m.member_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_contents[ids[i]] = struct{}{}
	}
}

// ClearMemberContents clears the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) ClearMemberContents() {
	m.clearedmember_contents = true
}

// MemberContentsCleared reports if the "member_contents" edge to the MemberContract entity was cleared.
func (m *MemberMutation) MemberContentsCleared() bool {
	return m.clearedmember_contents
}

// RemoveMemberContentIDs removes the "member_contents" edge to the MemberContract entity by IDs.
func (m *MemberMutation) RemoveMemberContentIDs(ids ...int64) {
	if m.removedmember_contents == nil {
		m.removedmember_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_contents, ids[i])
		m.removedmember_contents[ids[i]] = struct{}{}
	}
}

// RemovedMemberContents returns the removed IDs of the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) RemovedMemberContentsIDs() (ids []int64) {
	for id := range m.removedmember_contents {
		ids = append(ids, id)
	}
	return
}

// MemberContentsIDs returns the "member_contents" edge IDs in the mutation.
func (m *MemberMutation) MemberContentsIDs() (ids []int64) {
	for id := range m.member_contents {
		ids = append(ids, id)
	}
	return
}

// ResetMemberContents resets all changes to the "member_contents" edge.
func (m *MemberMutation) ResetMemberContents() {
	m.member_contents = nil
	m.clearedmember_contents = false
	m.removedmember_contents = nil
}

// AddContestParticipantIDs adds the "contestParticipants" edge to the ContestParticipant entity by ids.
func (m *MemberMutation) AddContestParticipantIDs(ids ...int64) {
	if m.contestParticipants == nil {
		m.contestParticipants = make(map[int64]struct{})
	}
	for i := range ids {
		m.contestParticipants[ids[i]] = struct{}{}
	}
}

// ClearContestParticipants clears the "contestParticipants" edge to the ContestParticipant entity.
func (m *MemberMutation) ClearContestParticipants() {
	m.clearedcontestParticipants = true
}

// ContestParticipantsCleared reports if the "contestParticipants" edge to the ContestParticipant entity was cleared.
func (m *MemberMutation) ContestParticipantsCleared() bool {
	return m.clearedcontestParticipants
}

// RemoveContestParticipantIDs removes the "contestParticipants" edge to the ContestParticipant entity by IDs.
func (m *MemberMutation) RemoveContestParticipantIDs(ids ...int64) {
	if m.removedcontestParticipants == nil {
		m.removedcontestParticipants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.contestParticipants, ids[i])
		m.removedcontestParticipants[ids[i]] = struct{}{}
	}
}

// RemovedContestParticipants returns the removed IDs of the "contestParticipants" edge to the ContestParticipant entity.
func (m *MemberMutation) RemovedContestParticipantsIDs() (ids []int64) {
	for id := range m.removedcontestParticipants {
		ids = append(ids, id)
	}
	return
}

// ContestParticipantsIDs returns the "contestParticipants" edge IDs in the mutation.
func (m *MemberMutation) ContestParticipantsIDs() (ids []int64) {
	for id := range m.contestParticipants {
		ids = append(ids, id)
	}
	return
}

// ResetContestParticipants resets all changes to the "contestParticipants" edge.
func (m *MemberMutation) ResetContestParticipants() {
	m.contestParticipants = nil
	m.clearedcontestParticipants = false
	m.removedcontestParticipants = nil
}

// AddBootcampParticipantIDs adds the "bootcampParticipants" edge to the BootcampParticipant entity by ids.
func (m *MemberMutation) AddBootcampParticipantIDs(ids ...int64) {
	if m.bootcampParticipants == nil {
		m.bootcampParticipants = make(map[int64]struct{})
	}
	for i := range ids {
		m.bootcampParticipants[ids[i]] = struct{}{}
	}
}

// ClearBootcampParticipants clears the "bootcampParticipants" edge to the BootcampParticipant entity.
func (m *MemberMutation) ClearBootcampParticipants() {
	m.clearedbootcampParticipants = true
}

// BootcampParticipantsCleared reports if the "bootcampParticipants" edge to the BootcampParticipant entity was cleared.
func (m *MemberMutation) BootcampParticipantsCleared() bool {
	return m.clearedbootcampParticipants
}

// RemoveBootcampParticipantIDs removes the "bootcampParticipants" edge to the BootcampParticipant entity by IDs.
func (m *MemberMutation) RemoveBootcampParticipantIDs(ids ...int64) {
	if m.removedbootcampParticipants == nil {
		m.removedbootcampParticipants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.bootcampParticipants, ids[i])
		m.removedbootcampParticipants[ids[i]] = struct{}{}
	}
}

// RemovedBootcampParticipants returns the removed IDs of the "bootcampParticipants" edge to the BootcampParticipant entity.
func (m *MemberMutation) RemovedBootcampParticipantsIDs() (ids []int64) {
	for id := range m.removedbootcampParticipants {
		ids = append(ids, id)
	}
	return
}

// BootcampParticipantsIDs returns the "bootcampParticipants" edge IDs in the mutation.
func (m *MemberMutation) BootcampParticipantsIDs() (ids []int64) {
	for id := range m.bootcampParticipants {
		ids = append(ids, id)
	}
	return
}

// ResetBootcampParticipants resets all changes to the "bootcampParticipants" edge.
func (m *MemberMutation) ResetBootcampParticipants() {
	m.bootcampParticipants = nil
	m.clearedbootcampParticipants = false
	m.removedbootcampParticipants = nil
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, member.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, member.FieldName)
	}
	if m.nickname != nil {
		fields = append(fields, member.FieldNickname)
	}
	if m.mobile != nil {
		fields = append(fields, member.FieldMobile)
	}
	if m.avatar != nil {
		fields = append(fields, member.FieldAvatar)
	}
	if m.condition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldDelete:
		return m.Delete()
	case member.FieldCreatedID:
		return m.CreatedID()
	case member.FieldStatus:
		return m.Status()
	case member.FieldPassword:
		return m.Password()
	case member.FieldName:
		return m.Name()
	case member.FieldNickname:
		return m.Nickname()
	case member.FieldMobile:
		return m.Mobile()
	case member.FieldAvatar:
		return m.Avatar()
	case member.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldDelete:
		return m.OldDelete(ctx)
	case member.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case member.FieldStatus:
		return m.OldStatus(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldName:
		return m.OldName(ctx)
	case member.FieldNickname:
		return m.OldNickname(ctx)
	case member.FieldMobile:
		return m.OldMobile(ctx)
	case member.FieldAvatar:
		return m.OldAvatar(ctx)
	case member.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case member.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case member.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case member.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case member.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, member.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.addcondition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldDelete:
		return m.AddedDelete()
	case member.FieldCreatedID:
		return m.AddedCreatedID()
	case member.FieldStatus:
		return m.AddedStatus()
	case member.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case member.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldCreatedAt) {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.FieldCleared(member.FieldUpdatedAt) {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.FieldCleared(member.FieldDelete) {
		fields = append(fields, member.FieldDelete)
	}
	if m.FieldCleared(member.FieldCreatedID) {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.FieldCleared(member.FieldStatus) {
		fields = append(fields, member.FieldStatus)
	}
	if m.FieldCleared(member.FieldPassword) {
		fields = append(fields, member.FieldPassword)
	}
	if m.FieldCleared(member.FieldName) {
		fields = append(fields, member.FieldName)
	}
	if m.FieldCleared(member.FieldNickname) {
		fields = append(fields, member.FieldNickname)
	}
	if m.FieldCleared(member.FieldMobile) {
		fields = append(fields, member.FieldMobile)
	}
	if m.FieldCleared(member.FieldAvatar) {
		fields = append(fields, member.FieldAvatar)
	}
	if m.FieldCleared(member.FieldCondition) {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case member.FieldDelete:
		m.ClearDelete()
		return nil
	case member.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case member.FieldStatus:
		m.ClearStatus()
		return nil
	case member.FieldPassword:
		m.ClearPassword()
		return nil
	case member.FieldName:
		m.ClearName()
		return nil
	case member.FieldNickname:
		m.ClearNickname()
		return nil
	case member.FieldMobile:
		m.ClearMobile()
		return nil
	case member.FieldAvatar:
		m.ClearAvatar()
		return nil
	case member.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldDelete:
		m.ResetDelete()
		return nil
	case member.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case member.FieldStatus:
		m.ResetStatus()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldName:
		m.ResetName()
		return nil
	case member.FieldNickname:
		m.ResetNickname()
		return nil
	case member.FieldMobile:
		m.ResetMobile()
		return nil
	case member.FieldAvatar:
		m.ResetAvatar()
		return nil
	case member.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.member_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.member_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.member_orders != nil {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.member_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.member_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	if m.contestParticipants != nil {
		edges = append(edges, member.EdgeContestParticipants)
	}
	if m.bootcampParticipants != nil {
		edges = append(edges, member.EdgeBootcampParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.member_details))
		for id := range m.member_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.member_notes))
		for id := range m.member_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberOrders:
		ids := make([]ent.Value, 0, len(m.member_orders))
		for id := range m.member_orders {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.member_entry))
		for id := range m.member_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.member_contents))
		for id := range m.member_contents {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeContestParticipants:
		ids := make([]ent.Value, 0, len(m.contestParticipants))
		for id := range m.contestParticipants {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeBootcampParticipants:
		ids := make([]ent.Value, 0, len(m.bootcampParticipants))
		for id := range m.bootcampParticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmember_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.removedmember_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.removedmember_orders != nil {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.removedmember_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.removedmember_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	if m.removedcontestParticipants != nil {
		edges = append(edges, member.EdgeContestParticipants)
	}
	if m.removedbootcampParticipants != nil {
		edges = append(edges, member.EdgeBootcampParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.removedmember_details))
		for id := range m.removedmember_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.removedmember_notes))
		for id := range m.removedmember_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberOrders:
		ids := make([]ent.Value, 0, len(m.removedmember_orders))
		for id := range m.removedmember_orders {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.removedmember_entry))
		for id := range m.removedmember_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.removedmember_contents))
		for id := range m.removedmember_contents {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeContestParticipants:
		ids := make([]ent.Value, 0, len(m.removedcontestParticipants))
		for id := range m.removedcontestParticipants {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeBootcampParticipants:
		ids := make([]ent.Value, 0, len(m.removedbootcampParticipants))
		for id := range m.removedbootcampParticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedmember_details {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.clearedmember_notes {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.clearedmember_orders {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.clearedmember_entry {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.clearedmember_contents {
		edges = append(edges, member.EdgeMemberContents)
	}
	if m.clearedcontestParticipants {
		edges = append(edges, member.EdgeContestParticipants)
	}
	if m.clearedbootcampParticipants {
		edges = append(edges, member.EdgeBootcampParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeMemberDetails:
		return m.clearedmember_details
	case member.EdgeMemberNotes:
		return m.clearedmember_notes
	case member.EdgeMemberOrders:
		return m.clearedmember_orders
	case member.EdgeMemberEntry:
		return m.clearedmember_entry
	case member.EdgeMemberContents:
		return m.clearedmember_contents
	case member.EdgeContestParticipants:
		return m.clearedcontestParticipants
	case member.EdgeBootcampParticipants:
		return m.clearedbootcampParticipants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberDetails:
		m.ResetMemberDetails()
		return nil
	case member.EdgeMemberNotes:
		m.ResetMemberNotes()
		return nil
	case member.EdgeMemberOrders:
		m.ResetMemberOrders()
		return nil
	case member.EdgeMemberEntry:
		m.ResetMemberEntry()
		return nil
	case member.EdgeMemberContents:
		m.ResetMemberContents()
		return nil
	case member.EdgeContestParticipants:
		m.ResetContestParticipants()
		return nil
	case member.EdgeBootcampParticipants:
		m.ResetBootcampParticipants()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// MemberContractMutation represents an operation that mutates the MemberContract nodes in the graph.
type MemberContractMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	delete               *int64
	adddelete            *int64
	created_id           *int64
	addcreated_id        *int64
	status               *int64
	addstatus            *int64
	contract_id          *int64
	addcontract_id       *int64
	venue_id             *int64
	addvenue_id          *int64
	member_product_id    *int64
	addmember_product_id *int64
	name                 *string
	sign                 *string
	clearedFields        map[string]struct{}
	content              map[int64]struct{}
	removedcontent       map[int64]struct{}
	clearedcontent       bool
	member               *int64
	clearedmember        bool
	_order               *int64
	cleared_order        bool
	done                 bool
	oldValue             func(context.Context) (*MemberContract, error)
	predicates           []predicate.MemberContract
}

var _ ent.Mutation = (*MemberContractMutation)(nil)

// membercontractOption allows management of the mutation configuration using functional options.
type membercontractOption func(*MemberContractMutation)

// newMemberContractMutation creates new mutation for the MemberContract entity.
func newMemberContractMutation(c config, op Op, opts ...membercontractOption) *MemberContractMutation {
	m := &MemberContractMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractID sets the ID field of the mutation.
func withMemberContractID(id int64) membercontractOption {
	return func(m *MemberContractMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContract
		)
		m.oldValue = func(ctx context.Context) (*MemberContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContract sets the old MemberContract of the mutation.
func withMemberContract(node *MemberContract) membercontractOption {
	return func(m *MemberContractMutation) {
		m.oldValue = func(context.Context) (*MemberContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContract entities.
func (m *MemberContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberContractMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membercontract.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberContractMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membercontract.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberContractMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membercontract.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberContractMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membercontract.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberContractMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberContractMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberContractMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberContractMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberContractMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membercontract.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberContractMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberContractMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membercontract.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberContractMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberContractMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberContractMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberContractMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberContractMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membercontract.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberContractMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberContractMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membercontract.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membercontract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membercontract.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberContractMutation) SetMemberID(i int64) {
	m.member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberContractMutation) MemberID() (r int64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberContractMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberContractMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, membercontract.FieldMemberID)
}

// SetContractID sets the "contract_id" field.
func (m *MemberContractMutation) SetContractID(i int64) {
	m.contract_id = &i
	m.addcontract_id = nil
}

// ContractID returns the value of the "contract_id" field in the mutation.
func (m *MemberContractMutation) ContractID() (r int64, exists bool) {
	v := m.contract_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContractID returns the old "contract_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractID: %w", err)
	}
	return oldValue.ContractID, nil
}

// AddContractID adds i to the "contract_id" field.
func (m *MemberContractMutation) AddContractID(i int64) {
	if m.addcontract_id != nil {
		*m.addcontract_id += i
	} else {
		m.addcontract_id = &i
	}
}

// AddedContractID returns the value that was added to the "contract_id" field in this mutation.
func (m *MemberContractMutation) AddedContractID() (r int64, exists bool) {
	v := m.addcontract_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContractID clears the value of the "contract_id" field.
func (m *MemberContractMutation) ClearContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	m.clearedFields[membercontract.FieldContractID] = struct{}{}
}

// ContractIDCleared returns if the "contract_id" field was cleared in this mutation.
func (m *MemberContractMutation) ContractIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldContractID]
	return ok
}

// ResetContractID resets all changes to the "contract_id" field.
func (m *MemberContractMutation) ResetContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	delete(m.clearedFields, membercontract.FieldContractID)
}

// SetOrderID sets the "order_id" field.
func (m *MemberContractMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MemberContractMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MemberContractMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[membercontract.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MemberContractMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MemberContractMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, membercontract.FieldOrderID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberContractMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberContractMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberContractMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberContractMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberContractMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[membercontract.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberContractMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberContractMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, membercontract.FieldVenueID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *MemberContractMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *MemberContractMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *MemberContractMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *MemberContractMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *MemberContractMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[membercontract.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *MemberContractMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, membercontract.FieldMemberProductID)
}

// SetName sets the "name" field.
func (m *MemberContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[membercontract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, membercontract.FieldName)
}

// SetSign sets the "sign" field.
func (m *MemberContractMutation) SetSign(s string) {
	m.sign = &s
}

// Sign returns the value of the "sign" field in the mutation.
func (m *MemberContractMutation) Sign() (r string, exists bool) {
	v := m.sign
	if v == nil {
		return
	}
	return *v, true
}

// OldSign returns the old "sign" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldSign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSign: %w", err)
	}
	return oldValue.Sign, nil
}

// ClearSign clears the value of the "sign" field.
func (m *MemberContractMutation) ClearSign() {
	m.sign = nil
	m.clearedFields[membercontract.FieldSign] = struct{}{}
}

// SignCleared returns if the "sign" field was cleared in this mutation.
func (m *MemberContractMutation) SignCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldSign]
	return ok
}

// ResetSign resets all changes to the "sign" field.
func (m *MemberContractMutation) ResetSign() {
	m.sign = nil
	delete(m.clearedFields, membercontract.FieldSign)
}

// AddContentIDs adds the "content" edge to the MemberContractContent entity by ids.
func (m *MemberContractMutation) AddContentIDs(ids ...int64) {
	if m.content == nil {
		m.content = make(map[int64]struct{})
	}
	for i := range ids {
		m.content[ids[i]] = struct{}{}
	}
}

// ClearContent clears the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) ClearContent() {
	m.clearedcontent = true
}

// ContentCleared reports if the "content" edge to the MemberContractContent entity was cleared.
func (m *MemberContractMutation) ContentCleared() bool {
	return m.clearedcontent
}

// RemoveContentIDs removes the "content" edge to the MemberContractContent entity by IDs.
func (m *MemberContractMutation) RemoveContentIDs(ids ...int64) {
	if m.removedcontent == nil {
		m.removedcontent = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.content, ids[i])
		m.removedcontent[ids[i]] = struct{}{}
	}
}

// RemovedContent returns the removed IDs of the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) RemovedContentIDs() (ids []int64) {
	for id := range m.removedcontent {
		ids = append(ids, id)
	}
	return
}

// ContentIDs returns the "content" edge IDs in the mutation.
func (m *MemberContractMutation) ContentIDs() (ids []int64) {
	for id := range m.content {
		ids = append(ids, id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *MemberContractMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
	m.removedcontent = nil
}

// ClearMember clears the "member" edge to the Member entity.
func (m *MemberContractMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *MemberContractMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) MemberIDs() (ids []int64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *MemberContractMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *MemberContractMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[membercontract.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *MemberContractMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *MemberContractMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the MemberContractMutation builder.
func (m *MemberContractMutation) Where(ps ...predicate.MemberContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContract).
func (m *MemberContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, membercontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontract.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.member != nil {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m.contract_id != nil {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m._order != nil {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.venue_id != nil {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.member_product_id != nil {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.name != nil {
		fields = append(fields, membercontract.FieldName)
	}
	if m.sign != nil {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.CreatedAt()
	case membercontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontract.FieldDelete:
		return m.Delete()
	case membercontract.FieldCreatedID:
		return m.CreatedID()
	case membercontract.FieldStatus:
		return m.Status()
	case membercontract.FieldMemberID:
		return m.MemberID()
	case membercontract.FieldContractID:
		return m.ContractID()
	case membercontract.FieldOrderID:
		return m.OrderID()
	case membercontract.FieldVenueID:
		return m.VenueID()
	case membercontract.FieldMemberProductID:
		return m.MemberProductID()
	case membercontract.FieldName:
		return m.Name()
	case membercontract.FieldSign:
		return m.Sign()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontract.FieldDelete:
		return m.OldDelete(ctx)
	case membercontract.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membercontract.FieldStatus:
		return m.OldStatus(ctx)
	case membercontract.FieldMemberID:
		return m.OldMemberID(ctx)
	case membercontract.FieldContractID:
		return m.OldContractID(ctx)
	case membercontract.FieldOrderID:
		return m.OldOrderID(ctx)
	case membercontract.FieldVenueID:
		return m.OldVenueID(ctx)
	case membercontract.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case membercontract.FieldName:
		return m.OldName(ctx)
	case membercontract.FieldSign:
		return m.OldSign(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membercontract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membercontract.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membercontract.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractID(v)
		return nil
	case membercontract.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case membercontract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case membercontract.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case membercontract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case membercontract.FieldSign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSign(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.addcontract_id != nil {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m.addvenue_id != nil {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.addmember_product_id != nil {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldDelete:
		return m.AddedDelete()
	case membercontract.FieldCreatedID:
		return m.AddedCreatedID()
	case membercontract.FieldStatus:
		return m.AddedStatus()
	case membercontract.FieldContractID:
		return m.AddedContractID()
	case membercontract.FieldVenueID:
		return m.AddedVenueID()
	case membercontract.FieldMemberProductID:
		return m.AddedMemberProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membercontract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case membercontract.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractID(v)
		return nil
	case membercontract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case membercontract.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontract.FieldCreatedAt) {
		fields = append(fields, membercontract.FieldCreatedAt)
	}
	if m.FieldCleared(membercontract.FieldUpdatedAt) {
		fields = append(fields, membercontract.FieldUpdatedAt)
	}
	if m.FieldCleared(membercontract.FieldDelete) {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.FieldCleared(membercontract.FieldCreatedID) {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.FieldCleared(membercontract.FieldStatus) {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.FieldCleared(membercontract.FieldMemberID) {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m.FieldCleared(membercontract.FieldContractID) {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m.FieldCleared(membercontract.FieldOrderID) {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.FieldCleared(membercontract.FieldVenueID) {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.FieldCleared(membercontract.FieldMemberProductID) {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.FieldCleared(membercontract.FieldName) {
		fields = append(fields, membercontract.FieldName)
	}
	if m.FieldCleared(membercontract.FieldSign) {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractMutation) ClearField(name string) error {
	switch name {
	case membercontract.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membercontract.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membercontract.FieldDelete:
		m.ClearDelete()
		return nil
	case membercontract.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membercontract.FieldStatus:
		m.ClearStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membercontract.FieldContractID:
		m.ClearContractID()
		return nil
	case membercontract.FieldOrderID:
		m.ClearOrderID()
		return nil
	case membercontract.FieldVenueID:
		m.ClearVenueID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ClearName()
		return nil
	case membercontract.FieldSign:
		m.ClearSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractMutation) ResetField(name string) error {
	switch name {
	case membercontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontract.FieldDelete:
		m.ResetDelete()
		return nil
	case membercontract.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membercontract.FieldStatus:
		m.ResetStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membercontract.FieldContractID:
		m.ResetContractID()
		return nil
	case membercontract.FieldOrderID:
		m.ResetOrderID()
		return nil
	case membercontract.FieldVenueID:
		m.ResetVenueID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ResetName()
		return nil
	case membercontract.FieldSign:
		m.ResetSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.content != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.member != nil {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m._order != nil {
		edges = append(edges, membercontract.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.content))
		for id := range m.content {
			ids = append(ids, id)
		}
		return ids
	case membercontract.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case membercontract.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcontent != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.removedcontent))
		for id := range m.removedcontent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcontent {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.clearedmember {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m.cleared_order {
		edges = append(edges, membercontract.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontract.EdgeContent:
		return m.clearedcontent
	case membercontract.EdgeMember:
		return m.clearedmember
	case membercontract.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractMutation) ClearEdge(name string) error {
	switch name {
	case membercontract.EdgeMember:
		m.ClearMember()
		return nil
	case membercontract.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown MemberContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractMutation) ResetEdge(name string) error {
	switch name {
	case membercontract.EdgeContent:
		m.ResetContent()
		return nil
	case membercontract.EdgeMember:
		m.ResetMember()
		return nil
	case membercontract.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown MemberContract edge %s", name)
}

// MemberContractContentMutation represents an operation that mutates the MemberContractContent nodes in the graph.
type MemberContractContentMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	content         *string
	sign_img        *string
	clearedFields   map[string]struct{}
	contract        *int64
	clearedcontract bool
	done            bool
	oldValue        func(context.Context) (*MemberContractContent, error)
	predicates      []predicate.MemberContractContent
}

var _ ent.Mutation = (*MemberContractContentMutation)(nil)

// membercontractcontentOption allows management of the mutation configuration using functional options.
type membercontractcontentOption func(*MemberContractContentMutation)

// newMemberContractContentMutation creates new mutation for the MemberContractContent entity.
func newMemberContractContentMutation(c config, op Op, opts ...membercontractcontentOption) *MemberContractContentMutation {
	m := &MemberContractContentMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContractContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractContentID sets the ID field of the mutation.
func withMemberContractContentID(id int64) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContractContent
		)
		m.oldValue = func(ctx context.Context) (*MemberContractContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContractContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContractContent sets the old MemberContractContent of the mutation.
func withMemberContractContent(node *MemberContractContent) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		m.oldValue = func(context.Context) (*MemberContractContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContractContent entities.
func (m *MemberContractContentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractContentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractContentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContractContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberContractContentMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membercontractcontent.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberContractContentMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractContentMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membercontractcontent.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberContractContentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membercontractcontent.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberContractContentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membercontractcontent.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberContractContentMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberContractContentMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberContractContentMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberContractContentMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberContractContentMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membercontractcontent.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberContractContentMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberContractContentMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membercontractcontent.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberContractContentMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberContractContentMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberContractContentMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberContractContentMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberContractContentMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membercontractcontent.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberContractContentMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberContractContentMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membercontractcontent.FieldCreatedID)
}

// SetMemberContractID sets the "member_contract_id" field.
func (m *MemberContractContentMutation) SetMemberContractID(i int64) {
	m.contract = &i
}

// MemberContractID returns the value of the "member_contract_id" field in the mutation.
func (m *MemberContractContentMutation) MemberContractID() (r int64, exists bool) {
	v := m.contract
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberContractID returns the old "member_contract_id" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldMemberContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberContractID: %w", err)
	}
	return oldValue.MemberContractID, nil
}

// ClearMemberContractID clears the value of the "member_contract_id" field.
func (m *MemberContractContentMutation) ClearMemberContractID() {
	m.contract = nil
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// MemberContractIDCleared returns if the "member_contract_id" field was cleared in this mutation.
func (m *MemberContractContentMutation) MemberContractIDCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldMemberContractID]
	return ok
}

// ResetMemberContractID resets all changes to the "member_contract_id" field.
func (m *MemberContractContentMutation) ResetMemberContractID() {
	m.contract = nil
	delete(m.clearedFields, membercontractcontent.FieldMemberContractID)
}

// SetContent sets the "content" field.
func (m *MemberContractContentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MemberContractContentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MemberContractContentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[membercontractcontent.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MemberContractContentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MemberContractContentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, membercontractcontent.FieldContent)
}

// SetSignImg sets the "sign_img" field.
func (m *MemberContractContentMutation) SetSignImg(s string) {
	m.sign_img = &s
}

// SignImg returns the value of the "sign_img" field in the mutation.
func (m *MemberContractContentMutation) SignImg() (r string, exists bool) {
	v := m.sign_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSignImg returns the old "sign_img" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldSignImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignImg: %w", err)
	}
	return oldValue.SignImg, nil
}

// ClearSignImg clears the value of the "sign_img" field.
func (m *MemberContractContentMutation) ClearSignImg() {
	m.sign_img = nil
	m.clearedFields[membercontractcontent.FieldSignImg] = struct{}{}
}

// SignImgCleared returns if the "sign_img" field was cleared in this mutation.
func (m *MemberContractContentMutation) SignImgCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldSignImg]
	return ok
}

// ResetSignImg resets all changes to the "sign_img" field.
func (m *MemberContractContentMutation) ResetSignImg() {
	m.sign_img = nil
	delete(m.clearedFields, membercontractcontent.FieldSignImg)
}

// SetContractID sets the "contract" edge to the MemberContract entity by id.
func (m *MemberContractContentMutation) SetContractID(id int64) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the MemberContract entity.
func (m *MemberContractContentMutation) ClearContract() {
	m.clearedcontract = true
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// ContractCleared reports if the "contract" edge to the MemberContract entity was cleared.
func (m *MemberContractContentMutation) ContractCleared() bool {
	return m.MemberContractIDCleared() || m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *MemberContractContentMutation) ContractID() (id int64, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *MemberContractContentMutation) ContractIDs() (ids []int64) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *MemberContractContentMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// Where appends a list predicates to the MemberContractContentMutation builder.
func (m *MemberContractContentMutation) Where(ps ...predicate.MemberContractContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContractContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContractContent).
func (m *MemberContractContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractContentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, membercontractcontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontractcontent.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	if m.contract != nil {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.content != nil {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.sign_img != nil {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.CreatedAt()
	case membercontractcontent.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontractcontent.FieldDelete:
		return m.Delete()
	case membercontractcontent.FieldCreatedID:
		return m.CreatedID()
	case membercontractcontent.FieldMemberContractID:
		return m.MemberContractID()
	case membercontractcontent.FieldContent:
		return m.Content()
	case membercontractcontent.FieldSignImg:
		return m.SignImg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontractcontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontractcontent.FieldDelete:
		return m.OldDelete(ctx)
	case membercontractcontent.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membercontractcontent.FieldMemberContractID:
		return m.OldMemberContractID(ctx)
	case membercontractcontent.FieldContent:
		return m.OldContent(ctx)
	case membercontractcontent.FieldSignImg:
		return m.OldSignImg(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContractContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontractcontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontractcontent.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membercontractcontent.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membercontractcontent.FieldMemberContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberContractID(v)
		return nil
	case membercontractcontent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case membercontractcontent.FieldSignImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignImg(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractContentMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractContentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membercontractcontent.FieldDelete:
		return m.AddedDelete()
	case membercontractcontent.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membercontractcontent.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membercontractcontent.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontractcontent.FieldCreatedAt) {
		fields = append(fields, membercontractcontent.FieldCreatedAt)
	}
	if m.FieldCleared(membercontractcontent.FieldUpdatedAt) {
		fields = append(fields, membercontractcontent.FieldUpdatedAt)
	}
	if m.FieldCleared(membercontractcontent.FieldDelete) {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.FieldCleared(membercontractcontent.FieldCreatedID) {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	if m.FieldCleared(membercontractcontent.FieldMemberContractID) {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.FieldCleared(membercontractcontent.FieldContent) {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.FieldCleared(membercontractcontent.FieldSignImg) {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ClearField(name string) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membercontractcontent.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membercontractcontent.FieldDelete:
		m.ClearDelete()
		return nil
	case membercontractcontent.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membercontractcontent.FieldMemberContractID:
		m.ClearMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ClearContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ClearSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ResetField(name string) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontractcontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontractcontent.FieldDelete:
		m.ResetDelete()
		return nil
	case membercontractcontent.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membercontractcontent.FieldMemberContractID:
		m.ResetMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ResetContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ResetSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contract != nil {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontractcontent.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontract {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractContentMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontractcontent.EdgeContract:
		return m.clearedcontract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractContentMutation) ClearEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractContentMutation) ResetEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ResetContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent edge %s", name)
}

// MemberDetailsMutation represents an operation that mutates the MemberDetails nodes in the graph.
type MemberDetailsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete              *int64
	adddelete           *int64
	created_id          *int64
	addcreated_id       *int64
	email               *string
	wecom               *string
	gender              *int64
	addgender           *int64
	birthday            *time.Time
	money_sum           *float64
	addmoney_sum        *float64
	product_id          *int64
	addproduct_id       *int64
	product_name        *string
	product_venue       *int64
	addproduct_venue    *int64
	product_venue_name  *string
	entry_sum           *int64
	addentry_sum        *int64
	entry_last_time     *time.Time
	entry_deadline_time *time.Time
	class_last_time     *time.Time
	relation_uid        *int64
	addrelation_uid     *int64
	relation_uname      *string
	relation_mid        *int64
	addrelation_mid     *int64
	relation_mame       *string
	create_id           *int64
	addcreate_id        *int64
	create_name         *string
	clearedFields       map[string]struct{}
	info                *int64
	clearedinfo         bool
	done                bool
	oldValue            func(context.Context) (*MemberDetails, error)
	predicates          []predicate.MemberDetails
}

var _ ent.Mutation = (*MemberDetailsMutation)(nil)

// memberdetailsOption allows management of the mutation configuration using functional options.
type memberdetailsOption func(*MemberDetailsMutation)

// newMemberDetailsMutation creates new mutation for the MemberDetails entity.
func newMemberDetailsMutation(c config, op Op, opts ...memberdetailsOption) *MemberDetailsMutation {
	m := &MemberDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberDetailsID sets the ID field of the mutation.
func withMemberDetailsID(id int64) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberDetails
		)
		m.oldValue = func(ctx context.Context) (*MemberDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberDetails sets the old MemberDetails of the mutation.
func withMemberDetails(node *MemberDetails) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		m.oldValue = func(context.Context) (*MemberDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberDetails entities.
func (m *MemberDetailsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberDetailsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberDetailsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberDetailsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberDetailsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberDetailsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberdetails.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberDetailsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberdetails.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberDetailsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberDetailsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberDetailsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberdetails.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberDetailsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberDetailsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberdetails.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberDetailsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberDetailsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberDetailsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberDetailsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberDetailsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberdetails.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberDetailsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberDetailsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberdetails.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberDetailsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberDetailsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberDetailsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberDetailsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberDetailsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberdetails.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberDetailsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberdetails.FieldCreatedID)
}

// SetMemberID sets the "member_id" field.
func (m *MemberDetailsMutation) SetMemberID(i int64) {
	m.info = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberDetailsMutation) MemberID() (r int64, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberDetailsMutation) ClearMemberID() {
	m.info = nil
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberDetailsMutation) ResetMemberID() {
	m.info = nil
	delete(m.clearedFields, memberdetails.FieldMemberID)
}

// SetEmail sets the "email" field.
func (m *MemberDetailsMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberDetailsMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MemberDetailsMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[memberdetails.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MemberDetailsMutation) EmailCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberDetailsMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, memberdetails.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *MemberDetailsMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *MemberDetailsMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *MemberDetailsMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[memberdetails.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *MemberDetailsMutation) WecomCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *MemberDetailsMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, memberdetails.FieldWecom)
}

// SetGender sets the "gender" field.
func (m *MemberDetailsMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *MemberDetailsMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *MemberDetailsMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *MemberDetailsMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *MemberDetailsMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[memberdetails.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *MemberDetailsMutation) GenderCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *MemberDetailsMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, memberdetails.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *MemberDetailsMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *MemberDetailsMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *MemberDetailsMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[memberdetails.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *MemberDetailsMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *MemberDetailsMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, memberdetails.FieldBirthday)
}

// SetMoneySum sets the "money_sum" field.
func (m *MemberDetailsMutation) SetMoneySum(f float64) {
	m.money_sum = &f
	m.addmoney_sum = nil
}

// MoneySum returns the value of the "money_sum" field in the mutation.
func (m *MemberDetailsMutation) MoneySum() (r float64, exists bool) {
	v := m.money_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldMoneySum returns the old "money_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMoneySum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoneySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoneySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoneySum: %w", err)
	}
	return oldValue.MoneySum, nil
}

// AddMoneySum adds f to the "money_sum" field.
func (m *MemberDetailsMutation) AddMoneySum(f float64) {
	if m.addmoney_sum != nil {
		*m.addmoney_sum += f
	} else {
		m.addmoney_sum = &f
	}
}

// AddedMoneySum returns the value that was added to the "money_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedMoneySum() (r float64, exists bool) {
	v := m.addmoney_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearMoneySum clears the value of the "money_sum" field.
func (m *MemberDetailsMutation) ClearMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	m.clearedFields[memberdetails.FieldMoneySum] = struct{}{}
}

// MoneySumCleared returns if the "money_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) MoneySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMoneySum]
	return ok
}

// ResetMoneySum resets all changes to the "money_sum" field.
func (m *MemberDetailsMutation) ResetMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	delete(m.clearedFields, memberdetails.FieldMoneySum)
}

// SetProductID sets the "product_id" field.
func (m *MemberDetailsMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MemberDetailsMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *MemberDetailsMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *MemberDetailsMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *MemberDetailsMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[memberdetails.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MemberDetailsMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, memberdetails.FieldProductID)
}

// SetProductName sets the "product_name" field.
func (m *MemberDetailsMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *MemberDetailsMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *MemberDetailsMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[memberdetails.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *MemberDetailsMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, memberdetails.FieldProductName)
}

// SetProductVenue sets the "product_venue" field.
func (m *MemberDetailsMutation) SetProductVenue(i int64) {
	m.product_venue = &i
	m.addproduct_venue = nil
}

// ProductVenue returns the value of the "product_venue" field in the mutation.
func (m *MemberDetailsMutation) ProductVenue() (r int64, exists bool) {
	v := m.product_venue
	if v == nil {
		return
	}
	return *v, true
}

// OldProductVenue returns the old "product_venue" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductVenue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductVenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductVenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductVenue: %w", err)
	}
	return oldValue.ProductVenue, nil
}

// AddProductVenue adds i to the "product_venue" field.
func (m *MemberDetailsMutation) AddProductVenue(i int64) {
	if m.addproduct_venue != nil {
		*m.addproduct_venue += i
	} else {
		m.addproduct_venue = &i
	}
}

// AddedProductVenue returns the value that was added to the "product_venue" field in this mutation.
func (m *MemberDetailsMutation) AddedProductVenue() (r int64, exists bool) {
	v := m.addproduct_venue
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductVenue clears the value of the "product_venue" field.
func (m *MemberDetailsMutation) ClearProductVenue() {
	m.product_venue = nil
	m.addproduct_venue = nil
	m.clearedFields[memberdetails.FieldProductVenue] = struct{}{}
}

// ProductVenueCleared returns if the "product_venue" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductVenueCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductVenue]
	return ok
}

// ResetProductVenue resets all changes to the "product_venue" field.
func (m *MemberDetailsMutation) ResetProductVenue() {
	m.product_venue = nil
	m.addproduct_venue = nil
	delete(m.clearedFields, memberdetails.FieldProductVenue)
}

// SetProductVenueName sets the "product_venue_name" field.
func (m *MemberDetailsMutation) SetProductVenueName(s string) {
	m.product_venue_name = &s
}

// ProductVenueName returns the value of the "product_venue_name" field in the mutation.
func (m *MemberDetailsMutation) ProductVenueName() (r string, exists bool) {
	v := m.product_venue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductVenueName returns the old "product_venue_name" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductVenueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductVenueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductVenueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductVenueName: %w", err)
	}
	return oldValue.ProductVenueName, nil
}

// ClearProductVenueName clears the value of the "product_venue_name" field.
func (m *MemberDetailsMutation) ClearProductVenueName() {
	m.product_venue_name = nil
	m.clearedFields[memberdetails.FieldProductVenueName] = struct{}{}
}

// ProductVenueNameCleared returns if the "product_venue_name" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductVenueNameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductVenueName]
	return ok
}

// ResetProductVenueName resets all changes to the "product_venue_name" field.
func (m *MemberDetailsMutation) ResetProductVenueName() {
	m.product_venue_name = nil
	delete(m.clearedFields, memberdetails.FieldProductVenueName)
}

// SetEntrySum sets the "entry_sum" field.
func (m *MemberDetailsMutation) SetEntrySum(i int64) {
	m.entry_sum = &i
	m.addentry_sum = nil
}

// EntrySum returns the value of the "entry_sum" field in the mutation.
func (m *MemberDetailsMutation) EntrySum() (r int64, exists bool) {
	v := m.entry_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldEntrySum returns the old "entry_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntrySum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntrySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntrySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntrySum: %w", err)
	}
	return oldValue.EntrySum, nil
}

// AddEntrySum adds i to the "entry_sum" field.
func (m *MemberDetailsMutation) AddEntrySum(i int64) {
	if m.addentry_sum != nil {
		*m.addentry_sum += i
	} else {
		m.addentry_sum = &i
	}
}

// AddedEntrySum returns the value that was added to the "entry_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedEntrySum() (r int64, exists bool) {
	v := m.addentry_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearEntrySum clears the value of the "entry_sum" field.
func (m *MemberDetailsMutation) ClearEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	m.clearedFields[memberdetails.FieldEntrySum] = struct{}{}
}

// EntrySumCleared returns if the "entry_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntrySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntrySum]
	return ok
}

// ResetEntrySum resets all changes to the "entry_sum" field.
func (m *MemberDetailsMutation) ResetEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	delete(m.clearedFields, memberdetails.FieldEntrySum)
}

// SetEntryLastTime sets the "entry_last_time" field.
func (m *MemberDetailsMutation) SetEntryLastTime(t time.Time) {
	m.entry_last_time = &t
}

// EntryLastTime returns the value of the "entry_last_time" field in the mutation.
func (m *MemberDetailsMutation) EntryLastTime() (r time.Time, exists bool) {
	v := m.entry_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryLastTime returns the old "entry_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryLastTime: %w", err)
	}
	return oldValue.EntryLastTime, nil
}

// ClearEntryLastTime clears the value of the "entry_last_time" field.
func (m *MemberDetailsMutation) ClearEntryLastTime() {
	m.entry_last_time = nil
	m.clearedFields[memberdetails.FieldEntryLastTime] = struct{}{}
}

// EntryLastTimeCleared returns if the "entry_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryLastTime]
	return ok
}

// ResetEntryLastTime resets all changes to the "entry_last_time" field.
func (m *MemberDetailsMutation) ResetEntryLastTime() {
	m.entry_last_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryLastTime)
}

// SetEntryDeadlineTime sets the "entry_deadline_time" field.
func (m *MemberDetailsMutation) SetEntryDeadlineTime(t time.Time) {
	m.entry_deadline_time = &t
}

// EntryDeadlineTime returns the value of the "entry_deadline_time" field in the mutation.
func (m *MemberDetailsMutation) EntryDeadlineTime() (r time.Time, exists bool) {
	v := m.entry_deadline_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryDeadlineTime returns the old "entry_deadline_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryDeadlineTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryDeadlineTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryDeadlineTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryDeadlineTime: %w", err)
	}
	return oldValue.EntryDeadlineTime, nil
}

// ClearEntryDeadlineTime clears the value of the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ClearEntryDeadlineTime() {
	m.entry_deadline_time = nil
	m.clearedFields[memberdetails.FieldEntryDeadlineTime] = struct{}{}
}

// EntryDeadlineTimeCleared returns if the "entry_deadline_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryDeadlineTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryDeadlineTime]
	return ok
}

// ResetEntryDeadlineTime resets all changes to the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ResetEntryDeadlineTime() {
	m.entry_deadline_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryDeadlineTime)
}

// SetClassLastTime sets the "class_last_time" field.
func (m *MemberDetailsMutation) SetClassLastTime(t time.Time) {
	m.class_last_time = &t
}

// ClassLastTime returns the value of the "class_last_time" field in the mutation.
func (m *MemberDetailsMutation) ClassLastTime() (r time.Time, exists bool) {
	v := m.class_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClassLastTime returns the old "class_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldClassLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassLastTime: %w", err)
	}
	return oldValue.ClassLastTime, nil
}

// ClearClassLastTime clears the value of the "class_last_time" field.
func (m *MemberDetailsMutation) ClearClassLastTime() {
	m.class_last_time = nil
	m.clearedFields[memberdetails.FieldClassLastTime] = struct{}{}
}

// ClassLastTimeCleared returns if the "class_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) ClassLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldClassLastTime]
	return ok
}

// ResetClassLastTime resets all changes to the "class_last_time" field.
func (m *MemberDetailsMutation) ResetClassLastTime() {
	m.class_last_time = nil
	delete(m.clearedFields, memberdetails.FieldClassLastTime)
}

// SetRelationUID sets the "relation_uid" field.
func (m *MemberDetailsMutation) SetRelationUID(i int64) {
	m.relation_uid = &i
	m.addrelation_uid = nil
}

// RelationUID returns the value of the "relation_uid" field in the mutation.
func (m *MemberDetailsMutation) RelationUID() (r int64, exists bool) {
	v := m.relation_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationUID returns the old "relation_uid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationUID: %w", err)
	}
	return oldValue.RelationUID, nil
}

// AddRelationUID adds i to the "relation_uid" field.
func (m *MemberDetailsMutation) AddRelationUID(i int64) {
	if m.addrelation_uid != nil {
		*m.addrelation_uid += i
	} else {
		m.addrelation_uid = &i
	}
}

// AddedRelationUID returns the value that was added to the "relation_uid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationUID() (r int64, exists bool) {
	v := m.addrelation_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationUID clears the value of the "relation_uid" field.
func (m *MemberDetailsMutation) ClearRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	m.clearedFields[memberdetails.FieldRelationUID] = struct{}{}
}

// RelationUIDCleared returns if the "relation_uid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationUIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationUID]
	return ok
}

// ResetRelationUID resets all changes to the "relation_uid" field.
func (m *MemberDetailsMutation) ResetRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	delete(m.clearedFields, memberdetails.FieldRelationUID)
}

// SetRelationUname sets the "relation_uname" field.
func (m *MemberDetailsMutation) SetRelationUname(s string) {
	m.relation_uname = &s
}

// RelationUname returns the value of the "relation_uname" field in the mutation.
func (m *MemberDetailsMutation) RelationUname() (r string, exists bool) {
	v := m.relation_uname
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationUname returns the old "relation_uname" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationUname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationUname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationUname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationUname: %w", err)
	}
	return oldValue.RelationUname, nil
}

// ClearRelationUname clears the value of the "relation_uname" field.
func (m *MemberDetailsMutation) ClearRelationUname() {
	m.relation_uname = nil
	m.clearedFields[memberdetails.FieldRelationUname] = struct{}{}
}

// RelationUnameCleared returns if the "relation_uname" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationUnameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationUname]
	return ok
}

// ResetRelationUname resets all changes to the "relation_uname" field.
func (m *MemberDetailsMutation) ResetRelationUname() {
	m.relation_uname = nil
	delete(m.clearedFields, memberdetails.FieldRelationUname)
}

// SetRelationMid sets the "relation_mid" field.
func (m *MemberDetailsMutation) SetRelationMid(i int64) {
	m.relation_mid = &i
	m.addrelation_mid = nil
}

// RelationMid returns the value of the "relation_mid" field in the mutation.
func (m *MemberDetailsMutation) RelationMid() (r int64, exists bool) {
	v := m.relation_mid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMid returns the old "relation_mid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationMid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMid: %w", err)
	}
	return oldValue.RelationMid, nil
}

// AddRelationMid adds i to the "relation_mid" field.
func (m *MemberDetailsMutation) AddRelationMid(i int64) {
	if m.addrelation_mid != nil {
		*m.addrelation_mid += i
	} else {
		m.addrelation_mid = &i
	}
}

// AddedRelationMid returns the value that was added to the "relation_mid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationMid() (r int64, exists bool) {
	v := m.addrelation_mid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationMid clears the value of the "relation_mid" field.
func (m *MemberDetailsMutation) ClearRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	m.clearedFields[memberdetails.FieldRelationMid] = struct{}{}
}

// RelationMidCleared returns if the "relation_mid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationMidCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationMid]
	return ok
}

// ResetRelationMid resets all changes to the "relation_mid" field.
func (m *MemberDetailsMutation) ResetRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	delete(m.clearedFields, memberdetails.FieldRelationMid)
}

// SetRelationMame sets the "relation_mame" field.
func (m *MemberDetailsMutation) SetRelationMame(s string) {
	m.relation_mame = &s
}

// RelationMame returns the value of the "relation_mame" field in the mutation.
func (m *MemberDetailsMutation) RelationMame() (r string, exists bool) {
	v := m.relation_mame
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMame returns the old "relation_mame" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationMame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMame: %w", err)
	}
	return oldValue.RelationMame, nil
}

// ClearRelationMame clears the value of the "relation_mame" field.
func (m *MemberDetailsMutation) ClearRelationMame() {
	m.relation_mame = nil
	m.clearedFields[memberdetails.FieldRelationMame] = struct{}{}
}

// RelationMameCleared returns if the "relation_mame" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationMameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationMame]
	return ok
}

// ResetRelationMame resets all changes to the "relation_mame" field.
func (m *MemberDetailsMutation) ResetRelationMame() {
	m.relation_mame = nil
	delete(m.clearedFields, memberdetails.FieldRelationMame)
}

// SetCreateID sets the "create_id" field.
func (m *MemberDetailsMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *MemberDetailsMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *MemberDetailsMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *MemberDetailsMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *MemberDetailsMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[memberdetails.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *MemberDetailsMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, memberdetails.FieldCreateID)
}

// SetCreateName sets the "create_name" field.
func (m *MemberDetailsMutation) SetCreateName(s string) {
	m.create_name = &s
}

// CreateName returns the value of the "create_name" field in the mutation.
func (m *MemberDetailsMutation) CreateName() (r string, exists bool) {
	v := m.create_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateName returns the old "create_name" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateName: %w", err)
	}
	return oldValue.CreateName, nil
}

// ClearCreateName clears the value of the "create_name" field.
func (m *MemberDetailsMutation) ClearCreateName() {
	m.create_name = nil
	m.clearedFields[memberdetails.FieldCreateName] = struct{}{}
}

// CreateNameCleared returns if the "create_name" field was cleared in this mutation.
func (m *MemberDetailsMutation) CreateNameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldCreateName]
	return ok
}

// ResetCreateName resets all changes to the "create_name" field.
func (m *MemberDetailsMutation) ResetCreateName() {
	m.create_name = nil
	delete(m.clearedFields, memberdetails.FieldCreateName)
}

// SetInfoID sets the "info" edge to the Member entity by id.
func (m *MemberDetailsMutation) SetInfoID(id int64) {
	m.info = &id
}

// ClearInfo clears the "info" edge to the Member entity.
func (m *MemberDetailsMutation) ClearInfo() {
	m.clearedinfo = true
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// InfoCleared reports if the "info" edge to the Member entity was cleared.
func (m *MemberDetailsMutation) InfoCleared() bool {
	return m.MemberIDCleared() || m.clearedinfo
}

// InfoID returns the "info" edge ID in the mutation.
func (m *MemberDetailsMutation) InfoID() (id int64, exists bool) {
	if m.info != nil {
		return *m.info, true
	}
	return
}

// InfoIDs returns the "info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InfoID instead. It exists only for internal usage by the builders.
func (m *MemberDetailsMutation) InfoIDs() (ids []int64) {
	if id := m.info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInfo resets all changes to the "info" edge.
func (m *MemberDetailsMutation) ResetInfo() {
	m.info = nil
	m.clearedinfo = false
}

// Where appends a list predicates to the MemberDetailsMutation builder.
func (m *MemberDetailsMutation) Where(ps ...predicate.MemberDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberDetails).
func (m *MemberDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberDetailsMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, memberdetails.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberdetails.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberdetails.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberdetails.FieldCreatedID)
	}
	if m.info != nil {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.email != nil {
		fields = append(fields, memberdetails.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, memberdetails.FieldWecom)
	}
	if m.gender != nil {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, memberdetails.FieldBirthday)
	}
	if m.money_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.product_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, memberdetails.FieldProductName)
	}
	if m.product_venue != nil {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.product_venue_name != nil {
		fields = append(fields, memberdetails.FieldProductVenueName)
	}
	if m.entry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.entry_last_time != nil {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.entry_deadline_time != nil {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.class_last_time != nil {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.relation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.relation_uname != nil {
		fields = append(fields, memberdetails.FieldRelationUname)
	}
	if m.relation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.relation_mame != nil {
		fields = append(fields, memberdetails.FieldRelationMame)
	}
	if m.create_id != nil {
		fields = append(fields, memberdetails.FieldCreateID)
	}
	if m.create_name != nil {
		fields = append(fields, memberdetails.FieldCreateName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.CreatedAt()
	case memberdetails.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberdetails.FieldDelete:
		return m.Delete()
	case memberdetails.FieldCreatedID:
		return m.CreatedID()
	case memberdetails.FieldMemberID:
		return m.MemberID()
	case memberdetails.FieldEmail:
		return m.Email()
	case memberdetails.FieldWecom:
		return m.Wecom()
	case memberdetails.FieldGender:
		return m.Gender()
	case memberdetails.FieldBirthday:
		return m.Birthday()
	case memberdetails.FieldMoneySum:
		return m.MoneySum()
	case memberdetails.FieldProductID:
		return m.ProductID()
	case memberdetails.FieldProductName:
		return m.ProductName()
	case memberdetails.FieldProductVenue:
		return m.ProductVenue()
	case memberdetails.FieldProductVenueName:
		return m.ProductVenueName()
	case memberdetails.FieldEntrySum:
		return m.EntrySum()
	case memberdetails.FieldEntryLastTime:
		return m.EntryLastTime()
	case memberdetails.FieldEntryDeadlineTime:
		return m.EntryDeadlineTime()
	case memberdetails.FieldClassLastTime:
		return m.ClassLastTime()
	case memberdetails.FieldRelationUID:
		return m.RelationUID()
	case memberdetails.FieldRelationUname:
		return m.RelationUname()
	case memberdetails.FieldRelationMid:
		return m.RelationMid()
	case memberdetails.FieldRelationMame:
		return m.RelationMame()
	case memberdetails.FieldCreateID:
		return m.CreateID()
	case memberdetails.FieldCreateName:
		return m.CreateName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberdetails.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberdetails.FieldDelete:
		return m.OldDelete(ctx)
	case memberdetails.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberdetails.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberdetails.FieldEmail:
		return m.OldEmail(ctx)
	case memberdetails.FieldWecom:
		return m.OldWecom(ctx)
	case memberdetails.FieldGender:
		return m.OldGender(ctx)
	case memberdetails.FieldBirthday:
		return m.OldBirthday(ctx)
	case memberdetails.FieldMoneySum:
		return m.OldMoneySum(ctx)
	case memberdetails.FieldProductID:
		return m.OldProductID(ctx)
	case memberdetails.FieldProductName:
		return m.OldProductName(ctx)
	case memberdetails.FieldProductVenue:
		return m.OldProductVenue(ctx)
	case memberdetails.FieldProductVenueName:
		return m.OldProductVenueName(ctx)
	case memberdetails.FieldEntrySum:
		return m.OldEntrySum(ctx)
	case memberdetails.FieldEntryLastTime:
		return m.OldEntryLastTime(ctx)
	case memberdetails.FieldEntryDeadlineTime:
		return m.OldEntryDeadlineTime(ctx)
	case memberdetails.FieldClassLastTime:
		return m.OldClassLastTime(ctx)
	case memberdetails.FieldRelationUID:
		return m.OldRelationUID(ctx)
	case memberdetails.FieldRelationUname:
		return m.OldRelationUname(ctx)
	case memberdetails.FieldRelationMid:
		return m.OldRelationMid(ctx)
	case memberdetails.FieldRelationMame:
		return m.OldRelationMame(ctx)
	case memberdetails.FieldCreateID:
		return m.OldCreateID(ctx)
	case memberdetails.FieldCreateName:
		return m.OldCreateName(ctx)
	}
	return nil, fmt.Errorf("unknown MemberDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberdetails.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberdetails.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberdetails.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberdetails.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberdetails.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case memberdetails.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case memberdetails.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case memberdetails.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case memberdetails.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case memberdetails.FieldProductVenue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductVenue(v)
		return nil
	case memberdetails.FieldProductVenueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductVenueName(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntrySum(v)
		return nil
	case memberdetails.FieldEntryLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryLastTime(v)
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryDeadlineTime(v)
		return nil
	case memberdetails.FieldClassLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassLastTime(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationUID(v)
		return nil
	case memberdetails.FieldRelationUname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationUname(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMid(v)
		return nil
	case memberdetails.FieldRelationMame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMame(v)
		return nil
	case memberdetails.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	case memberdetails.FieldCreateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateName(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberDetailsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberdetails.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberdetails.FieldCreatedID)
	}
	if m.addgender != nil {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.addmoney_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.addproduct_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.addproduct_venue != nil {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.addentry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.addrelation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.addrelation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.addcreate_id != nil {
		fields = append(fields, memberdetails.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldDelete:
		return m.AddedDelete()
	case memberdetails.FieldCreatedID:
		return m.AddedCreatedID()
	case memberdetails.FieldGender:
		return m.AddedGender()
	case memberdetails.FieldMoneySum:
		return m.AddedMoneySum()
	case memberdetails.FieldProductID:
		return m.AddedProductID()
	case memberdetails.FieldProductVenue:
		return m.AddedProductVenue()
	case memberdetails.FieldEntrySum:
		return m.AddedEntrySum()
	case memberdetails.FieldRelationUID:
		return m.AddedRelationUID()
	case memberdetails.FieldRelationMid:
		return m.AddedRelationMid()
	case memberdetails.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberdetails.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberdetails.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case memberdetails.FieldProductVenue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductVenue(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntrySum(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationUID(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationMid(v)
		return nil
	case memberdetails.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberdetails.FieldCreatedAt) {
		fields = append(fields, memberdetails.FieldCreatedAt)
	}
	if m.FieldCleared(memberdetails.FieldUpdatedAt) {
		fields = append(fields, memberdetails.FieldUpdatedAt)
	}
	if m.FieldCleared(memberdetails.FieldDelete) {
		fields = append(fields, memberdetails.FieldDelete)
	}
	if m.FieldCleared(memberdetails.FieldCreatedID) {
		fields = append(fields, memberdetails.FieldCreatedID)
	}
	if m.FieldCleared(memberdetails.FieldMemberID) {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.FieldCleared(memberdetails.FieldEmail) {
		fields = append(fields, memberdetails.FieldEmail)
	}
	if m.FieldCleared(memberdetails.FieldWecom) {
		fields = append(fields, memberdetails.FieldWecom)
	}
	if m.FieldCleared(memberdetails.FieldGender) {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.FieldCleared(memberdetails.FieldBirthday) {
		fields = append(fields, memberdetails.FieldBirthday)
	}
	if m.FieldCleared(memberdetails.FieldMoneySum) {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.FieldCleared(memberdetails.FieldProductID) {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.FieldCleared(memberdetails.FieldProductName) {
		fields = append(fields, memberdetails.FieldProductName)
	}
	if m.FieldCleared(memberdetails.FieldProductVenue) {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.FieldCleared(memberdetails.FieldProductVenueName) {
		fields = append(fields, memberdetails.FieldProductVenueName)
	}
	if m.FieldCleared(memberdetails.FieldEntrySum) {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.FieldCleared(memberdetails.FieldEntryLastTime) {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.FieldCleared(memberdetails.FieldEntryDeadlineTime) {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.FieldCleared(memberdetails.FieldClassLastTime) {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.FieldCleared(memberdetails.FieldRelationUID) {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.FieldCleared(memberdetails.FieldRelationUname) {
		fields = append(fields, memberdetails.FieldRelationUname)
	}
	if m.FieldCleared(memberdetails.FieldRelationMid) {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	if m.FieldCleared(memberdetails.FieldRelationMame) {
		fields = append(fields, memberdetails.FieldRelationMame)
	}
	if m.FieldCleared(memberdetails.FieldCreateID) {
		fields = append(fields, memberdetails.FieldCreateID)
	}
	if m.FieldCleared(memberdetails.FieldCreateName) {
		fields = append(fields, memberdetails.FieldCreateName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ClearField(name string) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberdetails.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberdetails.FieldDelete:
		m.ClearDelete()
		return nil
	case memberdetails.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberdetails.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberdetails.FieldEmail:
		m.ClearEmail()
		return nil
	case memberdetails.FieldWecom:
		m.ClearWecom()
		return nil
	case memberdetails.FieldGender:
		m.ClearGender()
		return nil
	case memberdetails.FieldBirthday:
		m.ClearBirthday()
		return nil
	case memberdetails.FieldMoneySum:
		m.ClearMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ClearProductID()
		return nil
	case memberdetails.FieldProductName:
		m.ClearProductName()
		return nil
	case memberdetails.FieldProductVenue:
		m.ClearProductVenue()
		return nil
	case memberdetails.FieldProductVenueName:
		m.ClearProductVenueName()
		return nil
	case memberdetails.FieldEntrySum:
		m.ClearEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ClearEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ClearEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ClearClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ClearRelationUID()
		return nil
	case memberdetails.FieldRelationUname:
		m.ClearRelationUname()
		return nil
	case memberdetails.FieldRelationMid:
		m.ClearRelationMid()
		return nil
	case memberdetails.FieldRelationMame:
		m.ClearRelationMame()
		return nil
	case memberdetails.FieldCreateID:
		m.ClearCreateID()
		return nil
	case memberdetails.FieldCreateName:
		m.ClearCreateName()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ResetField(name string) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberdetails.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberdetails.FieldDelete:
		m.ResetDelete()
		return nil
	case memberdetails.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberdetails.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberdetails.FieldEmail:
		m.ResetEmail()
		return nil
	case memberdetails.FieldWecom:
		m.ResetWecom()
		return nil
	case memberdetails.FieldGender:
		m.ResetGender()
		return nil
	case memberdetails.FieldBirthday:
		m.ResetBirthday()
		return nil
	case memberdetails.FieldMoneySum:
		m.ResetMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ResetProductID()
		return nil
	case memberdetails.FieldProductName:
		m.ResetProductName()
		return nil
	case memberdetails.FieldProductVenue:
		m.ResetProductVenue()
		return nil
	case memberdetails.FieldProductVenueName:
		m.ResetProductVenueName()
		return nil
	case memberdetails.FieldEntrySum:
		m.ResetEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ResetEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ResetEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ResetClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ResetRelationUID()
		return nil
	case memberdetails.FieldRelationUname:
		m.ResetRelationUname()
		return nil
	case memberdetails.FieldRelationMid:
		m.ResetRelationMid()
		return nil
	case memberdetails.FieldRelationMame:
		m.ResetRelationMame()
		return nil
	case memberdetails.FieldCreateID:
		m.ResetCreateID()
		return nil
	case memberdetails.FieldCreateName:
		m.ResetCreateName()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.info != nil {
		edges = append(edges, memberdetails.EdgeInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberdetails.EdgeInfo:
		if id := m.info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinfo {
		edges = append(edges, memberdetails.EdgeInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case memberdetails.EdgeInfo:
		return m.clearedinfo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberDetailsMutation) ClearEdge(name string) error {
	switch name {
	case memberdetails.EdgeInfo:
		m.ClearInfo()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberDetailsMutation) ResetEdge(name string) error {
	switch name {
	case memberdetails.EdgeInfo:
		m.ResetInfo()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails edge %s", name)
}

// MemberNoteMutation represents an operation that mutates the MemberNote nodes in the graph.
type MemberNoteMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	note          *string
	clearedFields map[string]struct{}
	notes         *int64
	clearednotes  bool
	done          bool
	oldValue      func(context.Context) (*MemberNote, error)
	predicates    []predicate.MemberNote
}

var _ ent.Mutation = (*MemberNoteMutation)(nil)

// membernoteOption allows management of the mutation configuration using functional options.
type membernoteOption func(*MemberNoteMutation)

// newMemberNoteMutation creates new mutation for the MemberNote entity.
func newMemberNoteMutation(c config, op Op, opts ...membernoteOption) *MemberNoteMutation {
	m := &MemberNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberNoteID sets the ID field of the mutation.
func withMemberNoteID(id int64) membernoteOption {
	return func(m *MemberNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberNote
		)
		m.oldValue = func(ctx context.Context) (*MemberNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberNote sets the old MemberNote of the mutation.
func withMemberNote(node *MemberNote) membernoteOption {
	return func(m *MemberNoteMutation) {
		m.oldValue = func(context.Context) (*MemberNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberNote entities.
func (m *MemberNoteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberNoteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberNoteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberNoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberNoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberNoteMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membernote.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberNoteMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membernote.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberNoteMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membernote.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberNoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberNoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberNoteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membernote.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberNoteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membernote.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberNoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membernote.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberNoteMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberNoteMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberNoteMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberNoteMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberNoteMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membernote.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberNoteMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberNoteMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membernote.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberNoteMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberNoteMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberNoteMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberNoteMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberNoteMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membernote.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberNoteMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberNoteMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membernote.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberNoteMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberNoteMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberNoteMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberNoteMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberNoteMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membernote.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberNoteMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membernote.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberNoteMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membernote.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberNoteMutation) SetMemberID(i int64) {
	m.notes = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberNoteMutation) MemberID() (r int64, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberNoteMutation) ClearMemberID() {
	m.notes = nil
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberNoteMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberNoteMutation) ResetMemberID() {
	m.notes = nil
	delete(m.clearedFields, membernote.FieldMemberID)
}

// SetNote sets the "note" field.
func (m *MemberNoteMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MemberNoteMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *MemberNoteMutation) ClearNote() {
	m.note = nil
	m.clearedFields[membernote.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *MemberNoteMutation) NoteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *MemberNoteMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, membernote.FieldNote)
}

// SetNotesID sets the "notes" edge to the Member entity by id.
func (m *MemberNoteMutation) SetNotesID(id int64) {
	m.notes = &id
}

// ClearNotes clears the "notes" edge to the Member entity.
func (m *MemberNoteMutation) ClearNotes() {
	m.clearednotes = true
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// NotesCleared reports if the "notes" edge to the Member entity was cleared.
func (m *MemberNoteMutation) NotesCleared() bool {
	return m.MemberIDCleared() || m.clearednotes
}

// NotesID returns the "notes" edge ID in the mutation.
func (m *MemberNoteMutation) NotesID() (id int64, exists bool) {
	if m.notes != nil {
		return *m.notes, true
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotesID instead. It exists only for internal usage by the builders.
func (m *MemberNoteMutation) NotesIDs() (ids []int64) {
	if id := m.notes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *MemberNoteMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
}

// Where appends a list predicates to the MemberNoteMutation builder.
func (m *MemberNoteMutation) Where(ps ...predicate.MemberNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberNote).
func (m *MemberNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberNoteMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.note != nil {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.CreatedAt()
	case membernote.FieldUpdatedAt:
		return m.UpdatedAt()
	case membernote.FieldDelete:
		return m.Delete()
	case membernote.FieldCreatedID:
		return m.CreatedID()
	case membernote.FieldStatus:
		return m.Status()
	case membernote.FieldMemberID:
		return m.MemberID()
	case membernote.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membernote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membernote.FieldDelete:
		return m.OldDelete(ctx)
	case membernote.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membernote.FieldStatus:
		return m.OldStatus(ctx)
	case membernote.FieldMemberID:
		return m.OldMemberID(ctx)
	case membernote.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown MemberNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membernote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membernote.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membernote.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membernote.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membernote.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberNoteMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberNoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldDelete:
		return m.AddedDelete()
	case membernote.FieldCreatedID:
		return m.AddedCreatedID()
	case membernote.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membernote.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberNoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membernote.FieldCreatedAt) {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.FieldCleared(membernote.FieldUpdatedAt) {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.FieldCleared(membernote.FieldDelete) {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.FieldCleared(membernote.FieldCreatedID) {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.FieldCleared(membernote.FieldStatus) {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.FieldCleared(membernote.FieldMemberID) {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.FieldCleared(membernote.FieldNote) {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberNoteMutation) ClearField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membernote.FieldDelete:
		m.ClearDelete()
		return nil
	case membernote.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membernote.FieldStatus:
		m.ClearStatus()
		return nil
	case membernote.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membernote.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberNoteMutation) ResetField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membernote.FieldDelete:
		m.ResetDelete()
		return nil
	case membernote.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membernote.FieldStatus:
		m.ResetStatus()
		return nil
	case membernote.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membernote.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.notes != nil {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membernote.EdgeNotes:
		if id := m.notes; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednotes {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case membernote.EdgeNotes:
		return m.clearednotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberNoteMutation) ClearEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberNoteMutation) ResetEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	_path           *string
	name            *string
	sort            *int64
	addsort         *int64
	disabled        *int64
	adddisabled     *int64
	ignore          *bool
	level           *int64
	addlevel        *int64
	menu_type       *int64
	addmenu_type    *int64
	redirect        *string
	component       *string
	url             *string
	hidden          *bool
	title           *string
	icon            *string
	active_menu     *string
	affix           *bool
	no_cache        *bool
	clearedFields   map[string]struct{}
	roles           map[int64]struct{}
	removedroles    map[int64]struct{}
	clearedroles    bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	params          map[int64]struct{}
	removedparams   map[int64]struct{}
	clearedparams   bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menu.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menu.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menu.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MenuMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MenuMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MenuMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MenuMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MenuMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[menu.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MenuMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[menu.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MenuMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, menu.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MenuMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MenuMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MenuMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MenuMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MenuMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[menu.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MenuMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MenuMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, menu.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MenuMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MenuMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MenuMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MenuMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MenuMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[menu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MenuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[menu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, menu.FieldStatus)
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[menu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[menu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, menu.FieldName)
}

// SetSort sets the "sort" field.
func (m *MenuMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MenuMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *MenuMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MenuMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *MenuMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[menu.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *MenuMutation) SortCleared() bool {
	_, ok := m.clearedFields[menu.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *MenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, menu.FieldSort)
}

// SetDisabled sets the "disabled" field.
func (m *MenuMutation) SetDisabled(i int64) {
	m.disabled = &i
	m.adddisabled = nil
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *MenuMutation) Disabled() (r int64, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDisabled(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// AddDisabled adds i to the "disabled" field.
func (m *MenuMutation) AddDisabled(i int64) {
	if m.adddisabled != nil {
		*m.adddisabled += i
	} else {
		m.adddisabled = &i
	}
}

// AddedDisabled returns the value that was added to the "disabled" field in this mutation.
func (m *MenuMutation) AddedDisabled() (r int64, exists bool) {
	v := m.adddisabled
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabled clears the value of the "disabled" field.
func (m *MenuMutation) ClearDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	m.clearedFields[menu.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *MenuMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[menu.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *MenuMutation) ResetDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	delete(m.clearedFields, menu.FieldDisabled)
}

// SetIgnore sets the "ignore" field.
func (m *MenuMutation) SetIgnore(b bool) {
	m.ignore = &b
}

// Ignore returns the value of the "ignore" field in the mutation.
func (m *MenuMutation) Ignore() (r bool, exists bool) {
	v := m.ignore
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnore returns the old "ignore" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIgnore(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnore: %w", err)
	}
	return oldValue.Ignore, nil
}

// ClearIgnore clears the value of the "ignore" field.
func (m *MenuMutation) ClearIgnore() {
	m.ignore = nil
	m.clearedFields[menu.FieldIgnore] = struct{}{}
}

// IgnoreCleared returns if the "ignore" field was cleared in this mutation.
func (m *MenuMutation) IgnoreCleared() bool {
	_, ok := m.clearedFields[menu.FieldIgnore]
	return ok
}

// ResetIgnore resets all changes to the "ignore" field.
func (m *MenuMutation) ResetIgnore() {
	m.ignore = nil
	delete(m.clearedFields, menu.FieldIgnore)
}

// SetLevel sets the "level" field.
func (m *MenuMutation) SetLevel(i int64) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *MenuMutation) Level() (r int64, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldLevel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *MenuMutation) AddLevel(i int64) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *MenuMutation) AddedLevel() (r int64, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *MenuMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[menu.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *MenuMutation) LevelCleared() bool {
	_, ok := m.clearedFields[menu.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *MenuMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, menu.FieldLevel)
}

// SetMenuType sets the "menu_type" field.
func (m *MenuMutation) SetMenuType(i int64) {
	m.menu_type = &i
	m.addmenu_type = nil
}

// MenuType returns the value of the "menu_type" field in the mutation.
func (m *MenuMutation) MenuType() (r int64, exists bool) {
	v := m.menu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuType returns the old "menu_type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuType: %w", err)
	}
	return oldValue.MenuType, nil
}

// AddMenuType adds i to the "menu_type" field.
func (m *MenuMutation) AddMenuType(i int64) {
	if m.addmenu_type != nil {
		*m.addmenu_type += i
	} else {
		m.addmenu_type = &i
	}
}

// AddedMenuType returns the value that was added to the "menu_type" field in this mutation.
func (m *MenuMutation) AddedMenuType() (r int64, exists bool) {
	v := m.addmenu_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearMenuType clears the value of the "menu_type" field.
func (m *MenuMutation) ClearMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
	m.clearedFields[menu.FieldMenuType] = struct{}{}
}

// MenuTypeCleared returns if the "menu_type" field was cleared in this mutation.
func (m *MenuMutation) MenuTypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldMenuType]
	return ok
}

// ResetMenuType resets all changes to the "menu_type" field.
func (m *MenuMutation) ResetMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
	delete(m.clearedFields, menu.FieldMenuType)
}

// SetRedirect sets the "redirect" field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of the "redirect" field.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the "redirect" field was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetURL sets the "url" field.
func (m *MenuMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *MenuMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *MenuMutation) ClearURL() {
	m.url = nil
	m.clearedFields[menu.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *MenuMutation) URLCleared() bool {
	_, ok := m.clearedFields[menu.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *MenuMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, menu.FieldURL)
}

// SetHidden sets the "hidden" field.
func (m *MenuMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *MenuMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *MenuMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[menu.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *MenuMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[menu.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *MenuMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, menu.FieldHidden)
}

// SetTitle sets the "title" field.
func (m *MenuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MenuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *MenuMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[menu.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *MenuMutation) TitleCleared() bool {
	_, ok := m.clearedFields[menu.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *MenuMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, menu.FieldTitle)
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetActiveMenu sets the "active_menu" field.
func (m *MenuMutation) SetActiveMenu(s string) {
	m.active_menu = &s
}

// ActiveMenu returns the value of the "active_menu" field in the mutation.
func (m *MenuMutation) ActiveMenu() (r string, exists bool) {
	v := m.active_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveMenu returns the old "active_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldActiveMenu(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveMenu: %w", err)
	}
	return oldValue.ActiveMenu, nil
}

// ClearActiveMenu clears the value of the "active_menu" field.
func (m *MenuMutation) ClearActiveMenu() {
	m.active_menu = nil
	m.clearedFields[menu.FieldActiveMenu] = struct{}{}
}

// ActiveMenuCleared returns if the "active_menu" field was cleared in this mutation.
func (m *MenuMutation) ActiveMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldActiveMenu]
	return ok
}

// ResetActiveMenu resets all changes to the "active_menu" field.
func (m *MenuMutation) ResetActiveMenu() {
	m.active_menu = nil
	delete(m.clearedFields, menu.FieldActiveMenu)
}

// SetAffix sets the "affix" field.
func (m *MenuMutation) SetAffix(b bool) {
	m.affix = &b
}

// Affix returns the value of the "affix" field in the mutation.
func (m *MenuMutation) Affix() (r bool, exists bool) {
	v := m.affix
	if v == nil {
		return
	}
	return *v, true
}

// OldAffix returns the old "affix" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldAffix(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffix: %w", err)
	}
	return oldValue.Affix, nil
}

// ClearAffix clears the value of the "affix" field.
func (m *MenuMutation) ClearAffix() {
	m.affix = nil
	m.clearedFields[menu.FieldAffix] = struct{}{}
}

// AffixCleared returns if the "affix" field was cleared in this mutation.
func (m *MenuMutation) AffixCleared() bool {
	_, ok := m.clearedFields[menu.FieldAffix]
	return ok
}

// ResetAffix resets all changes to the "affix" field.
func (m *MenuMutation) ResetAffix() {
	m.affix = nil
	delete(m.clearedFields, menu.FieldAffix)
}

// SetNoCache sets the "no_cache" field.
func (m *MenuMutation) SetNoCache(b bool) {
	m.no_cache = &b
}

// NoCache returns the value of the "no_cache" field in the mutation.
func (m *MenuMutation) NoCache() (r bool, exists bool) {
	v := m.no_cache
	if v == nil {
		return
	}
	return *v, true
}

// OldNoCache returns the old "no_cache" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldNoCache(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoCache is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoCache requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoCache: %w", err)
	}
	return oldValue.NoCache, nil
}

// ClearNoCache clears the value of the "no_cache" field.
func (m *MenuMutation) ClearNoCache() {
	m.no_cache = nil
	m.clearedFields[menu.FieldNoCache] = struct{}{}
}

// NoCacheCleared returns if the "no_cache" field was cleared in this mutation.
func (m *MenuMutation) NoCacheCleared() bool {
	_, ok := m.clearedFields[menu.FieldNoCache]
	return ok
}

// ResetNoCache resets all changes to the "no_cache" field.
func (m *MenuMutation) ResetNoCache() {
	m.no_cache = nil
	delete(m.clearedFields, menu.FieldNoCache)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddParamIDs adds the "params" edge to the MenuParam entity by ids.
func (m *MenuMutation) AddParamIDs(ids ...int64) {
	if m.params == nil {
		m.params = make(map[int64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the MenuParam entity.
func (m *MenuMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the MenuParam entity was cleared.
func (m *MenuMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the MenuParam entity by IDs.
func (m *MenuMutation) RemoveParamIDs(ids ...int64) {
	if m.removedparams == nil {
		m.removedparams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the MenuParam entity.
func (m *MenuMutation) RemovedParamsIDs() (ids []int64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *MenuMutation) ParamsIDs() (ids []int64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *MenuMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.disabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.ignore != nil {
		fields = append(fields, menu.FieldIgnore)
	}
	if m.level != nil {
		fields = append(fields, menu.FieldLevel)
	}
	if m.menu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.url != nil {
		fields = append(fields, menu.FieldURL)
	}
	if m.hidden != nil {
		fields = append(fields, menu.FieldHidden)
	}
	if m.title != nil {
		fields = append(fields, menu.FieldTitle)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.active_menu != nil {
		fields = append(fields, menu.FieldActiveMenu)
	}
	if m.affix != nil {
		fields = append(fields, menu.FieldAffix)
	}
	if m.no_cache != nil {
		fields = append(fields, menu.FieldNoCache)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldDelete:
		return m.Delete()
	case menu.FieldCreatedID:
		return m.CreatedID()
	case menu.FieldStatus:
		return m.Status()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldSort:
		return m.Sort()
	case menu.FieldDisabled:
		return m.Disabled()
	case menu.FieldIgnore:
		return m.Ignore()
	case menu.FieldLevel:
		return m.Level()
	case menu.FieldMenuType:
		return m.MenuType()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldURL:
		return m.URL()
	case menu.FieldHidden:
		return m.Hidden()
	case menu.FieldTitle:
		return m.Title()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldActiveMenu:
		return m.ActiveMenu()
	case menu.FieldAffix:
		return m.Affix()
	case menu.FieldNoCache:
		return m.NoCache()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldDelete:
		return m.OldDelete(ctx)
	case menu.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case menu.FieldStatus:
		return m.OldStatus(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldSort:
		return m.OldSort(ctx)
	case menu.FieldDisabled:
		return m.OldDisabled(ctx)
	case menu.FieldIgnore:
		return m.OldIgnore(ctx)
	case menu.FieldLevel:
		return m.OldLevel(ctx)
	case menu.FieldMenuType:
		return m.OldMenuType(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldURL:
		return m.OldURL(ctx)
	case menu.FieldHidden:
		return m.OldHidden(ctx)
	case menu.FieldTitle:
		return m.OldTitle(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldActiveMenu:
		return m.OldActiveMenu(ctx)
	case menu.FieldAffix:
		return m.OldAffix(ctx)
	case menu.FieldNoCache:
		return m.OldNoCache(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case menu.FieldIgnore:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnore(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuType(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case menu.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case menu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldActiveMenu:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveMenu(v)
		return nil
	case menu.FieldAffix:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffix(v)
		return nil
	case menu.FieldNoCache:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoCache(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.addsort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.adddisabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.addlevel != nil {
		fields = append(fields, menu.FieldLevel)
	}
	if m.addmenu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldDelete:
		return m.AddedDelete()
	case menu.FieldCreatedID:
		return m.AddedCreatedID()
	case menu.FieldStatus:
		return m.AddedStatus()
	case menu.FieldSort:
		return m.AddedSort()
	case menu.FieldDisabled:
		return m.AddedDisabled()
	case menu.FieldLevel:
		return m.AddedLevel()
	case menu.FieldMenuType:
		return m.AddedMenuType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabled(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuType(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldCreatedAt) {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.FieldCleared(menu.FieldUpdatedAt) {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.FieldCleared(menu.FieldDelete) {
		fields = append(fields, menu.FieldDelete)
	}
	if m.FieldCleared(menu.FieldCreatedID) {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.FieldCleared(menu.FieldStatus) {
		fields = append(fields, menu.FieldStatus)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldName) {
		fields = append(fields, menu.FieldName)
	}
	if m.FieldCleared(menu.FieldSort) {
		fields = append(fields, menu.FieldSort)
	}
	if m.FieldCleared(menu.FieldDisabled) {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.FieldCleared(menu.FieldIgnore) {
		fields = append(fields, menu.FieldIgnore)
	}
	if m.FieldCleared(menu.FieldLevel) {
		fields = append(fields, menu.FieldLevel)
	}
	if m.FieldCleared(menu.FieldMenuType) {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldURL) {
		fields = append(fields, menu.FieldURL)
	}
	if m.FieldCleared(menu.FieldHidden) {
		fields = append(fields, menu.FieldHidden)
	}
	if m.FieldCleared(menu.FieldTitle) {
		fields = append(fields, menu.FieldTitle)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldActiveMenu) {
		fields = append(fields, menu.FieldActiveMenu)
	}
	if m.FieldCleared(menu.FieldAffix) {
		fields = append(fields, menu.FieldAffix)
	}
	if m.FieldCleared(menu.FieldNoCache) {
		fields = append(fields, menu.FieldNoCache)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ClearDelete()
		return nil
	case menu.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case menu.FieldStatus:
		m.ClearStatus()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldName:
		m.ClearName()
		return nil
	case menu.FieldSort:
		m.ClearSort()
		return nil
	case menu.FieldDisabled:
		m.ClearDisabled()
		return nil
	case menu.FieldIgnore:
		m.ClearIgnore()
		return nil
	case menu.FieldLevel:
		m.ClearLevel()
		return nil
	case menu.FieldMenuType:
		m.ClearMenuType()
		return nil
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldURL:
		m.ClearURL()
		return nil
	case menu.FieldHidden:
		m.ClearHidden()
		return nil
	case menu.FieldTitle:
		m.ClearTitle()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldActiveMenu:
		m.ClearActiveMenu()
		return nil
	case menu.FieldAffix:
		m.ClearAffix()
		return nil
	case menu.FieldNoCache:
		m.ClearNoCache()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ResetDelete()
		return nil
	case menu.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case menu.FieldStatus:
		m.ResetStatus()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldSort:
		m.ResetSort()
		return nil
	case menu.FieldDisabled:
		m.ResetDisabled()
		return nil
	case menu.FieldIgnore:
		m.ResetIgnore()
		return nil
	case menu.FieldLevel:
		m.ResetLevel()
		return nil
	case menu.FieldMenuType:
		m.ResetMenuType()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldURL:
		m.ResetURL()
		return nil
	case menu.FieldHidden:
		m.ResetHidden()
		return nil
	case menu.FieldTitle:
		m.ResetTitle()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldActiveMenu:
		m.ResetActiveMenu()
		return nil
	case menu.FieldAffix:
		m.ResetAffix()
		return nil
	case menu.FieldNoCache:
		m.ResetNoCache()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.params != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedparams != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedparams {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeParams:
		return m.clearedparams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuParamMutation represents an operation that mutates the MenuParam nodes in the graph.
type MenuParamMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	key           *string
	value         *string
	clearedFields map[string]struct{}
	menus         *int64
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*MenuParam, error)
	predicates    []predicate.MenuParam
}

var _ ent.Mutation = (*MenuParamMutation)(nil)

// menuparamOption allows management of the mutation configuration using functional options.
type menuparamOption func(*MenuParamMutation)

// newMenuParamMutation creates new mutation for the MenuParam entity.
func newMenuParamMutation(c config, op Op, opts ...menuparamOption) *MenuParamMutation {
	m := &MenuParamMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuParamID sets the ID field of the mutation.
func withMenuParamID(id int64) menuparamOption {
	return func(m *MenuParamMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuParam
		)
		m.oldValue = func(ctx context.Context) (*MenuParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuParam sets the old MenuParam of the mutation.
func withMenuParam(node *MenuParam) menuparamOption {
	return func(m *MenuParamMutation) {
		m.oldValue = func(context.Context) (*MenuParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuParam entities.
func (m *MenuParamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuParamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuParamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuParamMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menuparam.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuParamMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuParamMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menuparam.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuParamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menuparam.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuParamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menuparam.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MenuParamMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MenuParamMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MenuParamMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MenuParamMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MenuParamMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[menuparam.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MenuParamMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MenuParamMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, menuparam.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MenuParamMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MenuParamMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MenuParamMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MenuParamMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MenuParamMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[menuparam.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MenuParamMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[menuparam.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MenuParamMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, menuparam.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *MenuParamMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuParamMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MenuParamMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *MenuParamMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *MenuParamMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *MenuParamMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *MenuParamMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MenuParamMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MenuParamMutation) ResetValue() {
	m.value = nil
}

// SetMenusID sets the "menus" edge to the Menu entity by id.
func (m *MenuParamMutation) SetMenusID(id int64) {
	m.menus = &id
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *MenuParamMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *MenuParamMutation) MenusCleared() bool {
	return m.clearedmenus
}

// MenusID returns the "menus" edge ID in the mutation.
func (m *MenuParamMutation) MenusID() (id int64, exists bool) {
	if m.menus != nil {
		return *m.menus, true
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenusID instead. It exists only for internal usage by the builders.
func (m *MenuParamMutation) MenusIDs() (ids []int64) {
	if id := m.menus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *MenuParamMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
}

// Where appends a list predicates to the MenuParamMutation builder.
func (m *MenuParamMutation) Where(ps ...predicate.MenuParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuParam).
func (m *MenuParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuParamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, menuparam.FieldType)
	}
	if m.key != nil {
		fields = append(fields, menuparam.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, menuparam.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.CreatedAt()
	case menuparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuparam.FieldDelete:
		return m.Delete()
	case menuparam.FieldCreatedID:
		return m.CreatedID()
	case menuparam.FieldType:
		return m.GetType()
	case menuparam.FieldKey:
		return m.Key()
	case menuparam.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuparam.FieldDelete:
		return m.OldDelete(ctx)
	case menuparam.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case menuparam.FieldType:
		return m.OldType(ctx)
	case menuparam.FieldKey:
		return m.OldKey(ctx)
	case menuparam.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown MenuParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuparam.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case menuparam.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case menuparam.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menuparam.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case menuparam.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuParamMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuParamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldDelete:
		return m.AddedDelete()
	case menuparam.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case menuparam.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuParamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menuparam.FieldCreatedAt) {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.FieldCleared(menuparam.FieldUpdatedAt) {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m.FieldCleared(menuparam.FieldDelete) {
		fields = append(fields, menuparam.FieldDelete)
	}
	if m.FieldCleared(menuparam.FieldCreatedID) {
		fields = append(fields, menuparam.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuParamMutation) ClearField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menuparam.FieldDelete:
		m.ClearDelete()
		return nil
	case menuparam.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown MenuParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuParamMutation) ResetField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuparam.FieldDelete:
		m.ResetDelete()
		return nil
	case menuparam.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case menuparam.FieldType:
		m.ResetType()
		return nil
	case menuparam.FieldKey:
		m.ResetKey()
		return nil
	case menuparam.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuparam.EdgeMenus:
		if id := m.menus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuParamMutation) EdgeCleared(name string) bool {
	switch name {
	case menuparam.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuParamMutation) ClearEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ClearMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuParamMutation) ResetEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam edge %s", name)
}

// MessagesMutation represents an operation that mutates the Messages nodes in the graph.
type MessagesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	to_user_id    *string
	from_user_id  *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Messages, error)
	predicates    []predicate.Messages
}

var _ ent.Mutation = (*MessagesMutation)(nil)

// messagesOption allows management of the mutation configuration using functional options.
type messagesOption func(*MessagesMutation)

// newMessagesMutation creates new mutation for the Messages entity.
func newMessagesMutation(c config, op Op, opts ...messagesOption) *MessagesMutation {
	m := &MessagesMutation{
		config:        c,
		op:            op,
		typ:           TypeMessages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesID sets the ID field of the mutation.
func withMessagesID(id int64) messagesOption {
	return func(m *MessagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Messages
		)
		m.oldValue = func(ctx context.Context) (*Messages, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Messages.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessages sets the old Messages of the mutation.
func withMessages(node *Messages) messagesOption {
	return func(m *MessagesMutation) {
		m.oldValue = func(context.Context) (*Messages, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Messages entities.
func (m *MessagesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Messages.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MessagesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[messages.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MessagesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, messages.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MessagesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[messages.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MessagesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, messages.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MessagesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MessagesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MessagesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MessagesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MessagesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[messages.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MessagesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[messages.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MessagesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, messages.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MessagesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MessagesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MessagesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MessagesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MessagesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[messages.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MessagesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MessagesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, messages.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *MessagesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessagesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessagesMutation) ResetType() {
	m._type = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *MessagesMutation) SetToUserID(s string) {
	m.to_user_id = &s
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *MessagesMutation) ToUserID() (r string, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldToUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *MessagesMutation) ResetToUserID() {
	m.to_user_id = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *MessagesMutation) SetFromUserID(s string) {
	m.from_user_id = &s
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *MessagesMutation) FromUserID() (r string, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldFromUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *MessagesMutation) ResetFromUserID() {
	m.from_user_id = nil
}

// SetContent sets the "content" field.
func (m *MessagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessagesMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the MessagesMutation builder.
func (m *MessagesMutation) Where(ps ...predicate.Messages) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Messages, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Messages).
func (m *MessagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, messages.FieldType)
	}
	if m.to_user_id != nil {
		fields = append(fields, messages.FieldToUserID)
	}
	if m.from_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.content != nil {
		fields = append(fields, messages.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldCreatedAt:
		return m.CreatedAt()
	case messages.FieldUpdatedAt:
		return m.UpdatedAt()
	case messages.FieldDelete:
		return m.Delete()
	case messages.FieldCreatedID:
		return m.CreatedID()
	case messages.FieldType:
		return m.GetType()
	case messages.FieldToUserID:
		return m.ToUserID()
	case messages.FieldFromUserID:
		return m.FromUserID()
	case messages.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messages.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messages.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messages.FieldDelete:
		return m.OldDelete(ctx)
	case messages.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case messages.FieldType:
		return m.OldType(ctx)
	case messages.FieldToUserID:
		return m.OldToUserID(ctx)
	case messages.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case messages.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Messages field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messages.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messages.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case messages.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case messages.FieldToUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case messages.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldDelete:
		return m.AddedDelete()
	case messages.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown Messages numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(messages.FieldCreatedAt) {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.FieldCleared(messages.FieldUpdatedAt) {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.FieldCleared(messages.FieldDelete) {
		fields = append(fields, messages.FieldDelete)
	}
	if m.FieldCleared(messages.FieldCreatedID) {
		fields = append(fields, messages.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesMutation) ClearField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ClearDelete()
		return nil
	case messages.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown Messages nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesMutation) ResetField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ResetDelete()
		return nil
	case messages.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case messages.FieldType:
		m.ResetType()
		return nil
	case messages.FieldToUserID:
		m.ResetToUserID()
		return nil
	case messages.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case messages.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Messages unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Messages edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	delete                *int64
	adddelete             *int64
	order_sn              *string
	nature                *string
	product_type          *string
	status                *int64
	addstatus             *int64
	source                *string
	device                *string
	completion_at         *time.Time
	clearedFields         map[string]struct{}
	amount                map[int64]struct{}
	removedamount         map[int64]struct{}
	clearedamount         bool
	item                  map[int64]struct{}
	removeditem           map[int64]struct{}
	cleareditem           bool
	pay                   map[int64]struct{}
	removedpay            map[int64]struct{}
	clearedpay            bool
	order_contents        map[int64]struct{}
	removedorder_contents map[int64]struct{}
	clearedorder_contents bool
	sales                 map[int64]struct{}
	removedsales          map[int64]struct{}
	clearedsales          bool
	order_venues          *int64
	clearedorder_venues   bool
	order_members         *int64
	clearedorder_members  bool
	order_creates         *int64
	clearedorder_creates  bool
	done                  bool
	oldValue              func(context.Context) (*Order, error)
	predicates            []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[order.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, order.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[order.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, order.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[order.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[order.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, order.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderMutation) SetCreatedID(i int64) {
	m.order_creates = &i
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderMutation) CreatedID() (r int64, exists bool) {
	v := m.order_creates
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderMutation) ClearCreatedID() {
	m.order_creates = nil
	m.clearedFields[order.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[order.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderMutation) ResetCreatedID() {
	m.order_creates = nil
	delete(m.clearedFields, order.FieldCreatedID)
}

// SetOrderSn sets the "order_sn" field.
func (m *OrderMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *OrderMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *OrderMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[order.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *OrderMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[order.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *OrderMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, order.FieldOrderSn)
}

// SetVenueID sets the "venue_id" field.
func (m *OrderMutation) SetVenueID(i int64) {
	m.order_venues = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *OrderMutation) VenueID() (r int64, exists bool) {
	v := m.order_venues
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *OrderMutation) ClearVenueID() {
	m.order_venues = nil
	m.clearedFields[order.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *OrderMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[order.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *OrderMutation) ResetVenueID() {
	m.order_venues = nil
	delete(m.clearedFields, order.FieldVenueID)
}

// SetMemberID sets the "member_id" field.
func (m *OrderMutation) SetMemberID(i int64) {
	m.order_members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OrderMutation) MemberID() (r int64, exists bool) {
	v := m.order_members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *OrderMutation) ClearMemberID() {
	m.order_members = nil
	m.clearedFields[order.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *OrderMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[order.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OrderMutation) ResetMemberID() {
	m.order_members = nil
	delete(m.clearedFields, order.FieldMemberID)
}

// SetNature sets the "nature" field.
func (m *OrderMutation) SetNature(s string) {
	m.nature = &s
}

// Nature returns the value of the "nature" field in the mutation.
func (m *OrderMutation) Nature() (r string, exists bool) {
	v := m.nature
	if v == nil {
		return
	}
	return *v, true
}

// OldNature returns the old "nature" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNature: %w", err)
	}
	return oldValue.Nature, nil
}

// ClearNature clears the value of the "nature" field.
func (m *OrderMutation) ClearNature() {
	m.nature = nil
	m.clearedFields[order.FieldNature] = struct{}{}
}

// NatureCleared returns if the "nature" field was cleared in this mutation.
func (m *OrderMutation) NatureCleared() bool {
	_, ok := m.clearedFields[order.FieldNature]
	return ok
}

// ResetNature resets all changes to the "nature" field.
func (m *OrderMutation) ResetNature() {
	m.nature = nil
	delete(m.clearedFields, order.FieldNature)
}

// SetProductType sets the "product_type" field.
func (m *OrderMutation) SetProductType(s string) {
	m.product_type = &s
}

// ProductType returns the value of the "product_type" field in the mutation.
func (m *OrderMutation) ProductType() (r string, exists bool) {
	v := m.product_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProductType returns the old "product_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldProductType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductType: %w", err)
	}
	return oldValue.ProductType, nil
}

// ClearProductType clears the value of the "product_type" field.
func (m *OrderMutation) ClearProductType() {
	m.product_type = nil
	m.clearedFields[order.FieldProductType] = struct{}{}
}

// ProductTypeCleared returns if the "product_type" field was cleared in this mutation.
func (m *OrderMutation) ProductTypeCleared() bool {
	_, ok := m.clearedFields[order.FieldProductType]
	return ok
}

// ResetProductType resets all changes to the "product_type" field.
func (m *OrderMutation) ResetProductType() {
	m.product_type = nil
	delete(m.clearedFields, order.FieldProductType)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[order.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[order.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, order.FieldStatus)
}

// SetSource sets the "source" field.
func (m *OrderMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *OrderMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *OrderMutation) ClearSource() {
	m.source = nil
	m.clearedFields[order.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *OrderMutation) SourceCleared() bool {
	_, ok := m.clearedFields[order.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *OrderMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, order.FieldSource)
}

// SetDevice sets the "device" field.
func (m *OrderMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *OrderMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *OrderMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[order.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *OrderMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[order.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *OrderMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, order.FieldDevice)
}

// SetCompletionAt sets the "completion_at" field.
func (m *OrderMutation) SetCompletionAt(t time.Time) {
	m.completion_at = &t
}

// CompletionAt returns the value of the "completion_at" field in the mutation.
func (m *OrderMutation) CompletionAt() (r time.Time, exists bool) {
	v := m.completion_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAt returns the old "completion_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCompletionAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAt: %w", err)
	}
	return oldValue.CompletionAt, nil
}

// ClearCompletionAt clears the value of the "completion_at" field.
func (m *OrderMutation) ClearCompletionAt() {
	m.completion_at = nil
	m.clearedFields[order.FieldCompletionAt] = struct{}{}
}

// CompletionAtCleared returns if the "completion_at" field was cleared in this mutation.
func (m *OrderMutation) CompletionAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCompletionAt]
	return ok
}

// ResetCompletionAt resets all changes to the "completion_at" field.
func (m *OrderMutation) ResetCompletionAt() {
	m.completion_at = nil
	delete(m.clearedFields, order.FieldCompletionAt)
}

// AddAmountIDs adds the "amount" edge to the OrderAmount entity by ids.
func (m *OrderMutation) AddAmountIDs(ids ...int64) {
	if m.amount == nil {
		m.amount = make(map[int64]struct{})
	}
	for i := range ids {
		m.amount[ids[i]] = struct{}{}
	}
}

// ClearAmount clears the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) ClearAmount() {
	m.clearedamount = true
}

// AmountCleared reports if the "amount" edge to the OrderAmount entity was cleared.
func (m *OrderMutation) AmountCleared() bool {
	return m.clearedamount
}

// RemoveAmountIDs removes the "amount" edge to the OrderAmount entity by IDs.
func (m *OrderMutation) RemoveAmountIDs(ids ...int64) {
	if m.removedamount == nil {
		m.removedamount = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.amount, ids[i])
		m.removedamount[ids[i]] = struct{}{}
	}
}

// RemovedAmount returns the removed IDs of the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) RemovedAmountIDs() (ids []int64) {
	for id := range m.removedamount {
		ids = append(ids, id)
	}
	return
}

// AmountIDs returns the "amount" edge IDs in the mutation.
func (m *OrderMutation) AmountIDs() (ids []int64) {
	for id := range m.amount {
		ids = append(ids, id)
	}
	return
}

// ResetAmount resets all changes to the "amount" edge.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.clearedamount = false
	m.removedamount = nil
}

// AddItemIDs adds the "item" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddItemIDs(ids ...int64) {
	if m.item == nil {
		m.item = make(map[int64]struct{})
	}
	for i := range ids {
		m.item[ids[i]] = struct{}{}
	}
}

// ClearItem clears the "item" edge to the OrderItem entity.
func (m *OrderMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the OrderItem entity was cleared.
func (m *OrderMutation) ItemCleared() bool {
	return m.cleareditem
}

// RemoveItemIDs removes the "item" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveItemIDs(ids ...int64) {
	if m.removeditem == nil {
		m.removeditem = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.item, ids[i])
		m.removeditem[ids[i]] = struct{}{}
	}
}

// RemovedItem returns the removed IDs of the "item" edge to the OrderItem entity.
func (m *OrderMutation) RemovedItemIDs() (ids []int64) {
	for id := range m.removeditem {
		ids = append(ids, id)
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
func (m *OrderMutation) ItemIDs() (ids []int64) {
	for id := range m.item {
		ids = append(ids, id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *OrderMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
	m.removeditem = nil
}

// AddPayIDs adds the "pay" edge to the OrderPay entity by ids.
func (m *OrderMutation) AddPayIDs(ids ...int64) {
	if m.pay == nil {
		m.pay = make(map[int64]struct{})
	}
	for i := range ids {
		m.pay[ids[i]] = struct{}{}
	}
}

// ClearPay clears the "pay" edge to the OrderPay entity.
func (m *OrderMutation) ClearPay() {
	m.clearedpay = true
}

// PayCleared reports if the "pay" edge to the OrderPay entity was cleared.
func (m *OrderMutation) PayCleared() bool {
	return m.clearedpay
}

// RemovePayIDs removes the "pay" edge to the OrderPay entity by IDs.
func (m *OrderMutation) RemovePayIDs(ids ...int64) {
	if m.removedpay == nil {
		m.removedpay = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.pay, ids[i])
		m.removedpay[ids[i]] = struct{}{}
	}
}

// RemovedPay returns the removed IDs of the "pay" edge to the OrderPay entity.
func (m *OrderMutation) RemovedPayIDs() (ids []int64) {
	for id := range m.removedpay {
		ids = append(ids, id)
	}
	return
}

// PayIDs returns the "pay" edge IDs in the mutation.
func (m *OrderMutation) PayIDs() (ids []int64) {
	for id := range m.pay {
		ids = append(ids, id)
	}
	return
}

// ResetPay resets all changes to the "pay" edge.
func (m *OrderMutation) ResetPay() {
	m.pay = nil
	m.clearedpay = false
	m.removedpay = nil
}

// AddOrderContentIDs adds the "order_contents" edge to the MemberContract entity by ids.
func (m *OrderMutation) AddOrderContentIDs(ids ...int64) {
	if m.order_contents == nil {
		m.order_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_contents[ids[i]] = struct{}{}
	}
}

// ClearOrderContents clears the "order_contents" edge to the MemberContract entity.
func (m *OrderMutation) ClearOrderContents() {
	m.clearedorder_contents = true
}

// OrderContentsCleared reports if the "order_contents" edge to the MemberContract entity was cleared.
func (m *OrderMutation) OrderContentsCleared() bool {
	return m.clearedorder_contents
}

// RemoveOrderContentIDs removes the "order_contents" edge to the MemberContract entity by IDs.
func (m *OrderMutation) RemoveOrderContentIDs(ids ...int64) {
	if m.removedorder_contents == nil {
		m.removedorder_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_contents, ids[i])
		m.removedorder_contents[ids[i]] = struct{}{}
	}
}

// RemovedOrderContents returns the removed IDs of the "order_contents" edge to the MemberContract entity.
func (m *OrderMutation) RemovedOrderContentsIDs() (ids []int64) {
	for id := range m.removedorder_contents {
		ids = append(ids, id)
	}
	return
}

// OrderContentsIDs returns the "order_contents" edge IDs in the mutation.
func (m *OrderMutation) OrderContentsIDs() (ids []int64) {
	for id := range m.order_contents {
		ids = append(ids, id)
	}
	return
}

// ResetOrderContents resets all changes to the "order_contents" edge.
func (m *OrderMutation) ResetOrderContents() {
	m.order_contents = nil
	m.clearedorder_contents = false
	m.removedorder_contents = nil
}

// AddSaleIDs adds the "sales" edge to the OrderSales entity by ids.
func (m *OrderMutation) AddSaleIDs(ids ...int64) {
	if m.sales == nil {
		m.sales = make(map[int64]struct{})
	}
	for i := range ids {
		m.sales[ids[i]] = struct{}{}
	}
}

// ClearSales clears the "sales" edge to the OrderSales entity.
func (m *OrderMutation) ClearSales() {
	m.clearedsales = true
}

// SalesCleared reports if the "sales" edge to the OrderSales entity was cleared.
func (m *OrderMutation) SalesCleared() bool {
	return m.clearedsales
}

// RemoveSaleIDs removes the "sales" edge to the OrderSales entity by IDs.
func (m *OrderMutation) RemoveSaleIDs(ids ...int64) {
	if m.removedsales == nil {
		m.removedsales = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sales, ids[i])
		m.removedsales[ids[i]] = struct{}{}
	}
}

// RemovedSales returns the removed IDs of the "sales" edge to the OrderSales entity.
func (m *OrderMutation) RemovedSalesIDs() (ids []int64) {
	for id := range m.removedsales {
		ids = append(ids, id)
	}
	return
}

// SalesIDs returns the "sales" edge IDs in the mutation.
func (m *OrderMutation) SalesIDs() (ids []int64) {
	for id := range m.sales {
		ids = append(ids, id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *OrderMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
	m.removedsales = nil
}

// SetOrderVenuesID sets the "order_venues" edge to the Venue entity by id.
func (m *OrderMutation) SetOrderVenuesID(id int64) {
	m.order_venues = &id
}

// ClearOrderVenues clears the "order_venues" edge to the Venue entity.
func (m *OrderMutation) ClearOrderVenues() {
	m.clearedorder_venues = true
	m.clearedFields[order.FieldVenueID] = struct{}{}
}

// OrderVenuesCleared reports if the "order_venues" edge to the Venue entity was cleared.
func (m *OrderMutation) OrderVenuesCleared() bool {
	return m.VenueIDCleared() || m.clearedorder_venues
}

// OrderVenuesID returns the "order_venues" edge ID in the mutation.
func (m *OrderMutation) OrderVenuesID() (id int64, exists bool) {
	if m.order_venues != nil {
		return *m.order_venues, true
	}
	return
}

// OrderVenuesIDs returns the "order_venues" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderVenuesID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderVenuesIDs() (ids []int64) {
	if id := m.order_venues; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderVenues resets all changes to the "order_venues" edge.
func (m *OrderMutation) ResetOrderVenues() {
	m.order_venues = nil
	m.clearedorder_venues = false
}

// SetOrderMembersID sets the "order_members" edge to the Member entity by id.
func (m *OrderMutation) SetOrderMembersID(id int64) {
	m.order_members = &id
}

// ClearOrderMembers clears the "order_members" edge to the Member entity.
func (m *OrderMutation) ClearOrderMembers() {
	m.clearedorder_members = true
	m.clearedFields[order.FieldMemberID] = struct{}{}
}

// OrderMembersCleared reports if the "order_members" edge to the Member entity was cleared.
func (m *OrderMutation) OrderMembersCleared() bool {
	return m.MemberIDCleared() || m.clearedorder_members
}

// OrderMembersID returns the "order_members" edge ID in the mutation.
func (m *OrderMutation) OrderMembersID() (id int64, exists bool) {
	if m.order_members != nil {
		return *m.order_members, true
	}
	return
}

// OrderMembersIDs returns the "order_members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderMembersID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderMembersIDs() (ids []int64) {
	if id := m.order_members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderMembers resets all changes to the "order_members" edge.
func (m *OrderMutation) ResetOrderMembers() {
	m.order_members = nil
	m.clearedorder_members = false
}

// SetOrderCreatesID sets the "order_creates" edge to the User entity by id.
func (m *OrderMutation) SetOrderCreatesID(id int64) {
	m.order_creates = &id
}

// ClearOrderCreates clears the "order_creates" edge to the User entity.
func (m *OrderMutation) ClearOrderCreates() {
	m.clearedorder_creates = true
	m.clearedFields[order.FieldCreatedID] = struct{}{}
}

// OrderCreatesCleared reports if the "order_creates" edge to the User entity was cleared.
func (m *OrderMutation) OrderCreatesCleared() bool {
	return m.CreatedIDCleared() || m.clearedorder_creates
}

// OrderCreatesID returns the "order_creates" edge ID in the mutation.
func (m *OrderMutation) OrderCreatesID() (id int64, exists bool) {
	if m.order_creates != nil {
		return *m.order_creates, true
	}
	return
}

// OrderCreatesIDs returns the "order_creates" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderCreatesID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderCreatesIDs() (ids []int64) {
	if id := m.order_creates; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderCreates resets all changes to the "order_creates" edge.
func (m *OrderMutation) ResetOrderCreates() {
	m.order_creates = nil
	m.clearedorder_creates = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, order.FieldDelete)
	}
	if m.order_creates != nil {
		fields = append(fields, order.FieldCreatedID)
	}
	if m.order_sn != nil {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.order_venues != nil {
		fields = append(fields, order.FieldVenueID)
	}
	if m.order_members != nil {
		fields = append(fields, order.FieldMemberID)
	}
	if m.nature != nil {
		fields = append(fields, order.FieldNature)
	}
	if m.product_type != nil {
		fields = append(fields, order.FieldProductType)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, order.FieldSource)
	}
	if m.device != nil {
		fields = append(fields, order.FieldDevice)
	}
	if m.completion_at != nil {
		fields = append(fields, order.FieldCompletionAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldDelete:
		return m.Delete()
	case order.FieldCreatedID:
		return m.CreatedID()
	case order.FieldOrderSn:
		return m.OrderSn()
	case order.FieldVenueID:
		return m.VenueID()
	case order.FieldMemberID:
		return m.MemberID()
	case order.FieldNature:
		return m.Nature()
	case order.FieldProductType:
		return m.ProductType()
	case order.FieldStatus:
		return m.Status()
	case order.FieldSource:
		return m.Source()
	case order.FieldDevice:
		return m.Device()
	case order.FieldCompletionAt:
		return m.CompletionAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldDelete:
		return m.OldDelete(ctx)
	case order.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case order.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case order.FieldVenueID:
		return m.OldVenueID(ctx)
	case order.FieldMemberID:
		return m.OldMemberID(ctx)
	case order.FieldNature:
		return m.OldNature(ctx)
	case order.FieldProductType:
		return m.OldProductType(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldSource:
		return m.OldSource(ctx)
	case order.FieldDevice:
		return m.OldDevice(ctx)
	case order.FieldCompletionAt:
		return m.OldCompletionAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case order.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case order.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case order.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case order.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case order.FieldNature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNature(v)
		return nil
	case order.FieldProductType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductType(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case order.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case order.FieldCompletionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, order.FieldDelete)
	}
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldDelete:
		return m.AddedDelete()
	case order.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldCreatedAt) {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.FieldCleared(order.FieldUpdatedAt) {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.FieldCleared(order.FieldDelete) {
		fields = append(fields, order.FieldDelete)
	}
	if m.FieldCleared(order.FieldCreatedID) {
		fields = append(fields, order.FieldCreatedID)
	}
	if m.FieldCleared(order.FieldOrderSn) {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.FieldCleared(order.FieldVenueID) {
		fields = append(fields, order.FieldVenueID)
	}
	if m.FieldCleared(order.FieldMemberID) {
		fields = append(fields, order.FieldMemberID)
	}
	if m.FieldCleared(order.FieldNature) {
		fields = append(fields, order.FieldNature)
	}
	if m.FieldCleared(order.FieldProductType) {
		fields = append(fields, order.FieldProductType)
	}
	if m.FieldCleared(order.FieldStatus) {
		fields = append(fields, order.FieldStatus)
	}
	if m.FieldCleared(order.FieldSource) {
		fields = append(fields, order.FieldSource)
	}
	if m.FieldCleared(order.FieldDevice) {
		fields = append(fields, order.FieldDevice)
	}
	if m.FieldCleared(order.FieldCompletionAt) {
		fields = append(fields, order.FieldCompletionAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case order.FieldDelete:
		m.ClearDelete()
		return nil
	case order.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case order.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case order.FieldVenueID:
		m.ClearVenueID()
		return nil
	case order.FieldMemberID:
		m.ClearMemberID()
		return nil
	case order.FieldNature:
		m.ClearNature()
		return nil
	case order.FieldProductType:
		m.ClearProductType()
		return nil
	case order.FieldStatus:
		m.ClearStatus()
		return nil
	case order.FieldSource:
		m.ClearSource()
		return nil
	case order.FieldDevice:
		m.ClearDevice()
		return nil
	case order.FieldCompletionAt:
		m.ClearCompletionAt()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldDelete:
		m.ResetDelete()
		return nil
	case order.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case order.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case order.FieldVenueID:
		m.ResetVenueID()
		return nil
	case order.FieldMemberID:
		m.ResetMemberID()
		return nil
	case order.FieldNature:
		m.ResetNature()
		return nil
	case order.FieldProductType:
		m.ResetProductType()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldSource:
		m.ResetSource()
		return nil
	case order.FieldDevice:
		m.ResetDevice()
		return nil
	case order.FieldCompletionAt:
		m.ResetCompletionAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.amount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.item != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.pay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.order_contents != nil {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.sales != nil {
		edges = append(edges, order.EdgeSales)
	}
	if m.order_venues != nil {
		edges = append(edges, order.EdgeOrderVenues)
	}
	if m.order_members != nil {
		edges = append(edges, order.EdgeOrderMembers)
	}
	if m.order_creates != nil {
		edges = append(edges, order.EdgeOrderCreates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.amount))
		for id := range m.amount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.item))
		for id := range m.item {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.pay))
		for id := range m.pay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderContents:
		ids := make([]ent.Value, 0, len(m.order_contents))
		for id := range m.order_contents {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.sales))
		for id := range m.sales {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderVenues:
		if id := m.order_venues; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderMembers:
		if id := m.order_members; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderCreates:
		if id := m.order_creates; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedamount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.removeditem != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.removedpay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.removedorder_contents != nil {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.removedsales != nil {
		edges = append(edges, order.EdgeSales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.removedamount))
		for id := range m.removedamount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.removeditem))
		for id := range m.removeditem {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.removedpay))
		for id := range m.removedpay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderContents:
		ids := make([]ent.Value, 0, len(m.removedorder_contents))
		for id := range m.removedorder_contents {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.removedsales))
		for id := range m.removedsales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedamount {
		edges = append(edges, order.EdgeAmount)
	}
	if m.cleareditem {
		edges = append(edges, order.EdgeItem)
	}
	if m.clearedpay {
		edges = append(edges, order.EdgePay)
	}
	if m.clearedorder_contents {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.clearedsales {
		edges = append(edges, order.EdgeSales)
	}
	if m.clearedorder_venues {
		edges = append(edges, order.EdgeOrderVenues)
	}
	if m.clearedorder_members {
		edges = append(edges, order.EdgeOrderMembers)
	}
	if m.clearedorder_creates {
		edges = append(edges, order.EdgeOrderCreates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeAmount:
		return m.clearedamount
	case order.EdgeItem:
		return m.cleareditem
	case order.EdgePay:
		return m.clearedpay
	case order.EdgeOrderContents:
		return m.clearedorder_contents
	case order.EdgeSales:
		return m.clearedsales
	case order.EdgeOrderVenues:
		return m.clearedorder_venues
	case order.EdgeOrderMembers:
		return m.clearedorder_members
	case order.EdgeOrderCreates:
		return m.clearedorder_creates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeOrderVenues:
		m.ClearOrderVenues()
		return nil
	case order.EdgeOrderMembers:
		m.ClearOrderMembers()
		return nil
	case order.EdgeOrderCreates:
		m.ClearOrderCreates()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeAmount:
		m.ResetAmount()
		return nil
	case order.EdgeItem:
		m.ResetItem()
		return nil
	case order.EdgePay:
		m.ResetPay()
		return nil
	case order.EdgeOrderContents:
		m.ResetOrderContents()
		return nil
	case order.EdgeSales:
		m.ResetSales()
		return nil
	case order.EdgeOrderVenues:
		m.ResetOrderVenues()
		return nil
	case order.EdgeOrderMembers:
		m.ResetOrderMembers()
		return nil
	case order.EdgeOrderCreates:
		m.ResetOrderCreates()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderAmountMutation represents an operation that mutates the OrderAmount nodes in the graph.
type OrderAmountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	total         *float64
	addtotal      *float64
	actual        *float64
	addactual     *float64
	residue       *float64
	addresidue    *float64
	remission     *float64
	addremission  *float64
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderAmount, error)
	predicates    []predicate.OrderAmount
}

var _ ent.Mutation = (*OrderAmountMutation)(nil)

// orderamountOption allows management of the mutation configuration using functional options.
type orderamountOption func(*OrderAmountMutation)

// newOrderAmountMutation creates new mutation for the OrderAmount entity.
func newOrderAmountMutation(c config, op Op, opts ...orderamountOption) *OrderAmountMutation {
	m := &OrderAmountMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAmount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAmountID sets the ID field of the mutation.
func withOrderAmountID(id int64) orderamountOption {
	return func(m *OrderAmountMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAmount
		)
		m.oldValue = func(ctx context.Context) (*OrderAmount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAmount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAmount sets the old OrderAmount of the mutation.
func withOrderAmount(node *OrderAmount) orderamountOption {
	return func(m *OrderAmountMutation) {
		m.oldValue = func(context.Context) (*OrderAmount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAmountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAmountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderAmount entities.
func (m *OrderAmountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAmountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderAmountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderAmount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderAmountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderAmountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderAmountMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderamount.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderAmountMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderAmountMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderamount.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderAmountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderAmountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderAmountMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderamount.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderAmountMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderAmountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderamount.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderAmountMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderAmountMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderAmountMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderAmountMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderAmountMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[orderamount.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderAmountMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderAmountMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, orderamount.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderAmountMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderAmountMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderAmountMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderAmountMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderAmountMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[orderamount.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderAmountMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderAmountMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, orderamount.FieldCreatedID)
}

// SetOrderID sets the "order_id" field.
func (m *OrderAmountMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderAmountMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderAmountMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderAmountMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderAmountMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderamount.FieldOrderID)
}

// SetTotal sets the "total" field.
func (m *OrderAmountMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderAmountMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *OrderAmountMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *OrderAmountMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *OrderAmountMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[orderamount.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *OrderAmountMutation) TotalCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderAmountMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, orderamount.FieldTotal)
}

// SetActual sets the "actual" field.
func (m *OrderAmountMutation) SetActual(f float64) {
	m.actual = &f
	m.addactual = nil
}

// Actual returns the value of the "actual" field in the mutation.
func (m *OrderAmountMutation) Actual() (r float64, exists bool) {
	v := m.actual
	if v == nil {
		return
	}
	return *v, true
}

// OldActual returns the old "actual" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldActual(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActual: %w", err)
	}
	return oldValue.Actual, nil
}

// AddActual adds f to the "actual" field.
func (m *OrderAmountMutation) AddActual(f float64) {
	if m.addactual != nil {
		*m.addactual += f
	} else {
		m.addactual = &f
	}
}

// AddedActual returns the value that was added to the "actual" field in this mutation.
func (m *OrderAmountMutation) AddedActual() (r float64, exists bool) {
	v := m.addactual
	if v == nil {
		return
	}
	return *v, true
}

// ClearActual clears the value of the "actual" field.
func (m *OrderAmountMutation) ClearActual() {
	m.actual = nil
	m.addactual = nil
	m.clearedFields[orderamount.FieldActual] = struct{}{}
}

// ActualCleared returns if the "actual" field was cleared in this mutation.
func (m *OrderAmountMutation) ActualCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldActual]
	return ok
}

// ResetActual resets all changes to the "actual" field.
func (m *OrderAmountMutation) ResetActual() {
	m.actual = nil
	m.addactual = nil
	delete(m.clearedFields, orderamount.FieldActual)
}

// SetResidue sets the "residue" field.
func (m *OrderAmountMutation) SetResidue(f float64) {
	m.residue = &f
	m.addresidue = nil
}

// Residue returns the value of the "residue" field in the mutation.
func (m *OrderAmountMutation) Residue() (r float64, exists bool) {
	v := m.residue
	if v == nil {
		return
	}
	return *v, true
}

// OldResidue returns the old "residue" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldResidue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResidue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResidue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResidue: %w", err)
	}
	return oldValue.Residue, nil
}

// AddResidue adds f to the "residue" field.
func (m *OrderAmountMutation) AddResidue(f float64) {
	if m.addresidue != nil {
		*m.addresidue += f
	} else {
		m.addresidue = &f
	}
}

// AddedResidue returns the value that was added to the "residue" field in this mutation.
func (m *OrderAmountMutation) AddedResidue() (r float64, exists bool) {
	v := m.addresidue
	if v == nil {
		return
	}
	return *v, true
}

// ClearResidue clears the value of the "residue" field.
func (m *OrderAmountMutation) ClearResidue() {
	m.residue = nil
	m.addresidue = nil
	m.clearedFields[orderamount.FieldResidue] = struct{}{}
}

// ResidueCleared returns if the "residue" field was cleared in this mutation.
func (m *OrderAmountMutation) ResidueCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldResidue]
	return ok
}

// ResetResidue resets all changes to the "residue" field.
func (m *OrderAmountMutation) ResetResidue() {
	m.residue = nil
	m.addresidue = nil
	delete(m.clearedFields, orderamount.FieldResidue)
}

// SetRemission sets the "remission" field.
func (m *OrderAmountMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderAmountMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderAmountMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderAmountMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderAmountMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderamount.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderAmountMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderAmountMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderamount.FieldRemission)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderAmountMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderAmountMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderAmountMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderAmountMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderAmountMutation builder.
func (m *OrderAmountMutation) Where(ps ...predicate.OrderAmount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderAmountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderAmountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderAmount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderAmountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderAmountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderAmount).
func (m *OrderAmountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAmountMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, orderamount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderamount.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, orderamount.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, orderamount.FieldCreatedID)
	}
	if m._order != nil {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.total != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.actual != nil {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.residue != nil {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.remission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAmountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.CreatedAt()
	case orderamount.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderamount.FieldDelete:
		return m.Delete()
	case orderamount.FieldCreatedID:
		return m.CreatedID()
	case orderamount.FieldOrderID:
		return m.OrderID()
	case orderamount.FieldTotal:
		return m.Total()
	case orderamount.FieldActual:
		return m.Actual()
	case orderamount.FieldResidue:
		return m.Residue()
	case orderamount.FieldRemission:
		return m.Remission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAmountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderamount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderamount.FieldDelete:
		return m.OldDelete(ctx)
	case orderamount.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case orderamount.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderamount.FieldTotal:
		return m.OldTotal(ctx)
	case orderamount.FieldActual:
		return m.OldActual(ctx)
	case orderamount.FieldResidue:
		return m.OldResidue(ctx)
	case orderamount.FieldRemission:
		return m.OldRemission(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAmount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderamount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderamount.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case orderamount.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case orderamount.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case orderamount.FieldActual:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActual(v)
		return nil
	case orderamount.FieldResidue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResidue(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAmountMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, orderamount.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, orderamount.FieldCreatedID)
	}
	if m.addtotal != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.addactual != nil {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.addresidue != nil {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.addremission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAmountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldDelete:
		return m.AddedDelete()
	case orderamount.FieldCreatedID:
		return m.AddedCreatedID()
	case orderamount.FieldTotal:
		return m.AddedTotal()
	case orderamount.FieldActual:
		return m.AddedActual()
	case orderamount.FieldResidue:
		return m.AddedResidue()
	case orderamount.FieldRemission:
		return m.AddedRemission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case orderamount.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case orderamount.FieldActual:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActual(v)
		return nil
	case orderamount.FieldResidue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResidue(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAmountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderamount.FieldCreatedAt) {
		fields = append(fields, orderamount.FieldCreatedAt)
	}
	if m.FieldCleared(orderamount.FieldUpdatedAt) {
		fields = append(fields, orderamount.FieldUpdatedAt)
	}
	if m.FieldCleared(orderamount.FieldDelete) {
		fields = append(fields, orderamount.FieldDelete)
	}
	if m.FieldCleared(orderamount.FieldCreatedID) {
		fields = append(fields, orderamount.FieldCreatedID)
	}
	if m.FieldCleared(orderamount.FieldOrderID) {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.FieldCleared(orderamount.FieldTotal) {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.FieldCleared(orderamount.FieldActual) {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.FieldCleared(orderamount.FieldResidue) {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.FieldCleared(orderamount.FieldRemission) {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAmountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAmountMutation) ClearField(name string) error {
	switch name {
	case orderamount.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderamount.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderamount.FieldDelete:
		m.ClearDelete()
		return nil
	case orderamount.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case orderamount.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ClearTotal()
		return nil
	case orderamount.FieldActual:
		m.ClearActual()
		return nil
	case orderamount.FieldResidue:
		m.ClearResidue()
		return nil
	case orderamount.FieldRemission:
		m.ClearRemission()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAmountMutation) ResetField(name string) error {
	switch name {
	case orderamount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderamount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderamount.FieldDelete:
		m.ResetDelete()
		return nil
	case orderamount.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case orderamount.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ResetTotal()
		return nil
	case orderamount.FieldActual:
		m.ResetActual()
		return nil
	case orderamount.FieldResidue:
		m.ResetResidue()
		return nil
	case orderamount.FieldRemission:
		m.ResetRemission()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAmountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderamount.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAmountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderamount.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAmountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAmountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAmountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderamount.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAmountMutation) EdgeCleared(name string) bool {
	switch name {
	case orderamount.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAmountMutation) ClearEdge(name string) error {
	switch name {
	case orderamount.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAmountMutation) ResetEdge(name string) error {
	switch name {
	case orderamount.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	delete                     *int64
	adddelete                  *int64
	created_id                 *int64
	addcreated_id              *int64
	product_id                 *int64
	addproduct_id              *int64
	related_user_product_id    *int64
	addrelated_user_product_id *int64
	contest_id                 *int64
	addcontest_id              *int64
	bootcamp_id                *int64
	addbootcamp_id             *int64
	name                       *string
	data                       *[]string
	appenddata                 []string
	clearedFields              map[string]struct{}
	_order                     *int64
	cleared_order              bool
	done                       bool
	oldValue                   func(context.Context) (*OrderItem, error)
	predicates                 []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int64) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderItemMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderitem.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderItemMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderitem.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderItemMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderitem.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderItemMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderitem.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderItemMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderItemMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderItemMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderItemMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderItemMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[orderitem.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderItemMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderItemMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, orderitem.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderItemMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderItemMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderItemMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderItemMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderItemMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[orderitem.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderItemMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderItemMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, orderitem.FieldCreatedID)
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderItemMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderitem.FieldOrderID)
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, orderitem.FieldProductID)
}

// SetRelatedUserProductID sets the "related_user_product_id" field.
func (m *OrderItemMutation) SetRelatedUserProductID(i int64) {
	m.related_user_product_id = &i
	m.addrelated_user_product_id = nil
}

// RelatedUserProductID returns the value of the "related_user_product_id" field in the mutation.
func (m *OrderItemMutation) RelatedUserProductID() (r int64, exists bool) {
	v := m.related_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedUserProductID returns the old "related_user_product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRelatedUserProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedUserProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedUserProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedUserProductID: %w", err)
	}
	return oldValue.RelatedUserProductID, nil
}

// AddRelatedUserProductID adds i to the "related_user_product_id" field.
func (m *OrderItemMutation) AddRelatedUserProductID(i int64) {
	if m.addrelated_user_product_id != nil {
		*m.addrelated_user_product_id += i
	} else {
		m.addrelated_user_product_id = &i
	}
}

// AddedRelatedUserProductID returns the value that was added to the "related_user_product_id" field in this mutation.
func (m *OrderItemMutation) AddedRelatedUserProductID() (r int64, exists bool) {
	v := m.addrelated_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelatedUserProductID clears the value of the "related_user_product_id" field.
func (m *OrderItemMutation) ClearRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	m.clearedFields[orderitem.FieldRelatedUserProductID] = struct{}{}
}

// RelatedUserProductIDCleared returns if the "related_user_product_id" field was cleared in this mutation.
func (m *OrderItemMutation) RelatedUserProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldRelatedUserProductID]
	return ok
}

// ResetRelatedUserProductID resets all changes to the "related_user_product_id" field.
func (m *OrderItemMutation) ResetRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	delete(m.clearedFields, orderitem.FieldRelatedUserProductID)
}

// SetContestID sets the "contest_id" field.
func (m *OrderItemMutation) SetContestID(i int64) {
	m.contest_id = &i
	m.addcontest_id = nil
}

// ContestID returns the value of the "contest_id" field in the mutation.
func (m *OrderItemMutation) ContestID() (r int64, exists bool) {
	v := m.contest_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContestID returns the old "contest_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldContestID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContestID: %w", err)
	}
	return oldValue.ContestID, nil
}

// AddContestID adds i to the "contest_id" field.
func (m *OrderItemMutation) AddContestID(i int64) {
	if m.addcontest_id != nil {
		*m.addcontest_id += i
	} else {
		m.addcontest_id = &i
	}
}

// AddedContestID returns the value that was added to the "contest_id" field in this mutation.
func (m *OrderItemMutation) AddedContestID() (r int64, exists bool) {
	v := m.addcontest_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContestID clears the value of the "contest_id" field.
func (m *OrderItemMutation) ClearContestID() {
	m.contest_id = nil
	m.addcontest_id = nil
	m.clearedFields[orderitem.FieldContestID] = struct{}{}
}

// ContestIDCleared returns if the "contest_id" field was cleared in this mutation.
func (m *OrderItemMutation) ContestIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldContestID]
	return ok
}

// ResetContestID resets all changes to the "contest_id" field.
func (m *OrderItemMutation) ResetContestID() {
	m.contest_id = nil
	m.addcontest_id = nil
	delete(m.clearedFields, orderitem.FieldContestID)
}

// SetBootcampID sets the "bootcamp_id" field.
func (m *OrderItemMutation) SetBootcampID(i int64) {
	m.bootcamp_id = &i
	m.addbootcamp_id = nil
}

// BootcampID returns the value of the "bootcamp_id" field in the mutation.
func (m *OrderItemMutation) BootcampID() (r int64, exists bool) {
	v := m.bootcamp_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBootcampID returns the old "bootcamp_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldBootcampID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBootcampID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBootcampID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBootcampID: %w", err)
	}
	return oldValue.BootcampID, nil
}

// AddBootcampID adds i to the "bootcamp_id" field.
func (m *OrderItemMutation) AddBootcampID(i int64) {
	if m.addbootcamp_id != nil {
		*m.addbootcamp_id += i
	} else {
		m.addbootcamp_id = &i
	}
}

// AddedBootcampID returns the value that was added to the "bootcamp_id" field in this mutation.
func (m *OrderItemMutation) AddedBootcampID() (r int64, exists bool) {
	v := m.addbootcamp_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBootcampID clears the value of the "bootcamp_id" field.
func (m *OrderItemMutation) ClearBootcampID() {
	m.bootcamp_id = nil
	m.addbootcamp_id = nil
	m.clearedFields[orderitem.FieldBootcampID] = struct{}{}
}

// BootcampIDCleared returns if the "bootcamp_id" field was cleared in this mutation.
func (m *OrderItemMutation) BootcampIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldBootcampID]
	return ok
}

// ResetBootcampID resets all changes to the "bootcamp_id" field.
func (m *OrderItemMutation) ResetBootcampID() {
	m.bootcamp_id = nil
	m.addbootcamp_id = nil
	delete(m.clearedFields, orderitem.FieldBootcampID)
}

// SetName sets the "name" field.
func (m *OrderItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *OrderItemMutation) ClearName() {
	m.name = nil
	m.clearedFields[orderitem.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *OrderItemMutation) NameCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *OrderItemMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, orderitem.FieldName)
}

// SetData sets the "data" field.
func (m *OrderItemMutation) SetData(s []string) {
	m.data = &s
	m.appenddata = nil
}

// Data returns the value of the "data" field in the mutation.
func (m *OrderItemMutation) Data() (r []string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldData(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// AppendData adds s to the "data" field.
func (m *OrderItemMutation) AppendData(s []string) {
	m.appenddata = append(m.appenddata, s...)
}

// AppendedData returns the list of values that were appended to the "data" field in this mutation.
func (m *OrderItemMutation) AppendedData() ([]string, bool) {
	if len(m.appenddata) == 0 {
		return nil, false
	}
	return m.appenddata, true
}

// ClearData clears the value of the "data" field.
func (m *OrderItemMutation) ClearData() {
	m.data = nil
	m.appenddata = nil
	m.clearedFields[orderitem.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *OrderItemMutation) DataCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *OrderItemMutation) ResetData() {
	m.data = nil
	m.appenddata = nil
	delete(m.clearedFields, orderitem.FieldData)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, orderitem.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, orderitem.FieldCreatedID)
	}
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.related_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.contest_id != nil {
		fields = append(fields, orderitem.FieldContestID)
	}
	if m.bootcamp_id != nil {
		fields = append(fields, orderitem.FieldBootcampID)
	}
	if m.name != nil {
		fields = append(fields, orderitem.FieldName)
	}
	if m.data != nil {
		fields = append(fields, orderitem.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldDelete:
		return m.Delete()
	case orderitem.FieldCreatedID:
		return m.CreatedID()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldRelatedUserProductID:
		return m.RelatedUserProductID()
	case orderitem.FieldContestID:
		return m.ContestID()
	case orderitem.FieldBootcampID:
		return m.BootcampID()
	case orderitem.FieldName:
		return m.Name()
	case orderitem.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldDelete:
		return m.OldDelete(ctx)
	case orderitem.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldRelatedUserProductID:
		return m.OldRelatedUserProductID(ctx)
	case orderitem.FieldContestID:
		return m.OldContestID(ctx)
	case orderitem.FieldBootcampID:
		return m.OldBootcampID(ctx)
	case orderitem.FieldName:
		return m.OldName(ctx)
	case orderitem.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case orderitem.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedUserProductID(v)
		return nil
	case orderitem.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContestID(v)
		return nil
	case orderitem.FieldBootcampID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBootcampID(v)
		return nil
	case orderitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderitem.FieldData:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, orderitem.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, orderitem.FieldCreatedID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.addrelated_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.addcontest_id != nil {
		fields = append(fields, orderitem.FieldContestID)
	}
	if m.addbootcamp_id != nil {
		fields = append(fields, orderitem.FieldBootcampID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldDelete:
		return m.AddedDelete()
	case orderitem.FieldCreatedID:
		return m.AddedCreatedID()
	case orderitem.FieldProductID:
		return m.AddedProductID()
	case orderitem.FieldRelatedUserProductID:
		return m.AddedRelatedUserProductID()
	case orderitem.FieldContestID:
		return m.AddedContestID()
	case orderitem.FieldBootcampID:
		return m.AddedBootcampID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case orderitem.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedUserProductID(v)
		return nil
	case orderitem.FieldContestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContestID(v)
		return nil
	case orderitem.FieldBootcampID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBootcampID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldCreatedAt) {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.FieldCleared(orderitem.FieldUpdatedAt) {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.FieldCleared(orderitem.FieldDelete) {
		fields = append(fields, orderitem.FieldDelete)
	}
	if m.FieldCleared(orderitem.FieldCreatedID) {
		fields = append(fields, orderitem.FieldCreatedID)
	}
	if m.FieldCleared(orderitem.FieldOrderID) {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.FieldCleared(orderitem.FieldProductID) {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.FieldCleared(orderitem.FieldRelatedUserProductID) {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.FieldCleared(orderitem.FieldContestID) {
		fields = append(fields, orderitem.FieldContestID)
	}
	if m.FieldCleared(orderitem.FieldBootcampID) {
		fields = append(fields, orderitem.FieldBootcampID)
	}
	if m.FieldCleared(orderitem.FieldName) {
		fields = append(fields, orderitem.FieldName)
	}
	if m.FieldCleared(orderitem.FieldData) {
		fields = append(fields, orderitem.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderitem.FieldDelete:
		m.ClearDelete()
		return nil
	case orderitem.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case orderitem.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ClearProductID()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ClearRelatedUserProductID()
		return nil
	case orderitem.FieldContestID:
		m.ClearContestID()
		return nil
	case orderitem.FieldBootcampID:
		m.ClearBootcampID()
		return nil
	case orderitem.FieldName:
		m.ClearName()
		return nil
	case orderitem.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldDelete:
		m.ResetDelete()
		return nil
	case orderitem.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ResetRelatedUserProductID()
		return nil
	case orderitem.FieldContestID:
		m.ResetContestID()
		return nil
	case orderitem.FieldBootcampID:
		m.ResetBootcampID()
		return nil
	case orderitem.FieldName:
		m.ResetName()
		return nil
	case orderitem.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderPayMutation represents an operation that mutates the OrderPay nodes in the graph.
type OrderPayMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	remission       *float64
	addremission    *float64
	pay             *float64
	addpay          *float64
	note            *string
	pay_way         *string
	pay_sn          *string
	prepay_id       *string
	pay_extra       *[]string
	appendpay_extra []string
	clearedFields   map[string]struct{}
	_order          *int64
	cleared_order   bool
	done            bool
	oldValue        func(context.Context) (*OrderPay, error)
	predicates      []predicate.OrderPay
}

var _ ent.Mutation = (*OrderPayMutation)(nil)

// orderpayOption allows management of the mutation configuration using functional options.
type orderpayOption func(*OrderPayMutation)

// newOrderPayMutation creates new mutation for the OrderPay entity.
func newOrderPayMutation(c config, op Op, opts ...orderpayOption) *OrderPayMutation {
	m := &OrderPayMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPayID sets the ID field of the mutation.
func withOrderPayID(id int64) orderpayOption {
	return func(m *OrderPayMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPay
		)
		m.oldValue = func(ctx context.Context) (*OrderPay, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPay sets the old OrderPay of the mutation.
func withOrderPay(node *OrderPay) orderpayOption {
	return func(m *OrderPayMutation) {
		m.oldValue = func(context.Context) (*OrderPay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderPay entities.
func (m *OrderPayMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPayMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderPayMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderPay.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderPayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderPayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderPayMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderpay.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderPayMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderPayMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderpay.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderPayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderPayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderPayMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderpay.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderPayMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderPayMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderpay.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderPayMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderPayMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderPayMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderPayMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderPayMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[orderpay.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderPayMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderPayMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, orderpay.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderPayMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderPayMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderPayMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderPayMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderPayMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[orderpay.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderPayMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderPayMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, orderpay.FieldCreatedID)
}

// SetOrderID sets the "order_id" field.
func (m *OrderPayMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderPayMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderPayMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderPayMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderPayMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderpay.FieldOrderID)
}

// SetRemission sets the "remission" field.
func (m *OrderPayMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderPayMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderPayMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderPayMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderPayMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderpay.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderPayMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderPayMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderpay.FieldRemission)
}

// SetPay sets the "pay" field.
func (m *OrderPayMutation) SetPay(f float64) {
	m.pay = &f
	m.addpay = nil
}

// Pay returns the value of the "pay" field in the mutation.
func (m *OrderPayMutation) Pay() (r float64, exists bool) {
	v := m.pay
	if v == nil {
		return
	}
	return *v, true
}

// OldPay returns the old "pay" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPay: %w", err)
	}
	return oldValue.Pay, nil
}

// AddPay adds f to the "pay" field.
func (m *OrderPayMutation) AddPay(f float64) {
	if m.addpay != nil {
		*m.addpay += f
	} else {
		m.addpay = &f
	}
}

// AddedPay returns the value that was added to the "pay" field in this mutation.
func (m *OrderPayMutation) AddedPay() (r float64, exists bool) {
	v := m.addpay
	if v == nil {
		return
	}
	return *v, true
}

// ClearPay clears the value of the "pay" field.
func (m *OrderPayMutation) ClearPay() {
	m.pay = nil
	m.addpay = nil
	m.clearedFields[orderpay.FieldPay] = struct{}{}
}

// PayCleared returns if the "pay" field was cleared in this mutation.
func (m *OrderPayMutation) PayCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPay]
	return ok
}

// ResetPay resets all changes to the "pay" field.
func (m *OrderPayMutation) ResetPay() {
	m.pay = nil
	m.addpay = nil
	delete(m.clearedFields, orderpay.FieldPay)
}

// SetNote sets the "note" field.
func (m *OrderPayMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderPayMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OrderPayMutation) ClearNote() {
	m.note = nil
	m.clearedFields[orderpay.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OrderPayMutation) NoteCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OrderPayMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, orderpay.FieldNote)
}

// SetPayWay sets the "pay_way" field.
func (m *OrderPayMutation) SetPayWay(s string) {
	m.pay_way = &s
}

// PayWay returns the value of the "pay_way" field in the mutation.
func (m *OrderPayMutation) PayWay() (r string, exists bool) {
	v := m.pay_way
	if v == nil {
		return
	}
	return *v, true
}

// OldPayWay returns the old "pay_way" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPayWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayWay: %w", err)
	}
	return oldValue.PayWay, nil
}

// ClearPayWay clears the value of the "pay_way" field.
func (m *OrderPayMutation) ClearPayWay() {
	m.pay_way = nil
	m.clearedFields[orderpay.FieldPayWay] = struct{}{}
}

// PayWayCleared returns if the "pay_way" field was cleared in this mutation.
func (m *OrderPayMutation) PayWayCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPayWay]
	return ok
}

// ResetPayWay resets all changes to the "pay_way" field.
func (m *OrderPayMutation) ResetPayWay() {
	m.pay_way = nil
	delete(m.clearedFields, orderpay.FieldPayWay)
}

// SetPaySn sets the "pay_sn" field.
func (m *OrderPayMutation) SetPaySn(s string) {
	m.pay_sn = &s
}

// PaySn returns the value of the "pay_sn" field in the mutation.
func (m *OrderPayMutation) PaySn() (r string, exists bool) {
	v := m.pay_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldPaySn returns the old "pay_sn" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPaySn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaySn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaySn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaySn: %w", err)
	}
	return oldValue.PaySn, nil
}

// ClearPaySn clears the value of the "pay_sn" field.
func (m *OrderPayMutation) ClearPaySn() {
	m.pay_sn = nil
	m.clearedFields[orderpay.FieldPaySn] = struct{}{}
}

// PaySnCleared returns if the "pay_sn" field was cleared in this mutation.
func (m *OrderPayMutation) PaySnCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPaySn]
	return ok
}

// ResetPaySn resets all changes to the "pay_sn" field.
func (m *OrderPayMutation) ResetPaySn() {
	m.pay_sn = nil
	delete(m.clearedFields, orderpay.FieldPaySn)
}

// SetPrepayID sets the "prepay_id" field.
func (m *OrderPayMutation) SetPrepayID(s string) {
	m.prepay_id = &s
}

// PrepayID returns the value of the "prepay_id" field in the mutation.
func (m *OrderPayMutation) PrepayID() (r string, exists bool) {
	v := m.prepay_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepayID returns the old "prepay_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPrepayID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepayID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepayID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepayID: %w", err)
	}
	return oldValue.PrepayID, nil
}

// ClearPrepayID clears the value of the "prepay_id" field.
func (m *OrderPayMutation) ClearPrepayID() {
	m.prepay_id = nil
	m.clearedFields[orderpay.FieldPrepayID] = struct{}{}
}

// PrepayIDCleared returns if the "prepay_id" field was cleared in this mutation.
func (m *OrderPayMutation) PrepayIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPrepayID]
	return ok
}

// ResetPrepayID resets all changes to the "prepay_id" field.
func (m *OrderPayMutation) ResetPrepayID() {
	m.prepay_id = nil
	delete(m.clearedFields, orderpay.FieldPrepayID)
}

// SetPayExtra sets the "pay_extra" field.
func (m *OrderPayMutation) SetPayExtra(s []string) {
	m.pay_extra = &s
	m.appendpay_extra = nil
}

// PayExtra returns the value of the "pay_extra" field in the mutation.
func (m *OrderPayMutation) PayExtra() (r []string, exists bool) {
	v := m.pay_extra
	if v == nil {
		return
	}
	return *v, true
}

// OldPayExtra returns the old "pay_extra" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPayExtra(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayExtra: %w", err)
	}
	return oldValue.PayExtra, nil
}

// AppendPayExtra adds s to the "pay_extra" field.
func (m *OrderPayMutation) AppendPayExtra(s []string) {
	m.appendpay_extra = append(m.appendpay_extra, s...)
}

// AppendedPayExtra returns the list of values that were appended to the "pay_extra" field in this mutation.
func (m *OrderPayMutation) AppendedPayExtra() ([]string, bool) {
	if len(m.appendpay_extra) == 0 {
		return nil, false
	}
	return m.appendpay_extra, true
}

// ClearPayExtra clears the value of the "pay_extra" field.
func (m *OrderPayMutation) ClearPayExtra() {
	m.pay_extra = nil
	m.appendpay_extra = nil
	m.clearedFields[orderpay.FieldPayExtra] = struct{}{}
}

// PayExtraCleared returns if the "pay_extra" field was cleared in this mutation.
func (m *OrderPayMutation) PayExtraCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPayExtra]
	return ok
}

// ResetPayExtra resets all changes to the "pay_extra" field.
func (m *OrderPayMutation) ResetPayExtra() {
	m.pay_extra = nil
	m.appendpay_extra = nil
	delete(m.clearedFields, orderpay.FieldPayExtra)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderPayMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderPayMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderPayMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderPayMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderPayMutation builder.
func (m *OrderPayMutation) Where(ps ...predicate.OrderPay) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderPayMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderPayMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderPay, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderPayMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderPayMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderPay).
func (m *OrderPayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPayMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, orderpay.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, orderpay.FieldCreatedID)
	}
	if m._order != nil {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.remission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.pay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.note != nil {
		fields = append(fields, orderpay.FieldNote)
	}
	if m.pay_way != nil {
		fields = append(fields, orderpay.FieldPayWay)
	}
	if m.pay_sn != nil {
		fields = append(fields, orderpay.FieldPaySn)
	}
	if m.prepay_id != nil {
		fields = append(fields, orderpay.FieldPrepayID)
	}
	if m.pay_extra != nil {
		fields = append(fields, orderpay.FieldPayExtra)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.CreatedAt()
	case orderpay.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderpay.FieldDelete:
		return m.Delete()
	case orderpay.FieldCreatedID:
		return m.CreatedID()
	case orderpay.FieldOrderID:
		return m.OrderID()
	case orderpay.FieldRemission:
		return m.Remission()
	case orderpay.FieldPay:
		return m.Pay()
	case orderpay.FieldNote:
		return m.Note()
	case orderpay.FieldPayWay:
		return m.PayWay()
	case orderpay.FieldPaySn:
		return m.PaySn()
	case orderpay.FieldPrepayID:
		return m.PrepayID()
	case orderpay.FieldPayExtra:
		return m.PayExtra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderpay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderpay.FieldDelete:
		return m.OldDelete(ctx)
	case orderpay.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case orderpay.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderpay.FieldRemission:
		return m.OldRemission(ctx)
	case orderpay.FieldPay:
		return m.OldPay(ctx)
	case orderpay.FieldNote:
		return m.OldNote(ctx)
	case orderpay.FieldPayWay:
		return m.OldPayWay(ctx)
	case orderpay.FieldPaySn:
		return m.OldPaySn(ctx)
	case orderpay.FieldPrepayID:
		return m.OldPrepayID(ctx)
	case orderpay.FieldPayExtra:
		return m.OldPayExtra(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderpay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderpay.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case orderpay.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case orderpay.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPay(v)
		return nil
	case orderpay.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case orderpay.FieldPayWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayWay(v)
		return nil
	case orderpay.FieldPaySn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaySn(v)
		return nil
	case orderpay.FieldPrepayID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepayID(v)
		return nil
	case orderpay.FieldPayExtra:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayExtra(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPayMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, orderpay.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, orderpay.FieldCreatedID)
	}
	if m.addremission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.addpay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldDelete:
		return m.AddedDelete()
	case orderpay.FieldCreatedID:
		return m.AddedCreatedID()
	case orderpay.FieldRemission:
		return m.AddedRemission()
	case orderpay.FieldPay:
		return m.AddedPay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case orderpay.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPay(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpay.FieldCreatedAt) {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.FieldCleared(orderpay.FieldUpdatedAt) {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m.FieldCleared(orderpay.FieldDelete) {
		fields = append(fields, orderpay.FieldDelete)
	}
	if m.FieldCleared(orderpay.FieldCreatedID) {
		fields = append(fields, orderpay.FieldCreatedID)
	}
	if m.FieldCleared(orderpay.FieldOrderID) {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.FieldCleared(orderpay.FieldRemission) {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.FieldCleared(orderpay.FieldPay) {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.FieldCleared(orderpay.FieldNote) {
		fields = append(fields, orderpay.FieldNote)
	}
	if m.FieldCleared(orderpay.FieldPayWay) {
		fields = append(fields, orderpay.FieldPayWay)
	}
	if m.FieldCleared(orderpay.FieldPaySn) {
		fields = append(fields, orderpay.FieldPaySn)
	}
	if m.FieldCleared(orderpay.FieldPrepayID) {
		fields = append(fields, orderpay.FieldPrepayID)
	}
	if m.FieldCleared(orderpay.FieldPayExtra) {
		fields = append(fields, orderpay.FieldPayExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPayMutation) ClearField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderpay.FieldDelete:
		m.ClearDelete()
		return nil
	case orderpay.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case orderpay.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderpay.FieldRemission:
		m.ClearRemission()
		return nil
	case orderpay.FieldPay:
		m.ClearPay()
		return nil
	case orderpay.FieldNote:
		m.ClearNote()
		return nil
	case orderpay.FieldPayWay:
		m.ClearPayWay()
		return nil
	case orderpay.FieldPaySn:
		m.ClearPaySn()
		return nil
	case orderpay.FieldPrepayID:
		m.ClearPrepayID()
		return nil
	case orderpay.FieldPayExtra:
		m.ClearPayExtra()
		return nil
	}
	return fmt.Errorf("unknown OrderPay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPayMutation) ResetField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderpay.FieldDelete:
		m.ResetDelete()
		return nil
	case orderpay.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case orderpay.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderpay.FieldRemission:
		m.ResetRemission()
		return nil
	case orderpay.FieldPay:
		m.ResetPay()
		return nil
	case orderpay.FieldNote:
		m.ResetNote()
		return nil
	case orderpay.FieldPayWay:
		m.ResetPayWay()
		return nil
	case orderpay.FieldPaySn:
		m.ResetPaySn()
		return nil
	case orderpay.FieldPrepayID:
		m.ResetPrepayID()
		return nil
	case orderpay.FieldPayExtra:
		m.ResetPayExtra()
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderpay.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPayMutation) EdgeCleared(name string) bool {
	switch name {
	case orderpay.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPayMutation) ClearEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPayMutation) ResetEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay edge %s", name)
}

// OrderSalesMutation represents an operation that mutates the OrderSales nodes in the graph.
type OrderSalesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	member_id     *int64
	addmember_id  *int64
	sales_id      *int64
	addsales_id   *int64
	ratio         *int64
	addratio      *int64
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderSales, error)
	predicates    []predicate.OrderSales
}

var _ ent.Mutation = (*OrderSalesMutation)(nil)

// ordersalesOption allows management of the mutation configuration using functional options.
type ordersalesOption func(*OrderSalesMutation)

// newOrderSalesMutation creates new mutation for the OrderSales entity.
func newOrderSalesMutation(c config, op Op, opts ...ordersalesOption) *OrderSalesMutation {
	m := &OrderSalesMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSales,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSalesID sets the ID field of the mutation.
func withOrderSalesID(id int64) ordersalesOption {
	return func(m *OrderSalesMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSales
		)
		m.oldValue = func(ctx context.Context) (*OrderSales, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSales.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSales sets the old OrderSales of the mutation.
func withOrderSales(node *OrderSales) ordersalesOption {
	return func(m *OrderSalesMutation) {
		m.oldValue = func(context.Context) (*OrderSales, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSalesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSalesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderSales entities.
func (m *OrderSalesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSalesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderSalesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderSales.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderSalesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderSalesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderSalesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[ordersales.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderSalesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderSalesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, ordersales.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderSalesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderSalesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderSalesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[ordersales.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderSalesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderSalesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, ordersales.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OrderSalesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OrderSalesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OrderSalesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OrderSalesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OrderSalesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[ordersales.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OrderSalesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OrderSalesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, ordersales.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OrderSalesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OrderSalesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OrderSalesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OrderSalesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OrderSalesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[ordersales.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OrderSalesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OrderSalesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, ordersales.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *OrderSalesMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderSalesMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderSalesMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderSalesMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderSalesMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[ordersales.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderSalesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderSalesMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, ordersales.FieldStatus)
}

// SetOrderID sets the "order_id" field.
func (m *OrderSalesMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderSalesMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderSalesMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderSalesMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderSalesMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, ordersales.FieldOrderID)
}

// SetMemberID sets the "member_id" field.
func (m *OrderSalesMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OrderSalesMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *OrderSalesMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *OrderSalesMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *OrderSalesMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[ordersales.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *OrderSalesMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OrderSalesMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, ordersales.FieldMemberID)
}

// SetSalesID sets the "sales_id" field.
func (m *OrderSalesMutation) SetSalesID(i int64) {
	m.sales_id = &i
	m.addsales_id = nil
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *OrderSalesMutation) SalesID() (r int64, exists bool) {
	v := m.sales_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldSalesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// AddSalesID adds i to the "sales_id" field.
func (m *OrderSalesMutation) AddSalesID(i int64) {
	if m.addsales_id != nil {
		*m.addsales_id += i
	} else {
		m.addsales_id = &i
	}
}

// AddedSalesID returns the value that was added to the "sales_id" field in this mutation.
func (m *OrderSalesMutation) AddedSalesID() (r int64, exists bool) {
	v := m.addsales_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *OrderSalesMutation) ClearSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	m.clearedFields[ordersales.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *OrderSalesMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *OrderSalesMutation) ResetSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	delete(m.clearedFields, ordersales.FieldSalesID)
}

// SetRatio sets the "ratio" field.
func (m *OrderSalesMutation) SetRatio(i int64) {
	m.ratio = &i
	m.addratio = nil
}

// Ratio returns the value of the "ratio" field in the mutation.
func (m *OrderSalesMutation) Ratio() (r int64, exists bool) {
	v := m.ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldRatio returns the old "ratio" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldRatio(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatio: %w", err)
	}
	return oldValue.Ratio, nil
}

// AddRatio adds i to the "ratio" field.
func (m *OrderSalesMutation) AddRatio(i int64) {
	if m.addratio != nil {
		*m.addratio += i
	} else {
		m.addratio = &i
	}
}

// AddedRatio returns the value that was added to the "ratio" field in this mutation.
func (m *OrderSalesMutation) AddedRatio() (r int64, exists bool) {
	v := m.addratio
	if v == nil {
		return
	}
	return *v, true
}

// ClearRatio clears the value of the "ratio" field.
func (m *OrderSalesMutation) ClearRatio() {
	m.ratio = nil
	m.addratio = nil
	m.clearedFields[ordersales.FieldRatio] = struct{}{}
}

// RatioCleared returns if the "ratio" field was cleared in this mutation.
func (m *OrderSalesMutation) RatioCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldRatio]
	return ok
}

// ResetRatio resets all changes to the "ratio" field.
func (m *OrderSalesMutation) ResetRatio() {
	m.ratio = nil
	m.addratio = nil
	delete(m.clearedFields, ordersales.FieldRatio)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderSalesMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderSalesMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderSalesMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderSalesMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderSalesMutation builder.
func (m *OrderSalesMutation) Where(ps ...predicate.OrderSales) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderSalesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderSalesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderSales, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderSalesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderSalesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderSales).
func (m *OrderSalesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSalesMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, ordersales.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordersales.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, ordersales.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, ordersales.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m._order != nil {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.member_id != nil {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.sales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.ratio != nil {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSalesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.CreatedAt()
	case ordersales.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordersales.FieldDelete:
		return m.Delete()
	case ordersales.FieldCreatedID:
		return m.CreatedID()
	case ordersales.FieldStatus:
		return m.Status()
	case ordersales.FieldOrderID:
		return m.OrderID()
	case ordersales.FieldMemberID:
		return m.MemberID()
	case ordersales.FieldSalesID:
		return m.SalesID()
	case ordersales.FieldRatio:
		return m.Ratio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSalesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordersales.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordersales.FieldDelete:
		return m.OldDelete(ctx)
	case ordersales.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case ordersales.FieldStatus:
		return m.OldStatus(ctx)
	case ordersales.FieldOrderID:
		return m.OldOrderID(ctx)
	case ordersales.FieldMemberID:
		return m.OldMemberID(ctx)
	case ordersales.FieldSalesID:
		return m.OldSalesID(ctx)
	case ordersales.FieldRatio:
		return m.OldRatio(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSales field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordersales.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordersales.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case ordersales.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case ordersales.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ordersales.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case ordersales.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	case ordersales.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatio(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSalesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, ordersales.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, ordersales.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m.addmember_id != nil {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.addsales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.addratio != nil {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSalesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldDelete:
		return m.AddedDelete()
	case ordersales.FieldCreatedID:
		return m.AddedCreatedID()
	case ordersales.FieldStatus:
		return m.AddedStatus()
	case ordersales.FieldMemberID:
		return m.AddedMemberID()
	case ordersales.FieldSalesID:
		return m.AddedSalesID()
	case ordersales.FieldRatio:
		return m.AddedRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case ordersales.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case ordersales.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case ordersales.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesID(v)
		return nil
	case ordersales.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatio(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSalesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersales.FieldCreatedAt) {
		fields = append(fields, ordersales.FieldCreatedAt)
	}
	if m.FieldCleared(ordersales.FieldUpdatedAt) {
		fields = append(fields, ordersales.FieldUpdatedAt)
	}
	if m.FieldCleared(ordersales.FieldDelete) {
		fields = append(fields, ordersales.FieldDelete)
	}
	if m.FieldCleared(ordersales.FieldCreatedID) {
		fields = append(fields, ordersales.FieldCreatedID)
	}
	if m.FieldCleared(ordersales.FieldStatus) {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m.FieldCleared(ordersales.FieldOrderID) {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.FieldCleared(ordersales.FieldMemberID) {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.FieldCleared(ordersales.FieldSalesID) {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.FieldCleared(ordersales.FieldRatio) {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSalesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSalesMutation) ClearField(name string) error {
	switch name {
	case ordersales.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case ordersales.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case ordersales.FieldDelete:
		m.ClearDelete()
		return nil
	case ordersales.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case ordersales.FieldStatus:
		m.ClearStatus()
		return nil
	case ordersales.FieldOrderID:
		m.ClearOrderID()
		return nil
	case ordersales.FieldMemberID:
		m.ClearMemberID()
		return nil
	case ordersales.FieldSalesID:
		m.ClearSalesID()
		return nil
	case ordersales.FieldRatio:
		m.ClearRatio()
		return nil
	}
	return fmt.Errorf("unknown OrderSales nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSalesMutation) ResetField(name string) error {
	switch name {
	case ordersales.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordersales.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordersales.FieldDelete:
		m.ResetDelete()
		return nil
	case ordersales.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case ordersales.FieldStatus:
		m.ResetStatus()
		return nil
	case ordersales.FieldOrderID:
		m.ResetOrderID()
		return nil
	case ordersales.FieldMemberID:
		m.ResetMemberID()
		return nil
	case ordersales.FieldSalesID:
		m.ResetSalesID()
		return nil
	case ordersales.FieldRatio:
		m.ResetRatio()
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSalesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, ordersales.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSalesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersales.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSalesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSalesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSalesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, ordersales.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSalesMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersales.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSalesMutation) ClearEdge(name string) error {
	switch name {
	case ordersales.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSales unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSalesMutation) ResetEdge(name string) error {
	switch name {
	case ordersales.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSales edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	name           *string
	value          *string
	default_router *string
	remark         *string
	order_no       *int64
	addorder_no    *int64
	apis           *[]int
	appendapis     []int
	clearedFields  map[string]struct{}
	menus          map[int64]struct{}
	removedmenus   map[int64]struct{}
	clearedmenus   bool
	done           bool
	oldValue       func(context.Context) (*Role, error)
	predicates     []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[role.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, role.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[role.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, role.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *RoleMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *RoleMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *RoleMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *RoleMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *RoleMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[role.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *RoleMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[role.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *RoleMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, role.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *RoleMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *RoleMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *RoleMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *RoleMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *RoleMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[role.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *RoleMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *RoleMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, role.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RoleMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RoleMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RoleMutation) ResetValue() {
	m.value = nil
}

// SetDefaultRouter sets the "default_router" field.
func (m *RoleMutation) SetDefaultRouter(s string) {
	m.default_router = &s
}

// DefaultRouter returns the value of the "default_router" field in the mutation.
func (m *RoleMutation) DefaultRouter() (r string, exists bool) {
	v := m.default_router
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRouter returns the old "default_router" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDefaultRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRouter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRouter: %w", err)
	}
	return oldValue.DefaultRouter, nil
}

// ResetDefaultRouter resets all changes to the "default_router" field.
func (m *RoleMutation) ResetDefaultRouter() {
	m.default_router = nil
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
}

// SetOrderNo sets the "order_no" field.
func (m *RoleMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RoleMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *RoleMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *RoleMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RoleMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetApis sets the "apis" field.
func (m *RoleMutation) SetApis(i []int) {
	m.apis = &i
	m.appendapis = nil
}

// Apis returns the value of the "apis" field in the mutation.
func (m *RoleMutation) Apis() (r []int, exists bool) {
	v := m.apis
	if v == nil {
		return
	}
	return *v, true
}

// OldApis returns the old "apis" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApis(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApis: %w", err)
	}
	return oldValue.Apis, nil
}

// AppendApis adds i to the "apis" field.
func (m *RoleMutation) AppendApis(i []int) {
	m.appendapis = append(m.appendapis, i...)
}

// AppendedApis returns the list of values that were appended to the "apis" field in this mutation.
func (m *RoleMutation) AppendedApis() ([]int, bool) {
	if len(m.appendapis) == 0 {
		return nil, false
	}
	return m.appendapis, true
}

// ResetApis resets all changes to the "apis" field.
func (m *RoleMutation) ResetApis() {
	m.apis = nil
	m.appendapis = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.value != nil {
		fields = append(fields, role.FieldValue)
	}
	if m.default_router != nil {
		fields = append(fields, role.FieldDefaultRouter)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.order_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.apis != nil {
		fields = append(fields, role.FieldApis)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDelete:
		return m.Delete()
	case role.FieldCreatedID:
		return m.CreatedID()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldValue:
		return m.Value()
	case role.FieldDefaultRouter:
		return m.DefaultRouter()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldOrderNo:
		return m.OrderNo()
	case role.FieldApis:
		return m.Apis()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDelete:
		return m.OldDelete(ctx)
	case role.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldValue:
		return m.OldValue(ctx)
	case role.FieldDefaultRouter:
		return m.OldDefaultRouter(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case role.FieldApis:
		return m.OldApis(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case role.FieldDefaultRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRouter(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case role.FieldApis:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApis(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDelete:
		return m.AddedDelete()
	case role.FieldCreatedID:
		return m.AddedCreatedID()
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldOrderNo:
		return m.AddedOrderNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldCreatedAt) {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.FieldCleared(role.FieldUpdatedAt) {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.FieldCleared(role.FieldDelete) {
		fields = append(fields, role.FieldDelete)
	}
	if m.FieldCleared(role.FieldCreatedID) {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ClearDelete()
		return nil
	case role.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ResetDelete()
		return nil
	case role.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldValue:
		m.ResetValue()
		return nil
	case role.FieldDefaultRouter:
		m.ResetDefaultRouter()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case role.FieldApis:
		m.ResetApis()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	user_id       *int64
	adduser_id    *int64
	token         *string
	source        *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int64) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[token.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, token.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TokenMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[token.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TokenMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, token.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *TokenMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *TokenMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *TokenMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *TokenMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *TokenMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[token.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *TokenMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[token.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *TokenMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, token.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *TokenMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *TokenMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *TokenMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *TokenMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *TokenMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[token.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *TokenMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[token.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *TokenMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, token.FieldCreatedID)
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TokenMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TokenMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetSource sets the "source" field.
func (m *TokenMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TokenMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TokenMutation) ResetSource() {
	m.source = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TokenMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TokenMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, token.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, token.FieldCreatedID)
	}
	if m.user_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.source != nil {
		fields = append(fields, token.FieldSource)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldDelete:
		return m.Delete()
	case token.FieldCreatedID:
		return m.CreatedID()
	case token.FieldUserID:
		return m.UserID()
	case token.FieldToken:
		return m.Token()
	case token.FieldSource:
		return m.Source()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldDelete:
		return m.OldDelete(ctx)
	case token.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldSource:
		return m.OldSource(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case token.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, token.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, token.FieldCreatedID)
	}
	if m.adduser_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldDelete:
		return m.AddedDelete()
	case token.FieldCreatedID:
		return m.AddedCreatedID()
	case token.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case token.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldCreatedAt) {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.FieldCleared(token.FieldUpdatedAt) {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.FieldCleared(token.FieldDelete) {
		fields = append(fields, token.FieldDelete)
	}
	if m.FieldCleared(token.FieldCreatedID) {
		fields = append(fields, token.FieldCreatedID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case token.FieldDelete:
		m.ClearDelete()
		return nil
	case token.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldDelete:
		m.ResetDelete()
		return nil
	case token.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldSource:
		m.ResetSource()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	delete                *int64
	adddelete             *int64
	created_id            *int64
	addcreated_id         *int64
	status                *int64
	addstatus             *int64
	mobile                *string
	name                  *string
	gender                *int64
	addgender             *int64
	username              *string
	password              *string
	functions             *string
	job_time              *int64
	addjob_time           *int64
	role_id               *int64
	addrole_id            *int64
	default_venue_id      *int64
	adddefault_venue_id   *int64
	avatar                *string
	detail                *string
	clearedFields         map[string]struct{}
	token                 *int64
	clearedtoken          bool
	tag                   map[int64]struct{}
	removedtag            map[int64]struct{}
	clearedtag            bool
	created_orders        map[int64]struct{}
	removedcreated_orders map[int64]struct{}
	clearedcreated_orders bool
	user_entry            map[int64]struct{}
	removeduser_entry     map[int64]struct{}
	cleareduser_entry     bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *UserMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *UserMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *UserMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *UserMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *UserMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[user.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *UserMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[user.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *UserMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, user.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *UserMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *UserMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *UserMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *UserMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *UserMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[user.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *UserMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *UserMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, user.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *UserMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *UserMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFunctions sets the "functions" field.
func (m *UserMutation) SetFunctions(s string) {
	m.functions = &s
}

// Functions returns the value of the "functions" field in the mutation.
func (m *UserMutation) Functions() (r string, exists bool) {
	v := m.functions
	if v == nil {
		return
	}
	return *v, true
}

// OldFunctions returns the old "functions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFunctions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunctions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunctions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunctions: %w", err)
	}
	return oldValue.Functions, nil
}

// ResetFunctions resets all changes to the "functions" field.
func (m *UserMutation) ResetFunctions() {
	m.functions = nil
}

// SetJobTime sets the "job_time" field.
func (m *UserMutation) SetJobTime(i int64) {
	m.job_time = &i
	m.addjob_time = nil
}

// JobTime returns the value of the "job_time" field in the mutation.
func (m *UserMutation) JobTime() (r int64, exists bool) {
	v := m.job_time
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTime returns the old "job_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJobTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTime: %w", err)
	}
	return oldValue.JobTime, nil
}

// AddJobTime adds i to the "job_time" field.
func (m *UserMutation) AddJobTime(i int64) {
	if m.addjob_time != nil {
		*m.addjob_time += i
	} else {
		m.addjob_time = &i
	}
}

// AddedJobTime returns the value that was added to the "job_time" field in this mutation.
func (m *UserMutation) AddedJobTime() (r int64, exists bool) {
	v := m.addjob_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearJobTime clears the value of the "job_time" field.
func (m *UserMutation) ClearJobTime() {
	m.job_time = nil
	m.addjob_time = nil
	m.clearedFields[user.FieldJobTime] = struct{}{}
}

// JobTimeCleared returns if the "job_time" field was cleared in this mutation.
func (m *UserMutation) JobTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldJobTime]
	return ok
}

// ResetJobTime resets all changes to the "job_time" field.
func (m *UserMutation) ResetJobTime() {
	m.job_time = nil
	m.addjob_time = nil
	delete(m.clearedFields, user.FieldJobTime)
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(i int64) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r int64, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *UserMutation) AddRoleID(i int64) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *UserMutation) AddedRoleID() (r int64, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, user.FieldRoleID)
}

// SetDefaultVenueID sets the "default_venue_id" field.
func (m *UserMutation) SetDefaultVenueID(i int64) {
	m.default_venue_id = &i
	m.adddefault_venue_id = nil
}

// DefaultVenueID returns the value of the "default_venue_id" field in the mutation.
func (m *UserMutation) DefaultVenueID() (r int64, exists bool) {
	v := m.default_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultVenueID returns the old "default_venue_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDefaultVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultVenueID: %w", err)
	}
	return oldValue.DefaultVenueID, nil
}

// AddDefaultVenueID adds i to the "default_venue_id" field.
func (m *UserMutation) AddDefaultVenueID(i int64) {
	if m.adddefault_venue_id != nil {
		*m.adddefault_venue_id += i
	} else {
		m.adddefault_venue_id = &i
	}
}

// AddedDefaultVenueID returns the value that was added to the "default_venue_id" field in this mutation.
func (m *UserMutation) AddedDefaultVenueID() (r int64, exists bool) {
	v := m.adddefault_venue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultVenueID clears the value of the "default_venue_id" field.
func (m *UserMutation) ClearDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	m.clearedFields[user.FieldDefaultVenueID] = struct{}{}
}

// DefaultVenueIDCleared returns if the "default_venue_id" field was cleared in this mutation.
func (m *UserMutation) DefaultVenueIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDefaultVenueID]
	return ok
}

// ResetDefaultVenueID resets all changes to the "default_venue_id" field.
func (m *UserMutation) ResetDefaultVenueID() {
	m.default_venue_id = nil
	m.adddefault_venue_id = nil
	delete(m.clearedFields, user.FieldDefaultVenueID)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetDetail sets the "detail" field.
func (m *UserMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *UserMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *UserMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[user.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *UserMutation) DetailCleared() bool {
	_, ok := m.clearedFields[user.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *UserMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, user.FieldDetail)
}

// SetTokenID sets the "token" edge to the Token entity by id.
func (m *UserMutation) SetTokenID(id int64) {
	m.token = &id
}

// ClearToken clears the "token" edge to the Token entity.
func (m *UserMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the Token entity was cleared.
func (m *UserMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the "token" edge ID in the mutation.
func (m *UserMutation) TokenID() (id int64, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TokenIDs() (ids []int64) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *UserMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// AddTagIDs adds the "tag" edge to the DictionaryDetail entity by ids.
func (m *UserMutation) AddTagIDs(ids ...int64) {
	if m.tag == nil {
		m.tag = make(map[int64]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the DictionaryDetail entity.
func (m *UserMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the DictionaryDetail entity was cleared.
func (m *UserMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the DictionaryDetail entity by IDs.
func (m *UserMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtag == nil {
		m.removedtag = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the DictionaryDetail entity.
func (m *UserMutation) RemovedTagIDs() (ids []int64) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *UserMutation) TagIDs() (ids []int64) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *UserMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddCreatedOrderIDs adds the "created_orders" edge to the Order entity by ids.
func (m *UserMutation) AddCreatedOrderIDs(ids ...int64) {
	if m.created_orders == nil {
		m.created_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.created_orders[ids[i]] = struct{}{}
	}
}

// ClearCreatedOrders clears the "created_orders" edge to the Order entity.
func (m *UserMutation) ClearCreatedOrders() {
	m.clearedcreated_orders = true
}

// CreatedOrdersCleared reports if the "created_orders" edge to the Order entity was cleared.
func (m *UserMutation) CreatedOrdersCleared() bool {
	return m.clearedcreated_orders
}

// RemoveCreatedOrderIDs removes the "created_orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveCreatedOrderIDs(ids ...int64) {
	if m.removedcreated_orders == nil {
		m.removedcreated_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.created_orders, ids[i])
		m.removedcreated_orders[ids[i]] = struct{}{}
	}
}

// RemovedCreatedOrders returns the removed IDs of the "created_orders" edge to the Order entity.
func (m *UserMutation) RemovedCreatedOrdersIDs() (ids []int64) {
	for id := range m.removedcreated_orders {
		ids = append(ids, id)
	}
	return
}

// CreatedOrdersIDs returns the "created_orders" edge IDs in the mutation.
func (m *UserMutation) CreatedOrdersIDs() (ids []int64) {
	for id := range m.created_orders {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedOrders resets all changes to the "created_orders" edge.
func (m *UserMutation) ResetCreatedOrders() {
	m.created_orders = nil
	m.clearedcreated_orders = false
	m.removedcreated_orders = nil
}

// AddUserEntryIDs adds the "user_entry" edge to the EntryLogs entity by ids.
func (m *UserMutation) AddUserEntryIDs(ids ...int64) {
	if m.user_entry == nil {
		m.user_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_entry[ids[i]] = struct{}{}
	}
}

// ClearUserEntry clears the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) ClearUserEntry() {
	m.cleareduser_entry = true
}

// UserEntryCleared reports if the "user_entry" edge to the EntryLogs entity was cleared.
func (m *UserMutation) UserEntryCleared() bool {
	return m.cleareduser_entry
}

// RemoveUserEntryIDs removes the "user_entry" edge to the EntryLogs entity by IDs.
func (m *UserMutation) RemoveUserEntryIDs(ids ...int64) {
	if m.removeduser_entry == nil {
		m.removeduser_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_entry, ids[i])
		m.removeduser_entry[ids[i]] = struct{}{}
	}
}

// RemovedUserEntry returns the removed IDs of the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) RemovedUserEntryIDs() (ids []int64) {
	for id := range m.removeduser_entry {
		ids = append(ids, id)
	}
	return
}

// UserEntryIDs returns the "user_entry" edge IDs in the mutation.
func (m *UserMutation) UserEntryIDs() (ids []int64) {
	for id := range m.user_entry {
		ids = append(ids, id)
	}
	return
}

// ResetUserEntry resets all changes to the "user_entry" edge.
func (m *UserMutation) ResetUserEntry() {
	m.user_entry = nil
	m.cleareduser_entry = false
	m.removeduser_entry = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, user.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.functions != nil {
		fields = append(fields, user.FieldFunctions)
	}
	if m.job_time != nil {
		fields = append(fields, user.FieldJobTime)
	}
	if m.role_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.default_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.detail != nil {
		fields = append(fields, user.FieldDetail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDelete:
		return m.Delete()
	case user.FieldCreatedID:
		return m.CreatedID()
	case user.FieldStatus:
		return m.Status()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldName:
		return m.Name()
	case user.FieldGender:
		return m.Gender()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFunctions:
		return m.Functions()
	case user.FieldJobTime:
		return m.JobTime()
	case user.FieldRoleID:
		return m.RoleID()
	case user.FieldDefaultVenueID:
		return m.DefaultVenueID()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldDetail:
		return m.Detail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDelete:
		return m.OldDelete(ctx)
	case user.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFunctions:
		return m.OldFunctions(ctx)
	case user.FieldJobTime:
		return m.OldJobTime(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	case user.FieldDefaultVenueID:
		return m.OldDefaultVenueID(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldDetail:
		return m.OldDetail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case user.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFunctions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunctions(v)
		return nil
	case user.FieldJobTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTime(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultVenueID(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, user.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.addjob_time != nil {
		fields = append(fields, user.FieldJobTime)
	}
	if m.addrole_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.adddefault_venue_id != nil {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDelete:
		return m.AddedDelete()
	case user.FieldCreatedID:
		return m.AddedCreatedID()
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldGender:
		return m.AddedGender()
	case user.FieldJobTime:
		return m.AddedJobTime()
	case user.FieldRoleID:
		return m.AddedRoleID()
	case user.FieldDefaultVenueID:
		return m.AddedDefaultVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case user.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case user.FieldJobTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJobTime(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case user.FieldDefaultVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDelete) {
		fields = append(fields, user.FieldDelete)
	}
	if m.FieldCleared(user.FieldCreatedID) {
		fields = append(fields, user.FieldCreatedID)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldJobTime) {
		fields = append(fields, user.FieldJobTime)
	}
	if m.FieldCleared(user.FieldRoleID) {
		fields = append(fields, user.FieldRoleID)
	}
	if m.FieldCleared(user.FieldDefaultVenueID) {
		fields = append(fields, user.FieldDefaultVenueID)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldDetail) {
		fields = append(fields, user.FieldDetail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDelete:
		m.ClearDelete()
		return nil
	case user.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldJobTime:
		m.ClearJobTime()
		return nil
	case user.FieldRoleID:
		m.ClearRoleID()
		return nil
	case user.FieldDefaultVenueID:
		m.ClearDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldDetail:
		m.ClearDetail()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDelete:
		m.ResetDelete()
		return nil
	case user.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFunctions:
		m.ResetFunctions()
		return nil
	case user.FieldJobTime:
		m.ResetJobTime()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	case user.FieldDefaultVenueID:
		m.ResetDefaultVenueID()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldDetail:
		m.ResetDetail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.token != nil {
		edges = append(edges, user.EdgeToken)
	}
	if m.tag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m.created_orders != nil {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.user_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedOrders:
		ids := make([]ent.Value, 0, len(m.created_orders))
		for id := range m.created_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.user_entry))
		for id := range m.user_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m.removedcreated_orders != nil {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.removeduser_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedOrders:
		ids := make([]ent.Value, 0, len(m.removedcreated_orders))
		for id := range m.removedcreated_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.removeduser_entry))
		for id := range m.removeduser_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtoken {
		edges = append(edges, user.EdgeToken)
	}
	if m.clearedtag {
		edges = append(edges, user.EdgeTag)
	}
	if m.clearedcreated_orders {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.cleareduser_entry {
		edges = append(edges, user.EdgeUserEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeToken:
		return m.clearedtoken
	case user.EdgeTag:
		return m.clearedtag
	case user.EdgeCreatedOrders:
		return m.clearedcreated_orders
	case user.EdgeUserEntry:
		return m.cleareduser_entry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ResetToken()
		return nil
	case user.EdgeTag:
		m.ResetTag()
		return nil
	case user.EdgeCreatedOrders:
		m.ResetCreatedOrders()
		return nil
	case user.EdgeUserEntry:
		m.ResetUserEntry()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VenueMutation represents an operation that mutates the Venue nodes in the graph.
type VenueMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete              *int64
	adddelete           *int64
	created_id          *int64
	addcreated_id       *int64
	status              *int64
	addstatus           *int64
	name                *string
	address             *string
	address_detail      *string
	latitude            *string
	longitude           *string
	mobile              *string
	email               *string
	information         *string
	pic                 *string
	clearedFields       map[string]struct{}
	places              map[int64]struct{}
	removedplaces       map[int64]struct{}
	clearedplaces       bool
	venue_orders        map[int64]struct{}
	removedvenue_orders map[int64]struct{}
	clearedvenue_orders bool
	venue_entry         map[int64]struct{}
	removedvenue_entry  map[int64]struct{}
	clearedvenue_entry  bool
	done                bool
	oldValue            func(context.Context) (*Venue, error)
	predicates          []predicate.Venue
}

var _ ent.Mutation = (*VenueMutation)(nil)

// venueOption allows management of the mutation configuration using functional options.
type venueOption func(*VenueMutation)

// newVenueMutation creates new mutation for the Venue entity.
func newVenueMutation(c config, op Op, opts ...venueOption) *VenueMutation {
	m := &VenueMutation{
		config:        c,
		op:            op,
		typ:           TypeVenue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueID sets the ID field of the mutation.
func withVenueID(id int64) venueOption {
	return func(m *VenueMutation) {
		var (
			err   error
			once  sync.Once
			value *Venue
		)
		m.oldValue = func(ctx context.Context) (*Venue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Venue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenue sets the old Venue of the mutation.
func withVenue(node *Venue) venueOption {
	return func(m *VenueMutation) {
		m.oldValue = func(context.Context) (*Venue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Venue entities.
func (m *VenueMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Venue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VenueMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[venue.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VenueMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[venue.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, venue.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VenueMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[venue.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VenueMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[venue.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, venue.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *VenueMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *VenueMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *VenueMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *VenueMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *VenueMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[venue.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *VenueMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[venue.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *VenueMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, venue.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *VenueMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *VenueMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *VenueMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *VenueMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *VenueMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[venue.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *VenueMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[venue.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *VenueMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, venue.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *VenueMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenueMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenueMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenueMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenueMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venue.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenueMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venue.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenueMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venue.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenueMutation) ClearName() {
	m.name = nil
	m.clearedFields[venue.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenueMutation) NameCleared() bool {
	_, ok := m.clearedFields[venue.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenueMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venue.FieldName)
}

// SetAddress sets the "address" field.
func (m *VenueMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VenueMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VenueMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[venue.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VenueMutation) AddressCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VenueMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, venue.FieldAddress)
}

// SetAddressDetail sets the "address_detail" field.
func (m *VenueMutation) SetAddressDetail(s string) {
	m.address_detail = &s
}

// AddressDetail returns the value of the "address_detail" field in the mutation.
func (m *VenueMutation) AddressDetail() (r string, exists bool) {
	v := m.address_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "address_detail" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddressDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "address_detail" field.
func (m *VenueMutation) ClearAddressDetail() {
	m.address_detail = nil
	m.clearedFields[venue.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "address_detail" field was cleared in this mutation.
func (m *VenueMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "address_detail" field.
func (m *VenueMutation) ResetAddressDetail() {
	m.address_detail = nil
	delete(m.clearedFields, venue.FieldAddressDetail)
}

// SetLatitude sets the "latitude" field.
func (m *VenueMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *VenueMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *VenueMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[venue.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *VenueMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *VenueMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, venue.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *VenueMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *VenueMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *VenueMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[venue.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *VenueMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *VenueMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, venue.FieldLongitude)
}

// SetMobile sets the "mobile" field.
func (m *VenueMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *VenueMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *VenueMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[venue.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *VenueMutation) MobileCleared() bool {
	_, ok := m.clearedFields[venue.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *VenueMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, venue.FieldMobile)
}

// SetEmail sets the "email" field.
func (m *VenueMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *VenueMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *VenueMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[venue.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *VenueMutation) EmailCleared() bool {
	_, ok := m.clearedFields[venue.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *VenueMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, venue.FieldEmail)
}

// SetInformation sets the "information" field.
func (m *VenueMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the value of the "information" field in the mutation.
func (m *VenueMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old "information" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ClearInformation clears the value of the "information" field.
func (m *VenueMutation) ClearInformation() {
	m.information = nil
	m.clearedFields[venue.FieldInformation] = struct{}{}
}

// InformationCleared returns if the "information" field was cleared in this mutation.
func (m *VenueMutation) InformationCleared() bool {
	_, ok := m.clearedFields[venue.FieldInformation]
	return ok
}

// ResetInformation resets all changes to the "information" field.
func (m *VenueMutation) ResetInformation() {
	m.information = nil
	delete(m.clearedFields, venue.FieldInformation)
}

// SetPic sets the "pic" field.
func (m *VenueMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenueMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenueMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venue.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenueMutation) PicCleared() bool {
	_, ok := m.clearedFields[venue.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenueMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venue.FieldPic)
}

// AddPlaceIDs adds the "places" edge to the VenuePlace entity by ids.
func (m *VenueMutation) AddPlaceIDs(ids ...int64) {
	if m.places == nil {
		m.places = make(map[int64]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the VenuePlace entity.
func (m *VenueMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the VenuePlace entity was cleared.
func (m *VenueMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the VenuePlace entity by IDs.
func (m *VenueMutation) RemovePlaceIDs(ids ...int64) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the VenuePlace entity.
func (m *VenueMutation) RemovedPlacesIDs() (ids []int64) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *VenueMutation) PlacesIDs() (ids []int64) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *VenueMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddVenueOrderIDs adds the "venue_orders" edge to the Order entity by ids.
func (m *VenueMutation) AddVenueOrderIDs(ids ...int64) {
	if m.venue_orders == nil {
		m.venue_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.venue_orders[ids[i]] = struct{}{}
	}
}

// ClearVenueOrders clears the "venue_orders" edge to the Order entity.
func (m *VenueMutation) ClearVenueOrders() {
	m.clearedvenue_orders = true
}

// VenueOrdersCleared reports if the "venue_orders" edge to the Order entity was cleared.
func (m *VenueMutation) VenueOrdersCleared() bool {
	return m.clearedvenue_orders
}

// RemoveVenueOrderIDs removes the "venue_orders" edge to the Order entity by IDs.
func (m *VenueMutation) RemoveVenueOrderIDs(ids ...int64) {
	if m.removedvenue_orders == nil {
		m.removedvenue_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venue_orders, ids[i])
		m.removedvenue_orders[ids[i]] = struct{}{}
	}
}

// RemovedVenueOrders returns the removed IDs of the "venue_orders" edge to the Order entity.
func (m *VenueMutation) RemovedVenueOrdersIDs() (ids []int64) {
	for id := range m.removedvenue_orders {
		ids = append(ids, id)
	}
	return
}

// VenueOrdersIDs returns the "venue_orders" edge IDs in the mutation.
func (m *VenueMutation) VenueOrdersIDs() (ids []int64) {
	for id := range m.venue_orders {
		ids = append(ids, id)
	}
	return
}

// ResetVenueOrders resets all changes to the "venue_orders" edge.
func (m *VenueMutation) ResetVenueOrders() {
	m.venue_orders = nil
	m.clearedvenue_orders = false
	m.removedvenue_orders = nil
}

// AddVenueEntryIDs adds the "venue_entry" edge to the EntryLogs entity by ids.
func (m *VenueMutation) AddVenueEntryIDs(ids ...int64) {
	if m.venue_entry == nil {
		m.venue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.venue_entry[ids[i]] = struct{}{}
	}
}

// ClearVenueEntry clears the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) ClearVenueEntry() {
	m.clearedvenue_entry = true
}

// VenueEntryCleared reports if the "venue_entry" edge to the EntryLogs entity was cleared.
func (m *VenueMutation) VenueEntryCleared() bool {
	return m.clearedvenue_entry
}

// RemoveVenueEntryIDs removes the "venue_entry" edge to the EntryLogs entity by IDs.
func (m *VenueMutation) RemoveVenueEntryIDs(ids ...int64) {
	if m.removedvenue_entry == nil {
		m.removedvenue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venue_entry, ids[i])
		m.removedvenue_entry[ids[i]] = struct{}{}
	}
}

// RemovedVenueEntry returns the removed IDs of the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) RemovedVenueEntryIDs() (ids []int64) {
	for id := range m.removedvenue_entry {
		ids = append(ids, id)
	}
	return
}

// VenueEntryIDs returns the "venue_entry" edge IDs in the mutation.
func (m *VenueMutation) VenueEntryIDs() (ids []int64) {
	for id := range m.venue_entry {
		ids = append(ids, id)
	}
	return
}

// ResetVenueEntry resets all changes to the "venue_entry" edge.
func (m *VenueMutation) ResetVenueEntry() {
	m.venue_entry = nil
	m.clearedvenue_entry = false
	m.removedvenue_entry = nil
}

// Where appends a list predicates to the VenueMutation builder.
func (m *VenueMutation) Where(ps ...predicate.Venue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Venue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Venue).
func (m *VenueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, venue.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, venue.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, venue.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venue.FieldName)
	}
	if m.address != nil {
		fields = append(fields, venue.FieldAddress)
	}
	if m.address_detail != nil {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.latitude != nil {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.mobile != nil {
		fields = append(fields, venue.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, venue.FieldEmail)
	}
	if m.information != nil {
		fields = append(fields, venue.FieldInformation)
	}
	if m.pic != nil {
		fields = append(fields, venue.FieldPic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldCreatedAt:
		return m.CreatedAt()
	case venue.FieldUpdatedAt:
		return m.UpdatedAt()
	case venue.FieldDelete:
		return m.Delete()
	case venue.FieldCreatedID:
		return m.CreatedID()
	case venue.FieldStatus:
		return m.Status()
	case venue.FieldName:
		return m.Name()
	case venue.FieldAddress:
		return m.Address()
	case venue.FieldAddressDetail:
		return m.AddressDetail()
	case venue.FieldLatitude:
		return m.Latitude()
	case venue.FieldLongitude:
		return m.Longitude()
	case venue.FieldMobile:
		return m.Mobile()
	case venue.FieldEmail:
		return m.Email()
	case venue.FieldInformation:
		return m.Information()
	case venue.FieldPic:
		return m.Pic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venue.FieldDelete:
		return m.OldDelete(ctx)
	case venue.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case venue.FieldStatus:
		return m.OldStatus(ctx)
	case venue.FieldName:
		return m.OldName(ctx)
	case venue.FieldAddress:
		return m.OldAddress(ctx)
	case venue.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case venue.FieldLatitude:
		return m.OldLatitude(ctx)
	case venue.FieldLongitude:
		return m.OldLongitude(ctx)
	case venue.FieldMobile:
		return m.OldMobile(ctx)
	case venue.FieldEmail:
		return m.OldEmail(ctx)
	case venue.FieldInformation:
		return m.OldInformation(ctx)
	case venue.FieldPic:
		return m.OldPic(ctx)
	}
	return nil, fmt.Errorf("unknown Venue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venue.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case venue.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venue.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case venue.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case venue.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case venue.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case venue.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case venue.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case venue.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	case venue.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, venue.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, venue.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, venue.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldDelete:
		return m.AddedDelete()
	case venue.FieldCreatedID:
		return m.AddedCreatedID()
	case venue.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venue.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case venue.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Venue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venue.FieldCreatedAt) {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.FieldCleared(venue.FieldUpdatedAt) {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.FieldCleared(venue.FieldDelete) {
		fields = append(fields, venue.FieldDelete)
	}
	if m.FieldCleared(venue.FieldCreatedID) {
		fields = append(fields, venue.FieldCreatedID)
	}
	if m.FieldCleared(venue.FieldStatus) {
		fields = append(fields, venue.FieldStatus)
	}
	if m.FieldCleared(venue.FieldName) {
		fields = append(fields, venue.FieldName)
	}
	if m.FieldCleared(venue.FieldAddress) {
		fields = append(fields, venue.FieldAddress)
	}
	if m.FieldCleared(venue.FieldAddressDetail) {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.FieldCleared(venue.FieldLatitude) {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.FieldCleared(venue.FieldLongitude) {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.FieldCleared(venue.FieldMobile) {
		fields = append(fields, venue.FieldMobile)
	}
	if m.FieldCleared(venue.FieldEmail) {
		fields = append(fields, venue.FieldEmail)
	}
	if m.FieldCleared(venue.FieldInformation) {
		fields = append(fields, venue.FieldInformation)
	}
	if m.FieldCleared(venue.FieldPic) {
		fields = append(fields, venue.FieldPic)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueMutation) ClearField(name string) error {
	switch name {
	case venue.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case venue.FieldDelete:
		m.ClearDelete()
		return nil
	case venue.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case venue.FieldStatus:
		m.ClearStatus()
		return nil
	case venue.FieldName:
		m.ClearName()
		return nil
	case venue.FieldAddress:
		m.ClearAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ClearLatitude()
		return nil
	case venue.FieldLongitude:
		m.ClearLongitude()
		return nil
	case venue.FieldMobile:
		m.ClearMobile()
		return nil
	case venue.FieldEmail:
		m.ClearEmail()
		return nil
	case venue.FieldInformation:
		m.ClearInformation()
		return nil
	case venue.FieldPic:
		m.ClearPic()
		return nil
	}
	return fmt.Errorf("unknown Venue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueMutation) ResetField(name string) error {
	switch name {
	case venue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venue.FieldDelete:
		m.ResetDelete()
		return nil
	case venue.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case venue.FieldStatus:
		m.ResetStatus()
		return nil
	case venue.FieldName:
		m.ResetName()
		return nil
	case venue.FieldAddress:
		m.ResetAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ResetLatitude()
		return nil
	case venue.FieldLongitude:
		m.ResetLongitude()
		return nil
	case venue.FieldMobile:
		m.ResetMobile()
		return nil
	case venue.FieldEmail:
		m.ResetEmail()
		return nil
	case venue.FieldInformation:
		m.ResetInformation()
		return nil
	case venue.FieldPic:
		m.ResetPic()
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.places != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.venue_orders != nil {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.venue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueOrders:
		ids := make([]ent.Value, 0, len(m.venue_orders))
		for id := range m.venue_orders {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.venue_entry))
		for id := range m.venue_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplaces != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.removedvenue_orders != nil {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.removedvenue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueOrders:
		ids := make([]ent.Value, 0, len(m.removedvenue_orders))
		for id := range m.removedvenue_orders {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.removedvenue_entry))
		for id := range m.removedvenue_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplaces {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.clearedvenue_orders {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.clearedvenue_entry {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueMutation) EdgeCleared(name string) bool {
	switch name {
	case venue.EdgePlaces:
		return m.clearedplaces
	case venue.EdgeVenueOrders:
		return m.clearedvenue_orders
	case venue.EdgeVenueEntry:
		return m.clearedvenue_entry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Venue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueMutation) ResetEdge(name string) error {
	switch name {
	case venue.EdgePlaces:
		m.ResetPlaces()
		return nil
	case venue.EdgeVenueOrders:
		m.ResetVenueOrders()
		return nil
	case venue.EdgeVenueEntry:
		m.ResetVenueEntry()
		return nil
	}
	return fmt.Errorf("unknown Venue edge %s", name)
}

// VenuePlaceMutation represents an operation that mutates the VenuePlace nodes in the graph.
type VenuePlaceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	name          *string
	pic           *string
	number        *int64
	addnumber     *int64
	information   *string
	clearedFields map[string]struct{}
	venue         *int64
	clearedvenue  bool
	done          bool
	oldValue      func(context.Context) (*VenuePlace, error)
	predicates    []predicate.VenuePlace
}

var _ ent.Mutation = (*VenuePlaceMutation)(nil)

// venueplaceOption allows management of the mutation configuration using functional options.
type venueplaceOption func(*VenuePlaceMutation)

// newVenuePlaceMutation creates new mutation for the VenuePlace entity.
func newVenuePlaceMutation(c config, op Op, opts ...venueplaceOption) *VenuePlaceMutation {
	m := &VenuePlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeVenuePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenuePlaceID sets the ID field of the mutation.
func withVenuePlaceID(id int64) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *VenuePlace
		)
		m.oldValue = func(ctx context.Context) (*VenuePlace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VenuePlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenuePlace sets the old VenuePlace of the mutation.
func withVenuePlace(node *VenuePlace) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		m.oldValue = func(context.Context) (*VenuePlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenuePlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenuePlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VenuePlace entities.
func (m *VenuePlaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenuePlaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenuePlaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VenuePlace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenuePlaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenuePlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VenuePlaceMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[venueplace.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VenuePlaceMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenuePlaceMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, venueplace.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenuePlaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenuePlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VenuePlaceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[venueplace.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VenuePlaceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenuePlaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, venueplace.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *VenuePlaceMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *VenuePlaceMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *VenuePlaceMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *VenuePlaceMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *VenuePlaceMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[venueplace.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *VenuePlaceMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *VenuePlaceMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, venueplace.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *VenuePlaceMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *VenuePlaceMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *VenuePlaceMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *VenuePlaceMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *VenuePlaceMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[venueplace.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *VenuePlaceMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *VenuePlaceMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, venueplace.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *VenuePlaceMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenuePlaceMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenuePlaceMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenuePlaceMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenuePlaceMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venueplace.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenuePlaceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenuePlaceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venueplace.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenuePlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenuePlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenuePlaceMutation) ClearName() {
	m.name = nil
	m.clearedFields[venueplace.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenuePlaceMutation) NameCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenuePlaceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venueplace.FieldName)
}

// SetPic sets the "pic" field.
func (m *VenuePlaceMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenuePlaceMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenuePlaceMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venueplace.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenuePlaceMutation) PicCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenuePlaceMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venueplace.FieldPic)
}

// SetVenueID sets the "venue_id" field.
func (m *VenuePlaceMutation) SetVenueID(i int64) {
	m.venue = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenuePlaceMutation) VenueID() (r int64, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *VenuePlaceMutation) ClearVenueID() {
	m.venue = nil
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *VenuePlaceMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenuePlaceMutation) ResetVenueID() {
	m.venue = nil
	delete(m.clearedFields, venueplace.FieldVenueID)
}

// SetNumber sets the "number" field.
func (m *VenuePlaceMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *VenuePlaceMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *VenuePlaceMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *VenuePlaceMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *VenuePlaceMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[venueplace.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *VenuePlaceMutation) NumberCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *VenuePlaceMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, venueplace.FieldNumber)
}

// SetInformation sets the "information" field.
func (m *VenuePlaceMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the value of the "information" field in the mutation.
func (m *VenuePlaceMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old "information" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ClearInformation clears the value of the "information" field.
func (m *VenuePlaceMutation) ClearInformation() {
	m.information = nil
	m.clearedFields[venueplace.FieldInformation] = struct{}{}
}

// InformationCleared returns if the "information" field was cleared in this mutation.
func (m *VenuePlaceMutation) InformationCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldInformation]
	return ok
}

// ResetInformation resets all changes to the "information" field.
func (m *VenuePlaceMutation) ResetInformation() {
	m.information = nil
	delete(m.clearedFields, venueplace.FieldInformation)
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *VenuePlaceMutation) ClearVenue() {
	m.clearedvenue = true
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *VenuePlaceMutation) VenueCleared() bool {
	return m.VenueIDCleared() || m.clearedvenue
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *VenuePlaceMutation) VenueIDs() (ids []int64) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *VenuePlaceMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// Where appends a list predicates to the VenuePlaceMutation builder.
func (m *VenuePlaceMutation) Where(ps ...predicate.VenuePlace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenuePlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenuePlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VenuePlace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenuePlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenuePlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VenuePlace).
func (m *VenuePlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenuePlaceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, venueplace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venueplace.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, venueplace.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, venueplace.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venueplace.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.venue != nil {
		fields = append(fields, venueplace.FieldVenueID)
	}
	if m.number != nil {
		fields = append(fields, venueplace.FieldNumber)
	}
	if m.information != nil {
		fields = append(fields, venueplace.FieldInformation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenuePlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.CreatedAt()
	case venueplace.FieldUpdatedAt:
		return m.UpdatedAt()
	case venueplace.FieldDelete:
		return m.Delete()
	case venueplace.FieldCreatedID:
		return m.CreatedID()
	case venueplace.FieldStatus:
		return m.Status()
	case venueplace.FieldName:
		return m.Name()
	case venueplace.FieldPic:
		return m.Pic()
	case venueplace.FieldVenueID:
		return m.VenueID()
	case venueplace.FieldNumber:
		return m.Number()
	case venueplace.FieldInformation:
		return m.Information()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenuePlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venueplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venueplace.FieldDelete:
		return m.OldDelete(ctx)
	case venueplace.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case venueplace.FieldStatus:
		return m.OldStatus(ctx)
	case venueplace.FieldName:
		return m.OldName(ctx)
	case venueplace.FieldPic:
		return m.OldPic(ctx)
	case venueplace.FieldVenueID:
		return m.OldVenueID(ctx)
	case venueplace.FieldNumber:
		return m.OldNumber(ctx)
	case venueplace.FieldInformation:
		return m.OldInformation(ctx)
	}
	return nil, fmt.Errorf("unknown VenuePlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venueplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venueplace.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case venueplace.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venueplace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venueplace.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venueplace.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case venueplace.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case venueplace.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenuePlaceMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, venueplace.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, venueplace.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.addnumber != nil {
		fields = append(fields, venueplace.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenuePlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldDelete:
		return m.AddedDelete()
	case venueplace.FieldCreatedID:
		return m.AddedCreatedID()
	case venueplace.FieldStatus:
		return m.AddedStatus()
	case venueplace.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case venueplace.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case venueplace.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenuePlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venueplace.FieldCreatedAt) {
		fields = append(fields, venueplace.FieldCreatedAt)
	}
	if m.FieldCleared(venueplace.FieldUpdatedAt) {
		fields = append(fields, venueplace.FieldUpdatedAt)
	}
	if m.FieldCleared(venueplace.FieldDelete) {
		fields = append(fields, venueplace.FieldDelete)
	}
	if m.FieldCleared(venueplace.FieldCreatedID) {
		fields = append(fields, venueplace.FieldCreatedID)
	}
	if m.FieldCleared(venueplace.FieldStatus) {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.FieldCleared(venueplace.FieldName) {
		fields = append(fields, venueplace.FieldName)
	}
	if m.FieldCleared(venueplace.FieldPic) {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.FieldCleared(venueplace.FieldVenueID) {
		fields = append(fields, venueplace.FieldVenueID)
	}
	if m.FieldCleared(venueplace.FieldNumber) {
		fields = append(fields, venueplace.FieldNumber)
	}
	if m.FieldCleared(venueplace.FieldInformation) {
		fields = append(fields, venueplace.FieldInformation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenuePlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ClearField(name string) error {
	switch name {
	case venueplace.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case venueplace.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case venueplace.FieldDelete:
		m.ClearDelete()
		return nil
	case venueplace.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case venueplace.FieldStatus:
		m.ClearStatus()
		return nil
	case venueplace.FieldName:
		m.ClearName()
		return nil
	case venueplace.FieldPic:
		m.ClearPic()
		return nil
	case venueplace.FieldVenueID:
		m.ClearVenueID()
		return nil
	case venueplace.FieldNumber:
		m.ClearNumber()
		return nil
	case venueplace.FieldInformation:
		m.ClearInformation()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ResetField(name string) error {
	switch name {
	case venueplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venueplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venueplace.FieldDelete:
		m.ResetDelete()
		return nil
	case venueplace.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case venueplace.FieldStatus:
		m.ResetStatus()
		return nil
	case venueplace.FieldName:
		m.ResetName()
		return nil
	case venueplace.FieldPic:
		m.ResetPic()
		return nil
	case venueplace.FieldVenueID:
		m.ResetVenueID()
		return nil
	case venueplace.FieldNumber:
		m.ResetNumber()
		return nil
	case venueplace.FieldInformation:
		m.ResetInformation()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenuePlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.venue != nil {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenuePlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venueplace.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenuePlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenuePlaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenuePlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvenue {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenuePlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case venueplace.EdgeVenue:
		return m.clearedvenue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenuePlaceMutation) ClearEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenuePlaceMutation) ResetEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ResetVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace edge %s", name)
}
