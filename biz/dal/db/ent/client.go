// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"saas/biz/dal/db/ent/migrate"

	"saas/biz/dal/db/ent/api"
	"saas/biz/dal/db/ent/banner"
	"saas/biz/dal/db/ent/bootcamp"
	"saas/biz/dal/db/ent/bootcampparticipant"
	"saas/biz/dal/db/ent/community"
	"saas/biz/dal/db/ent/communityparticipant"
	"saas/biz/dal/db/ent/contest"
	"saas/biz/dal/db/ent/contestparticipant"
	"saas/biz/dal/db/ent/contract"
	"saas/biz/dal/db/ent/dictionary"
	"saas/biz/dal/db/ent/dictionarydetail"
	"saas/biz/dal/db/ent/entrylogs"
	"saas/biz/dal/db/ent/logs"
	"saas/biz/dal/db/ent/member"
	"saas/biz/dal/db/ent/membercontract"
	"saas/biz/dal/db/ent/membercontractcontent"
	"saas/biz/dal/db/ent/memberdetails"
	"saas/biz/dal/db/ent/membernote"
	"saas/biz/dal/db/ent/memberproduct"
	"saas/biz/dal/db/ent/memberprofile"
	"saas/biz/dal/db/ent/menu"
	"saas/biz/dal/db/ent/menuparam"
	"saas/biz/dal/db/ent/messages"
	"saas/biz/dal/db/ent/order"
	"saas/biz/dal/db/ent/orderamount"
	"saas/biz/dal/db/ent/orderitem"
	"saas/biz/dal/db/ent/orderpay"
	"saas/biz/dal/db/ent/ordersales"
	"saas/biz/dal/db/ent/product"
	"saas/biz/dal/db/ent/role"
	"saas/biz/dal/db/ent/schedule"
	"saas/biz/dal/db/ent/schedulecoach"
	"saas/biz/dal/db/ent/schedulemember"
	"saas/biz/dal/db/ent/token"
	"saas/biz/dal/db/ent/user"
	"saas/biz/dal/db/ent/userscheduling"
	"saas/biz/dal/db/ent/venue"
	"saas/biz/dal/db/ent/venueplace"
	"saas/biz/dal/db/ent/venuesms"
	"saas/biz/dal/db/ent/venuesmslog"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// API is the client for interacting with the API builders.
	API *APIClient
	// Banner is the client for interacting with the Banner builders.
	Banner *BannerClient
	// Bootcamp is the client for interacting with the Bootcamp builders.
	Bootcamp *BootcampClient
	// BootcampParticipant is the client for interacting with the BootcampParticipant builders.
	BootcampParticipant *BootcampParticipantClient
	// Community is the client for interacting with the Community builders.
	Community *CommunityClient
	// CommunityParticipant is the client for interacting with the CommunityParticipant builders.
	CommunityParticipant *CommunityParticipantClient
	// Contest is the client for interacting with the Contest builders.
	Contest *ContestClient
	// ContestParticipant is the client for interacting with the ContestParticipant builders.
	ContestParticipant *ContestParticipantClient
	// Contract is the client for interacting with the Contract builders.
	Contract *ContractClient
	// Dictionary is the client for interacting with the Dictionary builders.
	Dictionary *DictionaryClient
	// DictionaryDetail is the client for interacting with the DictionaryDetail builders.
	DictionaryDetail *DictionaryDetailClient
	// EntryLogs is the client for interacting with the EntryLogs builders.
	EntryLogs *EntryLogsClient
	// Logs is the client for interacting with the Logs builders.
	Logs *LogsClient
	// Member is the client for interacting with the Member builders.
	Member *MemberClient
	// MemberContract is the client for interacting with the MemberContract builders.
	MemberContract *MemberContractClient
	// MemberContractContent is the client for interacting with the MemberContractContent builders.
	MemberContractContent *MemberContractContentClient
	// MemberDetails is the client for interacting with the MemberDetails builders.
	MemberDetails *MemberDetailsClient
	// MemberNote is the client for interacting with the MemberNote builders.
	MemberNote *MemberNoteClient
	// MemberProduct is the client for interacting with the MemberProduct builders.
	MemberProduct *MemberProductClient
	// MemberProfile is the client for interacting with the MemberProfile builders.
	MemberProfile *MemberProfileClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// MenuParam is the client for interacting with the MenuParam builders.
	MenuParam *MenuParamClient
	// Messages is the client for interacting with the Messages builders.
	Messages *MessagesClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderAmount is the client for interacting with the OrderAmount builders.
	OrderAmount *OrderAmountClient
	// OrderItem is the client for interacting with the OrderItem builders.
	OrderItem *OrderItemClient
	// OrderPay is the client for interacting with the OrderPay builders.
	OrderPay *OrderPayClient
	// OrderSales is the client for interacting with the OrderSales builders.
	OrderSales *OrderSalesClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Schedule is the client for interacting with the Schedule builders.
	Schedule *ScheduleClient
	// ScheduleCoach is the client for interacting with the ScheduleCoach builders.
	ScheduleCoach *ScheduleCoachClient
	// ScheduleMember is the client for interacting with the ScheduleMember builders.
	ScheduleMember *ScheduleMemberClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserScheduling is the client for interacting with the UserScheduling builders.
	UserScheduling *UserSchedulingClient
	// Venue is the client for interacting with the Venue builders.
	Venue *VenueClient
	// VenuePlace is the client for interacting with the VenuePlace builders.
	VenuePlace *VenuePlaceClient
	// VenueSms is the client for interacting with the VenueSms builders.
	VenueSms *VenueSmsClient
	// VenueSmsLog is the client for interacting with the VenueSmsLog builders.
	VenueSmsLog *VenueSmsLogClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.API = NewAPIClient(c.config)
	c.Banner = NewBannerClient(c.config)
	c.Bootcamp = NewBootcampClient(c.config)
	c.BootcampParticipant = NewBootcampParticipantClient(c.config)
	c.Community = NewCommunityClient(c.config)
	c.CommunityParticipant = NewCommunityParticipantClient(c.config)
	c.Contest = NewContestClient(c.config)
	c.ContestParticipant = NewContestParticipantClient(c.config)
	c.Contract = NewContractClient(c.config)
	c.Dictionary = NewDictionaryClient(c.config)
	c.DictionaryDetail = NewDictionaryDetailClient(c.config)
	c.EntryLogs = NewEntryLogsClient(c.config)
	c.Logs = NewLogsClient(c.config)
	c.Member = NewMemberClient(c.config)
	c.MemberContract = NewMemberContractClient(c.config)
	c.MemberContractContent = NewMemberContractContentClient(c.config)
	c.MemberDetails = NewMemberDetailsClient(c.config)
	c.MemberNote = NewMemberNoteClient(c.config)
	c.MemberProduct = NewMemberProductClient(c.config)
	c.MemberProfile = NewMemberProfileClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.MenuParam = NewMenuParamClient(c.config)
	c.Messages = NewMessagesClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderAmount = NewOrderAmountClient(c.config)
	c.OrderItem = NewOrderItemClient(c.config)
	c.OrderPay = NewOrderPayClient(c.config)
	c.OrderSales = NewOrderSalesClient(c.config)
	c.Product = NewProductClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Schedule = NewScheduleClient(c.config)
	c.ScheduleCoach = NewScheduleCoachClient(c.config)
	c.ScheduleMember = NewScheduleMemberClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserScheduling = NewUserSchedulingClient(c.config)
	c.Venue = NewVenueClient(c.config)
	c.VenuePlace = NewVenuePlaceClient(c.config)
	c.VenueSms = NewVenueSmsClient(c.config)
	c.VenueSmsLog = NewVenueSmsLogClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		API:                   NewAPIClient(cfg),
		Banner:                NewBannerClient(cfg),
		Bootcamp:              NewBootcampClient(cfg),
		BootcampParticipant:   NewBootcampParticipantClient(cfg),
		Community:             NewCommunityClient(cfg),
		CommunityParticipant:  NewCommunityParticipantClient(cfg),
		Contest:               NewContestClient(cfg),
		ContestParticipant:    NewContestParticipantClient(cfg),
		Contract:              NewContractClient(cfg),
		Dictionary:            NewDictionaryClient(cfg),
		DictionaryDetail:      NewDictionaryDetailClient(cfg),
		EntryLogs:             NewEntryLogsClient(cfg),
		Logs:                  NewLogsClient(cfg),
		Member:                NewMemberClient(cfg),
		MemberContract:        NewMemberContractClient(cfg),
		MemberContractContent: NewMemberContractContentClient(cfg),
		MemberDetails:         NewMemberDetailsClient(cfg),
		MemberNote:            NewMemberNoteClient(cfg),
		MemberProduct:         NewMemberProductClient(cfg),
		MemberProfile:         NewMemberProfileClient(cfg),
		Menu:                  NewMenuClient(cfg),
		MenuParam:             NewMenuParamClient(cfg),
		Messages:              NewMessagesClient(cfg),
		Order:                 NewOrderClient(cfg),
		OrderAmount:           NewOrderAmountClient(cfg),
		OrderItem:             NewOrderItemClient(cfg),
		OrderPay:              NewOrderPayClient(cfg),
		OrderSales:            NewOrderSalesClient(cfg),
		Product:               NewProductClient(cfg),
		Role:                  NewRoleClient(cfg),
		Schedule:              NewScheduleClient(cfg),
		ScheduleCoach:         NewScheduleCoachClient(cfg),
		ScheduleMember:        NewScheduleMemberClient(cfg),
		Token:                 NewTokenClient(cfg),
		User:                  NewUserClient(cfg),
		UserScheduling:        NewUserSchedulingClient(cfg),
		Venue:                 NewVenueClient(cfg),
		VenuePlace:            NewVenuePlaceClient(cfg),
		VenueSms:              NewVenueSmsClient(cfg),
		VenueSmsLog:           NewVenueSmsLogClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		API:                   NewAPIClient(cfg),
		Banner:                NewBannerClient(cfg),
		Bootcamp:              NewBootcampClient(cfg),
		BootcampParticipant:   NewBootcampParticipantClient(cfg),
		Community:             NewCommunityClient(cfg),
		CommunityParticipant:  NewCommunityParticipantClient(cfg),
		Contest:               NewContestClient(cfg),
		ContestParticipant:    NewContestParticipantClient(cfg),
		Contract:              NewContractClient(cfg),
		Dictionary:            NewDictionaryClient(cfg),
		DictionaryDetail:      NewDictionaryDetailClient(cfg),
		EntryLogs:             NewEntryLogsClient(cfg),
		Logs:                  NewLogsClient(cfg),
		Member:                NewMemberClient(cfg),
		MemberContract:        NewMemberContractClient(cfg),
		MemberContractContent: NewMemberContractContentClient(cfg),
		MemberDetails:         NewMemberDetailsClient(cfg),
		MemberNote:            NewMemberNoteClient(cfg),
		MemberProduct:         NewMemberProductClient(cfg),
		MemberProfile:         NewMemberProfileClient(cfg),
		Menu:                  NewMenuClient(cfg),
		MenuParam:             NewMenuParamClient(cfg),
		Messages:              NewMessagesClient(cfg),
		Order:                 NewOrderClient(cfg),
		OrderAmount:           NewOrderAmountClient(cfg),
		OrderItem:             NewOrderItemClient(cfg),
		OrderPay:              NewOrderPayClient(cfg),
		OrderSales:            NewOrderSalesClient(cfg),
		Product:               NewProductClient(cfg),
		Role:                  NewRoleClient(cfg),
		Schedule:              NewScheduleClient(cfg),
		ScheduleCoach:         NewScheduleCoachClient(cfg),
		ScheduleMember:        NewScheduleMemberClient(cfg),
		Token:                 NewTokenClient(cfg),
		User:                  NewUserClient(cfg),
		UserScheduling:        NewUserSchedulingClient(cfg),
		Venue:                 NewVenueClient(cfg),
		VenuePlace:            NewVenuePlaceClient(cfg),
		VenueSms:              NewVenueSmsClient(cfg),
		VenueSmsLog:           NewVenueSmsLogClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		API.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.API, c.Banner, c.Bootcamp, c.BootcampParticipant, c.Community,
		c.CommunityParticipant, c.Contest, c.ContestParticipant, c.Contract,
		c.Dictionary, c.DictionaryDetail, c.EntryLogs, c.Logs, c.Member,
		c.MemberContract, c.MemberContractContent, c.MemberDetails, c.MemberNote,
		c.MemberProduct, c.MemberProfile, c.Menu, c.MenuParam, c.Messages, c.Order,
		c.OrderAmount, c.OrderItem, c.OrderPay, c.OrderSales, c.Product, c.Role,
		c.Schedule, c.ScheduleCoach, c.ScheduleMember, c.Token, c.User,
		c.UserScheduling, c.Venue, c.VenuePlace, c.VenueSms, c.VenueSmsLog,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.API, c.Banner, c.Bootcamp, c.BootcampParticipant, c.Community,
		c.CommunityParticipant, c.Contest, c.ContestParticipant, c.Contract,
		c.Dictionary, c.DictionaryDetail, c.EntryLogs, c.Logs, c.Member,
		c.MemberContract, c.MemberContractContent, c.MemberDetails, c.MemberNote,
		c.MemberProduct, c.MemberProfile, c.Menu, c.MenuParam, c.Messages, c.Order,
		c.OrderAmount, c.OrderItem, c.OrderPay, c.OrderSales, c.Product, c.Role,
		c.Schedule, c.ScheduleCoach, c.ScheduleMember, c.Token, c.User,
		c.UserScheduling, c.Venue, c.VenuePlace, c.VenueSms, c.VenueSmsLog,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIMutation:
		return c.API.mutate(ctx, m)
	case *BannerMutation:
		return c.Banner.mutate(ctx, m)
	case *BootcampMutation:
		return c.Bootcamp.mutate(ctx, m)
	case *BootcampParticipantMutation:
		return c.BootcampParticipant.mutate(ctx, m)
	case *CommunityMutation:
		return c.Community.mutate(ctx, m)
	case *CommunityParticipantMutation:
		return c.CommunityParticipant.mutate(ctx, m)
	case *ContestMutation:
		return c.Contest.mutate(ctx, m)
	case *ContestParticipantMutation:
		return c.ContestParticipant.mutate(ctx, m)
	case *ContractMutation:
		return c.Contract.mutate(ctx, m)
	case *DictionaryMutation:
		return c.Dictionary.mutate(ctx, m)
	case *DictionaryDetailMutation:
		return c.DictionaryDetail.mutate(ctx, m)
	case *EntryLogsMutation:
		return c.EntryLogs.mutate(ctx, m)
	case *LogsMutation:
		return c.Logs.mutate(ctx, m)
	case *MemberMutation:
		return c.Member.mutate(ctx, m)
	case *MemberContractMutation:
		return c.MemberContract.mutate(ctx, m)
	case *MemberContractContentMutation:
		return c.MemberContractContent.mutate(ctx, m)
	case *MemberDetailsMutation:
		return c.MemberDetails.mutate(ctx, m)
	case *MemberNoteMutation:
		return c.MemberNote.mutate(ctx, m)
	case *MemberProductMutation:
		return c.MemberProduct.mutate(ctx, m)
	case *MemberProfileMutation:
		return c.MemberProfile.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *MenuParamMutation:
		return c.MenuParam.mutate(ctx, m)
	case *MessagesMutation:
		return c.Messages.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderAmountMutation:
		return c.OrderAmount.mutate(ctx, m)
	case *OrderItemMutation:
		return c.OrderItem.mutate(ctx, m)
	case *OrderPayMutation:
		return c.OrderPay.mutate(ctx, m)
	case *OrderSalesMutation:
		return c.OrderSales.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *ScheduleMutation:
		return c.Schedule.mutate(ctx, m)
	case *ScheduleCoachMutation:
		return c.ScheduleCoach.mutate(ctx, m)
	case *ScheduleMemberMutation:
		return c.ScheduleMember.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserSchedulingMutation:
		return c.UserScheduling.mutate(ctx, m)
	case *VenueMutation:
		return c.Venue.mutate(ctx, m)
	case *VenuePlaceMutation:
		return c.VenuePlace.mutate(ctx, m)
	case *VenueSmsMutation:
		return c.VenueSms.mutate(ctx, m)
	case *VenueSmsLogMutation:
		return c.VenueSmsLog.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIClient is a client for the API schema.
type APIClient struct {
	config
}

// NewAPIClient returns a client for the API from the given config.
func NewAPIClient(c config) *APIClient {
	return &APIClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `api.Hooks(f(g(h())))`.
func (c *APIClient) Use(hooks ...Hook) {
	c.hooks.API = append(c.hooks.API, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `api.Intercept(f(g(h())))`.
func (c *APIClient) Intercept(interceptors ...Interceptor) {
	c.inters.API = append(c.inters.API, interceptors...)
}

// Create returns a builder for creating a API entity.
func (c *APIClient) Create() *APICreate {
	mutation := newAPIMutation(c.config, OpCreate)
	return &APICreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of API entities.
func (c *APIClient) CreateBulk(builders ...*APICreate) *APICreateBulk {
	return &APICreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIClient) MapCreateBulk(slice any, setFunc func(*APICreate, int)) *APICreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APICreateBulk{err: fmt.Errorf("calling to APIClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APICreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APICreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for API.
func (c *APIClient) Update() *APIUpdate {
	mutation := newAPIMutation(c.config, OpUpdate)
	return &APIUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIClient) UpdateOne(a *API) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withAPI(a))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIClient) UpdateOneID(id int64) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withAPIID(id))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for API.
func (c *APIClient) Delete() *APIDelete {
	mutation := newAPIMutation(c.config, OpDelete)
	return &APIDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIClient) DeleteOne(a *API) *APIDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIClient) DeleteOneID(id int64) *APIDeleteOne {
	builder := c.Delete().Where(api.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIDeleteOne{builder}
}

// Query returns a query builder for API.
func (c *APIClient) Query() *APIQuery {
	return &APIQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPI},
		inters: c.Interceptors(),
	}
}

// Get returns a API entity by its id.
func (c *APIClient) Get(ctx context.Context, id int64) (*API, error) {
	return c.Query().Where(api.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIClient) GetX(ctx context.Context, id int64) *API {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *APIClient) Hooks() []Hook {
	return c.hooks.API
}

// Interceptors returns the client interceptors.
func (c *APIClient) Interceptors() []Interceptor {
	return c.inters.API
}

func (c *APIClient) mutate(ctx context.Context, m *APIMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APICreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown API mutation op: %q", m.Op())
	}
}

// BannerClient is a client for the Banner schema.
type BannerClient struct {
	config
}

// NewBannerClient returns a client for the Banner from the given config.
func NewBannerClient(c config) *BannerClient {
	return &BannerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `banner.Hooks(f(g(h())))`.
func (c *BannerClient) Use(hooks ...Hook) {
	c.hooks.Banner = append(c.hooks.Banner, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `banner.Intercept(f(g(h())))`.
func (c *BannerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Banner = append(c.inters.Banner, interceptors...)
}

// Create returns a builder for creating a Banner entity.
func (c *BannerClient) Create() *BannerCreate {
	mutation := newBannerMutation(c.config, OpCreate)
	return &BannerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Banner entities.
func (c *BannerClient) CreateBulk(builders ...*BannerCreate) *BannerCreateBulk {
	return &BannerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BannerClient) MapCreateBulk(slice any, setFunc func(*BannerCreate, int)) *BannerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BannerCreateBulk{err: fmt.Errorf("calling to BannerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BannerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BannerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Banner.
func (c *BannerClient) Update() *BannerUpdate {
	mutation := newBannerMutation(c.config, OpUpdate)
	return &BannerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BannerClient) UpdateOne(b *Banner) *BannerUpdateOne {
	mutation := newBannerMutation(c.config, OpUpdateOne, withBanner(b))
	return &BannerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BannerClient) UpdateOneID(id int64) *BannerUpdateOne {
	mutation := newBannerMutation(c.config, OpUpdateOne, withBannerID(id))
	return &BannerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Banner.
func (c *BannerClient) Delete() *BannerDelete {
	mutation := newBannerMutation(c.config, OpDelete)
	return &BannerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BannerClient) DeleteOne(b *Banner) *BannerDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BannerClient) DeleteOneID(id int64) *BannerDeleteOne {
	builder := c.Delete().Where(banner.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BannerDeleteOne{builder}
}

// Query returns a query builder for Banner.
func (c *BannerClient) Query() *BannerQuery {
	return &BannerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBanner},
		inters: c.Interceptors(),
	}
}

// Get returns a Banner entity by its id.
func (c *BannerClient) Get(ctx context.Context, id int64) (*Banner, error) {
	return c.Query().Where(banner.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BannerClient) GetX(ctx context.Context, id int64) *Banner {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BannerClient) Hooks() []Hook {
	return c.hooks.Banner
}

// Interceptors returns the client interceptors.
func (c *BannerClient) Interceptors() []Interceptor {
	return c.inters.Banner
}

func (c *BannerClient) mutate(ctx context.Context, m *BannerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BannerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BannerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BannerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BannerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Banner mutation op: %q", m.Op())
	}
}

// BootcampClient is a client for the Bootcamp schema.
type BootcampClient struct {
	config
}

// NewBootcampClient returns a client for the Bootcamp from the given config.
func NewBootcampClient(c config) *BootcampClient {
	return &BootcampClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bootcamp.Hooks(f(g(h())))`.
func (c *BootcampClient) Use(hooks ...Hook) {
	c.hooks.Bootcamp = append(c.hooks.Bootcamp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bootcamp.Intercept(f(g(h())))`.
func (c *BootcampClient) Intercept(interceptors ...Interceptor) {
	c.inters.Bootcamp = append(c.inters.Bootcamp, interceptors...)
}

// Create returns a builder for creating a Bootcamp entity.
func (c *BootcampClient) Create() *BootcampCreate {
	mutation := newBootcampMutation(c.config, OpCreate)
	return &BootcampCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Bootcamp entities.
func (c *BootcampClient) CreateBulk(builders ...*BootcampCreate) *BootcampCreateBulk {
	return &BootcampCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BootcampClient) MapCreateBulk(slice any, setFunc func(*BootcampCreate, int)) *BootcampCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BootcampCreateBulk{err: fmt.Errorf("calling to BootcampClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BootcampCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BootcampCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Bootcamp.
func (c *BootcampClient) Update() *BootcampUpdate {
	mutation := newBootcampMutation(c.config, OpUpdate)
	return &BootcampUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BootcampClient) UpdateOne(b *Bootcamp) *BootcampUpdateOne {
	mutation := newBootcampMutation(c.config, OpUpdateOne, withBootcamp(b))
	return &BootcampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BootcampClient) UpdateOneID(id int64) *BootcampUpdateOne {
	mutation := newBootcampMutation(c.config, OpUpdateOne, withBootcampID(id))
	return &BootcampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Bootcamp.
func (c *BootcampClient) Delete() *BootcampDelete {
	mutation := newBootcampMutation(c.config, OpDelete)
	return &BootcampDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BootcampClient) DeleteOne(b *Bootcamp) *BootcampDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BootcampClient) DeleteOneID(id int64) *BootcampDeleteOne {
	builder := c.Delete().Where(bootcamp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BootcampDeleteOne{builder}
}

// Query returns a query builder for Bootcamp.
func (c *BootcampClient) Query() *BootcampQuery {
	return &BootcampQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBootcamp},
		inters: c.Interceptors(),
	}
}

// Get returns a Bootcamp entity by its id.
func (c *BootcampClient) Get(ctx context.Context, id int64) (*Bootcamp, error) {
	return c.Query().Where(bootcamp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BootcampClient) GetX(ctx context.Context, id int64) *Bootcamp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBootcampParticipants queries the bootcamp_participants edge of a Bootcamp.
func (c *BootcampClient) QueryBootcampParticipants(b *Bootcamp) *BootcampParticipantQuery {
	query := (&BootcampParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bootcamp.Table, bootcamp.FieldID, id),
			sqlgraph.To(bootcampparticipant.Table, bootcampparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bootcamp.BootcampParticipantsTable, bootcamp.BootcampParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BootcampClient) Hooks() []Hook {
	return c.hooks.Bootcamp
}

// Interceptors returns the client interceptors.
func (c *BootcampClient) Interceptors() []Interceptor {
	return c.inters.Bootcamp
}

func (c *BootcampClient) mutate(ctx context.Context, m *BootcampMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BootcampCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BootcampUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BootcampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BootcampDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Bootcamp mutation op: %q", m.Op())
	}
}

// BootcampParticipantClient is a client for the BootcampParticipant schema.
type BootcampParticipantClient struct {
	config
}

// NewBootcampParticipantClient returns a client for the BootcampParticipant from the given config.
func NewBootcampParticipantClient(c config) *BootcampParticipantClient {
	return &BootcampParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bootcampparticipant.Hooks(f(g(h())))`.
func (c *BootcampParticipantClient) Use(hooks ...Hook) {
	c.hooks.BootcampParticipant = append(c.hooks.BootcampParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bootcampparticipant.Intercept(f(g(h())))`.
func (c *BootcampParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.BootcampParticipant = append(c.inters.BootcampParticipant, interceptors...)
}

// Create returns a builder for creating a BootcampParticipant entity.
func (c *BootcampParticipantClient) Create() *BootcampParticipantCreate {
	mutation := newBootcampParticipantMutation(c.config, OpCreate)
	return &BootcampParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BootcampParticipant entities.
func (c *BootcampParticipantClient) CreateBulk(builders ...*BootcampParticipantCreate) *BootcampParticipantCreateBulk {
	return &BootcampParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BootcampParticipantClient) MapCreateBulk(slice any, setFunc func(*BootcampParticipantCreate, int)) *BootcampParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BootcampParticipantCreateBulk{err: fmt.Errorf("calling to BootcampParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BootcampParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BootcampParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BootcampParticipant.
func (c *BootcampParticipantClient) Update() *BootcampParticipantUpdate {
	mutation := newBootcampParticipantMutation(c.config, OpUpdate)
	return &BootcampParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BootcampParticipantClient) UpdateOne(bp *BootcampParticipant) *BootcampParticipantUpdateOne {
	mutation := newBootcampParticipantMutation(c.config, OpUpdateOne, withBootcampParticipant(bp))
	return &BootcampParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BootcampParticipantClient) UpdateOneID(id int64) *BootcampParticipantUpdateOne {
	mutation := newBootcampParticipantMutation(c.config, OpUpdateOne, withBootcampParticipantID(id))
	return &BootcampParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BootcampParticipant.
func (c *BootcampParticipantClient) Delete() *BootcampParticipantDelete {
	mutation := newBootcampParticipantMutation(c.config, OpDelete)
	return &BootcampParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BootcampParticipantClient) DeleteOne(bp *BootcampParticipant) *BootcampParticipantDeleteOne {
	return c.DeleteOneID(bp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BootcampParticipantClient) DeleteOneID(id int64) *BootcampParticipantDeleteOne {
	builder := c.Delete().Where(bootcampparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BootcampParticipantDeleteOne{builder}
}

// Query returns a query builder for BootcampParticipant.
func (c *BootcampParticipantClient) Query() *BootcampParticipantQuery {
	return &BootcampParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBootcampParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a BootcampParticipant entity by its id.
func (c *BootcampParticipantClient) Get(ctx context.Context, id int64) (*BootcampParticipant, error) {
	return c.Query().Where(bootcampparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BootcampParticipantClient) GetX(ctx context.Context, id int64) *BootcampParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBootcamps queries the bootcamps edge of a BootcampParticipant.
func (c *BootcampParticipantClient) QueryBootcamps(bp *BootcampParticipant) *BootcampQuery {
	query := (&BootcampClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bootcampparticipant.Table, bootcampparticipant.FieldID, id),
			sqlgraph.To(bootcamp.Table, bootcamp.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bootcampparticipant.BootcampsTable, bootcampparticipant.BootcampsColumn),
		)
		fromV = sqlgraph.Neighbors(bp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a BootcampParticipant.
func (c *BootcampParticipantClient) QueryMembers(bp *BootcampParticipant) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bootcampparticipant.Table, bootcampparticipant.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, bootcampparticipant.MembersTable, bootcampparticipant.MembersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BootcampParticipantClient) Hooks() []Hook {
	return c.hooks.BootcampParticipant
}

// Interceptors returns the client interceptors.
func (c *BootcampParticipantClient) Interceptors() []Interceptor {
	return c.inters.BootcampParticipant
}

func (c *BootcampParticipantClient) mutate(ctx context.Context, m *BootcampParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BootcampParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BootcampParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BootcampParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BootcampParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BootcampParticipant mutation op: %q", m.Op())
	}
}

// CommunityClient is a client for the Community schema.
type CommunityClient struct {
	config
}

// NewCommunityClient returns a client for the Community from the given config.
func NewCommunityClient(c config) *CommunityClient {
	return &CommunityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `community.Hooks(f(g(h())))`.
func (c *CommunityClient) Use(hooks ...Hook) {
	c.hooks.Community = append(c.hooks.Community, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `community.Intercept(f(g(h())))`.
func (c *CommunityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Community = append(c.inters.Community, interceptors...)
}

// Create returns a builder for creating a Community entity.
func (c *CommunityClient) Create() *CommunityCreate {
	mutation := newCommunityMutation(c.config, OpCreate)
	return &CommunityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Community entities.
func (c *CommunityClient) CreateBulk(builders ...*CommunityCreate) *CommunityCreateBulk {
	return &CommunityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommunityClient) MapCreateBulk(slice any, setFunc func(*CommunityCreate, int)) *CommunityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommunityCreateBulk{err: fmt.Errorf("calling to CommunityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommunityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommunityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Community.
func (c *CommunityClient) Update() *CommunityUpdate {
	mutation := newCommunityMutation(c.config, OpUpdate)
	return &CommunityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommunityClient) UpdateOne(co *Community) *CommunityUpdateOne {
	mutation := newCommunityMutation(c.config, OpUpdateOne, withCommunity(co))
	return &CommunityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommunityClient) UpdateOneID(id int64) *CommunityUpdateOne {
	mutation := newCommunityMutation(c.config, OpUpdateOne, withCommunityID(id))
	return &CommunityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Community.
func (c *CommunityClient) Delete() *CommunityDelete {
	mutation := newCommunityMutation(c.config, OpDelete)
	return &CommunityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommunityClient) DeleteOne(co *Community) *CommunityDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommunityClient) DeleteOneID(id int64) *CommunityDeleteOne {
	builder := c.Delete().Where(community.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommunityDeleteOne{builder}
}

// Query returns a query builder for Community.
func (c *CommunityClient) Query() *CommunityQuery {
	return &CommunityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCommunity},
		inters: c.Interceptors(),
	}
}

// Get returns a Community entity by its id.
func (c *CommunityClient) Get(ctx context.Context, id int64) (*Community, error) {
	return c.Query().Where(community.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommunityClient) GetX(ctx context.Context, id int64) *Community {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCommunityParticipants queries the community_participants edge of a Community.
func (c *CommunityClient) QueryCommunityParticipants(co *Community) *CommunityParticipantQuery {
	query := (&CommunityParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(community.Table, community.FieldID, id),
			sqlgraph.To(communityparticipant.Table, communityparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, community.CommunityParticipantsTable, community.CommunityParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommunityClient) Hooks() []Hook {
	return c.hooks.Community
}

// Interceptors returns the client interceptors.
func (c *CommunityClient) Interceptors() []Interceptor {
	return c.inters.Community
}

func (c *CommunityClient) mutate(ctx context.Context, m *CommunityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommunityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommunityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommunityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommunityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Community mutation op: %q", m.Op())
	}
}

// CommunityParticipantClient is a client for the CommunityParticipant schema.
type CommunityParticipantClient struct {
	config
}

// NewCommunityParticipantClient returns a client for the CommunityParticipant from the given config.
func NewCommunityParticipantClient(c config) *CommunityParticipantClient {
	return &CommunityParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `communityparticipant.Hooks(f(g(h())))`.
func (c *CommunityParticipantClient) Use(hooks ...Hook) {
	c.hooks.CommunityParticipant = append(c.hooks.CommunityParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `communityparticipant.Intercept(f(g(h())))`.
func (c *CommunityParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.CommunityParticipant = append(c.inters.CommunityParticipant, interceptors...)
}

// Create returns a builder for creating a CommunityParticipant entity.
func (c *CommunityParticipantClient) Create() *CommunityParticipantCreate {
	mutation := newCommunityParticipantMutation(c.config, OpCreate)
	return &CommunityParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CommunityParticipant entities.
func (c *CommunityParticipantClient) CreateBulk(builders ...*CommunityParticipantCreate) *CommunityParticipantCreateBulk {
	return &CommunityParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommunityParticipantClient) MapCreateBulk(slice any, setFunc func(*CommunityParticipantCreate, int)) *CommunityParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommunityParticipantCreateBulk{err: fmt.Errorf("calling to CommunityParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommunityParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommunityParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CommunityParticipant.
func (c *CommunityParticipantClient) Update() *CommunityParticipantUpdate {
	mutation := newCommunityParticipantMutation(c.config, OpUpdate)
	return &CommunityParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommunityParticipantClient) UpdateOne(cp *CommunityParticipant) *CommunityParticipantUpdateOne {
	mutation := newCommunityParticipantMutation(c.config, OpUpdateOne, withCommunityParticipant(cp))
	return &CommunityParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommunityParticipantClient) UpdateOneID(id int64) *CommunityParticipantUpdateOne {
	mutation := newCommunityParticipantMutation(c.config, OpUpdateOne, withCommunityParticipantID(id))
	return &CommunityParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CommunityParticipant.
func (c *CommunityParticipantClient) Delete() *CommunityParticipantDelete {
	mutation := newCommunityParticipantMutation(c.config, OpDelete)
	return &CommunityParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommunityParticipantClient) DeleteOne(cp *CommunityParticipant) *CommunityParticipantDeleteOne {
	return c.DeleteOneID(cp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommunityParticipantClient) DeleteOneID(id int64) *CommunityParticipantDeleteOne {
	builder := c.Delete().Where(communityparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommunityParticipantDeleteOne{builder}
}

// Query returns a query builder for CommunityParticipant.
func (c *CommunityParticipantClient) Query() *CommunityParticipantQuery {
	return &CommunityParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCommunityParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a CommunityParticipant entity by its id.
func (c *CommunityParticipantClient) Get(ctx context.Context, id int64) (*CommunityParticipant, error) {
	return c.Query().Where(communityparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommunityParticipantClient) GetX(ctx context.Context, id int64) *CommunityParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCommunity queries the community edge of a CommunityParticipant.
func (c *CommunityParticipantClient) QueryCommunity(cp *CommunityParticipant) *CommunityQuery {
	query := (&CommunityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(communityparticipant.Table, communityparticipant.FieldID, id),
			sqlgraph.To(community.Table, community.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, communityparticipant.CommunityTable, communityparticipant.CommunityColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a CommunityParticipant.
func (c *CommunityParticipantClient) QueryMembers(cp *CommunityParticipant) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(communityparticipant.Table, communityparticipant.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, communityparticipant.MembersTable, communityparticipant.MembersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommunityParticipantClient) Hooks() []Hook {
	return c.hooks.CommunityParticipant
}

// Interceptors returns the client interceptors.
func (c *CommunityParticipantClient) Interceptors() []Interceptor {
	return c.inters.CommunityParticipant
}

func (c *CommunityParticipantClient) mutate(ctx context.Context, m *CommunityParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommunityParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommunityParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommunityParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommunityParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CommunityParticipant mutation op: %q", m.Op())
	}
}

// ContestClient is a client for the Contest schema.
type ContestClient struct {
	config
}

// NewContestClient returns a client for the Contest from the given config.
func NewContestClient(c config) *ContestClient {
	return &ContestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contest.Hooks(f(g(h())))`.
func (c *ContestClient) Use(hooks ...Hook) {
	c.hooks.Contest = append(c.hooks.Contest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contest.Intercept(f(g(h())))`.
func (c *ContestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contest = append(c.inters.Contest, interceptors...)
}

// Create returns a builder for creating a Contest entity.
func (c *ContestClient) Create() *ContestCreate {
	mutation := newContestMutation(c.config, OpCreate)
	return &ContestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contest entities.
func (c *ContestClient) CreateBulk(builders ...*ContestCreate) *ContestCreateBulk {
	return &ContestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContestClient) MapCreateBulk(slice any, setFunc func(*ContestCreate, int)) *ContestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContestCreateBulk{err: fmt.Errorf("calling to ContestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contest.
func (c *ContestClient) Update() *ContestUpdate {
	mutation := newContestMutation(c.config, OpUpdate)
	return &ContestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContestClient) UpdateOne(co *Contest) *ContestUpdateOne {
	mutation := newContestMutation(c.config, OpUpdateOne, withContest(co))
	return &ContestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContestClient) UpdateOneID(id int64) *ContestUpdateOne {
	mutation := newContestMutation(c.config, OpUpdateOne, withContestID(id))
	return &ContestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contest.
func (c *ContestClient) Delete() *ContestDelete {
	mutation := newContestMutation(c.config, OpDelete)
	return &ContestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContestClient) DeleteOne(co *Contest) *ContestDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContestClient) DeleteOneID(id int64) *ContestDeleteOne {
	builder := c.Delete().Where(contest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContestDeleteOne{builder}
}

// Query returns a query builder for Contest.
func (c *ContestClient) Query() *ContestQuery {
	return &ContestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContest},
		inters: c.Interceptors(),
	}
}

// Get returns a Contest entity by its id.
func (c *ContestClient) Get(ctx context.Context, id int64) (*Contest, error) {
	return c.Query().Where(contest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContestClient) GetX(ctx context.Context, id int64) *Contest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContestParticipants queries the contest_participants edge of a Contest.
func (c *ContestClient) QueryContestParticipants(co *Contest) *ContestParticipantQuery {
	query := (&ContestParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contest.Table, contest.FieldID, id),
			sqlgraph.To(contestparticipant.Table, contestparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, contest.ContestParticipantsTable, contest.ContestParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContestClient) Hooks() []Hook {
	return c.hooks.Contest
}

// Interceptors returns the client interceptors.
func (c *ContestClient) Interceptors() []Interceptor {
	return c.inters.Contest
}

func (c *ContestClient) mutate(ctx context.Context, m *ContestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Contest mutation op: %q", m.Op())
	}
}

// ContestParticipantClient is a client for the ContestParticipant schema.
type ContestParticipantClient struct {
	config
}

// NewContestParticipantClient returns a client for the ContestParticipant from the given config.
func NewContestParticipantClient(c config) *ContestParticipantClient {
	return &ContestParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contestparticipant.Hooks(f(g(h())))`.
func (c *ContestParticipantClient) Use(hooks ...Hook) {
	c.hooks.ContestParticipant = append(c.hooks.ContestParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contestparticipant.Intercept(f(g(h())))`.
func (c *ContestParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.ContestParticipant = append(c.inters.ContestParticipant, interceptors...)
}

// Create returns a builder for creating a ContestParticipant entity.
func (c *ContestParticipantClient) Create() *ContestParticipantCreate {
	mutation := newContestParticipantMutation(c.config, OpCreate)
	return &ContestParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ContestParticipant entities.
func (c *ContestParticipantClient) CreateBulk(builders ...*ContestParticipantCreate) *ContestParticipantCreateBulk {
	return &ContestParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContestParticipantClient) MapCreateBulk(slice any, setFunc func(*ContestParticipantCreate, int)) *ContestParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContestParticipantCreateBulk{err: fmt.Errorf("calling to ContestParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContestParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContestParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ContestParticipant.
func (c *ContestParticipantClient) Update() *ContestParticipantUpdate {
	mutation := newContestParticipantMutation(c.config, OpUpdate)
	return &ContestParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContestParticipantClient) UpdateOne(cp *ContestParticipant) *ContestParticipantUpdateOne {
	mutation := newContestParticipantMutation(c.config, OpUpdateOne, withContestParticipant(cp))
	return &ContestParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContestParticipantClient) UpdateOneID(id int64) *ContestParticipantUpdateOne {
	mutation := newContestParticipantMutation(c.config, OpUpdateOne, withContestParticipantID(id))
	return &ContestParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ContestParticipant.
func (c *ContestParticipantClient) Delete() *ContestParticipantDelete {
	mutation := newContestParticipantMutation(c.config, OpDelete)
	return &ContestParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContestParticipantClient) DeleteOne(cp *ContestParticipant) *ContestParticipantDeleteOne {
	return c.DeleteOneID(cp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContestParticipantClient) DeleteOneID(id int64) *ContestParticipantDeleteOne {
	builder := c.Delete().Where(contestparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContestParticipantDeleteOne{builder}
}

// Query returns a query builder for ContestParticipant.
func (c *ContestParticipantClient) Query() *ContestParticipantQuery {
	return &ContestParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContestParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a ContestParticipant entity by its id.
func (c *ContestParticipantClient) Get(ctx context.Context, id int64) (*ContestParticipant, error) {
	return c.Query().Where(contestparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContestParticipantClient) GetX(ctx context.Context, id int64) *ContestParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContest queries the contest edge of a ContestParticipant.
func (c *ContestParticipantClient) QueryContest(cp *ContestParticipant) *ContestQuery {
	query := (&ContestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contestparticipant.Table, contestparticipant.FieldID, id),
			sqlgraph.To(contest.Table, contest.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contestparticipant.ContestTable, contestparticipant.ContestColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a ContestParticipant.
func (c *ContestParticipantClient) QueryMembers(cp *ContestParticipant) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contestparticipant.Table, contestparticipant.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, contestparticipant.MembersTable, contestparticipant.MembersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContestParticipantClient) Hooks() []Hook {
	return c.hooks.ContestParticipant
}

// Interceptors returns the client interceptors.
func (c *ContestParticipantClient) Interceptors() []Interceptor {
	return c.inters.ContestParticipant
}

func (c *ContestParticipantClient) mutate(ctx context.Context, m *ContestParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContestParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContestParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContestParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContestParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ContestParticipant mutation op: %q", m.Op())
	}
}

// ContractClient is a client for the Contract schema.
type ContractClient struct {
	config
}

// NewContractClient returns a client for the Contract from the given config.
func NewContractClient(c config) *ContractClient {
	return &ContractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contract.Hooks(f(g(h())))`.
func (c *ContractClient) Use(hooks ...Hook) {
	c.hooks.Contract = append(c.hooks.Contract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contract.Intercept(f(g(h())))`.
func (c *ContractClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contract = append(c.inters.Contract, interceptors...)
}

// Create returns a builder for creating a Contract entity.
func (c *ContractClient) Create() *ContractCreate {
	mutation := newContractMutation(c.config, OpCreate)
	return &ContractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contract entities.
func (c *ContractClient) CreateBulk(builders ...*ContractCreate) *ContractCreateBulk {
	return &ContractCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContractClient) MapCreateBulk(slice any, setFunc func(*ContractCreate, int)) *ContractCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContractCreateBulk{err: fmt.Errorf("calling to ContractClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContractCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contract.
func (c *ContractClient) Update() *ContractUpdate {
	mutation := newContractMutation(c.config, OpUpdate)
	return &ContractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContractClient) UpdateOne(co *Contract) *ContractUpdateOne {
	mutation := newContractMutation(c.config, OpUpdateOne, withContract(co))
	return &ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContractClient) UpdateOneID(id int64) *ContractUpdateOne {
	mutation := newContractMutation(c.config, OpUpdateOne, withContractID(id))
	return &ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contract.
func (c *ContractClient) Delete() *ContractDelete {
	mutation := newContractMutation(c.config, OpDelete)
	return &ContractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContractClient) DeleteOne(co *Contract) *ContractDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContractClient) DeleteOneID(id int64) *ContractDeleteOne {
	builder := c.Delete().Where(contract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContractDeleteOne{builder}
}

// Query returns a query builder for Contract.
func (c *ContractClient) Query() *ContractQuery {
	return &ContractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContract},
		inters: c.Interceptors(),
	}
}

// Get returns a Contract entity by its id.
func (c *ContractClient) Get(ctx context.Context, id int64) (*Contract, error) {
	return c.Query().Where(contract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContractClient) GetX(ctx context.Context, id int64) *Contract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Contract.
func (c *ContractClient) QueryProducts(co *Contract) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contract.Table, contract.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, contract.ProductsTable, contract.ProductsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContractClient) Hooks() []Hook {
	return c.hooks.Contract
}

// Interceptors returns the client interceptors.
func (c *ContractClient) Interceptors() []Interceptor {
	return c.inters.Contract
}

func (c *ContractClient) mutate(ctx context.Context, m *ContractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Contract mutation op: %q", m.Op())
	}
}

// DictionaryClient is a client for the Dictionary schema.
type DictionaryClient struct {
	config
}

// NewDictionaryClient returns a client for the Dictionary from the given config.
func NewDictionaryClient(c config) *DictionaryClient {
	return &DictionaryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionary.Hooks(f(g(h())))`.
func (c *DictionaryClient) Use(hooks ...Hook) {
	c.hooks.Dictionary = append(c.hooks.Dictionary, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionary.Intercept(f(g(h())))`.
func (c *DictionaryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dictionary = append(c.inters.Dictionary, interceptors...)
}

// Create returns a builder for creating a Dictionary entity.
func (c *DictionaryClient) Create() *DictionaryCreate {
	mutation := newDictionaryMutation(c.config, OpCreate)
	return &DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dictionary entities.
func (c *DictionaryClient) CreateBulk(builders ...*DictionaryCreate) *DictionaryCreateBulk {
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryClient) MapCreateBulk(slice any, setFunc func(*DictionaryCreate, int)) *DictionaryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryCreateBulk{err: fmt.Errorf("calling to DictionaryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dictionary.
func (c *DictionaryClient) Update() *DictionaryUpdate {
	mutation := newDictionaryMutation(c.config, OpUpdate)
	return &DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryClient) UpdateOne(d *Dictionary) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionary(d))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryClient) UpdateOneID(id int64) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionaryID(id))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dictionary.
func (c *DictionaryClient) Delete() *DictionaryDelete {
	mutation := newDictionaryMutation(c.config, OpDelete)
	return &DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryClient) DeleteOne(d *Dictionary) *DictionaryDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryClient) DeleteOneID(id int64) *DictionaryDeleteOne {
	builder := c.Delete().Where(dictionary.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryDeleteOne{builder}
}

// Query returns a query builder for Dictionary.
func (c *DictionaryClient) Query() *DictionaryQuery {
	return &DictionaryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionary},
		inters: c.Interceptors(),
	}
}

// Get returns a Dictionary entity by its id.
func (c *DictionaryClient) Get(ctx context.Context, id int64) (*Dictionary, error) {
	return c.Query().Where(dictionary.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryClient) GetX(ctx context.Context, id int64) *Dictionary {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDictionaryDetails queries the dictionary_details edge of a Dictionary.
func (c *DictionaryClient) QueryDictionaryDetails(d *Dictionary) *DictionaryDetailQuery {
	query := (&DictionaryDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionary.Table, dictionary.FieldID, id),
			sqlgraph.To(dictionarydetail.Table, dictionarydetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dictionary.DictionaryDetailsTable, dictionary.DictionaryDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryClient) Hooks() []Hook {
	return c.hooks.Dictionary
}

// Interceptors returns the client interceptors.
func (c *DictionaryClient) Interceptors() []Interceptor {
	return c.inters.Dictionary
}

func (c *DictionaryClient) mutate(ctx context.Context, m *DictionaryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dictionary mutation op: %q", m.Op())
	}
}

// DictionaryDetailClient is a client for the DictionaryDetail schema.
type DictionaryDetailClient struct {
	config
}

// NewDictionaryDetailClient returns a client for the DictionaryDetail from the given config.
func NewDictionaryDetailClient(c config) *DictionaryDetailClient {
	return &DictionaryDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionarydetail.Hooks(f(g(h())))`.
func (c *DictionaryDetailClient) Use(hooks ...Hook) {
	c.hooks.DictionaryDetail = append(c.hooks.DictionaryDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionarydetail.Intercept(f(g(h())))`.
func (c *DictionaryDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.DictionaryDetail = append(c.inters.DictionaryDetail, interceptors...)
}

// Create returns a builder for creating a DictionaryDetail entity.
func (c *DictionaryDetailClient) Create() *DictionaryDetailCreate {
	mutation := newDictionaryDetailMutation(c.config, OpCreate)
	return &DictionaryDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DictionaryDetail entities.
func (c *DictionaryDetailClient) CreateBulk(builders ...*DictionaryDetailCreate) *DictionaryDetailCreateBulk {
	return &DictionaryDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryDetailClient) MapCreateBulk(slice any, setFunc func(*DictionaryDetailCreate, int)) *DictionaryDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryDetailCreateBulk{err: fmt.Errorf("calling to DictionaryDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DictionaryDetail.
func (c *DictionaryDetailClient) Update() *DictionaryDetailUpdate {
	mutation := newDictionaryDetailMutation(c.config, OpUpdate)
	return &DictionaryDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryDetailClient) UpdateOne(dd *DictionaryDetail) *DictionaryDetailUpdateOne {
	mutation := newDictionaryDetailMutation(c.config, OpUpdateOne, withDictionaryDetail(dd))
	return &DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryDetailClient) UpdateOneID(id int64) *DictionaryDetailUpdateOne {
	mutation := newDictionaryDetailMutation(c.config, OpUpdateOne, withDictionaryDetailID(id))
	return &DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DictionaryDetail.
func (c *DictionaryDetailClient) Delete() *DictionaryDetailDelete {
	mutation := newDictionaryDetailMutation(c.config, OpDelete)
	return &DictionaryDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryDetailClient) DeleteOne(dd *DictionaryDetail) *DictionaryDetailDeleteOne {
	return c.DeleteOneID(dd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryDetailClient) DeleteOneID(id int64) *DictionaryDetailDeleteOne {
	builder := c.Delete().Where(dictionarydetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryDetailDeleteOne{builder}
}

// Query returns a query builder for DictionaryDetail.
func (c *DictionaryDetailClient) Query() *DictionaryDetailQuery {
	return &DictionaryDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionaryDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a DictionaryDetail entity by its id.
func (c *DictionaryDetailClient) Get(ctx context.Context, id int64) (*DictionaryDetail, error) {
	return c.Query().Where(dictionarydetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryDetailClient) GetX(ctx context.Context, id int64) *DictionaryDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDictionary queries the dictionary edge of a DictionaryDetail.
func (c *DictionaryDetailClient) QueryDictionary(dd *DictionaryDetail) *DictionaryQuery {
	query := (&DictionaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionarydetail.Table, dictionarydetail.FieldID, id),
			sqlgraph.To(dictionary.Table, dictionary.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dictionarydetail.DictionaryTable, dictionarydetail.DictionaryColumn),
		)
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a DictionaryDetail.
func (c *DictionaryDetailClient) QueryUsers(dd *DictionaryDetail) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionarydetail.Table, dictionarydetail.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dictionarydetail.UsersTable, dictionarydetail.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProducts queries the products edge of a DictionaryDetail.
func (c *DictionaryDetailClient) QueryProducts(dd *DictionaryDetail) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionarydetail.Table, dictionarydetail.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dictionarydetail.ProductsTable, dictionarydetail.ProductsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryDetailClient) Hooks() []Hook {
	return c.hooks.DictionaryDetail
}

// Interceptors returns the client interceptors.
func (c *DictionaryDetailClient) Interceptors() []Interceptor {
	return c.inters.DictionaryDetail
}

func (c *DictionaryDetailClient) mutate(ctx context.Context, m *DictionaryDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DictionaryDetail mutation op: %q", m.Op())
	}
}

// EntryLogsClient is a client for the EntryLogs schema.
type EntryLogsClient struct {
	config
}

// NewEntryLogsClient returns a client for the EntryLogs from the given config.
func NewEntryLogsClient(c config) *EntryLogsClient {
	return &EntryLogsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entrylogs.Hooks(f(g(h())))`.
func (c *EntryLogsClient) Use(hooks ...Hook) {
	c.hooks.EntryLogs = append(c.hooks.EntryLogs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entrylogs.Intercept(f(g(h())))`.
func (c *EntryLogsClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntryLogs = append(c.inters.EntryLogs, interceptors...)
}

// Create returns a builder for creating a EntryLogs entity.
func (c *EntryLogsClient) Create() *EntryLogsCreate {
	mutation := newEntryLogsMutation(c.config, OpCreate)
	return &EntryLogsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntryLogs entities.
func (c *EntryLogsClient) CreateBulk(builders ...*EntryLogsCreate) *EntryLogsCreateBulk {
	return &EntryLogsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntryLogsClient) MapCreateBulk(slice any, setFunc func(*EntryLogsCreate, int)) *EntryLogsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntryLogsCreateBulk{err: fmt.Errorf("calling to EntryLogsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntryLogsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntryLogsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntryLogs.
func (c *EntryLogsClient) Update() *EntryLogsUpdate {
	mutation := newEntryLogsMutation(c.config, OpUpdate)
	return &EntryLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntryLogsClient) UpdateOne(el *EntryLogs) *EntryLogsUpdateOne {
	mutation := newEntryLogsMutation(c.config, OpUpdateOne, withEntryLogs(el))
	return &EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntryLogsClient) UpdateOneID(id int64) *EntryLogsUpdateOne {
	mutation := newEntryLogsMutation(c.config, OpUpdateOne, withEntryLogsID(id))
	return &EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntryLogs.
func (c *EntryLogsClient) Delete() *EntryLogsDelete {
	mutation := newEntryLogsMutation(c.config, OpDelete)
	return &EntryLogsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntryLogsClient) DeleteOne(el *EntryLogs) *EntryLogsDeleteOne {
	return c.DeleteOneID(el.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntryLogsClient) DeleteOneID(id int64) *EntryLogsDeleteOne {
	builder := c.Delete().Where(entrylogs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntryLogsDeleteOne{builder}
}

// Query returns a query builder for EntryLogs.
func (c *EntryLogsClient) Query() *EntryLogsQuery {
	return &EntryLogsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntryLogs},
		inters: c.Interceptors(),
	}
}

// Get returns a EntryLogs entity by its id.
func (c *EntryLogsClient) Get(ctx context.Context, id int64) (*EntryLogs, error) {
	return c.Query().Where(entrylogs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntryLogsClient) GetX(ctx context.Context, id int64) *EntryLogs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVenues queries the venues edge of a EntryLogs.
func (c *EntryLogsClient) QueryVenues(el *EntryLogs) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := el.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entrylogs.Table, entrylogs.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entrylogs.VenuesTable, entrylogs.VenuesColumn),
		)
		fromV = sqlgraph.Neighbors(el.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a EntryLogs.
func (c *EntryLogsClient) QueryMembers(el *EntryLogs) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := el.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entrylogs.Table, entrylogs.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entrylogs.MembersTable, entrylogs.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(el.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a EntryLogs.
func (c *EntryLogsClient) QueryUsers(el *EntryLogs) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := el.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entrylogs.Table, entrylogs.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entrylogs.UsersTable, entrylogs.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(el.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntryLogsClient) Hooks() []Hook {
	return c.hooks.EntryLogs
}

// Interceptors returns the client interceptors.
func (c *EntryLogsClient) Interceptors() []Interceptor {
	return c.inters.EntryLogs
}

func (c *EntryLogsClient) mutate(ctx context.Context, m *EntryLogsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntryLogsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntryLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntryLogsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EntryLogs mutation op: %q", m.Op())
	}
}

// LogsClient is a client for the Logs schema.
type LogsClient struct {
	config
}

// NewLogsClient returns a client for the Logs from the given config.
func NewLogsClient(c config) *LogsClient {
	return &LogsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logs.Hooks(f(g(h())))`.
func (c *LogsClient) Use(hooks ...Hook) {
	c.hooks.Logs = append(c.hooks.Logs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logs.Intercept(f(g(h())))`.
func (c *LogsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Logs = append(c.inters.Logs, interceptors...)
}

// Create returns a builder for creating a Logs entity.
func (c *LogsClient) Create() *LogsCreate {
	mutation := newLogsMutation(c.config, OpCreate)
	return &LogsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Logs entities.
func (c *LogsClient) CreateBulk(builders ...*LogsCreate) *LogsCreateBulk {
	return &LogsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LogsClient) MapCreateBulk(slice any, setFunc func(*LogsCreate, int)) *LogsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LogsCreateBulk{err: fmt.Errorf("calling to LogsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LogsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LogsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Logs.
func (c *LogsClient) Update() *LogsUpdate {
	mutation := newLogsMutation(c.config, OpUpdate)
	return &LogsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogsClient) UpdateOne(l *Logs) *LogsUpdateOne {
	mutation := newLogsMutation(c.config, OpUpdateOne, withLogs(l))
	return &LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogsClient) UpdateOneID(id int64) *LogsUpdateOne {
	mutation := newLogsMutation(c.config, OpUpdateOne, withLogsID(id))
	return &LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Logs.
func (c *LogsClient) Delete() *LogsDelete {
	mutation := newLogsMutation(c.config, OpDelete)
	return &LogsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LogsClient) DeleteOne(l *Logs) *LogsDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LogsClient) DeleteOneID(id int64) *LogsDeleteOne {
	builder := c.Delete().Where(logs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogsDeleteOne{builder}
}

// Query returns a query builder for Logs.
func (c *LogsClient) Query() *LogsQuery {
	return &LogsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogs},
		inters: c.Interceptors(),
	}
}

// Get returns a Logs entity by its id.
func (c *LogsClient) Get(ctx context.Context, id int64) (*Logs, error) {
	return c.Query().Where(logs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogsClient) GetX(ctx context.Context, id int64) *Logs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LogsClient) Hooks() []Hook {
	return c.hooks.Logs
}

// Interceptors returns the client interceptors.
func (c *LogsClient) Interceptors() []Interceptor {
	return c.inters.Logs
}

func (c *LogsClient) mutate(ctx context.Context, m *LogsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LogsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LogsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LogsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Logs mutation op: %q", m.Op())
	}
}

// MemberClient is a client for the Member schema.
type MemberClient struct {
	config
}

// NewMemberClient returns a client for the Member from the given config.
func NewMemberClient(c config) *MemberClient {
	return &MemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `member.Hooks(f(g(h())))`.
func (c *MemberClient) Use(hooks ...Hook) {
	c.hooks.Member = append(c.hooks.Member, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `member.Intercept(f(g(h())))`.
func (c *MemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.Member = append(c.inters.Member, interceptors...)
}

// Create returns a builder for creating a Member entity.
func (c *MemberClient) Create() *MemberCreate {
	mutation := newMemberMutation(c.config, OpCreate)
	return &MemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Member entities.
func (c *MemberClient) CreateBulk(builders ...*MemberCreate) *MemberCreateBulk {
	return &MemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberClient) MapCreateBulk(slice any, setFunc func(*MemberCreate, int)) *MemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberCreateBulk{err: fmt.Errorf("calling to MemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Member.
func (c *MemberClient) Update() *MemberUpdate {
	mutation := newMemberMutation(c.config, OpUpdate)
	return &MemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberClient) UpdateOne(m *Member) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMember(m))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberClient) UpdateOneID(id int64) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMemberID(id))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Member.
func (c *MemberClient) Delete() *MemberDelete {
	mutation := newMemberMutation(c.config, OpDelete)
	return &MemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberClient) DeleteOne(m *Member) *MemberDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberClient) DeleteOneID(id int64) *MemberDeleteOne {
	builder := c.Delete().Where(member.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberDeleteOne{builder}
}

// Query returns a query builder for Member.
func (c *MemberClient) Query() *MemberQuery {
	return &MemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMember},
		inters: c.Interceptors(),
	}
}

// Get returns a Member entity by its id.
func (c *MemberClient) Get(ctx context.Context, id int64) (*Member, error) {
	return c.Query().Where(member.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberClient) GetX(ctx context.Context, id int64) *Member {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemberProfile queries the member_profile edge of a Member.
func (c *MemberClient) QueryMemberProfile(m *Member) *MemberProfileQuery {
	query := (&MemberProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(memberprofile.Table, memberprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberProfileTable, member.MemberProfileColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberDetails queries the member_details edge of a Member.
func (c *MemberClient) QueryMemberDetails(m *Member) *MemberDetailsQuery {
	query := (&MemberDetailsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(memberdetails.Table, memberdetails.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberDetailsTable, member.MemberDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberNotes queries the member_notes edge of a Member.
func (c *MemberClient) QueryMemberNotes(m *Member) *MemberNoteQuery {
	query := (&MemberNoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(membernote.Table, membernote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberNotesTable, member.MemberNotesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberOrders queries the member_orders edge of a Member.
func (c *MemberClient) QueryMemberOrders(m *Member) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberOrdersTable, member.MemberOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberProducts queries the member_products edge of a Member.
func (c *MemberClient) QueryMemberProducts(m *Member) *MemberProductQuery {
	query := (&MemberProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(memberproduct.Table, memberproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberProductsTable, member.MemberProductsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberEntry queries the member_entry edge of a Member.
func (c *MemberClient) QueryMemberEntry(m *Member) *EntryLogsQuery {
	query := (&EntryLogsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(entrylogs.Table, entrylogs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberEntryTable, member.MemberEntryColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberContents queries the member_contents edge of a Member.
func (c *MemberClient) QueryMemberContents(m *Member) *MemberContractQuery {
	query := (&MemberContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(membercontract.Table, membercontract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberContentsTable, member.MemberContentsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberContests queries the member_contests edge of a Member.
func (c *MemberClient) QueryMemberContests(m *Member) *ContestParticipantQuery {
	query := (&ContestParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(contestparticipant.Table, contestparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, member.MemberContestsTable, member.MemberContestsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberBootcamps queries the member_bootcamps edge of a Member.
func (c *MemberClient) QueryMemberBootcamps(m *Member) *BootcampParticipantQuery {
	query := (&BootcampParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(bootcampparticipant.Table, bootcampparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, member.MemberBootcampsTable, member.MemberBootcampsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberCommunitys queries the member_communitys edge of a Member.
func (c *MemberClient) QueryMemberCommunitys(m *Member) *CommunityParticipantQuery {
	query := (&CommunityParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(communityparticipant.Table, communityparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, member.MemberCommunitysTable, member.MemberCommunitysPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberClient) Hooks() []Hook {
	return c.hooks.Member
}

// Interceptors returns the client interceptors.
func (c *MemberClient) Interceptors() []Interceptor {
	return c.inters.Member
}

func (c *MemberClient) mutate(ctx context.Context, m *MemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Member mutation op: %q", m.Op())
	}
}

// MemberContractClient is a client for the MemberContract schema.
type MemberContractClient struct {
	config
}

// NewMemberContractClient returns a client for the MemberContract from the given config.
func NewMemberContractClient(c config) *MemberContractClient {
	return &MemberContractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membercontract.Hooks(f(g(h())))`.
func (c *MemberContractClient) Use(hooks ...Hook) {
	c.hooks.MemberContract = append(c.hooks.MemberContract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membercontract.Intercept(f(g(h())))`.
func (c *MemberContractClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberContract = append(c.inters.MemberContract, interceptors...)
}

// Create returns a builder for creating a MemberContract entity.
func (c *MemberContractClient) Create() *MemberContractCreate {
	mutation := newMemberContractMutation(c.config, OpCreate)
	return &MemberContractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberContract entities.
func (c *MemberContractClient) CreateBulk(builders ...*MemberContractCreate) *MemberContractCreateBulk {
	return &MemberContractCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberContractClient) MapCreateBulk(slice any, setFunc func(*MemberContractCreate, int)) *MemberContractCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberContractCreateBulk{err: fmt.Errorf("calling to MemberContractClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberContractCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberContractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberContract.
func (c *MemberContractClient) Update() *MemberContractUpdate {
	mutation := newMemberContractMutation(c.config, OpUpdate)
	return &MemberContractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberContractClient) UpdateOne(mc *MemberContract) *MemberContractUpdateOne {
	mutation := newMemberContractMutation(c.config, OpUpdateOne, withMemberContract(mc))
	return &MemberContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberContractClient) UpdateOneID(id int64) *MemberContractUpdateOne {
	mutation := newMemberContractMutation(c.config, OpUpdateOne, withMemberContractID(id))
	return &MemberContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberContract.
func (c *MemberContractClient) Delete() *MemberContractDelete {
	mutation := newMemberContractMutation(c.config, OpDelete)
	return &MemberContractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberContractClient) DeleteOne(mc *MemberContract) *MemberContractDeleteOne {
	return c.DeleteOneID(mc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberContractClient) DeleteOneID(id int64) *MemberContractDeleteOne {
	builder := c.Delete().Where(membercontract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberContractDeleteOne{builder}
}

// Query returns a query builder for MemberContract.
func (c *MemberContractClient) Query() *MemberContractQuery {
	return &MemberContractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberContract},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberContract entity by its id.
func (c *MemberContractClient) Get(ctx context.Context, id int64) (*MemberContract, error) {
	return c.Query().Where(membercontract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberContractClient) GetX(ctx context.Context, id int64) *MemberContract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContent queries the content edge of a MemberContract.
func (c *MemberContractClient) QueryContent(mc *MemberContract) *MemberContractContentQuery {
	query := (&MemberContractContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontract.Table, membercontract.FieldID, id),
			sqlgraph.To(membercontractcontent.Table, membercontractcontent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, membercontract.ContentTable, membercontract.ContentColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMember queries the member edge of a MemberContract.
func (c *MemberContractClient) QueryMember(mc *MemberContract) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontract.Table, membercontract.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membercontract.MemberTable, membercontract.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrder queries the order edge of a MemberContract.
func (c *MemberContractClient) QueryOrder(mc *MemberContract) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontract.Table, membercontract.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membercontract.OrderTable, membercontract.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberContractClient) Hooks() []Hook {
	return c.hooks.MemberContract
}

// Interceptors returns the client interceptors.
func (c *MemberContractClient) Interceptors() []Interceptor {
	return c.inters.MemberContract
}

func (c *MemberContractClient) mutate(ctx context.Context, m *MemberContractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberContractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberContractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberContractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberContract mutation op: %q", m.Op())
	}
}

// MemberContractContentClient is a client for the MemberContractContent schema.
type MemberContractContentClient struct {
	config
}

// NewMemberContractContentClient returns a client for the MemberContractContent from the given config.
func NewMemberContractContentClient(c config) *MemberContractContentClient {
	return &MemberContractContentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membercontractcontent.Hooks(f(g(h())))`.
func (c *MemberContractContentClient) Use(hooks ...Hook) {
	c.hooks.MemberContractContent = append(c.hooks.MemberContractContent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membercontractcontent.Intercept(f(g(h())))`.
func (c *MemberContractContentClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberContractContent = append(c.inters.MemberContractContent, interceptors...)
}

// Create returns a builder for creating a MemberContractContent entity.
func (c *MemberContractContentClient) Create() *MemberContractContentCreate {
	mutation := newMemberContractContentMutation(c.config, OpCreate)
	return &MemberContractContentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberContractContent entities.
func (c *MemberContractContentClient) CreateBulk(builders ...*MemberContractContentCreate) *MemberContractContentCreateBulk {
	return &MemberContractContentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberContractContentClient) MapCreateBulk(slice any, setFunc func(*MemberContractContentCreate, int)) *MemberContractContentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberContractContentCreateBulk{err: fmt.Errorf("calling to MemberContractContentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberContractContentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberContractContentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberContractContent.
func (c *MemberContractContentClient) Update() *MemberContractContentUpdate {
	mutation := newMemberContractContentMutation(c.config, OpUpdate)
	return &MemberContractContentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberContractContentClient) UpdateOne(mcc *MemberContractContent) *MemberContractContentUpdateOne {
	mutation := newMemberContractContentMutation(c.config, OpUpdateOne, withMemberContractContent(mcc))
	return &MemberContractContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberContractContentClient) UpdateOneID(id int64) *MemberContractContentUpdateOne {
	mutation := newMemberContractContentMutation(c.config, OpUpdateOne, withMemberContractContentID(id))
	return &MemberContractContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberContractContent.
func (c *MemberContractContentClient) Delete() *MemberContractContentDelete {
	mutation := newMemberContractContentMutation(c.config, OpDelete)
	return &MemberContractContentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberContractContentClient) DeleteOne(mcc *MemberContractContent) *MemberContractContentDeleteOne {
	return c.DeleteOneID(mcc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberContractContentClient) DeleteOneID(id int64) *MemberContractContentDeleteOne {
	builder := c.Delete().Where(membercontractcontent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberContractContentDeleteOne{builder}
}

// Query returns a query builder for MemberContractContent.
func (c *MemberContractContentClient) Query() *MemberContractContentQuery {
	return &MemberContractContentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberContractContent},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberContractContent entity by its id.
func (c *MemberContractContentClient) Get(ctx context.Context, id int64) (*MemberContractContent, error) {
	return c.Query().Where(membercontractcontent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberContractContentClient) GetX(ctx context.Context, id int64) *MemberContractContent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContract queries the contract edge of a MemberContractContent.
func (c *MemberContractContentClient) QueryContract(mcc *MemberContractContent) *MemberContractQuery {
	query := (&MemberContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mcc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontractcontent.Table, membercontractcontent.FieldID, id),
			sqlgraph.To(membercontract.Table, membercontract.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membercontractcontent.ContractTable, membercontractcontent.ContractColumn),
		)
		fromV = sqlgraph.Neighbors(mcc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberContractContentClient) Hooks() []Hook {
	return c.hooks.MemberContractContent
}

// Interceptors returns the client interceptors.
func (c *MemberContractContentClient) Interceptors() []Interceptor {
	return c.inters.MemberContractContent
}

func (c *MemberContractContentClient) mutate(ctx context.Context, m *MemberContractContentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberContractContentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberContractContentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberContractContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberContractContentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberContractContent mutation op: %q", m.Op())
	}
}

// MemberDetailsClient is a client for the MemberDetails schema.
type MemberDetailsClient struct {
	config
}

// NewMemberDetailsClient returns a client for the MemberDetails from the given config.
func NewMemberDetailsClient(c config) *MemberDetailsClient {
	return &MemberDetailsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberdetails.Hooks(f(g(h())))`.
func (c *MemberDetailsClient) Use(hooks ...Hook) {
	c.hooks.MemberDetails = append(c.hooks.MemberDetails, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberdetails.Intercept(f(g(h())))`.
func (c *MemberDetailsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberDetails = append(c.inters.MemberDetails, interceptors...)
}

// Create returns a builder for creating a MemberDetails entity.
func (c *MemberDetailsClient) Create() *MemberDetailsCreate {
	mutation := newMemberDetailsMutation(c.config, OpCreate)
	return &MemberDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberDetails entities.
func (c *MemberDetailsClient) CreateBulk(builders ...*MemberDetailsCreate) *MemberDetailsCreateBulk {
	return &MemberDetailsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberDetailsClient) MapCreateBulk(slice any, setFunc func(*MemberDetailsCreate, int)) *MemberDetailsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberDetailsCreateBulk{err: fmt.Errorf("calling to MemberDetailsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberDetailsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberDetailsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberDetails.
func (c *MemberDetailsClient) Update() *MemberDetailsUpdate {
	mutation := newMemberDetailsMutation(c.config, OpUpdate)
	return &MemberDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberDetailsClient) UpdateOne(md *MemberDetails) *MemberDetailsUpdateOne {
	mutation := newMemberDetailsMutation(c.config, OpUpdateOne, withMemberDetails(md))
	return &MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberDetailsClient) UpdateOneID(id int64) *MemberDetailsUpdateOne {
	mutation := newMemberDetailsMutation(c.config, OpUpdateOne, withMemberDetailsID(id))
	return &MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberDetails.
func (c *MemberDetailsClient) Delete() *MemberDetailsDelete {
	mutation := newMemberDetailsMutation(c.config, OpDelete)
	return &MemberDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberDetailsClient) DeleteOne(md *MemberDetails) *MemberDetailsDeleteOne {
	return c.DeleteOneID(md.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberDetailsClient) DeleteOneID(id int64) *MemberDetailsDeleteOne {
	builder := c.Delete().Where(memberdetails.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberDetailsDeleteOne{builder}
}

// Query returns a query builder for MemberDetails.
func (c *MemberDetailsClient) Query() *MemberDetailsQuery {
	return &MemberDetailsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberDetails},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberDetails entity by its id.
func (c *MemberDetailsClient) Get(ctx context.Context, id int64) (*MemberDetails, error) {
	return c.Query().Where(memberdetails.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberDetailsClient) GetX(ctx context.Context, id int64) *MemberDetails {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMember queries the member edge of a MemberDetails.
func (c *MemberDetailsClient) QueryMember(md *MemberDetails) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := md.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberdetails.Table, memberdetails.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberdetails.MemberTable, memberdetails.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(md.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberDetailsClient) Hooks() []Hook {
	return c.hooks.MemberDetails
}

// Interceptors returns the client interceptors.
func (c *MemberDetailsClient) Interceptors() []Interceptor {
	return c.inters.MemberDetails
}

func (c *MemberDetailsClient) mutate(ctx context.Context, m *MemberDetailsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberDetails mutation op: %q", m.Op())
	}
}

// MemberNoteClient is a client for the MemberNote schema.
type MemberNoteClient struct {
	config
}

// NewMemberNoteClient returns a client for the MemberNote from the given config.
func NewMemberNoteClient(c config) *MemberNoteClient {
	return &MemberNoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membernote.Hooks(f(g(h())))`.
func (c *MemberNoteClient) Use(hooks ...Hook) {
	c.hooks.MemberNote = append(c.hooks.MemberNote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membernote.Intercept(f(g(h())))`.
func (c *MemberNoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberNote = append(c.inters.MemberNote, interceptors...)
}

// Create returns a builder for creating a MemberNote entity.
func (c *MemberNoteClient) Create() *MemberNoteCreate {
	mutation := newMemberNoteMutation(c.config, OpCreate)
	return &MemberNoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberNote entities.
func (c *MemberNoteClient) CreateBulk(builders ...*MemberNoteCreate) *MemberNoteCreateBulk {
	return &MemberNoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberNoteClient) MapCreateBulk(slice any, setFunc func(*MemberNoteCreate, int)) *MemberNoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberNoteCreateBulk{err: fmt.Errorf("calling to MemberNoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberNoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberNoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberNote.
func (c *MemberNoteClient) Update() *MemberNoteUpdate {
	mutation := newMemberNoteMutation(c.config, OpUpdate)
	return &MemberNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberNoteClient) UpdateOne(mn *MemberNote) *MemberNoteUpdateOne {
	mutation := newMemberNoteMutation(c.config, OpUpdateOne, withMemberNote(mn))
	return &MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberNoteClient) UpdateOneID(id int64) *MemberNoteUpdateOne {
	mutation := newMemberNoteMutation(c.config, OpUpdateOne, withMemberNoteID(id))
	return &MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberNote.
func (c *MemberNoteClient) Delete() *MemberNoteDelete {
	mutation := newMemberNoteMutation(c.config, OpDelete)
	return &MemberNoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberNoteClient) DeleteOne(mn *MemberNote) *MemberNoteDeleteOne {
	return c.DeleteOneID(mn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberNoteClient) DeleteOneID(id int64) *MemberNoteDeleteOne {
	builder := c.Delete().Where(membernote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberNoteDeleteOne{builder}
}

// Query returns a query builder for MemberNote.
func (c *MemberNoteClient) Query() *MemberNoteQuery {
	return &MemberNoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberNote},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberNote entity by its id.
func (c *MemberNoteClient) Get(ctx context.Context, id int64) (*MemberNote, error) {
	return c.Query().Where(membernote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberNoteClient) GetX(ctx context.Context, id int64) *MemberNote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNotes queries the notes edge of a MemberNote.
func (c *MemberNoteClient) QueryNotes(mn *MemberNote) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membernote.Table, membernote.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membernote.NotesTable, membernote.NotesColumn),
		)
		fromV = sqlgraph.Neighbors(mn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberNoteClient) Hooks() []Hook {
	return c.hooks.MemberNote
}

// Interceptors returns the client interceptors.
func (c *MemberNoteClient) Interceptors() []Interceptor {
	return c.inters.MemberNote
}

func (c *MemberNoteClient) mutate(ctx context.Context, m *MemberNoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberNoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberNoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberNote mutation op: %q", m.Op())
	}
}

// MemberProductClient is a client for the MemberProduct schema.
type MemberProductClient struct {
	config
}

// NewMemberProductClient returns a client for the MemberProduct from the given config.
func NewMemberProductClient(c config) *MemberProductClient {
	return &MemberProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberproduct.Hooks(f(g(h())))`.
func (c *MemberProductClient) Use(hooks ...Hook) {
	c.hooks.MemberProduct = append(c.hooks.MemberProduct, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberproduct.Intercept(f(g(h())))`.
func (c *MemberProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberProduct = append(c.inters.MemberProduct, interceptors...)
}

// Create returns a builder for creating a MemberProduct entity.
func (c *MemberProductClient) Create() *MemberProductCreate {
	mutation := newMemberProductMutation(c.config, OpCreate)
	return &MemberProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberProduct entities.
func (c *MemberProductClient) CreateBulk(builders ...*MemberProductCreate) *MemberProductCreateBulk {
	return &MemberProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberProductClient) MapCreateBulk(slice any, setFunc func(*MemberProductCreate, int)) *MemberProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberProductCreateBulk{err: fmt.Errorf("calling to MemberProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberProduct.
func (c *MemberProductClient) Update() *MemberProductUpdate {
	mutation := newMemberProductMutation(c.config, OpUpdate)
	return &MemberProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberProductClient) UpdateOne(mp *MemberProduct) *MemberProductUpdateOne {
	mutation := newMemberProductMutation(c.config, OpUpdateOne, withMemberProduct(mp))
	return &MemberProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberProductClient) UpdateOneID(id int64) *MemberProductUpdateOne {
	mutation := newMemberProductMutation(c.config, OpUpdateOne, withMemberProductID(id))
	return &MemberProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberProduct.
func (c *MemberProductClient) Delete() *MemberProductDelete {
	mutation := newMemberProductMutation(c.config, OpDelete)
	return &MemberProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberProductClient) DeleteOne(mp *MemberProduct) *MemberProductDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberProductClient) DeleteOneID(id int64) *MemberProductDeleteOne {
	builder := c.Delete().Where(memberproduct.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberProductDeleteOne{builder}
}

// Query returns a query builder for MemberProduct.
func (c *MemberProductClient) Query() *MemberProductQuery {
	return &MemberProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberProduct entity by its id.
func (c *MemberProductClient) Get(ctx context.Context, id int64) (*MemberProduct, error) {
	return c.Query().Where(memberproduct.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberProductClient) GetX(ctx context.Context, id int64) *MemberProduct {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMembers queries the members edge of a MemberProduct.
func (c *MemberProductClient) QueryMembers(mp *MemberProduct) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproduct.Table, memberproduct.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberproduct.MembersTable, memberproduct.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberProductEntry queries the member_product_entry edge of a MemberProduct.
func (c *MemberProductClient) QueryMemberProductEntry(mp *MemberProduct) *EntryLogsQuery {
	query := (&EntryLogsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproduct.Table, memberproduct.FieldID, id),
			sqlgraph.To(entrylogs.Table, entrylogs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, memberproduct.MemberProductEntryTable, memberproduct.MemberProductEntryColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberProductContents queries the member_product_contents edge of a MemberProduct.
func (c *MemberProductClient) QueryMemberProductContents(mp *MemberProduct) *MemberContractQuery {
	query := (&MemberContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproduct.Table, memberproduct.FieldID, id),
			sqlgraph.To(membercontract.Table, membercontract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, memberproduct.MemberProductContentsTable, memberproduct.MemberProductContentsColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberProductClient) Hooks() []Hook {
	return c.hooks.MemberProduct
}

// Interceptors returns the client interceptors.
func (c *MemberProductClient) Interceptors() []Interceptor {
	return c.inters.MemberProduct
}

func (c *MemberProductClient) mutate(ctx context.Context, m *MemberProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberProduct mutation op: %q", m.Op())
	}
}

// MemberProfileClient is a client for the MemberProfile schema.
type MemberProfileClient struct {
	config
}

// NewMemberProfileClient returns a client for the MemberProfile from the given config.
func NewMemberProfileClient(c config) *MemberProfileClient {
	return &MemberProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberprofile.Hooks(f(g(h())))`.
func (c *MemberProfileClient) Use(hooks ...Hook) {
	c.hooks.MemberProfile = append(c.hooks.MemberProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberprofile.Intercept(f(g(h())))`.
func (c *MemberProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberProfile = append(c.inters.MemberProfile, interceptors...)
}

// Create returns a builder for creating a MemberProfile entity.
func (c *MemberProfileClient) Create() *MemberProfileCreate {
	mutation := newMemberProfileMutation(c.config, OpCreate)
	return &MemberProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberProfile entities.
func (c *MemberProfileClient) CreateBulk(builders ...*MemberProfileCreate) *MemberProfileCreateBulk {
	return &MemberProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberProfileClient) MapCreateBulk(slice any, setFunc func(*MemberProfileCreate, int)) *MemberProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberProfileCreateBulk{err: fmt.Errorf("calling to MemberProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberProfile.
func (c *MemberProfileClient) Update() *MemberProfileUpdate {
	mutation := newMemberProfileMutation(c.config, OpUpdate)
	return &MemberProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberProfileClient) UpdateOne(mp *MemberProfile) *MemberProfileUpdateOne {
	mutation := newMemberProfileMutation(c.config, OpUpdateOne, withMemberProfile(mp))
	return &MemberProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberProfileClient) UpdateOneID(id int64) *MemberProfileUpdateOne {
	mutation := newMemberProfileMutation(c.config, OpUpdateOne, withMemberProfileID(id))
	return &MemberProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberProfile.
func (c *MemberProfileClient) Delete() *MemberProfileDelete {
	mutation := newMemberProfileMutation(c.config, OpDelete)
	return &MemberProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberProfileClient) DeleteOne(mp *MemberProfile) *MemberProfileDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberProfileClient) DeleteOneID(id int64) *MemberProfileDeleteOne {
	builder := c.Delete().Where(memberprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberProfileDeleteOne{builder}
}

// Query returns a query builder for MemberProfile.
func (c *MemberProfileClient) Query() *MemberProfileQuery {
	return &MemberProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberProfile entity by its id.
func (c *MemberProfileClient) Get(ctx context.Context, id int64) (*MemberProfile, error) {
	return c.Query().Where(memberprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberProfileClient) GetX(ctx context.Context, id int64) *MemberProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMember queries the member edge of a MemberProfile.
func (c *MemberProfileClient) QueryMember(mp *MemberProfile) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberprofile.Table, memberprofile.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberprofile.MemberTable, memberprofile.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberProfileClient) Hooks() []Hook {
	return c.hooks.MemberProfile
}

// Interceptors returns the client interceptors.
func (c *MemberProfileClient) Interceptors() []Interceptor {
	return c.inters.MemberProfile
}

func (c *MemberProfileClient) mutate(ctx context.Context, m *MemberProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberProfile mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuClient) MapCreateBulk(slice any, setFunc func(*MenuCreate, int)) *MenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuCreateBulk{err: fmt.Errorf("calling to MenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id int64) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id int64) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id int64) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id int64) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Menu.
func (c *MenuClient) QueryRoles(m *Menu) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, menu.RolesTable, menu.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Menu.
func (c *MenuClient) QueryParent(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menu.ParentTable, menu.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Menu.
func (c *MenuClient) QueryChildren(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ChildrenTable, menu.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParams queries the params edge of a Menu.
func (c *MenuClient) QueryParams(m *Menu) *MenuParamQuery {
	query := (&MenuParamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menuparam.Table, menuparam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ParamsTable, menu.ParamsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// MenuParamClient is a client for the MenuParam schema.
type MenuParamClient struct {
	config
}

// NewMenuParamClient returns a client for the MenuParam from the given config.
func NewMenuParamClient(c config) *MenuParamClient {
	return &MenuParamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menuparam.Hooks(f(g(h())))`.
func (c *MenuParamClient) Use(hooks ...Hook) {
	c.hooks.MenuParam = append(c.hooks.MenuParam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menuparam.Intercept(f(g(h())))`.
func (c *MenuParamClient) Intercept(interceptors ...Interceptor) {
	c.inters.MenuParam = append(c.inters.MenuParam, interceptors...)
}

// Create returns a builder for creating a MenuParam entity.
func (c *MenuParamClient) Create() *MenuParamCreate {
	mutation := newMenuParamMutation(c.config, OpCreate)
	return &MenuParamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MenuParam entities.
func (c *MenuParamClient) CreateBulk(builders ...*MenuParamCreate) *MenuParamCreateBulk {
	return &MenuParamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuParamClient) MapCreateBulk(slice any, setFunc func(*MenuParamCreate, int)) *MenuParamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuParamCreateBulk{err: fmt.Errorf("calling to MenuParamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuParamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuParamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MenuParam.
func (c *MenuParamClient) Update() *MenuParamUpdate {
	mutation := newMenuParamMutation(c.config, OpUpdate)
	return &MenuParamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuParamClient) UpdateOne(mp *MenuParam) *MenuParamUpdateOne {
	mutation := newMenuParamMutation(c.config, OpUpdateOne, withMenuParam(mp))
	return &MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuParamClient) UpdateOneID(id int64) *MenuParamUpdateOne {
	mutation := newMenuParamMutation(c.config, OpUpdateOne, withMenuParamID(id))
	return &MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MenuParam.
func (c *MenuParamClient) Delete() *MenuParamDelete {
	mutation := newMenuParamMutation(c.config, OpDelete)
	return &MenuParamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuParamClient) DeleteOne(mp *MenuParam) *MenuParamDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuParamClient) DeleteOneID(id int64) *MenuParamDeleteOne {
	builder := c.Delete().Where(menuparam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuParamDeleteOne{builder}
}

// Query returns a query builder for MenuParam.
func (c *MenuParamClient) Query() *MenuParamQuery {
	return &MenuParamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenuParam},
		inters: c.Interceptors(),
	}
}

// Get returns a MenuParam entity by its id.
func (c *MenuParamClient) Get(ctx context.Context, id int64) (*MenuParam, error) {
	return c.Query().Where(menuparam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuParamClient) GetX(ctx context.Context, id int64) *MenuParam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenus queries the menus edge of a MenuParam.
func (c *MenuParamClient) QueryMenus(mp *MenuParam) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuparam.Table, menuparam.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menuparam.MenusTable, menuparam.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuParamClient) Hooks() []Hook {
	return c.hooks.MenuParam
}

// Interceptors returns the client interceptors.
func (c *MenuParamClient) Interceptors() []Interceptor {
	return c.inters.MenuParam
}

func (c *MenuParamClient) mutate(ctx context.Context, m *MenuParamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuParamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuParamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuParamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MenuParam mutation op: %q", m.Op())
	}
}

// MessagesClient is a client for the Messages schema.
type MessagesClient struct {
	config
}

// NewMessagesClient returns a client for the Messages from the given config.
func NewMessagesClient(c config) *MessagesClient {
	return &MessagesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messages.Hooks(f(g(h())))`.
func (c *MessagesClient) Use(hooks ...Hook) {
	c.hooks.Messages = append(c.hooks.Messages, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messages.Intercept(f(g(h())))`.
func (c *MessagesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Messages = append(c.inters.Messages, interceptors...)
}

// Create returns a builder for creating a Messages entity.
func (c *MessagesClient) Create() *MessagesCreate {
	mutation := newMessagesMutation(c.config, OpCreate)
	return &MessagesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Messages entities.
func (c *MessagesClient) CreateBulk(builders ...*MessagesCreate) *MessagesCreateBulk {
	return &MessagesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessagesClient) MapCreateBulk(slice any, setFunc func(*MessagesCreate, int)) *MessagesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessagesCreateBulk{err: fmt.Errorf("calling to MessagesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessagesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessagesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Messages.
func (c *MessagesClient) Update() *MessagesUpdate {
	mutation := newMessagesMutation(c.config, OpUpdate)
	return &MessagesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessagesClient) UpdateOne(m *Messages) *MessagesUpdateOne {
	mutation := newMessagesMutation(c.config, OpUpdateOne, withMessages(m))
	return &MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessagesClient) UpdateOneID(id int64) *MessagesUpdateOne {
	mutation := newMessagesMutation(c.config, OpUpdateOne, withMessagesID(id))
	return &MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Messages.
func (c *MessagesClient) Delete() *MessagesDelete {
	mutation := newMessagesMutation(c.config, OpDelete)
	return &MessagesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessagesClient) DeleteOne(m *Messages) *MessagesDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessagesClient) DeleteOneID(id int64) *MessagesDeleteOne {
	builder := c.Delete().Where(messages.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessagesDeleteOne{builder}
}

// Query returns a query builder for Messages.
func (c *MessagesClient) Query() *MessagesQuery {
	return &MessagesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessages},
		inters: c.Interceptors(),
	}
}

// Get returns a Messages entity by its id.
func (c *MessagesClient) Get(ctx context.Context, id int64) (*Messages, error) {
	return c.Query().Where(messages.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessagesClient) GetX(ctx context.Context, id int64) *Messages {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessagesClient) Hooks() []Hook {
	return c.hooks.Messages
}

// Interceptors returns the client interceptors.
func (c *MessagesClient) Interceptors() []Interceptor {
	return c.inters.Messages
}

func (c *MessagesClient) mutate(ctx context.Context, m *MessagesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessagesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessagesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessagesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Messages mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id int64) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id int64) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id int64) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id int64) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAmount queries the amount edge of a Order.
func (c *OrderClient) QueryAmount(o *Order) *OrderAmountQuery {
	query := (&OrderAmountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderamount.Table, orderamount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.AmountTable, order.AmountColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItem queries the item edge of a Order.
func (c *OrderClient) QueryItem(o *Order) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.ItemTable, order.ItemColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPay queries the pay edge of a Order.
func (c *OrderClient) QueryPay(o *Order) *OrderPayQuery {
	query := (&OrderPayClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderpay.Table, orderpay.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.PayTable, order.PayColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderContents queries the order_contents edge of a Order.
func (c *OrderClient) QueryOrderContents(o *Order) *MemberContractQuery {
	query := (&MemberContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(membercontract.Table, membercontract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.OrderContentsTable, order.OrderContentsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySales queries the sales edge of a Order.
func (c *OrderClient) QuerySales(o *Order) *OrderSalesQuery {
	query := (&OrderSalesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(ordersales.Table, ordersales.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.SalesTable, order.SalesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderVenues queries the order_venues edge of a Order.
func (c *OrderClient) QueryOrderVenues(o *Order) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.OrderVenuesTable, order.OrderVenuesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderMembers queries the order_members edge of a Order.
func (c *OrderClient) QueryOrderMembers(o *Order) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.OrderMembersTable, order.OrderMembersColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderCreates queries the order_creates edge of a Order.
func (c *OrderClient) QueryOrderCreates(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.OrderCreatesTable, order.OrderCreatesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderAmountClient is a client for the OrderAmount schema.
type OrderAmountClient struct {
	config
}

// NewOrderAmountClient returns a client for the OrderAmount from the given config.
func NewOrderAmountClient(c config) *OrderAmountClient {
	return &OrderAmountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderamount.Hooks(f(g(h())))`.
func (c *OrderAmountClient) Use(hooks ...Hook) {
	c.hooks.OrderAmount = append(c.hooks.OrderAmount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderamount.Intercept(f(g(h())))`.
func (c *OrderAmountClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderAmount = append(c.inters.OrderAmount, interceptors...)
}

// Create returns a builder for creating a OrderAmount entity.
func (c *OrderAmountClient) Create() *OrderAmountCreate {
	mutation := newOrderAmountMutation(c.config, OpCreate)
	return &OrderAmountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderAmount entities.
func (c *OrderAmountClient) CreateBulk(builders ...*OrderAmountCreate) *OrderAmountCreateBulk {
	return &OrderAmountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderAmountClient) MapCreateBulk(slice any, setFunc func(*OrderAmountCreate, int)) *OrderAmountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderAmountCreateBulk{err: fmt.Errorf("calling to OrderAmountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderAmountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderAmountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderAmount.
func (c *OrderAmountClient) Update() *OrderAmountUpdate {
	mutation := newOrderAmountMutation(c.config, OpUpdate)
	return &OrderAmountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderAmountClient) UpdateOne(oa *OrderAmount) *OrderAmountUpdateOne {
	mutation := newOrderAmountMutation(c.config, OpUpdateOne, withOrderAmount(oa))
	return &OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderAmountClient) UpdateOneID(id int64) *OrderAmountUpdateOne {
	mutation := newOrderAmountMutation(c.config, OpUpdateOne, withOrderAmountID(id))
	return &OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderAmount.
func (c *OrderAmountClient) Delete() *OrderAmountDelete {
	mutation := newOrderAmountMutation(c.config, OpDelete)
	return &OrderAmountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderAmountClient) DeleteOne(oa *OrderAmount) *OrderAmountDeleteOne {
	return c.DeleteOneID(oa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderAmountClient) DeleteOneID(id int64) *OrderAmountDeleteOne {
	builder := c.Delete().Where(orderamount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderAmountDeleteOne{builder}
}

// Query returns a query builder for OrderAmount.
func (c *OrderAmountClient) Query() *OrderAmountQuery {
	return &OrderAmountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderAmount},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderAmount entity by its id.
func (c *OrderAmountClient) Get(ctx context.Context, id int64) (*OrderAmount, error) {
	return c.Query().Where(orderamount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderAmountClient) GetX(ctx context.Context, id int64) *OrderAmount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderAmount.
func (c *OrderAmountClient) QueryOrder(oa *OrderAmount) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderamount.Table, orderamount.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderamount.OrderTable, orderamount.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderAmountClient) Hooks() []Hook {
	return c.hooks.OrderAmount
}

// Interceptors returns the client interceptors.
func (c *OrderAmountClient) Interceptors() []Interceptor {
	return c.inters.OrderAmount
}

func (c *OrderAmountClient) mutate(ctx context.Context, m *OrderAmountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderAmountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderAmountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderAmountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderAmount mutation op: %q", m.Op())
	}
}

// OrderItemClient is a client for the OrderItem schema.
type OrderItemClient struct {
	config
}

// NewOrderItemClient returns a client for the OrderItem from the given config.
func NewOrderItemClient(c config) *OrderItemClient {
	return &OrderItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderitem.Hooks(f(g(h())))`.
func (c *OrderItemClient) Use(hooks ...Hook) {
	c.hooks.OrderItem = append(c.hooks.OrderItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderitem.Intercept(f(g(h())))`.
func (c *OrderItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderItem = append(c.inters.OrderItem, interceptors...)
}

// Create returns a builder for creating a OrderItem entity.
func (c *OrderItemClient) Create() *OrderItemCreate {
	mutation := newOrderItemMutation(c.config, OpCreate)
	return &OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderItem entities.
func (c *OrderItemClient) CreateBulk(builders ...*OrderItemCreate) *OrderItemCreateBulk {
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderItemClient) MapCreateBulk(slice any, setFunc func(*OrderItemCreate, int)) *OrderItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderItemCreateBulk{err: fmt.Errorf("calling to OrderItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderItem.
func (c *OrderItemClient) Update() *OrderItemUpdate {
	mutation := newOrderItemMutation(c.config, OpUpdate)
	return &OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderItemClient) UpdateOne(oi *OrderItem) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItem(oi))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderItemClient) UpdateOneID(id int64) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItemID(id))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderItem.
func (c *OrderItemClient) Delete() *OrderItemDelete {
	mutation := newOrderItemMutation(c.config, OpDelete)
	return &OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderItemClient) DeleteOne(oi *OrderItem) *OrderItemDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderItemClient) DeleteOneID(id int64) *OrderItemDeleteOne {
	builder := c.Delete().Where(orderitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderItemDeleteOne{builder}
}

// Query returns a query builder for OrderItem.
func (c *OrderItemClient) Query() *OrderItemQuery {
	return &OrderItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderItem entity by its id.
func (c *OrderItemClient) Get(ctx context.Context, id int64) (*OrderItem, error) {
	return c.Query().Where(orderitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderItemClient) GetX(ctx context.Context, id int64) *OrderItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderItem.
func (c *OrderItemClient) QueryOrder(oi *OrderItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderitem.OrderTable, orderitem.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderItemClient) Hooks() []Hook {
	return c.hooks.OrderItem
}

// Interceptors returns the client interceptors.
func (c *OrderItemClient) Interceptors() []Interceptor {
	return c.inters.OrderItem
}

func (c *OrderItemClient) mutate(ctx context.Context, m *OrderItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderItem mutation op: %q", m.Op())
	}
}

// OrderPayClient is a client for the OrderPay schema.
type OrderPayClient struct {
	config
}

// NewOrderPayClient returns a client for the OrderPay from the given config.
func NewOrderPayClient(c config) *OrderPayClient {
	return &OrderPayClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderpay.Hooks(f(g(h())))`.
func (c *OrderPayClient) Use(hooks ...Hook) {
	c.hooks.OrderPay = append(c.hooks.OrderPay, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderpay.Intercept(f(g(h())))`.
func (c *OrderPayClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderPay = append(c.inters.OrderPay, interceptors...)
}

// Create returns a builder for creating a OrderPay entity.
func (c *OrderPayClient) Create() *OrderPayCreate {
	mutation := newOrderPayMutation(c.config, OpCreate)
	return &OrderPayCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderPay entities.
func (c *OrderPayClient) CreateBulk(builders ...*OrderPayCreate) *OrderPayCreateBulk {
	return &OrderPayCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderPayClient) MapCreateBulk(slice any, setFunc func(*OrderPayCreate, int)) *OrderPayCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderPayCreateBulk{err: fmt.Errorf("calling to OrderPayClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderPayCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderPayCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderPay.
func (c *OrderPayClient) Update() *OrderPayUpdate {
	mutation := newOrderPayMutation(c.config, OpUpdate)
	return &OrderPayUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderPayClient) UpdateOne(op *OrderPay) *OrderPayUpdateOne {
	mutation := newOrderPayMutation(c.config, OpUpdateOne, withOrderPay(op))
	return &OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderPayClient) UpdateOneID(id int64) *OrderPayUpdateOne {
	mutation := newOrderPayMutation(c.config, OpUpdateOne, withOrderPayID(id))
	return &OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderPay.
func (c *OrderPayClient) Delete() *OrderPayDelete {
	mutation := newOrderPayMutation(c.config, OpDelete)
	return &OrderPayDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderPayClient) DeleteOne(op *OrderPay) *OrderPayDeleteOne {
	return c.DeleteOneID(op.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderPayClient) DeleteOneID(id int64) *OrderPayDeleteOne {
	builder := c.Delete().Where(orderpay.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderPayDeleteOne{builder}
}

// Query returns a query builder for OrderPay.
func (c *OrderPayClient) Query() *OrderPayQuery {
	return &OrderPayQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderPay},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderPay entity by its id.
func (c *OrderPayClient) Get(ctx context.Context, id int64) (*OrderPay, error) {
	return c.Query().Where(orderpay.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderPayClient) GetX(ctx context.Context, id int64) *OrderPay {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderPay.
func (c *OrderPayClient) QueryOrder(op *OrderPay) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := op.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderpay.Table, orderpay.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderpay.OrderTable, orderpay.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(op.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderPayClient) Hooks() []Hook {
	return c.hooks.OrderPay
}

// Interceptors returns the client interceptors.
func (c *OrderPayClient) Interceptors() []Interceptor {
	return c.inters.OrderPay
}

func (c *OrderPayClient) mutate(ctx context.Context, m *OrderPayMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderPayCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderPayUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderPayDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderPay mutation op: %q", m.Op())
	}
}

// OrderSalesClient is a client for the OrderSales schema.
type OrderSalesClient struct {
	config
}

// NewOrderSalesClient returns a client for the OrderSales from the given config.
func NewOrderSalesClient(c config) *OrderSalesClient {
	return &OrderSalesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ordersales.Hooks(f(g(h())))`.
func (c *OrderSalesClient) Use(hooks ...Hook) {
	c.hooks.OrderSales = append(c.hooks.OrderSales, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ordersales.Intercept(f(g(h())))`.
func (c *OrderSalesClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderSales = append(c.inters.OrderSales, interceptors...)
}

// Create returns a builder for creating a OrderSales entity.
func (c *OrderSalesClient) Create() *OrderSalesCreate {
	mutation := newOrderSalesMutation(c.config, OpCreate)
	return &OrderSalesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderSales entities.
func (c *OrderSalesClient) CreateBulk(builders ...*OrderSalesCreate) *OrderSalesCreateBulk {
	return &OrderSalesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderSalesClient) MapCreateBulk(slice any, setFunc func(*OrderSalesCreate, int)) *OrderSalesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderSalesCreateBulk{err: fmt.Errorf("calling to OrderSalesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderSalesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderSalesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderSales.
func (c *OrderSalesClient) Update() *OrderSalesUpdate {
	mutation := newOrderSalesMutation(c.config, OpUpdate)
	return &OrderSalesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderSalesClient) UpdateOne(os *OrderSales) *OrderSalesUpdateOne {
	mutation := newOrderSalesMutation(c.config, OpUpdateOne, withOrderSales(os))
	return &OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderSalesClient) UpdateOneID(id int64) *OrderSalesUpdateOne {
	mutation := newOrderSalesMutation(c.config, OpUpdateOne, withOrderSalesID(id))
	return &OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderSales.
func (c *OrderSalesClient) Delete() *OrderSalesDelete {
	mutation := newOrderSalesMutation(c.config, OpDelete)
	return &OrderSalesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderSalesClient) DeleteOne(os *OrderSales) *OrderSalesDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderSalesClient) DeleteOneID(id int64) *OrderSalesDeleteOne {
	builder := c.Delete().Where(ordersales.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderSalesDeleteOne{builder}
}

// Query returns a query builder for OrderSales.
func (c *OrderSalesClient) Query() *OrderSalesQuery {
	return &OrderSalesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderSales},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderSales entity by its id.
func (c *OrderSalesClient) Get(ctx context.Context, id int64) (*OrderSales, error) {
	return c.Query().Where(ordersales.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderSalesClient) GetX(ctx context.Context, id int64) *OrderSales {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderSales.
func (c *OrderSalesClient) QueryOrder(os *OrderSales) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordersales.Table, ordersales.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ordersales.OrderTable, ordersales.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderSalesClient) Hooks() []Hook {
	return c.hooks.OrderSales
}

// Interceptors returns the client interceptors.
func (c *OrderSalesClient) Interceptors() []Interceptor {
	return c.inters.OrderSales
}

func (c *OrderSalesClient) mutate(ctx context.Context, m *OrderSalesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderSalesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderSalesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderSalesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderSales mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int64) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id int64) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int64) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int64) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTags queries the tags edge of a Product.
func (c *ProductClient) QueryTags(pr *Product) *DictionaryDetailQuery {
	query := (&DictionaryDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(dictionarydetail.Table, dictionarydetail.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.TagsTable, product.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContracts queries the contracts edge of a Product.
func (c *ProductClient) QueryContracts(pr *Product) *ContractQuery {
	query := (&ContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(contract.Table, contract.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.ContractsTable, product.ContractsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGoods queries the goods edge of a Product.
func (c *ProductClient) QueryGoods(pr *Product) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, product.GoodsTable, product.GoodsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLessons queries the lessons edge of a Product.
func (c *ProductClient) QueryLessons(pr *Product) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.LessonsTable, product.LessonsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int64) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id int64) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int64) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int64) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenus queries the menus edge of a Role.
func (c *RoleClient) QueryMenus(r *Role) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.MenusTable, role.MenusPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// ScheduleClient is a client for the Schedule schema.
type ScheduleClient struct {
	config
}

// NewScheduleClient returns a client for the Schedule from the given config.
func NewScheduleClient(c config) *ScheduleClient {
	return &ScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schedule.Hooks(f(g(h())))`.
func (c *ScheduleClient) Use(hooks ...Hook) {
	c.hooks.Schedule = append(c.hooks.Schedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `schedule.Intercept(f(g(h())))`.
func (c *ScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Schedule = append(c.inters.Schedule, interceptors...)
}

// Create returns a builder for creating a Schedule entity.
func (c *ScheduleClient) Create() *ScheduleCreate {
	mutation := newScheduleMutation(c.config, OpCreate)
	return &ScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Schedule entities.
func (c *ScheduleClient) CreateBulk(builders ...*ScheduleCreate) *ScheduleCreateBulk {
	return &ScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduleClient) MapCreateBulk(slice any, setFunc func(*ScheduleCreate, int)) *ScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduleCreateBulk{err: fmt.Errorf("calling to ScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Schedule.
func (c *ScheduleClient) Update() *ScheduleUpdate {
	mutation := newScheduleMutation(c.config, OpUpdate)
	return &ScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduleClient) UpdateOne(s *Schedule) *ScheduleUpdateOne {
	mutation := newScheduleMutation(c.config, OpUpdateOne, withSchedule(s))
	return &ScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduleClient) UpdateOneID(id int64) *ScheduleUpdateOne {
	mutation := newScheduleMutation(c.config, OpUpdateOne, withScheduleID(id))
	return &ScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Schedule.
func (c *ScheduleClient) Delete() *ScheduleDelete {
	mutation := newScheduleMutation(c.config, OpDelete)
	return &ScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduleClient) DeleteOne(s *Schedule) *ScheduleDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduleClient) DeleteOneID(id int64) *ScheduleDeleteOne {
	builder := c.Delete().Where(schedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduleDeleteOne{builder}
}

// Query returns a query builder for Schedule.
func (c *ScheduleClient) Query() *ScheduleQuery {
	return &ScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a Schedule entity by its id.
func (c *ScheduleClient) Get(ctx context.Context, id int64) (*Schedule, error) {
	return c.Query().Where(schedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduleClient) GetX(ctx context.Context, id int64) *Schedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMembers queries the members edge of a Schedule.
func (c *ScheduleClient) QueryMembers(s *Schedule) *ScheduleMemberQuery {
	query := (&ScheduleMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schedule.Table, schedule.FieldID, id),
			sqlgraph.To(schedulemember.Table, schedulemember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, schedule.MembersTable, schedule.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCoachs queries the coachs edge of a Schedule.
func (c *ScheduleClient) QueryCoachs(s *Schedule) *ScheduleCoachQuery {
	query := (&ScheduleCoachClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schedule.Table, schedule.FieldID, id),
			sqlgraph.To(schedulecoach.Table, schedulecoach.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, schedule.CoachsTable, schedule.CoachsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduleClient) Hooks() []Hook {
	return c.hooks.Schedule
}

// Interceptors returns the client interceptors.
func (c *ScheduleClient) Interceptors() []Interceptor {
	return c.inters.Schedule
}

func (c *ScheduleClient) mutate(ctx context.Context, m *ScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Schedule mutation op: %q", m.Op())
	}
}

// ScheduleCoachClient is a client for the ScheduleCoach schema.
type ScheduleCoachClient struct {
	config
}

// NewScheduleCoachClient returns a client for the ScheduleCoach from the given config.
func NewScheduleCoachClient(c config) *ScheduleCoachClient {
	return &ScheduleCoachClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schedulecoach.Hooks(f(g(h())))`.
func (c *ScheduleCoachClient) Use(hooks ...Hook) {
	c.hooks.ScheduleCoach = append(c.hooks.ScheduleCoach, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `schedulecoach.Intercept(f(g(h())))`.
func (c *ScheduleCoachClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheduleCoach = append(c.inters.ScheduleCoach, interceptors...)
}

// Create returns a builder for creating a ScheduleCoach entity.
func (c *ScheduleCoachClient) Create() *ScheduleCoachCreate {
	mutation := newScheduleCoachMutation(c.config, OpCreate)
	return &ScheduleCoachCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheduleCoach entities.
func (c *ScheduleCoachClient) CreateBulk(builders ...*ScheduleCoachCreate) *ScheduleCoachCreateBulk {
	return &ScheduleCoachCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduleCoachClient) MapCreateBulk(slice any, setFunc func(*ScheduleCoachCreate, int)) *ScheduleCoachCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduleCoachCreateBulk{err: fmt.Errorf("calling to ScheduleCoachClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduleCoachCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduleCoachCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheduleCoach.
func (c *ScheduleCoachClient) Update() *ScheduleCoachUpdate {
	mutation := newScheduleCoachMutation(c.config, OpUpdate)
	return &ScheduleCoachUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduleCoachClient) UpdateOne(sc *ScheduleCoach) *ScheduleCoachUpdateOne {
	mutation := newScheduleCoachMutation(c.config, OpUpdateOne, withScheduleCoach(sc))
	return &ScheduleCoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduleCoachClient) UpdateOneID(id int64) *ScheduleCoachUpdateOne {
	mutation := newScheduleCoachMutation(c.config, OpUpdateOne, withScheduleCoachID(id))
	return &ScheduleCoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheduleCoach.
func (c *ScheduleCoachClient) Delete() *ScheduleCoachDelete {
	mutation := newScheduleCoachMutation(c.config, OpDelete)
	return &ScheduleCoachDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduleCoachClient) DeleteOne(sc *ScheduleCoach) *ScheduleCoachDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduleCoachClient) DeleteOneID(id int64) *ScheduleCoachDeleteOne {
	builder := c.Delete().Where(schedulecoach.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduleCoachDeleteOne{builder}
}

// Query returns a query builder for ScheduleCoach.
func (c *ScheduleCoachClient) Query() *ScheduleCoachQuery {
	return &ScheduleCoachQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheduleCoach},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheduleCoach entity by its id.
func (c *ScheduleCoachClient) Get(ctx context.Context, id int64) (*ScheduleCoach, error) {
	return c.Query().Where(schedulecoach.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduleCoachClient) GetX(ctx context.Context, id int64) *ScheduleCoach {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedule queries the schedule edge of a ScheduleCoach.
func (c *ScheduleCoachClient) QuerySchedule(sc *ScheduleCoach) *ScheduleQuery {
	query := (&ScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schedulecoach.Table, schedulecoach.FieldID, id),
			sqlgraph.To(schedule.Table, schedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, schedulecoach.ScheduleTable, schedulecoach.ScheduleColumn),
		)
		fromV = sqlgraph.Neighbors(sc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduleCoachClient) Hooks() []Hook {
	return c.hooks.ScheduleCoach
}

// Interceptors returns the client interceptors.
func (c *ScheduleCoachClient) Interceptors() []Interceptor {
	return c.inters.ScheduleCoach
}

func (c *ScheduleCoachClient) mutate(ctx context.Context, m *ScheduleCoachMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduleCoachCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduleCoachUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduleCoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduleCoachDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScheduleCoach mutation op: %q", m.Op())
	}
}

// ScheduleMemberClient is a client for the ScheduleMember schema.
type ScheduleMemberClient struct {
	config
}

// NewScheduleMemberClient returns a client for the ScheduleMember from the given config.
func NewScheduleMemberClient(c config) *ScheduleMemberClient {
	return &ScheduleMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schedulemember.Hooks(f(g(h())))`.
func (c *ScheduleMemberClient) Use(hooks ...Hook) {
	c.hooks.ScheduleMember = append(c.hooks.ScheduleMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `schedulemember.Intercept(f(g(h())))`.
func (c *ScheduleMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheduleMember = append(c.inters.ScheduleMember, interceptors...)
}

// Create returns a builder for creating a ScheduleMember entity.
func (c *ScheduleMemberClient) Create() *ScheduleMemberCreate {
	mutation := newScheduleMemberMutation(c.config, OpCreate)
	return &ScheduleMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheduleMember entities.
func (c *ScheduleMemberClient) CreateBulk(builders ...*ScheduleMemberCreate) *ScheduleMemberCreateBulk {
	return &ScheduleMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduleMemberClient) MapCreateBulk(slice any, setFunc func(*ScheduleMemberCreate, int)) *ScheduleMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduleMemberCreateBulk{err: fmt.Errorf("calling to ScheduleMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduleMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduleMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheduleMember.
func (c *ScheduleMemberClient) Update() *ScheduleMemberUpdate {
	mutation := newScheduleMemberMutation(c.config, OpUpdate)
	return &ScheduleMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduleMemberClient) UpdateOne(sm *ScheduleMember) *ScheduleMemberUpdateOne {
	mutation := newScheduleMemberMutation(c.config, OpUpdateOne, withScheduleMember(sm))
	return &ScheduleMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduleMemberClient) UpdateOneID(id int64) *ScheduleMemberUpdateOne {
	mutation := newScheduleMemberMutation(c.config, OpUpdateOne, withScheduleMemberID(id))
	return &ScheduleMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheduleMember.
func (c *ScheduleMemberClient) Delete() *ScheduleMemberDelete {
	mutation := newScheduleMemberMutation(c.config, OpDelete)
	return &ScheduleMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduleMemberClient) DeleteOne(sm *ScheduleMember) *ScheduleMemberDeleteOne {
	return c.DeleteOneID(sm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduleMemberClient) DeleteOneID(id int64) *ScheduleMemberDeleteOne {
	builder := c.Delete().Where(schedulemember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduleMemberDeleteOne{builder}
}

// Query returns a query builder for ScheduleMember.
func (c *ScheduleMemberClient) Query() *ScheduleMemberQuery {
	return &ScheduleMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheduleMember},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheduleMember entity by its id.
func (c *ScheduleMemberClient) Get(ctx context.Context, id int64) (*ScheduleMember, error) {
	return c.Query().Where(schedulemember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduleMemberClient) GetX(ctx context.Context, id int64) *ScheduleMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedule queries the schedule edge of a ScheduleMember.
func (c *ScheduleMemberClient) QuerySchedule(sm *ScheduleMember) *ScheduleQuery {
	query := (&ScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schedulemember.Table, schedulemember.FieldID, id),
			sqlgraph.To(schedule.Table, schedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, schedulemember.ScheduleTable, schedulemember.ScheduleColumn),
		)
		fromV = sqlgraph.Neighbors(sm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduleMemberClient) Hooks() []Hook {
	return c.hooks.ScheduleMember
}

// Interceptors returns the client interceptors.
func (c *ScheduleMemberClient) Interceptors() []Interceptor {
	return c.inters.ScheduleMember
}

func (c *ScheduleMemberClient) mutate(ctx context.Context, m *ScheduleMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduleMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduleMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduleMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduleMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScheduleMember mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id int64) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id int64) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id int64) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id int64) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Token.
func (c *TokenClient) QueryOwner(t *Token) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, token.OwnerTable, token.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryToken queries the token edge of a User.
func (c *UserClient) QueryToken(u *User) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.TokenTable, user.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a User.
func (c *UserClient) QueryTags(u *User) *DictionaryDetailQuery {
	query := (&DictionaryDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(dictionarydetail.Table, dictionarydetail.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.TagsTable, user.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedOrders queries the created_orders edge of a User.
func (c *UserClient) QueryCreatedOrders(u *User) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedOrdersTable, user.CreatedOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserEntry queries the user_entry edge of a User.
func (c *UserClient) QueryUserEntry(u *User) *EntryLogsQuery {
	query := (&EntryLogsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(entrylogs.Table, entrylogs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserEntryTable, user.UserEntryColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVenues queries the venues edge of a User.
func (c *UserClient) QueryVenues(u *User) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.VenuesTable, user.VenuesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserScheduling queries the user_scheduling edge of a User.
func (c *UserClient) QueryUserScheduling(u *User) *UserSchedulingQuery {
	query := (&UserSchedulingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userscheduling.Table, userscheduling.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserSchedulingTable, user.UserSchedulingColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserSchedulingClient is a client for the UserScheduling schema.
type UserSchedulingClient struct {
	config
}

// NewUserSchedulingClient returns a client for the UserScheduling from the given config.
func NewUserSchedulingClient(c config) *UserSchedulingClient {
	return &UserSchedulingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userscheduling.Hooks(f(g(h())))`.
func (c *UserSchedulingClient) Use(hooks ...Hook) {
	c.hooks.UserScheduling = append(c.hooks.UserScheduling, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userscheduling.Intercept(f(g(h())))`.
func (c *UserSchedulingClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserScheduling = append(c.inters.UserScheduling, interceptors...)
}

// Create returns a builder for creating a UserScheduling entity.
func (c *UserSchedulingClient) Create() *UserSchedulingCreate {
	mutation := newUserSchedulingMutation(c.config, OpCreate)
	return &UserSchedulingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserScheduling entities.
func (c *UserSchedulingClient) CreateBulk(builders ...*UserSchedulingCreate) *UserSchedulingCreateBulk {
	return &UserSchedulingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSchedulingClient) MapCreateBulk(slice any, setFunc func(*UserSchedulingCreate, int)) *UserSchedulingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSchedulingCreateBulk{err: fmt.Errorf("calling to UserSchedulingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSchedulingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSchedulingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserScheduling.
func (c *UserSchedulingClient) Update() *UserSchedulingUpdate {
	mutation := newUserSchedulingMutation(c.config, OpUpdate)
	return &UserSchedulingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSchedulingClient) UpdateOne(us *UserScheduling) *UserSchedulingUpdateOne {
	mutation := newUserSchedulingMutation(c.config, OpUpdateOne, withUserScheduling(us))
	return &UserSchedulingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSchedulingClient) UpdateOneID(id int64) *UserSchedulingUpdateOne {
	mutation := newUserSchedulingMutation(c.config, OpUpdateOne, withUserSchedulingID(id))
	return &UserSchedulingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserScheduling.
func (c *UserSchedulingClient) Delete() *UserSchedulingDelete {
	mutation := newUserSchedulingMutation(c.config, OpDelete)
	return &UserSchedulingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSchedulingClient) DeleteOne(us *UserScheduling) *UserSchedulingDeleteOne {
	return c.DeleteOneID(us.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSchedulingClient) DeleteOneID(id int64) *UserSchedulingDeleteOne {
	builder := c.Delete().Where(userscheduling.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSchedulingDeleteOne{builder}
}

// Query returns a query builder for UserScheduling.
func (c *UserSchedulingClient) Query() *UserSchedulingQuery {
	return &UserSchedulingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserScheduling},
		inters: c.Interceptors(),
	}
}

// Get returns a UserScheduling entity by its id.
func (c *UserSchedulingClient) Get(ctx context.Context, id int64) (*UserScheduling, error) {
	return c.Query().Where(userscheduling.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSchedulingClient) GetX(ctx context.Context, id int64) *UserScheduling {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a UserScheduling.
func (c *UserSchedulingClient) QueryUsers(us *UserScheduling) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userscheduling.Table, userscheduling.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userscheduling.UsersTable, userscheduling.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSchedulingClient) Hooks() []Hook {
	return c.hooks.UserScheduling
}

// Interceptors returns the client interceptors.
func (c *UserSchedulingClient) Interceptors() []Interceptor {
	return c.inters.UserScheduling
}

func (c *UserSchedulingClient) mutate(ctx context.Context, m *UserSchedulingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSchedulingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSchedulingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSchedulingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSchedulingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserScheduling mutation op: %q", m.Op())
	}
}

// VenueClient is a client for the Venue schema.
type VenueClient struct {
	config
}

// NewVenueClient returns a client for the Venue from the given config.
func NewVenueClient(c config) *VenueClient {
	return &VenueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venue.Hooks(f(g(h())))`.
func (c *VenueClient) Use(hooks ...Hook) {
	c.hooks.Venue = append(c.hooks.Venue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venue.Intercept(f(g(h())))`.
func (c *VenueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Venue = append(c.inters.Venue, interceptors...)
}

// Create returns a builder for creating a Venue entity.
func (c *VenueClient) Create() *VenueCreate {
	mutation := newVenueMutation(c.config, OpCreate)
	return &VenueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Venue entities.
func (c *VenueClient) CreateBulk(builders ...*VenueCreate) *VenueCreateBulk {
	return &VenueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenueClient) MapCreateBulk(slice any, setFunc func(*VenueCreate, int)) *VenueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenueCreateBulk{err: fmt.Errorf("calling to VenueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Venue.
func (c *VenueClient) Update() *VenueUpdate {
	mutation := newVenueMutation(c.config, OpUpdate)
	return &VenueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenueClient) UpdateOne(v *Venue) *VenueUpdateOne {
	mutation := newVenueMutation(c.config, OpUpdateOne, withVenue(v))
	return &VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenueClient) UpdateOneID(id int64) *VenueUpdateOne {
	mutation := newVenueMutation(c.config, OpUpdateOne, withVenueID(id))
	return &VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Venue.
func (c *VenueClient) Delete() *VenueDelete {
	mutation := newVenueMutation(c.config, OpDelete)
	return &VenueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenueClient) DeleteOne(v *Venue) *VenueDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenueClient) DeleteOneID(id int64) *VenueDeleteOne {
	builder := c.Delete().Where(venue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenueDeleteOne{builder}
}

// Query returns a query builder for Venue.
func (c *VenueClient) Query() *VenueQuery {
	return &VenueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenue},
		inters: c.Interceptors(),
	}
}

// Get returns a Venue entity by its id.
func (c *VenueClient) Get(ctx context.Context, id int64) (*Venue, error) {
	return c.Query().Where(venue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenueClient) GetX(ctx context.Context, id int64) *Venue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlaces queries the places edge of a Venue.
func (c *VenueClient) QueryPlaces(v *Venue) *VenuePlaceQuery {
	query := (&VenuePlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(venueplace.Table, venueplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.PlacesTable, venue.PlacesColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVenueOrders queries the venue_orders edge of a Venue.
func (c *VenueClient) QueryVenueOrders(v *Venue) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.VenueOrdersTable, venue.VenueOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVenueEntry queries the venue_entry edge of a Venue.
func (c *VenueClient) QueryVenueEntry(v *Venue) *EntryLogsQuery {
	query := (&EntryLogsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(entrylogs.Table, entrylogs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.VenueEntryTable, venue.VenueEntryColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Venue.
func (c *VenueClient) QueryUsers(v *Venue) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, venue.UsersTable, venue.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySms queries the sms edge of a Venue.
func (c *VenueClient) QuerySms(v *Venue) *VenueSmsQuery {
	query := (&VenueSmsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(venuesms.Table, venuesms.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.SmsTable, venue.SmsColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySmslog queries the smslog edge of a Venue.
func (c *VenueClient) QuerySmslog(v *Venue) *VenueSmsLogQuery {
	query := (&VenueSmsLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(venuesmslog.Table, venuesmslog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.SmslogTable, venue.SmslogColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenueClient) Hooks() []Hook {
	return c.hooks.Venue
}

// Interceptors returns the client interceptors.
func (c *VenueClient) Interceptors() []Interceptor {
	return c.inters.Venue
}

func (c *VenueClient) mutate(ctx context.Context, m *VenueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Venue mutation op: %q", m.Op())
	}
}

// VenuePlaceClient is a client for the VenuePlace schema.
type VenuePlaceClient struct {
	config
}

// NewVenuePlaceClient returns a client for the VenuePlace from the given config.
func NewVenuePlaceClient(c config) *VenuePlaceClient {
	return &VenuePlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venueplace.Hooks(f(g(h())))`.
func (c *VenuePlaceClient) Use(hooks ...Hook) {
	c.hooks.VenuePlace = append(c.hooks.VenuePlace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venueplace.Intercept(f(g(h())))`.
func (c *VenuePlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.VenuePlace = append(c.inters.VenuePlace, interceptors...)
}

// Create returns a builder for creating a VenuePlace entity.
func (c *VenuePlaceClient) Create() *VenuePlaceCreate {
	mutation := newVenuePlaceMutation(c.config, OpCreate)
	return &VenuePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VenuePlace entities.
func (c *VenuePlaceClient) CreateBulk(builders ...*VenuePlaceCreate) *VenuePlaceCreateBulk {
	return &VenuePlaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenuePlaceClient) MapCreateBulk(slice any, setFunc func(*VenuePlaceCreate, int)) *VenuePlaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenuePlaceCreateBulk{err: fmt.Errorf("calling to VenuePlaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenuePlaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenuePlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VenuePlace.
func (c *VenuePlaceClient) Update() *VenuePlaceUpdate {
	mutation := newVenuePlaceMutation(c.config, OpUpdate)
	return &VenuePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenuePlaceClient) UpdateOne(vp *VenuePlace) *VenuePlaceUpdateOne {
	mutation := newVenuePlaceMutation(c.config, OpUpdateOne, withVenuePlace(vp))
	return &VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenuePlaceClient) UpdateOneID(id int64) *VenuePlaceUpdateOne {
	mutation := newVenuePlaceMutation(c.config, OpUpdateOne, withVenuePlaceID(id))
	return &VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VenuePlace.
func (c *VenuePlaceClient) Delete() *VenuePlaceDelete {
	mutation := newVenuePlaceMutation(c.config, OpDelete)
	return &VenuePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenuePlaceClient) DeleteOne(vp *VenuePlace) *VenuePlaceDeleteOne {
	return c.DeleteOneID(vp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenuePlaceClient) DeleteOneID(id int64) *VenuePlaceDeleteOne {
	builder := c.Delete().Where(venueplace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenuePlaceDeleteOne{builder}
}

// Query returns a query builder for VenuePlace.
func (c *VenuePlaceClient) Query() *VenuePlaceQuery {
	return &VenuePlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenuePlace},
		inters: c.Interceptors(),
	}
}

// Get returns a VenuePlace entity by its id.
func (c *VenuePlaceClient) Get(ctx context.Context, id int64) (*VenuePlace, error) {
	return c.Query().Where(venueplace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenuePlaceClient) GetX(ctx context.Context, id int64) *VenuePlace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVenue queries the venue edge of a VenuePlace.
func (c *VenuePlaceClient) QueryVenue(vp *VenuePlace) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venueplace.Table, venueplace.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, venueplace.VenueTable, venueplace.VenueColumn),
		)
		fromV = sqlgraph.Neighbors(vp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenuePlaceClient) Hooks() []Hook {
	return c.hooks.VenuePlace
}

// Interceptors returns the client interceptors.
func (c *VenuePlaceClient) Interceptors() []Interceptor {
	return c.inters.VenuePlace
}

func (c *VenuePlaceClient) mutate(ctx context.Context, m *VenuePlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenuePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenuePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenuePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VenuePlace mutation op: %q", m.Op())
	}
}

// VenueSmsClient is a client for the VenueSms schema.
type VenueSmsClient struct {
	config
}

// NewVenueSmsClient returns a client for the VenueSms from the given config.
func NewVenueSmsClient(c config) *VenueSmsClient {
	return &VenueSmsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venuesms.Hooks(f(g(h())))`.
func (c *VenueSmsClient) Use(hooks ...Hook) {
	c.hooks.VenueSms = append(c.hooks.VenueSms, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venuesms.Intercept(f(g(h())))`.
func (c *VenueSmsClient) Intercept(interceptors ...Interceptor) {
	c.inters.VenueSms = append(c.inters.VenueSms, interceptors...)
}

// Create returns a builder for creating a VenueSms entity.
func (c *VenueSmsClient) Create() *VenueSmsCreate {
	mutation := newVenueSmsMutation(c.config, OpCreate)
	return &VenueSmsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VenueSms entities.
func (c *VenueSmsClient) CreateBulk(builders ...*VenueSmsCreate) *VenueSmsCreateBulk {
	return &VenueSmsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenueSmsClient) MapCreateBulk(slice any, setFunc func(*VenueSmsCreate, int)) *VenueSmsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenueSmsCreateBulk{err: fmt.Errorf("calling to VenueSmsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenueSmsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenueSmsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VenueSms.
func (c *VenueSmsClient) Update() *VenueSmsUpdate {
	mutation := newVenueSmsMutation(c.config, OpUpdate)
	return &VenueSmsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenueSmsClient) UpdateOne(vs *VenueSms) *VenueSmsUpdateOne {
	mutation := newVenueSmsMutation(c.config, OpUpdateOne, withVenueSms(vs))
	return &VenueSmsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenueSmsClient) UpdateOneID(id int64) *VenueSmsUpdateOne {
	mutation := newVenueSmsMutation(c.config, OpUpdateOne, withVenueSmsID(id))
	return &VenueSmsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VenueSms.
func (c *VenueSmsClient) Delete() *VenueSmsDelete {
	mutation := newVenueSmsMutation(c.config, OpDelete)
	return &VenueSmsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenueSmsClient) DeleteOne(vs *VenueSms) *VenueSmsDeleteOne {
	return c.DeleteOneID(vs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenueSmsClient) DeleteOneID(id int64) *VenueSmsDeleteOne {
	builder := c.Delete().Where(venuesms.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenueSmsDeleteOne{builder}
}

// Query returns a query builder for VenueSms.
func (c *VenueSmsClient) Query() *VenueSmsQuery {
	return &VenueSmsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenueSms},
		inters: c.Interceptors(),
	}
}

// Get returns a VenueSms entity by its id.
func (c *VenueSmsClient) Get(ctx context.Context, id int64) (*VenueSms, error) {
	return c.Query().Where(venuesms.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenueSmsClient) GetX(ctx context.Context, id int64) *VenueSms {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVenue queries the venue edge of a VenueSms.
func (c *VenueSmsClient) QueryVenue(vs *VenueSms) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venuesms.Table, venuesms.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, venuesms.VenueTable, venuesms.VenueColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenueSmsClient) Hooks() []Hook {
	return c.hooks.VenueSms
}

// Interceptors returns the client interceptors.
func (c *VenueSmsClient) Interceptors() []Interceptor {
	return c.inters.VenueSms
}

func (c *VenueSmsClient) mutate(ctx context.Context, m *VenueSmsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenueSmsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenueSmsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenueSmsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenueSmsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VenueSms mutation op: %q", m.Op())
	}
}

// VenueSmsLogClient is a client for the VenueSmsLog schema.
type VenueSmsLogClient struct {
	config
}

// NewVenueSmsLogClient returns a client for the VenueSmsLog from the given config.
func NewVenueSmsLogClient(c config) *VenueSmsLogClient {
	return &VenueSmsLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venuesmslog.Hooks(f(g(h())))`.
func (c *VenueSmsLogClient) Use(hooks ...Hook) {
	c.hooks.VenueSmsLog = append(c.hooks.VenueSmsLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venuesmslog.Intercept(f(g(h())))`.
func (c *VenueSmsLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.VenueSmsLog = append(c.inters.VenueSmsLog, interceptors...)
}

// Create returns a builder for creating a VenueSmsLog entity.
func (c *VenueSmsLogClient) Create() *VenueSmsLogCreate {
	mutation := newVenueSmsLogMutation(c.config, OpCreate)
	return &VenueSmsLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VenueSmsLog entities.
func (c *VenueSmsLogClient) CreateBulk(builders ...*VenueSmsLogCreate) *VenueSmsLogCreateBulk {
	return &VenueSmsLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenueSmsLogClient) MapCreateBulk(slice any, setFunc func(*VenueSmsLogCreate, int)) *VenueSmsLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenueSmsLogCreateBulk{err: fmt.Errorf("calling to VenueSmsLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenueSmsLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenueSmsLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VenueSmsLog.
func (c *VenueSmsLogClient) Update() *VenueSmsLogUpdate {
	mutation := newVenueSmsLogMutation(c.config, OpUpdate)
	return &VenueSmsLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenueSmsLogClient) UpdateOne(vsl *VenueSmsLog) *VenueSmsLogUpdateOne {
	mutation := newVenueSmsLogMutation(c.config, OpUpdateOne, withVenueSmsLog(vsl))
	return &VenueSmsLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenueSmsLogClient) UpdateOneID(id int64) *VenueSmsLogUpdateOne {
	mutation := newVenueSmsLogMutation(c.config, OpUpdateOne, withVenueSmsLogID(id))
	return &VenueSmsLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VenueSmsLog.
func (c *VenueSmsLogClient) Delete() *VenueSmsLogDelete {
	mutation := newVenueSmsLogMutation(c.config, OpDelete)
	return &VenueSmsLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenueSmsLogClient) DeleteOne(vsl *VenueSmsLog) *VenueSmsLogDeleteOne {
	return c.DeleteOneID(vsl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenueSmsLogClient) DeleteOneID(id int64) *VenueSmsLogDeleteOne {
	builder := c.Delete().Where(venuesmslog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenueSmsLogDeleteOne{builder}
}

// Query returns a query builder for VenueSmsLog.
func (c *VenueSmsLogClient) Query() *VenueSmsLogQuery {
	return &VenueSmsLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenueSmsLog},
		inters: c.Interceptors(),
	}
}

// Get returns a VenueSmsLog entity by its id.
func (c *VenueSmsLogClient) Get(ctx context.Context, id int64) (*VenueSmsLog, error) {
	return c.Query().Where(venuesmslog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenueSmsLogClient) GetX(ctx context.Context, id int64) *VenueSmsLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVenue queries the venue edge of a VenueSmsLog.
func (c *VenueSmsLogClient) QueryVenue(vsl *VenueSmsLog) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vsl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venuesmslog.Table, venuesmslog.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, venuesmslog.VenueTable, venuesmslog.VenueColumn),
		)
		fromV = sqlgraph.Neighbors(vsl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenueSmsLogClient) Hooks() []Hook {
	return c.hooks.VenueSmsLog
}

// Interceptors returns the client interceptors.
func (c *VenueSmsLogClient) Interceptors() []Interceptor {
	return c.inters.VenueSmsLog
}

func (c *VenueSmsLogClient) mutate(ctx context.Context, m *VenueSmsLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenueSmsLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenueSmsLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenueSmsLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenueSmsLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VenueSmsLog mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		API, Banner, Bootcamp, BootcampParticipant, Community, CommunityParticipant,
		Contest, ContestParticipant, Contract, Dictionary, DictionaryDetail, EntryLogs,
		Logs, Member, MemberContract, MemberContractContent, MemberDetails, MemberNote,
		MemberProduct, MemberProfile, Menu, MenuParam, Messages, Order, OrderAmount,
		OrderItem, OrderPay, OrderSales, Product, Role, Schedule, ScheduleCoach,
		ScheduleMember, Token, User, UserScheduling, Venue, VenuePlace, VenueSms,
		VenueSmsLog []ent.Hook
	}
	inters struct {
		API, Banner, Bootcamp, BootcampParticipant, Community, CommunityParticipant,
		Contest, ContestParticipant, Contract, Dictionary, DictionaryDetail, EntryLogs,
		Logs, Member, MemberContract, MemberContractContent, MemberDetails, MemberNote,
		MemberProduct, MemberProfile, Menu, MenuParam, Messages, Order, OrderAmount,
		OrderItem, OrderPay, OrderSales, Product, Role, Schedule, ScheduleCoach,
		ScheduleMember, Token, User, UserScheduling, Venue, VenuePlace, VenueSms,
		VenueSmsLog []ent.Interceptor
	}
)
