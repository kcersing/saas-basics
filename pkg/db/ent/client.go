// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"saas/pkg/db/ent/migrate"

	"saas/pkg/db/ent/api"
	"saas/pkg/db/ent/courserecordcoach"
	"saas/pkg/db/ent/courserecordmember"
	"saas/pkg/db/ent/courserecordschedule"
	"saas/pkg/db/ent/dictionary"
	"saas/pkg/db/ent/dictionarydetail"
	"saas/pkg/db/ent/entrylogs"
	"saas/pkg/db/ent/logs"
	"saas/pkg/db/ent/member"
	"saas/pkg/db/ent/memberdetails"
	"saas/pkg/db/ent/membernote"
	"saas/pkg/db/ent/memberproduct"
	"saas/pkg/db/ent/memberproductproperty"
	"saas/pkg/db/ent/memberproductpropertyvenue"
	"saas/pkg/db/ent/menu"
	"saas/pkg/db/ent/menuparam"
	"saas/pkg/db/ent/order"
	"saas/pkg/db/ent/orderamount"
	"saas/pkg/db/ent/orderitem"
	"saas/pkg/db/ent/orderpay"
	"saas/pkg/db/ent/ordersales"
	"saas/pkg/db/ent/product"
	"saas/pkg/db/ent/productproperty"
	"saas/pkg/db/ent/productpropertyvenue"
	"saas/pkg/db/ent/role"
	"saas/pkg/db/ent/token"
	"saas/pkg/db/ent/user"
	"saas/pkg/db/ent/venue"
	"saas/pkg/db/ent/venueplace"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// API is the client for interacting with the API builders.
	API *APIClient
	// CourseRecordCoach is the client for interacting with the CourseRecordCoach builders.
	CourseRecordCoach *CourseRecordCoachClient
	// CourseRecordMember is the client for interacting with the CourseRecordMember builders.
	CourseRecordMember *CourseRecordMemberClient
	// CourseRecordSchedule is the client for interacting with the CourseRecordSchedule builders.
	CourseRecordSchedule *CourseRecordScheduleClient
	// Dictionary is the client for interacting with the Dictionary builders.
	Dictionary *DictionaryClient
	// DictionaryDetail is the client for interacting with the DictionaryDetail builders.
	DictionaryDetail *DictionaryDetailClient
	// EntryLogs is the client for interacting with the EntryLogs builders.
	EntryLogs *EntryLogsClient
	// Logs is the client for interacting with the Logs builders.
	Logs *LogsClient
	// Member is the client for interacting with the Member builders.
	Member *MemberClient
	// MemberDetails is the client for interacting with the MemberDetails builders.
	MemberDetails *MemberDetailsClient
	// MemberNote is the client for interacting with the MemberNote builders.
	MemberNote *MemberNoteClient
	// MemberProduct is the client for interacting with the MemberProduct builders.
	MemberProduct *MemberProductClient
	// MemberProductProperty is the client for interacting with the MemberProductProperty builders.
	MemberProductProperty *MemberProductPropertyClient
	// MemberProductPropertyVenue is the client for interacting with the MemberProductPropertyVenue builders.
	MemberProductPropertyVenue *MemberProductPropertyVenueClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// MenuParam is the client for interacting with the MenuParam builders.
	MenuParam *MenuParamClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderAmount is the client for interacting with the OrderAmount builders.
	OrderAmount *OrderAmountClient
	// OrderItem is the client for interacting with the OrderItem builders.
	OrderItem *OrderItemClient
	// OrderPay is the client for interacting with the OrderPay builders.
	OrderPay *OrderPayClient
	// OrderSales is the client for interacting with the OrderSales builders.
	OrderSales *OrderSalesClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// ProductProperty is the client for interacting with the ProductProperty builders.
	ProductProperty *ProductPropertyClient
	// ProductPropertyVenue is the client for interacting with the ProductPropertyVenue builders.
	ProductPropertyVenue *ProductPropertyVenueClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Venue is the client for interacting with the Venue builders.
	Venue *VenueClient
	// VenuePlace is the client for interacting with the VenuePlace builders.
	VenuePlace *VenuePlaceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.API = NewAPIClient(c.config)
	c.CourseRecordCoach = NewCourseRecordCoachClient(c.config)
	c.CourseRecordMember = NewCourseRecordMemberClient(c.config)
	c.CourseRecordSchedule = NewCourseRecordScheduleClient(c.config)
	c.Dictionary = NewDictionaryClient(c.config)
	c.DictionaryDetail = NewDictionaryDetailClient(c.config)
	c.EntryLogs = NewEntryLogsClient(c.config)
	c.Logs = NewLogsClient(c.config)
	c.Member = NewMemberClient(c.config)
	c.MemberDetails = NewMemberDetailsClient(c.config)
	c.MemberNote = NewMemberNoteClient(c.config)
	c.MemberProduct = NewMemberProductClient(c.config)
	c.MemberProductProperty = NewMemberProductPropertyClient(c.config)
	c.MemberProductPropertyVenue = NewMemberProductPropertyVenueClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.MenuParam = NewMenuParamClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderAmount = NewOrderAmountClient(c.config)
	c.OrderItem = NewOrderItemClient(c.config)
	c.OrderPay = NewOrderPayClient(c.config)
	c.OrderSales = NewOrderSalesClient(c.config)
	c.Product = NewProductClient(c.config)
	c.ProductProperty = NewProductPropertyClient(c.config)
	c.ProductPropertyVenue = NewProductPropertyVenueClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.User = NewUserClient(c.config)
	c.Venue = NewVenueClient(c.config)
	c.VenuePlace = NewVenuePlaceClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                        ctx,
		config:                     cfg,
		API:                        NewAPIClient(cfg),
		CourseRecordCoach:          NewCourseRecordCoachClient(cfg),
		CourseRecordMember:         NewCourseRecordMemberClient(cfg),
		CourseRecordSchedule:       NewCourseRecordScheduleClient(cfg),
		Dictionary:                 NewDictionaryClient(cfg),
		DictionaryDetail:           NewDictionaryDetailClient(cfg),
		EntryLogs:                  NewEntryLogsClient(cfg),
		Logs:                       NewLogsClient(cfg),
		Member:                     NewMemberClient(cfg),
		MemberDetails:              NewMemberDetailsClient(cfg),
		MemberNote:                 NewMemberNoteClient(cfg),
		MemberProduct:              NewMemberProductClient(cfg),
		MemberProductProperty:      NewMemberProductPropertyClient(cfg),
		MemberProductPropertyVenue: NewMemberProductPropertyVenueClient(cfg),
		Menu:                       NewMenuClient(cfg),
		MenuParam:                  NewMenuParamClient(cfg),
		Order:                      NewOrderClient(cfg),
		OrderAmount:                NewOrderAmountClient(cfg),
		OrderItem:                  NewOrderItemClient(cfg),
		OrderPay:                   NewOrderPayClient(cfg),
		OrderSales:                 NewOrderSalesClient(cfg),
		Product:                    NewProductClient(cfg),
		ProductProperty:            NewProductPropertyClient(cfg),
		ProductPropertyVenue:       NewProductPropertyVenueClient(cfg),
		Role:                       NewRoleClient(cfg),
		Token:                      NewTokenClient(cfg),
		User:                       NewUserClient(cfg),
		Venue:                      NewVenueClient(cfg),
		VenuePlace:                 NewVenuePlaceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                        ctx,
		config:                     cfg,
		API:                        NewAPIClient(cfg),
		CourseRecordCoach:          NewCourseRecordCoachClient(cfg),
		CourseRecordMember:         NewCourseRecordMemberClient(cfg),
		CourseRecordSchedule:       NewCourseRecordScheduleClient(cfg),
		Dictionary:                 NewDictionaryClient(cfg),
		DictionaryDetail:           NewDictionaryDetailClient(cfg),
		EntryLogs:                  NewEntryLogsClient(cfg),
		Logs:                       NewLogsClient(cfg),
		Member:                     NewMemberClient(cfg),
		MemberDetails:              NewMemberDetailsClient(cfg),
		MemberNote:                 NewMemberNoteClient(cfg),
		MemberProduct:              NewMemberProductClient(cfg),
		MemberProductProperty:      NewMemberProductPropertyClient(cfg),
		MemberProductPropertyVenue: NewMemberProductPropertyVenueClient(cfg),
		Menu:                       NewMenuClient(cfg),
		MenuParam:                  NewMenuParamClient(cfg),
		Order:                      NewOrderClient(cfg),
		OrderAmount:                NewOrderAmountClient(cfg),
		OrderItem:                  NewOrderItemClient(cfg),
		OrderPay:                   NewOrderPayClient(cfg),
		OrderSales:                 NewOrderSalesClient(cfg),
		Product:                    NewProductClient(cfg),
		ProductProperty:            NewProductPropertyClient(cfg),
		ProductPropertyVenue:       NewProductPropertyVenueClient(cfg),
		Role:                       NewRoleClient(cfg),
		Token:                      NewTokenClient(cfg),
		User:                       NewUserClient(cfg),
		Venue:                      NewVenueClient(cfg),
		VenuePlace:                 NewVenuePlaceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		API.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.API, c.CourseRecordCoach, c.CourseRecordMember, c.CourseRecordSchedule,
		c.Dictionary, c.DictionaryDetail, c.EntryLogs, c.Logs, c.Member,
		c.MemberDetails, c.MemberNote, c.MemberProduct, c.MemberProductProperty,
		c.MemberProductPropertyVenue, c.Menu, c.MenuParam, c.Order, c.OrderAmount,
		c.OrderItem, c.OrderPay, c.OrderSales, c.Product, c.ProductProperty,
		c.ProductPropertyVenue, c.Role, c.Token, c.User, c.Venue, c.VenuePlace,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.API, c.CourseRecordCoach, c.CourseRecordMember, c.CourseRecordSchedule,
		c.Dictionary, c.DictionaryDetail, c.EntryLogs, c.Logs, c.Member,
		c.MemberDetails, c.MemberNote, c.MemberProduct, c.MemberProductProperty,
		c.MemberProductPropertyVenue, c.Menu, c.MenuParam, c.Order, c.OrderAmount,
		c.OrderItem, c.OrderPay, c.OrderSales, c.Product, c.ProductProperty,
		c.ProductPropertyVenue, c.Role, c.Token, c.User, c.Venue, c.VenuePlace,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIMutation:
		return c.API.mutate(ctx, m)
	case *CourseRecordCoachMutation:
		return c.CourseRecordCoach.mutate(ctx, m)
	case *CourseRecordMemberMutation:
		return c.CourseRecordMember.mutate(ctx, m)
	case *CourseRecordScheduleMutation:
		return c.CourseRecordSchedule.mutate(ctx, m)
	case *DictionaryMutation:
		return c.Dictionary.mutate(ctx, m)
	case *DictionaryDetailMutation:
		return c.DictionaryDetail.mutate(ctx, m)
	case *EntryLogsMutation:
		return c.EntryLogs.mutate(ctx, m)
	case *LogsMutation:
		return c.Logs.mutate(ctx, m)
	case *MemberMutation:
		return c.Member.mutate(ctx, m)
	case *MemberDetailsMutation:
		return c.MemberDetails.mutate(ctx, m)
	case *MemberNoteMutation:
		return c.MemberNote.mutate(ctx, m)
	case *MemberProductMutation:
		return c.MemberProduct.mutate(ctx, m)
	case *MemberProductPropertyMutation:
		return c.MemberProductProperty.mutate(ctx, m)
	case *MemberProductPropertyVenueMutation:
		return c.MemberProductPropertyVenue.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *MenuParamMutation:
		return c.MenuParam.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderAmountMutation:
		return c.OrderAmount.mutate(ctx, m)
	case *OrderItemMutation:
		return c.OrderItem.mutate(ctx, m)
	case *OrderPayMutation:
		return c.OrderPay.mutate(ctx, m)
	case *OrderSalesMutation:
		return c.OrderSales.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProductPropertyMutation:
		return c.ProductProperty.mutate(ctx, m)
	case *ProductPropertyVenueMutation:
		return c.ProductPropertyVenue.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VenueMutation:
		return c.Venue.mutate(ctx, m)
	case *VenuePlaceMutation:
		return c.VenuePlace.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIClient is a client for the API schema.
type APIClient struct {
	config
}

// NewAPIClient returns a client for the API from the given config.
func NewAPIClient(c config) *APIClient {
	return &APIClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `api.Hooks(f(g(h())))`.
func (c *APIClient) Use(hooks ...Hook) {
	c.hooks.API = append(c.hooks.API, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `api.Intercept(f(g(h())))`.
func (c *APIClient) Intercept(interceptors ...Interceptor) {
	c.inters.API = append(c.inters.API, interceptors...)
}

// Create returns a builder for creating a API entity.
func (c *APIClient) Create() *APICreate {
	mutation := newAPIMutation(c.config, OpCreate)
	return &APICreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of API entities.
func (c *APIClient) CreateBulk(builders ...*APICreate) *APICreateBulk {
	return &APICreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIClient) MapCreateBulk(slice any, setFunc func(*APICreate, int)) *APICreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APICreateBulk{err: fmt.Errorf("calling to APIClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APICreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APICreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for API.
func (c *APIClient) Update() *APIUpdate {
	mutation := newAPIMutation(c.config, OpUpdate)
	return &APIUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIClient) UpdateOne(a *API) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withAPI(a))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIClient) UpdateOneID(id int64) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withAPIID(id))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for API.
func (c *APIClient) Delete() *APIDelete {
	mutation := newAPIMutation(c.config, OpDelete)
	return &APIDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIClient) DeleteOne(a *API) *APIDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIClient) DeleteOneID(id int64) *APIDeleteOne {
	builder := c.Delete().Where(api.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIDeleteOne{builder}
}

// Query returns a query builder for API.
func (c *APIClient) Query() *APIQuery {
	return &APIQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPI},
		inters: c.Interceptors(),
	}
}

// Get returns a API entity by its id.
func (c *APIClient) Get(ctx context.Context, id int64) (*API, error) {
	return c.Query().Where(api.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIClient) GetX(ctx context.Context, id int64) *API {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *APIClient) Hooks() []Hook {
	return c.hooks.API
}

// Interceptors returns the client interceptors.
func (c *APIClient) Interceptors() []Interceptor {
	return c.inters.API
}

func (c *APIClient) mutate(ctx context.Context, m *APIMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APICreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown API mutation op: %q", m.Op())
	}
}

// CourseRecordCoachClient is a client for the CourseRecordCoach schema.
type CourseRecordCoachClient struct {
	config
}

// NewCourseRecordCoachClient returns a client for the CourseRecordCoach from the given config.
func NewCourseRecordCoachClient(c config) *CourseRecordCoachClient {
	return &CourseRecordCoachClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `courserecordcoach.Hooks(f(g(h())))`.
func (c *CourseRecordCoachClient) Use(hooks ...Hook) {
	c.hooks.CourseRecordCoach = append(c.hooks.CourseRecordCoach, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `courserecordcoach.Intercept(f(g(h())))`.
func (c *CourseRecordCoachClient) Intercept(interceptors ...Interceptor) {
	c.inters.CourseRecordCoach = append(c.inters.CourseRecordCoach, interceptors...)
}

// Create returns a builder for creating a CourseRecordCoach entity.
func (c *CourseRecordCoachClient) Create() *CourseRecordCoachCreate {
	mutation := newCourseRecordCoachMutation(c.config, OpCreate)
	return &CourseRecordCoachCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CourseRecordCoach entities.
func (c *CourseRecordCoachClient) CreateBulk(builders ...*CourseRecordCoachCreate) *CourseRecordCoachCreateBulk {
	return &CourseRecordCoachCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseRecordCoachClient) MapCreateBulk(slice any, setFunc func(*CourseRecordCoachCreate, int)) *CourseRecordCoachCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseRecordCoachCreateBulk{err: fmt.Errorf("calling to CourseRecordCoachClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseRecordCoachCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseRecordCoachCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CourseRecordCoach.
func (c *CourseRecordCoachClient) Update() *CourseRecordCoachUpdate {
	mutation := newCourseRecordCoachMutation(c.config, OpUpdate)
	return &CourseRecordCoachUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseRecordCoachClient) UpdateOne(crc *CourseRecordCoach) *CourseRecordCoachUpdateOne {
	mutation := newCourseRecordCoachMutation(c.config, OpUpdateOne, withCourseRecordCoach(crc))
	return &CourseRecordCoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseRecordCoachClient) UpdateOneID(id int64) *CourseRecordCoachUpdateOne {
	mutation := newCourseRecordCoachMutation(c.config, OpUpdateOne, withCourseRecordCoachID(id))
	return &CourseRecordCoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CourseRecordCoach.
func (c *CourseRecordCoachClient) Delete() *CourseRecordCoachDelete {
	mutation := newCourseRecordCoachMutation(c.config, OpDelete)
	return &CourseRecordCoachDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseRecordCoachClient) DeleteOne(crc *CourseRecordCoach) *CourseRecordCoachDeleteOne {
	return c.DeleteOneID(crc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseRecordCoachClient) DeleteOneID(id int64) *CourseRecordCoachDeleteOne {
	builder := c.Delete().Where(courserecordcoach.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseRecordCoachDeleteOne{builder}
}

// Query returns a query builder for CourseRecordCoach.
func (c *CourseRecordCoachClient) Query() *CourseRecordCoachQuery {
	return &CourseRecordCoachQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourseRecordCoach},
		inters: c.Interceptors(),
	}
}

// Get returns a CourseRecordCoach entity by its id.
func (c *CourseRecordCoachClient) Get(ctx context.Context, id int64) (*CourseRecordCoach, error) {
	return c.Query().Where(courserecordcoach.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseRecordCoachClient) GetX(ctx context.Context, id int64) *CourseRecordCoach {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedule queries the schedule edge of a CourseRecordCoach.
func (c *CourseRecordCoachClient) QuerySchedule(crc *CourseRecordCoach) *CourseRecordScheduleQuery {
	query := (&CourseRecordScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := crc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(courserecordcoach.Table, courserecordcoach.FieldID, id),
			sqlgraph.To(courserecordschedule.Table, courserecordschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, courserecordcoach.ScheduleTable, courserecordcoach.ScheduleColumn),
		)
		fromV = sqlgraph.Neighbors(crc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseRecordCoachClient) Hooks() []Hook {
	return c.hooks.CourseRecordCoach
}

// Interceptors returns the client interceptors.
func (c *CourseRecordCoachClient) Interceptors() []Interceptor {
	return c.inters.CourseRecordCoach
}

func (c *CourseRecordCoachClient) mutate(ctx context.Context, m *CourseRecordCoachMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseRecordCoachCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseRecordCoachUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseRecordCoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseRecordCoachDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CourseRecordCoach mutation op: %q", m.Op())
	}
}

// CourseRecordMemberClient is a client for the CourseRecordMember schema.
type CourseRecordMemberClient struct {
	config
}

// NewCourseRecordMemberClient returns a client for the CourseRecordMember from the given config.
func NewCourseRecordMemberClient(c config) *CourseRecordMemberClient {
	return &CourseRecordMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `courserecordmember.Hooks(f(g(h())))`.
func (c *CourseRecordMemberClient) Use(hooks ...Hook) {
	c.hooks.CourseRecordMember = append(c.hooks.CourseRecordMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `courserecordmember.Intercept(f(g(h())))`.
func (c *CourseRecordMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.CourseRecordMember = append(c.inters.CourseRecordMember, interceptors...)
}

// Create returns a builder for creating a CourseRecordMember entity.
func (c *CourseRecordMemberClient) Create() *CourseRecordMemberCreate {
	mutation := newCourseRecordMemberMutation(c.config, OpCreate)
	return &CourseRecordMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CourseRecordMember entities.
func (c *CourseRecordMemberClient) CreateBulk(builders ...*CourseRecordMemberCreate) *CourseRecordMemberCreateBulk {
	return &CourseRecordMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseRecordMemberClient) MapCreateBulk(slice any, setFunc func(*CourseRecordMemberCreate, int)) *CourseRecordMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseRecordMemberCreateBulk{err: fmt.Errorf("calling to CourseRecordMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseRecordMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseRecordMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CourseRecordMember.
func (c *CourseRecordMemberClient) Update() *CourseRecordMemberUpdate {
	mutation := newCourseRecordMemberMutation(c.config, OpUpdate)
	return &CourseRecordMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseRecordMemberClient) UpdateOne(crm *CourseRecordMember) *CourseRecordMemberUpdateOne {
	mutation := newCourseRecordMemberMutation(c.config, OpUpdateOne, withCourseRecordMember(crm))
	return &CourseRecordMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseRecordMemberClient) UpdateOneID(id int64) *CourseRecordMemberUpdateOne {
	mutation := newCourseRecordMemberMutation(c.config, OpUpdateOne, withCourseRecordMemberID(id))
	return &CourseRecordMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CourseRecordMember.
func (c *CourseRecordMemberClient) Delete() *CourseRecordMemberDelete {
	mutation := newCourseRecordMemberMutation(c.config, OpDelete)
	return &CourseRecordMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseRecordMemberClient) DeleteOne(crm *CourseRecordMember) *CourseRecordMemberDeleteOne {
	return c.DeleteOneID(crm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseRecordMemberClient) DeleteOneID(id int64) *CourseRecordMemberDeleteOne {
	builder := c.Delete().Where(courserecordmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseRecordMemberDeleteOne{builder}
}

// Query returns a query builder for CourseRecordMember.
func (c *CourseRecordMemberClient) Query() *CourseRecordMemberQuery {
	return &CourseRecordMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourseRecordMember},
		inters: c.Interceptors(),
	}
}

// Get returns a CourseRecordMember entity by its id.
func (c *CourseRecordMemberClient) Get(ctx context.Context, id int64) (*CourseRecordMember, error) {
	return c.Query().Where(courserecordmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseRecordMemberClient) GetX(ctx context.Context, id int64) *CourseRecordMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchedule queries the schedule edge of a CourseRecordMember.
func (c *CourseRecordMemberClient) QuerySchedule(crm *CourseRecordMember) *CourseRecordScheduleQuery {
	query := (&CourseRecordScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := crm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(courserecordmember.Table, courserecordmember.FieldID, id),
			sqlgraph.To(courserecordschedule.Table, courserecordschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, courserecordmember.ScheduleTable, courserecordmember.ScheduleColumn),
		)
		fromV = sqlgraph.Neighbors(crm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseRecordMemberClient) Hooks() []Hook {
	return c.hooks.CourseRecordMember
}

// Interceptors returns the client interceptors.
func (c *CourseRecordMemberClient) Interceptors() []Interceptor {
	return c.inters.CourseRecordMember
}

func (c *CourseRecordMemberClient) mutate(ctx context.Context, m *CourseRecordMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseRecordMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseRecordMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseRecordMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseRecordMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CourseRecordMember mutation op: %q", m.Op())
	}
}

// CourseRecordScheduleClient is a client for the CourseRecordSchedule schema.
type CourseRecordScheduleClient struct {
	config
}

// NewCourseRecordScheduleClient returns a client for the CourseRecordSchedule from the given config.
func NewCourseRecordScheduleClient(c config) *CourseRecordScheduleClient {
	return &CourseRecordScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `courserecordschedule.Hooks(f(g(h())))`.
func (c *CourseRecordScheduleClient) Use(hooks ...Hook) {
	c.hooks.CourseRecordSchedule = append(c.hooks.CourseRecordSchedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `courserecordschedule.Intercept(f(g(h())))`.
func (c *CourseRecordScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.CourseRecordSchedule = append(c.inters.CourseRecordSchedule, interceptors...)
}

// Create returns a builder for creating a CourseRecordSchedule entity.
func (c *CourseRecordScheduleClient) Create() *CourseRecordScheduleCreate {
	mutation := newCourseRecordScheduleMutation(c.config, OpCreate)
	return &CourseRecordScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CourseRecordSchedule entities.
func (c *CourseRecordScheduleClient) CreateBulk(builders ...*CourseRecordScheduleCreate) *CourseRecordScheduleCreateBulk {
	return &CourseRecordScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseRecordScheduleClient) MapCreateBulk(slice any, setFunc func(*CourseRecordScheduleCreate, int)) *CourseRecordScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseRecordScheduleCreateBulk{err: fmt.Errorf("calling to CourseRecordScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseRecordScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseRecordScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CourseRecordSchedule.
func (c *CourseRecordScheduleClient) Update() *CourseRecordScheduleUpdate {
	mutation := newCourseRecordScheduleMutation(c.config, OpUpdate)
	return &CourseRecordScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseRecordScheduleClient) UpdateOne(crs *CourseRecordSchedule) *CourseRecordScheduleUpdateOne {
	mutation := newCourseRecordScheduleMutation(c.config, OpUpdateOne, withCourseRecordSchedule(crs))
	return &CourseRecordScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseRecordScheduleClient) UpdateOneID(id int64) *CourseRecordScheduleUpdateOne {
	mutation := newCourseRecordScheduleMutation(c.config, OpUpdateOne, withCourseRecordScheduleID(id))
	return &CourseRecordScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CourseRecordSchedule.
func (c *CourseRecordScheduleClient) Delete() *CourseRecordScheduleDelete {
	mutation := newCourseRecordScheduleMutation(c.config, OpDelete)
	return &CourseRecordScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseRecordScheduleClient) DeleteOne(crs *CourseRecordSchedule) *CourseRecordScheduleDeleteOne {
	return c.DeleteOneID(crs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseRecordScheduleClient) DeleteOneID(id int64) *CourseRecordScheduleDeleteOne {
	builder := c.Delete().Where(courserecordschedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseRecordScheduleDeleteOne{builder}
}

// Query returns a query builder for CourseRecordSchedule.
func (c *CourseRecordScheduleClient) Query() *CourseRecordScheduleQuery {
	return &CourseRecordScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourseRecordSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a CourseRecordSchedule entity by its id.
func (c *CourseRecordScheduleClient) Get(ctx context.Context, id int64) (*CourseRecordSchedule, error) {
	return c.Query().Where(courserecordschedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseRecordScheduleClient) GetX(ctx context.Context, id int64) *CourseRecordSchedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMembers queries the members edge of a CourseRecordSchedule.
func (c *CourseRecordScheduleClient) QueryMembers(crs *CourseRecordSchedule) *CourseRecordMemberQuery {
	query := (&CourseRecordMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := crs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(courserecordschedule.Table, courserecordschedule.FieldID, id),
			sqlgraph.To(courserecordmember.Table, courserecordmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, courserecordschedule.MembersTable, courserecordschedule.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(crs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCoachs queries the coachs edge of a CourseRecordSchedule.
func (c *CourseRecordScheduleClient) QueryCoachs(crs *CourseRecordSchedule) *CourseRecordCoachQuery {
	query := (&CourseRecordCoachClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := crs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(courserecordschedule.Table, courserecordschedule.FieldID, id),
			sqlgraph.To(courserecordcoach.Table, courserecordcoach.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, courserecordschedule.CoachsTable, courserecordschedule.CoachsColumn),
		)
		fromV = sqlgraph.Neighbors(crs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseRecordScheduleClient) Hooks() []Hook {
	return c.hooks.CourseRecordSchedule
}

// Interceptors returns the client interceptors.
func (c *CourseRecordScheduleClient) Interceptors() []Interceptor {
	return c.inters.CourseRecordSchedule
}

func (c *CourseRecordScheduleClient) mutate(ctx context.Context, m *CourseRecordScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseRecordScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseRecordScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseRecordScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseRecordScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CourseRecordSchedule mutation op: %q", m.Op())
	}
}

// DictionaryClient is a client for the Dictionary schema.
type DictionaryClient struct {
	config
}

// NewDictionaryClient returns a client for the Dictionary from the given config.
func NewDictionaryClient(c config) *DictionaryClient {
	return &DictionaryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionary.Hooks(f(g(h())))`.
func (c *DictionaryClient) Use(hooks ...Hook) {
	c.hooks.Dictionary = append(c.hooks.Dictionary, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionary.Intercept(f(g(h())))`.
func (c *DictionaryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dictionary = append(c.inters.Dictionary, interceptors...)
}

// Create returns a builder for creating a Dictionary entity.
func (c *DictionaryClient) Create() *DictionaryCreate {
	mutation := newDictionaryMutation(c.config, OpCreate)
	return &DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dictionary entities.
func (c *DictionaryClient) CreateBulk(builders ...*DictionaryCreate) *DictionaryCreateBulk {
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryClient) MapCreateBulk(slice any, setFunc func(*DictionaryCreate, int)) *DictionaryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryCreateBulk{err: fmt.Errorf("calling to DictionaryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dictionary.
func (c *DictionaryClient) Update() *DictionaryUpdate {
	mutation := newDictionaryMutation(c.config, OpUpdate)
	return &DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryClient) UpdateOne(d *Dictionary) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionary(d))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryClient) UpdateOneID(id int64) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionaryID(id))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dictionary.
func (c *DictionaryClient) Delete() *DictionaryDelete {
	mutation := newDictionaryMutation(c.config, OpDelete)
	return &DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryClient) DeleteOne(d *Dictionary) *DictionaryDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryClient) DeleteOneID(id int64) *DictionaryDeleteOne {
	builder := c.Delete().Where(dictionary.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryDeleteOne{builder}
}

// Query returns a query builder for Dictionary.
func (c *DictionaryClient) Query() *DictionaryQuery {
	return &DictionaryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionary},
		inters: c.Interceptors(),
	}
}

// Get returns a Dictionary entity by its id.
func (c *DictionaryClient) Get(ctx context.Context, id int64) (*Dictionary, error) {
	return c.Query().Where(dictionary.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryClient) GetX(ctx context.Context, id int64) *Dictionary {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDictionaryDetails queries the dictionary_details edge of a Dictionary.
func (c *DictionaryClient) QueryDictionaryDetails(d *Dictionary) *DictionaryDetailQuery {
	query := (&DictionaryDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionary.Table, dictionary.FieldID, id),
			sqlgraph.To(dictionarydetail.Table, dictionarydetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dictionary.DictionaryDetailsTable, dictionary.DictionaryDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryClient) Hooks() []Hook {
	return c.hooks.Dictionary
}

// Interceptors returns the client interceptors.
func (c *DictionaryClient) Interceptors() []Interceptor {
	return c.inters.Dictionary
}

func (c *DictionaryClient) mutate(ctx context.Context, m *DictionaryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dictionary mutation op: %q", m.Op())
	}
}

// DictionaryDetailClient is a client for the DictionaryDetail schema.
type DictionaryDetailClient struct {
	config
}

// NewDictionaryDetailClient returns a client for the DictionaryDetail from the given config.
func NewDictionaryDetailClient(c config) *DictionaryDetailClient {
	return &DictionaryDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionarydetail.Hooks(f(g(h())))`.
func (c *DictionaryDetailClient) Use(hooks ...Hook) {
	c.hooks.DictionaryDetail = append(c.hooks.DictionaryDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionarydetail.Intercept(f(g(h())))`.
func (c *DictionaryDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.DictionaryDetail = append(c.inters.DictionaryDetail, interceptors...)
}

// Create returns a builder for creating a DictionaryDetail entity.
func (c *DictionaryDetailClient) Create() *DictionaryDetailCreate {
	mutation := newDictionaryDetailMutation(c.config, OpCreate)
	return &DictionaryDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DictionaryDetail entities.
func (c *DictionaryDetailClient) CreateBulk(builders ...*DictionaryDetailCreate) *DictionaryDetailCreateBulk {
	return &DictionaryDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryDetailClient) MapCreateBulk(slice any, setFunc func(*DictionaryDetailCreate, int)) *DictionaryDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryDetailCreateBulk{err: fmt.Errorf("calling to DictionaryDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DictionaryDetail.
func (c *DictionaryDetailClient) Update() *DictionaryDetailUpdate {
	mutation := newDictionaryDetailMutation(c.config, OpUpdate)
	return &DictionaryDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryDetailClient) UpdateOne(dd *DictionaryDetail) *DictionaryDetailUpdateOne {
	mutation := newDictionaryDetailMutation(c.config, OpUpdateOne, withDictionaryDetail(dd))
	return &DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryDetailClient) UpdateOneID(id int64) *DictionaryDetailUpdateOne {
	mutation := newDictionaryDetailMutation(c.config, OpUpdateOne, withDictionaryDetailID(id))
	return &DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DictionaryDetail.
func (c *DictionaryDetailClient) Delete() *DictionaryDetailDelete {
	mutation := newDictionaryDetailMutation(c.config, OpDelete)
	return &DictionaryDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryDetailClient) DeleteOne(dd *DictionaryDetail) *DictionaryDetailDeleteOne {
	return c.DeleteOneID(dd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryDetailClient) DeleteOneID(id int64) *DictionaryDetailDeleteOne {
	builder := c.Delete().Where(dictionarydetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryDetailDeleteOne{builder}
}

// Query returns a query builder for DictionaryDetail.
func (c *DictionaryDetailClient) Query() *DictionaryDetailQuery {
	return &DictionaryDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionaryDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a DictionaryDetail entity by its id.
func (c *DictionaryDetailClient) Get(ctx context.Context, id int64) (*DictionaryDetail, error) {
	return c.Query().Where(dictionarydetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryDetailClient) GetX(ctx context.Context, id int64) *DictionaryDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDictionary queries the dictionary edge of a DictionaryDetail.
func (c *DictionaryDetailClient) QueryDictionary(dd *DictionaryDetail) *DictionaryQuery {
	query := (&DictionaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionarydetail.Table, dictionarydetail.FieldID, id),
			sqlgraph.To(dictionary.Table, dictionary.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dictionarydetail.DictionaryTable, dictionarydetail.DictionaryColumn),
		)
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryDetailClient) Hooks() []Hook {
	return c.hooks.DictionaryDetail
}

// Interceptors returns the client interceptors.
func (c *DictionaryDetailClient) Interceptors() []Interceptor {
	return c.inters.DictionaryDetail
}

func (c *DictionaryDetailClient) mutate(ctx context.Context, m *DictionaryDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DictionaryDetail mutation op: %q", m.Op())
	}
}

// EntryLogsClient is a client for the EntryLogs schema.
type EntryLogsClient struct {
	config
}

// NewEntryLogsClient returns a client for the EntryLogs from the given config.
func NewEntryLogsClient(c config) *EntryLogsClient {
	return &EntryLogsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entrylogs.Hooks(f(g(h())))`.
func (c *EntryLogsClient) Use(hooks ...Hook) {
	c.hooks.EntryLogs = append(c.hooks.EntryLogs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entrylogs.Intercept(f(g(h())))`.
func (c *EntryLogsClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntryLogs = append(c.inters.EntryLogs, interceptors...)
}

// Create returns a builder for creating a EntryLogs entity.
func (c *EntryLogsClient) Create() *EntryLogsCreate {
	mutation := newEntryLogsMutation(c.config, OpCreate)
	return &EntryLogsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntryLogs entities.
func (c *EntryLogsClient) CreateBulk(builders ...*EntryLogsCreate) *EntryLogsCreateBulk {
	return &EntryLogsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntryLogsClient) MapCreateBulk(slice any, setFunc func(*EntryLogsCreate, int)) *EntryLogsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntryLogsCreateBulk{err: fmt.Errorf("calling to EntryLogsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntryLogsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntryLogsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntryLogs.
func (c *EntryLogsClient) Update() *EntryLogsUpdate {
	mutation := newEntryLogsMutation(c.config, OpUpdate)
	return &EntryLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntryLogsClient) UpdateOne(el *EntryLogs) *EntryLogsUpdateOne {
	mutation := newEntryLogsMutation(c.config, OpUpdateOne, withEntryLogs(el))
	return &EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntryLogsClient) UpdateOneID(id int64) *EntryLogsUpdateOne {
	mutation := newEntryLogsMutation(c.config, OpUpdateOne, withEntryLogsID(id))
	return &EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntryLogs.
func (c *EntryLogsClient) Delete() *EntryLogsDelete {
	mutation := newEntryLogsMutation(c.config, OpDelete)
	return &EntryLogsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntryLogsClient) DeleteOne(el *EntryLogs) *EntryLogsDeleteOne {
	return c.DeleteOneID(el.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntryLogsClient) DeleteOneID(id int64) *EntryLogsDeleteOne {
	builder := c.Delete().Where(entrylogs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntryLogsDeleteOne{builder}
}

// Query returns a query builder for EntryLogs.
func (c *EntryLogsClient) Query() *EntryLogsQuery {
	return &EntryLogsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntryLogs},
		inters: c.Interceptors(),
	}
}

// Get returns a EntryLogs entity by its id.
func (c *EntryLogsClient) Get(ctx context.Context, id int64) (*EntryLogs, error) {
	return c.Query().Where(entrylogs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntryLogsClient) GetX(ctx context.Context, id int64) *EntryLogs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntryLogsClient) Hooks() []Hook {
	return c.hooks.EntryLogs
}

// Interceptors returns the client interceptors.
func (c *EntryLogsClient) Interceptors() []Interceptor {
	return c.inters.EntryLogs
}

func (c *EntryLogsClient) mutate(ctx context.Context, m *EntryLogsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntryLogsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntryLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntryLogsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EntryLogs mutation op: %q", m.Op())
	}
}

// LogsClient is a client for the Logs schema.
type LogsClient struct {
	config
}

// NewLogsClient returns a client for the Logs from the given config.
func NewLogsClient(c config) *LogsClient {
	return &LogsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logs.Hooks(f(g(h())))`.
func (c *LogsClient) Use(hooks ...Hook) {
	c.hooks.Logs = append(c.hooks.Logs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logs.Intercept(f(g(h())))`.
func (c *LogsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Logs = append(c.inters.Logs, interceptors...)
}

// Create returns a builder for creating a Logs entity.
func (c *LogsClient) Create() *LogsCreate {
	mutation := newLogsMutation(c.config, OpCreate)
	return &LogsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Logs entities.
func (c *LogsClient) CreateBulk(builders ...*LogsCreate) *LogsCreateBulk {
	return &LogsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LogsClient) MapCreateBulk(slice any, setFunc func(*LogsCreate, int)) *LogsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LogsCreateBulk{err: fmt.Errorf("calling to LogsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LogsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LogsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Logs.
func (c *LogsClient) Update() *LogsUpdate {
	mutation := newLogsMutation(c.config, OpUpdate)
	return &LogsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogsClient) UpdateOne(l *Logs) *LogsUpdateOne {
	mutation := newLogsMutation(c.config, OpUpdateOne, withLogs(l))
	return &LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogsClient) UpdateOneID(id int64) *LogsUpdateOne {
	mutation := newLogsMutation(c.config, OpUpdateOne, withLogsID(id))
	return &LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Logs.
func (c *LogsClient) Delete() *LogsDelete {
	mutation := newLogsMutation(c.config, OpDelete)
	return &LogsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LogsClient) DeleteOne(l *Logs) *LogsDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LogsClient) DeleteOneID(id int64) *LogsDeleteOne {
	builder := c.Delete().Where(logs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogsDeleteOne{builder}
}

// Query returns a query builder for Logs.
func (c *LogsClient) Query() *LogsQuery {
	return &LogsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogs},
		inters: c.Interceptors(),
	}
}

// Get returns a Logs entity by its id.
func (c *LogsClient) Get(ctx context.Context, id int64) (*Logs, error) {
	return c.Query().Where(logs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogsClient) GetX(ctx context.Context, id int64) *Logs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LogsClient) Hooks() []Hook {
	return c.hooks.Logs
}

// Interceptors returns the client interceptors.
func (c *LogsClient) Interceptors() []Interceptor {
	return c.inters.Logs
}

func (c *LogsClient) mutate(ctx context.Context, m *LogsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LogsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LogsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LogsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Logs mutation op: %q", m.Op())
	}
}

// MemberClient is a client for the Member schema.
type MemberClient struct {
	config
}

// NewMemberClient returns a client for the Member from the given config.
func NewMemberClient(c config) *MemberClient {
	return &MemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `member.Hooks(f(g(h())))`.
func (c *MemberClient) Use(hooks ...Hook) {
	c.hooks.Member = append(c.hooks.Member, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `member.Intercept(f(g(h())))`.
func (c *MemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.Member = append(c.inters.Member, interceptors...)
}

// Create returns a builder for creating a Member entity.
func (c *MemberClient) Create() *MemberCreate {
	mutation := newMemberMutation(c.config, OpCreate)
	return &MemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Member entities.
func (c *MemberClient) CreateBulk(builders ...*MemberCreate) *MemberCreateBulk {
	return &MemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberClient) MapCreateBulk(slice any, setFunc func(*MemberCreate, int)) *MemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberCreateBulk{err: fmt.Errorf("calling to MemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Member.
func (c *MemberClient) Update() *MemberUpdate {
	mutation := newMemberMutation(c.config, OpUpdate)
	return &MemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberClient) UpdateOne(m *Member) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMember(m))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberClient) UpdateOneID(id int64) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMemberID(id))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Member.
func (c *MemberClient) Delete() *MemberDelete {
	mutation := newMemberMutation(c.config, OpDelete)
	return &MemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberClient) DeleteOne(m *Member) *MemberDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberClient) DeleteOneID(id int64) *MemberDeleteOne {
	builder := c.Delete().Where(member.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberDeleteOne{builder}
}

// Query returns a query builder for Member.
func (c *MemberClient) Query() *MemberQuery {
	return &MemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMember},
		inters: c.Interceptors(),
	}
}

// Get returns a Member entity by its id.
func (c *MemberClient) Get(ctx context.Context, id int64) (*Member, error) {
	return c.Query().Where(member.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberClient) GetX(ctx context.Context, id int64) *Member {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemberDetails queries the member_details edge of a Member.
func (c *MemberClient) QueryMemberDetails(m *Member) *MemberDetailsQuery {
	query := (&MemberDetailsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(memberdetails.Table, memberdetails.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberDetailsTable, member.MemberDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberNotes queries the member_notes edge of a Member.
func (c *MemberClient) QueryMemberNotes(m *Member) *MemberNoteQuery {
	query := (&MemberNoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(membernote.Table, membernote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberNotesTable, member.MemberNotesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberProducts queries the member_products edge of a Member.
func (c *MemberClient) QueryMemberProducts(m *Member) *MemberProductQuery {
	query := (&MemberProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(memberproduct.Table, memberproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberProductsTable, member.MemberProductsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberClient) Hooks() []Hook {
	return c.hooks.Member
}

// Interceptors returns the client interceptors.
func (c *MemberClient) Interceptors() []Interceptor {
	return c.inters.Member
}

func (c *MemberClient) mutate(ctx context.Context, m *MemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Member mutation op: %q", m.Op())
	}
}

// MemberDetailsClient is a client for the MemberDetails schema.
type MemberDetailsClient struct {
	config
}

// NewMemberDetailsClient returns a client for the MemberDetails from the given config.
func NewMemberDetailsClient(c config) *MemberDetailsClient {
	return &MemberDetailsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberdetails.Hooks(f(g(h())))`.
func (c *MemberDetailsClient) Use(hooks ...Hook) {
	c.hooks.MemberDetails = append(c.hooks.MemberDetails, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberdetails.Intercept(f(g(h())))`.
func (c *MemberDetailsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberDetails = append(c.inters.MemberDetails, interceptors...)
}

// Create returns a builder for creating a MemberDetails entity.
func (c *MemberDetailsClient) Create() *MemberDetailsCreate {
	mutation := newMemberDetailsMutation(c.config, OpCreate)
	return &MemberDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberDetails entities.
func (c *MemberDetailsClient) CreateBulk(builders ...*MemberDetailsCreate) *MemberDetailsCreateBulk {
	return &MemberDetailsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberDetailsClient) MapCreateBulk(slice any, setFunc func(*MemberDetailsCreate, int)) *MemberDetailsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberDetailsCreateBulk{err: fmt.Errorf("calling to MemberDetailsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberDetailsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberDetailsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberDetails.
func (c *MemberDetailsClient) Update() *MemberDetailsUpdate {
	mutation := newMemberDetailsMutation(c.config, OpUpdate)
	return &MemberDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberDetailsClient) UpdateOne(md *MemberDetails) *MemberDetailsUpdateOne {
	mutation := newMemberDetailsMutation(c.config, OpUpdateOne, withMemberDetails(md))
	return &MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberDetailsClient) UpdateOneID(id int64) *MemberDetailsUpdateOne {
	mutation := newMemberDetailsMutation(c.config, OpUpdateOne, withMemberDetailsID(id))
	return &MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberDetails.
func (c *MemberDetailsClient) Delete() *MemberDetailsDelete {
	mutation := newMemberDetailsMutation(c.config, OpDelete)
	return &MemberDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberDetailsClient) DeleteOne(md *MemberDetails) *MemberDetailsDeleteOne {
	return c.DeleteOneID(md.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberDetailsClient) DeleteOneID(id int64) *MemberDetailsDeleteOne {
	builder := c.Delete().Where(memberdetails.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberDetailsDeleteOne{builder}
}

// Query returns a query builder for MemberDetails.
func (c *MemberDetailsClient) Query() *MemberDetailsQuery {
	return &MemberDetailsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberDetails},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberDetails entity by its id.
func (c *MemberDetailsClient) Get(ctx context.Context, id int64) (*MemberDetails, error) {
	return c.Query().Where(memberdetails.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberDetailsClient) GetX(ctx context.Context, id int64) *MemberDetails {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInfo queries the info edge of a MemberDetails.
func (c *MemberDetailsClient) QueryInfo(md *MemberDetails) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := md.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberdetails.Table, memberdetails.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberdetails.InfoTable, memberdetails.InfoColumn),
		)
		fromV = sqlgraph.Neighbors(md.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberDetailsClient) Hooks() []Hook {
	return c.hooks.MemberDetails
}

// Interceptors returns the client interceptors.
func (c *MemberDetailsClient) Interceptors() []Interceptor {
	return c.inters.MemberDetails
}

func (c *MemberDetailsClient) mutate(ctx context.Context, m *MemberDetailsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberDetails mutation op: %q", m.Op())
	}
}

// MemberNoteClient is a client for the MemberNote schema.
type MemberNoteClient struct {
	config
}

// NewMemberNoteClient returns a client for the MemberNote from the given config.
func NewMemberNoteClient(c config) *MemberNoteClient {
	return &MemberNoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membernote.Hooks(f(g(h())))`.
func (c *MemberNoteClient) Use(hooks ...Hook) {
	c.hooks.MemberNote = append(c.hooks.MemberNote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membernote.Intercept(f(g(h())))`.
func (c *MemberNoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberNote = append(c.inters.MemberNote, interceptors...)
}

// Create returns a builder for creating a MemberNote entity.
func (c *MemberNoteClient) Create() *MemberNoteCreate {
	mutation := newMemberNoteMutation(c.config, OpCreate)
	return &MemberNoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberNote entities.
func (c *MemberNoteClient) CreateBulk(builders ...*MemberNoteCreate) *MemberNoteCreateBulk {
	return &MemberNoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberNoteClient) MapCreateBulk(slice any, setFunc func(*MemberNoteCreate, int)) *MemberNoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberNoteCreateBulk{err: fmt.Errorf("calling to MemberNoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberNoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberNoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberNote.
func (c *MemberNoteClient) Update() *MemberNoteUpdate {
	mutation := newMemberNoteMutation(c.config, OpUpdate)
	return &MemberNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberNoteClient) UpdateOne(mn *MemberNote) *MemberNoteUpdateOne {
	mutation := newMemberNoteMutation(c.config, OpUpdateOne, withMemberNote(mn))
	return &MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberNoteClient) UpdateOneID(id int64) *MemberNoteUpdateOne {
	mutation := newMemberNoteMutation(c.config, OpUpdateOne, withMemberNoteID(id))
	return &MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberNote.
func (c *MemberNoteClient) Delete() *MemberNoteDelete {
	mutation := newMemberNoteMutation(c.config, OpDelete)
	return &MemberNoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberNoteClient) DeleteOne(mn *MemberNote) *MemberNoteDeleteOne {
	return c.DeleteOneID(mn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberNoteClient) DeleteOneID(id int64) *MemberNoteDeleteOne {
	builder := c.Delete().Where(membernote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberNoteDeleteOne{builder}
}

// Query returns a query builder for MemberNote.
func (c *MemberNoteClient) Query() *MemberNoteQuery {
	return &MemberNoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberNote},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberNote entity by its id.
func (c *MemberNoteClient) Get(ctx context.Context, id int64) (*MemberNote, error) {
	return c.Query().Where(membernote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberNoteClient) GetX(ctx context.Context, id int64) *MemberNote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNotes queries the notes edge of a MemberNote.
func (c *MemberNoteClient) QueryNotes(mn *MemberNote) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membernote.Table, membernote.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membernote.NotesTable, membernote.NotesColumn),
		)
		fromV = sqlgraph.Neighbors(mn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberNoteClient) Hooks() []Hook {
	return c.hooks.MemberNote
}

// Interceptors returns the client interceptors.
func (c *MemberNoteClient) Interceptors() []Interceptor {
	return c.inters.MemberNote
}

func (c *MemberNoteClient) mutate(ctx context.Context, m *MemberNoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberNoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberNoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberNote mutation op: %q", m.Op())
	}
}

// MemberProductClient is a client for the MemberProduct schema.
type MemberProductClient struct {
	config
}

// NewMemberProductClient returns a client for the MemberProduct from the given config.
func NewMemberProductClient(c config) *MemberProductClient {
	return &MemberProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberproduct.Hooks(f(g(h())))`.
func (c *MemberProductClient) Use(hooks ...Hook) {
	c.hooks.MemberProduct = append(c.hooks.MemberProduct, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberproduct.Intercept(f(g(h())))`.
func (c *MemberProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberProduct = append(c.inters.MemberProduct, interceptors...)
}

// Create returns a builder for creating a MemberProduct entity.
func (c *MemberProductClient) Create() *MemberProductCreate {
	mutation := newMemberProductMutation(c.config, OpCreate)
	return &MemberProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberProduct entities.
func (c *MemberProductClient) CreateBulk(builders ...*MemberProductCreate) *MemberProductCreateBulk {
	return &MemberProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberProductClient) MapCreateBulk(slice any, setFunc func(*MemberProductCreate, int)) *MemberProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberProductCreateBulk{err: fmt.Errorf("calling to MemberProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberProduct.
func (c *MemberProductClient) Update() *MemberProductUpdate {
	mutation := newMemberProductMutation(c.config, OpUpdate)
	return &MemberProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberProductClient) UpdateOne(mp *MemberProduct) *MemberProductUpdateOne {
	mutation := newMemberProductMutation(c.config, OpUpdateOne, withMemberProduct(mp))
	return &MemberProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberProductClient) UpdateOneID(id int64) *MemberProductUpdateOne {
	mutation := newMemberProductMutation(c.config, OpUpdateOne, withMemberProductID(id))
	return &MemberProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberProduct.
func (c *MemberProductClient) Delete() *MemberProductDelete {
	mutation := newMemberProductMutation(c.config, OpDelete)
	return &MemberProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberProductClient) DeleteOne(mp *MemberProduct) *MemberProductDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberProductClient) DeleteOneID(id int64) *MemberProductDeleteOne {
	builder := c.Delete().Where(memberproduct.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberProductDeleteOne{builder}
}

// Query returns a query builder for MemberProduct.
func (c *MemberProductClient) Query() *MemberProductQuery {
	return &MemberProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberProduct entity by its id.
func (c *MemberProductClient) Get(ctx context.Context, id int64) (*MemberProduct, error) {
	return c.Query().Where(memberproduct.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberProductClient) GetX(ctx context.Context, id int64) *MemberProduct {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a MemberProduct.
func (c *MemberProductClient) QueryOwner(mp *MemberProduct) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproduct.Table, memberproduct.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberproduct.OwnerTable, memberproduct.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberProductPropertys queries the member_product_propertys edge of a MemberProduct.
func (c *MemberProductClient) QueryMemberProductPropertys(mp *MemberProduct) *MemberProductPropertyQuery {
	query := (&MemberProductPropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproduct.Table, memberproduct.FieldID, id),
			sqlgraph.To(memberproductproperty.Table, memberproductproperty.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, memberproduct.MemberProductPropertysTable, memberproduct.MemberProductPropertysColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberProductClient) Hooks() []Hook {
	return c.hooks.MemberProduct
}

// Interceptors returns the client interceptors.
func (c *MemberProductClient) Interceptors() []Interceptor {
	return c.inters.MemberProduct
}

func (c *MemberProductClient) mutate(ctx context.Context, m *MemberProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberProduct mutation op: %q", m.Op())
	}
}

// MemberProductPropertyClient is a client for the MemberProductProperty schema.
type MemberProductPropertyClient struct {
	config
}

// NewMemberProductPropertyClient returns a client for the MemberProductProperty from the given config.
func NewMemberProductPropertyClient(c config) *MemberProductPropertyClient {
	return &MemberProductPropertyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberproductproperty.Hooks(f(g(h())))`.
func (c *MemberProductPropertyClient) Use(hooks ...Hook) {
	c.hooks.MemberProductProperty = append(c.hooks.MemberProductProperty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberproductproperty.Intercept(f(g(h())))`.
func (c *MemberProductPropertyClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberProductProperty = append(c.inters.MemberProductProperty, interceptors...)
}

// Create returns a builder for creating a MemberProductProperty entity.
func (c *MemberProductPropertyClient) Create() *MemberProductPropertyCreate {
	mutation := newMemberProductPropertyMutation(c.config, OpCreate)
	return &MemberProductPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberProductProperty entities.
func (c *MemberProductPropertyClient) CreateBulk(builders ...*MemberProductPropertyCreate) *MemberProductPropertyCreateBulk {
	return &MemberProductPropertyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberProductPropertyClient) MapCreateBulk(slice any, setFunc func(*MemberProductPropertyCreate, int)) *MemberProductPropertyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberProductPropertyCreateBulk{err: fmt.Errorf("calling to MemberProductPropertyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberProductPropertyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberProductPropertyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberProductProperty.
func (c *MemberProductPropertyClient) Update() *MemberProductPropertyUpdate {
	mutation := newMemberProductPropertyMutation(c.config, OpUpdate)
	return &MemberProductPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberProductPropertyClient) UpdateOne(mpp *MemberProductProperty) *MemberProductPropertyUpdateOne {
	mutation := newMemberProductPropertyMutation(c.config, OpUpdateOne, withMemberProductProperty(mpp))
	return &MemberProductPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberProductPropertyClient) UpdateOneID(id int64) *MemberProductPropertyUpdateOne {
	mutation := newMemberProductPropertyMutation(c.config, OpUpdateOne, withMemberProductPropertyID(id))
	return &MemberProductPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberProductProperty.
func (c *MemberProductPropertyClient) Delete() *MemberProductPropertyDelete {
	mutation := newMemberProductPropertyMutation(c.config, OpDelete)
	return &MemberProductPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberProductPropertyClient) DeleteOne(mpp *MemberProductProperty) *MemberProductPropertyDeleteOne {
	return c.DeleteOneID(mpp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberProductPropertyClient) DeleteOneID(id int64) *MemberProductPropertyDeleteOne {
	builder := c.Delete().Where(memberproductproperty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberProductPropertyDeleteOne{builder}
}

// Query returns a query builder for MemberProductProperty.
func (c *MemberProductPropertyClient) Query() *MemberProductPropertyQuery {
	return &MemberProductPropertyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberProductProperty},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberProductProperty entity by its id.
func (c *MemberProductPropertyClient) Get(ctx context.Context, id int64) (*MemberProductProperty, error) {
	return c.Query().Where(memberproductproperty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberProductPropertyClient) GetX(ctx context.Context, id int64) *MemberProductProperty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a MemberProductProperty.
func (c *MemberProductPropertyClient) QueryOwner(mpp *MemberProductProperty) *MemberProductQuery {
	query := (&MemberProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproductproperty.Table, memberproductproperty.FieldID, id),
			sqlgraph.To(memberproduct.Table, memberproduct.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberproductproperty.OwnerTable, memberproductproperty.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(mpp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberProductPropertyVenues queries the member_product_property_venues edge of a MemberProductProperty.
func (c *MemberProductPropertyClient) QueryMemberProductPropertyVenues(mpp *MemberProductProperty) *MemberProductPropertyVenueQuery {
	query := (&MemberProductPropertyVenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mpp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproductproperty.Table, memberproductproperty.FieldID, id),
			sqlgraph.To(memberproductpropertyvenue.Table, memberproductpropertyvenue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, memberproductproperty.MemberProductPropertyVenuesTable, memberproductproperty.MemberProductPropertyVenuesColumn),
		)
		fromV = sqlgraph.Neighbors(mpp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberProductPropertyClient) Hooks() []Hook {
	return c.hooks.MemberProductProperty
}

// Interceptors returns the client interceptors.
func (c *MemberProductPropertyClient) Interceptors() []Interceptor {
	return c.inters.MemberProductProperty
}

func (c *MemberProductPropertyClient) mutate(ctx context.Context, m *MemberProductPropertyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberProductPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberProductPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberProductPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberProductPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberProductProperty mutation op: %q", m.Op())
	}
}

// MemberProductPropertyVenueClient is a client for the MemberProductPropertyVenue schema.
type MemberProductPropertyVenueClient struct {
	config
}

// NewMemberProductPropertyVenueClient returns a client for the MemberProductPropertyVenue from the given config.
func NewMemberProductPropertyVenueClient(c config) *MemberProductPropertyVenueClient {
	return &MemberProductPropertyVenueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberproductpropertyvenue.Hooks(f(g(h())))`.
func (c *MemberProductPropertyVenueClient) Use(hooks ...Hook) {
	c.hooks.MemberProductPropertyVenue = append(c.hooks.MemberProductPropertyVenue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberproductpropertyvenue.Intercept(f(g(h())))`.
func (c *MemberProductPropertyVenueClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberProductPropertyVenue = append(c.inters.MemberProductPropertyVenue, interceptors...)
}

// Create returns a builder for creating a MemberProductPropertyVenue entity.
func (c *MemberProductPropertyVenueClient) Create() *MemberProductPropertyVenueCreate {
	mutation := newMemberProductPropertyVenueMutation(c.config, OpCreate)
	return &MemberProductPropertyVenueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberProductPropertyVenue entities.
func (c *MemberProductPropertyVenueClient) CreateBulk(builders ...*MemberProductPropertyVenueCreate) *MemberProductPropertyVenueCreateBulk {
	return &MemberProductPropertyVenueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberProductPropertyVenueClient) MapCreateBulk(slice any, setFunc func(*MemberProductPropertyVenueCreate, int)) *MemberProductPropertyVenueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberProductPropertyVenueCreateBulk{err: fmt.Errorf("calling to MemberProductPropertyVenueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberProductPropertyVenueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberProductPropertyVenueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberProductPropertyVenue.
func (c *MemberProductPropertyVenueClient) Update() *MemberProductPropertyVenueUpdate {
	mutation := newMemberProductPropertyVenueMutation(c.config, OpUpdate)
	return &MemberProductPropertyVenueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberProductPropertyVenueClient) UpdateOne(mppv *MemberProductPropertyVenue) *MemberProductPropertyVenueUpdateOne {
	mutation := newMemberProductPropertyVenueMutation(c.config, OpUpdateOne, withMemberProductPropertyVenue(mppv))
	return &MemberProductPropertyVenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberProductPropertyVenueClient) UpdateOneID(id int64) *MemberProductPropertyVenueUpdateOne {
	mutation := newMemberProductPropertyVenueMutation(c.config, OpUpdateOne, withMemberProductPropertyVenueID(id))
	return &MemberProductPropertyVenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberProductPropertyVenue.
func (c *MemberProductPropertyVenueClient) Delete() *MemberProductPropertyVenueDelete {
	mutation := newMemberProductPropertyVenueMutation(c.config, OpDelete)
	return &MemberProductPropertyVenueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberProductPropertyVenueClient) DeleteOne(mppv *MemberProductPropertyVenue) *MemberProductPropertyVenueDeleteOne {
	return c.DeleteOneID(mppv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberProductPropertyVenueClient) DeleteOneID(id int64) *MemberProductPropertyVenueDeleteOne {
	builder := c.Delete().Where(memberproductpropertyvenue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberProductPropertyVenueDeleteOne{builder}
}

// Query returns a query builder for MemberProductPropertyVenue.
func (c *MemberProductPropertyVenueClient) Query() *MemberProductPropertyVenueQuery {
	return &MemberProductPropertyVenueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberProductPropertyVenue},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberProductPropertyVenue entity by its id.
func (c *MemberProductPropertyVenueClient) Get(ctx context.Context, id int64) (*MemberProductPropertyVenue, error) {
	return c.Query().Where(memberproductpropertyvenue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberProductPropertyVenueClient) GetX(ctx context.Context, id int64) *MemberProductPropertyVenue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a MemberProductPropertyVenue.
func (c *MemberProductPropertyVenueClient) QueryOwner(mppv *MemberProductPropertyVenue) *MemberProductPropertyQuery {
	query := (&MemberProductPropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mppv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberproductpropertyvenue.Table, memberproductpropertyvenue.FieldID, id),
			sqlgraph.To(memberproductproperty.Table, memberproductproperty.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberproductpropertyvenue.OwnerTable, memberproductpropertyvenue.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(mppv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberProductPropertyVenueClient) Hooks() []Hook {
	return c.hooks.MemberProductPropertyVenue
}

// Interceptors returns the client interceptors.
func (c *MemberProductPropertyVenueClient) Interceptors() []Interceptor {
	return c.inters.MemberProductPropertyVenue
}

func (c *MemberProductPropertyVenueClient) mutate(ctx context.Context, m *MemberProductPropertyVenueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberProductPropertyVenueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberProductPropertyVenueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberProductPropertyVenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberProductPropertyVenueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberProductPropertyVenue mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuClient) MapCreateBulk(slice any, setFunc func(*MenuCreate, int)) *MenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuCreateBulk{err: fmt.Errorf("calling to MenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id int64) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id int64) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id int64) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id int64) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Menu.
func (c *MenuClient) QueryRoles(m *Menu) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, menu.RolesTable, menu.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Menu.
func (c *MenuClient) QueryParent(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menu.ParentTable, menu.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Menu.
func (c *MenuClient) QueryChildren(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ChildrenTable, menu.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParams queries the params edge of a Menu.
func (c *MenuClient) QueryParams(m *Menu) *MenuParamQuery {
	query := (&MenuParamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menuparam.Table, menuparam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ParamsTable, menu.ParamsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// MenuParamClient is a client for the MenuParam schema.
type MenuParamClient struct {
	config
}

// NewMenuParamClient returns a client for the MenuParam from the given config.
func NewMenuParamClient(c config) *MenuParamClient {
	return &MenuParamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menuparam.Hooks(f(g(h())))`.
func (c *MenuParamClient) Use(hooks ...Hook) {
	c.hooks.MenuParam = append(c.hooks.MenuParam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menuparam.Intercept(f(g(h())))`.
func (c *MenuParamClient) Intercept(interceptors ...Interceptor) {
	c.inters.MenuParam = append(c.inters.MenuParam, interceptors...)
}

// Create returns a builder for creating a MenuParam entity.
func (c *MenuParamClient) Create() *MenuParamCreate {
	mutation := newMenuParamMutation(c.config, OpCreate)
	return &MenuParamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MenuParam entities.
func (c *MenuParamClient) CreateBulk(builders ...*MenuParamCreate) *MenuParamCreateBulk {
	return &MenuParamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuParamClient) MapCreateBulk(slice any, setFunc func(*MenuParamCreate, int)) *MenuParamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuParamCreateBulk{err: fmt.Errorf("calling to MenuParamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuParamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuParamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MenuParam.
func (c *MenuParamClient) Update() *MenuParamUpdate {
	mutation := newMenuParamMutation(c.config, OpUpdate)
	return &MenuParamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuParamClient) UpdateOne(mp *MenuParam) *MenuParamUpdateOne {
	mutation := newMenuParamMutation(c.config, OpUpdateOne, withMenuParam(mp))
	return &MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuParamClient) UpdateOneID(id int64) *MenuParamUpdateOne {
	mutation := newMenuParamMutation(c.config, OpUpdateOne, withMenuParamID(id))
	return &MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MenuParam.
func (c *MenuParamClient) Delete() *MenuParamDelete {
	mutation := newMenuParamMutation(c.config, OpDelete)
	return &MenuParamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuParamClient) DeleteOne(mp *MenuParam) *MenuParamDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuParamClient) DeleteOneID(id int64) *MenuParamDeleteOne {
	builder := c.Delete().Where(menuparam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuParamDeleteOne{builder}
}

// Query returns a query builder for MenuParam.
func (c *MenuParamClient) Query() *MenuParamQuery {
	return &MenuParamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenuParam},
		inters: c.Interceptors(),
	}
}

// Get returns a MenuParam entity by its id.
func (c *MenuParamClient) Get(ctx context.Context, id int64) (*MenuParam, error) {
	return c.Query().Where(menuparam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuParamClient) GetX(ctx context.Context, id int64) *MenuParam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenus queries the menus edge of a MenuParam.
func (c *MenuParamClient) QueryMenus(mp *MenuParam) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuparam.Table, menuparam.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menuparam.MenusTable, menuparam.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuParamClient) Hooks() []Hook {
	return c.hooks.MenuParam
}

// Interceptors returns the client interceptors.
func (c *MenuParamClient) Interceptors() []Interceptor {
	return c.inters.MenuParam
}

func (c *MenuParamClient) mutate(ctx context.Context, m *MenuParamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuParamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuParamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuParamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MenuParam mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id int64) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id int64) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id int64) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id int64) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAmount queries the amount edge of a Order.
func (c *OrderClient) QueryAmount(o *Order) *OrderAmountQuery {
	query := (&OrderAmountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderamount.Table, orderamount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.AmountTable, order.AmountColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItem queries the item edge of a Order.
func (c *OrderClient) QueryItem(o *Order) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.ItemTable, order.ItemColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPay queries the pay edge of a Order.
func (c *OrderClient) QueryPay(o *Order) *OrderPayQuery {
	query := (&OrderPayClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderpay.Table, orderpay.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.PayTable, order.PayColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySales queries the sales edge of a Order.
func (c *OrderClient) QuerySales(o *Order) *OrderSalesQuery {
	query := (&OrderSalesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(ordersales.Table, ordersales.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.SalesTable, order.SalesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderAmountClient is a client for the OrderAmount schema.
type OrderAmountClient struct {
	config
}

// NewOrderAmountClient returns a client for the OrderAmount from the given config.
func NewOrderAmountClient(c config) *OrderAmountClient {
	return &OrderAmountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderamount.Hooks(f(g(h())))`.
func (c *OrderAmountClient) Use(hooks ...Hook) {
	c.hooks.OrderAmount = append(c.hooks.OrderAmount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderamount.Intercept(f(g(h())))`.
func (c *OrderAmountClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderAmount = append(c.inters.OrderAmount, interceptors...)
}

// Create returns a builder for creating a OrderAmount entity.
func (c *OrderAmountClient) Create() *OrderAmountCreate {
	mutation := newOrderAmountMutation(c.config, OpCreate)
	return &OrderAmountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderAmount entities.
func (c *OrderAmountClient) CreateBulk(builders ...*OrderAmountCreate) *OrderAmountCreateBulk {
	return &OrderAmountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderAmountClient) MapCreateBulk(slice any, setFunc func(*OrderAmountCreate, int)) *OrderAmountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderAmountCreateBulk{err: fmt.Errorf("calling to OrderAmountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderAmountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderAmountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderAmount.
func (c *OrderAmountClient) Update() *OrderAmountUpdate {
	mutation := newOrderAmountMutation(c.config, OpUpdate)
	return &OrderAmountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderAmountClient) UpdateOne(oa *OrderAmount) *OrderAmountUpdateOne {
	mutation := newOrderAmountMutation(c.config, OpUpdateOne, withOrderAmount(oa))
	return &OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderAmountClient) UpdateOneID(id int64) *OrderAmountUpdateOne {
	mutation := newOrderAmountMutation(c.config, OpUpdateOne, withOrderAmountID(id))
	return &OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderAmount.
func (c *OrderAmountClient) Delete() *OrderAmountDelete {
	mutation := newOrderAmountMutation(c.config, OpDelete)
	return &OrderAmountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderAmountClient) DeleteOne(oa *OrderAmount) *OrderAmountDeleteOne {
	return c.DeleteOneID(oa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderAmountClient) DeleteOneID(id int64) *OrderAmountDeleteOne {
	builder := c.Delete().Where(orderamount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderAmountDeleteOne{builder}
}

// Query returns a query builder for OrderAmount.
func (c *OrderAmountClient) Query() *OrderAmountQuery {
	return &OrderAmountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderAmount},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderAmount entity by its id.
func (c *OrderAmountClient) Get(ctx context.Context, id int64) (*OrderAmount, error) {
	return c.Query().Where(orderamount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderAmountClient) GetX(ctx context.Context, id int64) *OrderAmount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrderAmount.
func (c *OrderAmountClient) QueryOwner(oa *OrderAmount) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderamount.Table, orderamount.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderamount.OwnerTable, orderamount.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderAmountClient) Hooks() []Hook {
	return c.hooks.OrderAmount
}

// Interceptors returns the client interceptors.
func (c *OrderAmountClient) Interceptors() []Interceptor {
	return c.inters.OrderAmount
}

func (c *OrderAmountClient) mutate(ctx context.Context, m *OrderAmountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderAmountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderAmountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderAmountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderAmount mutation op: %q", m.Op())
	}
}

// OrderItemClient is a client for the OrderItem schema.
type OrderItemClient struct {
	config
}

// NewOrderItemClient returns a client for the OrderItem from the given config.
func NewOrderItemClient(c config) *OrderItemClient {
	return &OrderItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderitem.Hooks(f(g(h())))`.
func (c *OrderItemClient) Use(hooks ...Hook) {
	c.hooks.OrderItem = append(c.hooks.OrderItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderitem.Intercept(f(g(h())))`.
func (c *OrderItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderItem = append(c.inters.OrderItem, interceptors...)
}

// Create returns a builder for creating a OrderItem entity.
func (c *OrderItemClient) Create() *OrderItemCreate {
	mutation := newOrderItemMutation(c.config, OpCreate)
	return &OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderItem entities.
func (c *OrderItemClient) CreateBulk(builders ...*OrderItemCreate) *OrderItemCreateBulk {
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderItemClient) MapCreateBulk(slice any, setFunc func(*OrderItemCreate, int)) *OrderItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderItemCreateBulk{err: fmt.Errorf("calling to OrderItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderItem.
func (c *OrderItemClient) Update() *OrderItemUpdate {
	mutation := newOrderItemMutation(c.config, OpUpdate)
	return &OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderItemClient) UpdateOne(oi *OrderItem) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItem(oi))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderItemClient) UpdateOneID(id int64) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItemID(id))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderItem.
func (c *OrderItemClient) Delete() *OrderItemDelete {
	mutation := newOrderItemMutation(c.config, OpDelete)
	return &OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderItemClient) DeleteOne(oi *OrderItem) *OrderItemDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderItemClient) DeleteOneID(id int64) *OrderItemDeleteOne {
	builder := c.Delete().Where(orderitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderItemDeleteOne{builder}
}

// Query returns a query builder for OrderItem.
func (c *OrderItemClient) Query() *OrderItemQuery {
	return &OrderItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderItem entity by its id.
func (c *OrderItemClient) Get(ctx context.Context, id int64) (*OrderItem, error) {
	return c.Query().Where(orderitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderItemClient) GetX(ctx context.Context, id int64) *OrderItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrderItem.
func (c *OrderItemClient) QueryOwner(oi *OrderItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderitem.OwnerTable, orderitem.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderItemClient) Hooks() []Hook {
	return c.hooks.OrderItem
}

// Interceptors returns the client interceptors.
func (c *OrderItemClient) Interceptors() []Interceptor {
	return c.inters.OrderItem
}

func (c *OrderItemClient) mutate(ctx context.Context, m *OrderItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderItem mutation op: %q", m.Op())
	}
}

// OrderPayClient is a client for the OrderPay schema.
type OrderPayClient struct {
	config
}

// NewOrderPayClient returns a client for the OrderPay from the given config.
func NewOrderPayClient(c config) *OrderPayClient {
	return &OrderPayClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderpay.Hooks(f(g(h())))`.
func (c *OrderPayClient) Use(hooks ...Hook) {
	c.hooks.OrderPay = append(c.hooks.OrderPay, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderpay.Intercept(f(g(h())))`.
func (c *OrderPayClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderPay = append(c.inters.OrderPay, interceptors...)
}

// Create returns a builder for creating a OrderPay entity.
func (c *OrderPayClient) Create() *OrderPayCreate {
	mutation := newOrderPayMutation(c.config, OpCreate)
	return &OrderPayCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderPay entities.
func (c *OrderPayClient) CreateBulk(builders ...*OrderPayCreate) *OrderPayCreateBulk {
	return &OrderPayCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderPayClient) MapCreateBulk(slice any, setFunc func(*OrderPayCreate, int)) *OrderPayCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderPayCreateBulk{err: fmt.Errorf("calling to OrderPayClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderPayCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderPayCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderPay.
func (c *OrderPayClient) Update() *OrderPayUpdate {
	mutation := newOrderPayMutation(c.config, OpUpdate)
	return &OrderPayUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderPayClient) UpdateOne(op *OrderPay) *OrderPayUpdateOne {
	mutation := newOrderPayMutation(c.config, OpUpdateOne, withOrderPay(op))
	return &OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderPayClient) UpdateOneID(id int64) *OrderPayUpdateOne {
	mutation := newOrderPayMutation(c.config, OpUpdateOne, withOrderPayID(id))
	return &OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderPay.
func (c *OrderPayClient) Delete() *OrderPayDelete {
	mutation := newOrderPayMutation(c.config, OpDelete)
	return &OrderPayDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderPayClient) DeleteOne(op *OrderPay) *OrderPayDeleteOne {
	return c.DeleteOneID(op.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderPayClient) DeleteOneID(id int64) *OrderPayDeleteOne {
	builder := c.Delete().Where(orderpay.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderPayDeleteOne{builder}
}

// Query returns a query builder for OrderPay.
func (c *OrderPayClient) Query() *OrderPayQuery {
	return &OrderPayQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderPay},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderPay entity by its id.
func (c *OrderPayClient) Get(ctx context.Context, id int64) (*OrderPay, error) {
	return c.Query().Where(orderpay.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderPayClient) GetX(ctx context.Context, id int64) *OrderPay {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrderPay.
func (c *OrderPayClient) QueryOwner(op *OrderPay) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := op.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderpay.Table, orderpay.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderpay.OwnerTable, orderpay.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(op.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderPayClient) Hooks() []Hook {
	return c.hooks.OrderPay
}

// Interceptors returns the client interceptors.
func (c *OrderPayClient) Interceptors() []Interceptor {
	return c.inters.OrderPay
}

func (c *OrderPayClient) mutate(ctx context.Context, m *OrderPayMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderPayCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderPayUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderPayDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderPay mutation op: %q", m.Op())
	}
}

// OrderSalesClient is a client for the OrderSales schema.
type OrderSalesClient struct {
	config
}

// NewOrderSalesClient returns a client for the OrderSales from the given config.
func NewOrderSalesClient(c config) *OrderSalesClient {
	return &OrderSalesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ordersales.Hooks(f(g(h())))`.
func (c *OrderSalesClient) Use(hooks ...Hook) {
	c.hooks.OrderSales = append(c.hooks.OrderSales, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ordersales.Intercept(f(g(h())))`.
func (c *OrderSalesClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderSales = append(c.inters.OrderSales, interceptors...)
}

// Create returns a builder for creating a OrderSales entity.
func (c *OrderSalesClient) Create() *OrderSalesCreate {
	mutation := newOrderSalesMutation(c.config, OpCreate)
	return &OrderSalesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderSales entities.
func (c *OrderSalesClient) CreateBulk(builders ...*OrderSalesCreate) *OrderSalesCreateBulk {
	return &OrderSalesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderSalesClient) MapCreateBulk(slice any, setFunc func(*OrderSalesCreate, int)) *OrderSalesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderSalesCreateBulk{err: fmt.Errorf("calling to OrderSalesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderSalesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderSalesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderSales.
func (c *OrderSalesClient) Update() *OrderSalesUpdate {
	mutation := newOrderSalesMutation(c.config, OpUpdate)
	return &OrderSalesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderSalesClient) UpdateOne(os *OrderSales) *OrderSalesUpdateOne {
	mutation := newOrderSalesMutation(c.config, OpUpdateOne, withOrderSales(os))
	return &OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderSalesClient) UpdateOneID(id int64) *OrderSalesUpdateOne {
	mutation := newOrderSalesMutation(c.config, OpUpdateOne, withOrderSalesID(id))
	return &OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderSales.
func (c *OrderSalesClient) Delete() *OrderSalesDelete {
	mutation := newOrderSalesMutation(c.config, OpDelete)
	return &OrderSalesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderSalesClient) DeleteOne(os *OrderSales) *OrderSalesDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderSalesClient) DeleteOneID(id int64) *OrderSalesDeleteOne {
	builder := c.Delete().Where(ordersales.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderSalesDeleteOne{builder}
}

// Query returns a query builder for OrderSales.
func (c *OrderSalesClient) Query() *OrderSalesQuery {
	return &OrderSalesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderSales},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderSales entity by its id.
func (c *OrderSalesClient) Get(ctx context.Context, id int64) (*OrderSales, error) {
	return c.Query().Where(ordersales.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderSalesClient) GetX(ctx context.Context, id int64) *OrderSales {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrderSales.
func (c *OrderSalesClient) QueryOwner(os *OrderSales) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordersales.Table, ordersales.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ordersales.OwnerTable, ordersales.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderSalesClient) Hooks() []Hook {
	return c.hooks.OrderSales
}

// Interceptors returns the client interceptors.
func (c *OrderSalesClient) Interceptors() []Interceptor {
	return c.inters.OrderSales
}

func (c *OrderSalesClient) mutate(ctx context.Context, m *OrderSalesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderSalesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderSalesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderSalesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderSales mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int64) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id int64) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int64) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int64) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPropertys queries the propertys edge of a Product.
func (c *ProductClient) QueryPropertys(pr *Product) *ProductPropertyQuery {
	query := (&ProductPropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(productproperty.Table, productproperty.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.PropertysTable, product.PropertysPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// ProductPropertyClient is a client for the ProductProperty schema.
type ProductPropertyClient struct {
	config
}

// NewProductPropertyClient returns a client for the ProductProperty from the given config.
func NewProductPropertyClient(c config) *ProductPropertyClient {
	return &ProductPropertyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productproperty.Hooks(f(g(h())))`.
func (c *ProductPropertyClient) Use(hooks ...Hook) {
	c.hooks.ProductProperty = append(c.hooks.ProductProperty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productproperty.Intercept(f(g(h())))`.
func (c *ProductPropertyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductProperty = append(c.inters.ProductProperty, interceptors...)
}

// Create returns a builder for creating a ProductProperty entity.
func (c *ProductPropertyClient) Create() *ProductPropertyCreate {
	mutation := newProductPropertyMutation(c.config, OpCreate)
	return &ProductPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductProperty entities.
func (c *ProductPropertyClient) CreateBulk(builders ...*ProductPropertyCreate) *ProductPropertyCreateBulk {
	return &ProductPropertyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductPropertyClient) MapCreateBulk(slice any, setFunc func(*ProductPropertyCreate, int)) *ProductPropertyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductPropertyCreateBulk{err: fmt.Errorf("calling to ProductPropertyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductPropertyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductPropertyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductProperty.
func (c *ProductPropertyClient) Update() *ProductPropertyUpdate {
	mutation := newProductPropertyMutation(c.config, OpUpdate)
	return &ProductPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductPropertyClient) UpdateOne(pp *ProductProperty) *ProductPropertyUpdateOne {
	mutation := newProductPropertyMutation(c.config, OpUpdateOne, withProductProperty(pp))
	return &ProductPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductPropertyClient) UpdateOneID(id int64) *ProductPropertyUpdateOne {
	mutation := newProductPropertyMutation(c.config, OpUpdateOne, withProductPropertyID(id))
	return &ProductPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductProperty.
func (c *ProductPropertyClient) Delete() *ProductPropertyDelete {
	mutation := newProductPropertyMutation(c.config, OpDelete)
	return &ProductPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductPropertyClient) DeleteOne(pp *ProductProperty) *ProductPropertyDeleteOne {
	return c.DeleteOneID(pp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductPropertyClient) DeleteOneID(id int64) *ProductPropertyDeleteOne {
	builder := c.Delete().Where(productproperty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductPropertyDeleteOne{builder}
}

// Query returns a query builder for ProductProperty.
func (c *ProductPropertyClient) Query() *ProductPropertyQuery {
	return &ProductPropertyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductProperty},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductProperty entity by its id.
func (c *ProductPropertyClient) Get(ctx context.Context, id int64) (*ProductProperty, error) {
	return c.Query().Where(productproperty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductPropertyClient) GetX(ctx context.Context, id int64) *ProductProperty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ProductProperty.
func (c *ProductPropertyClient) QueryProduct(pp *ProductProperty) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productproperty.Table, productproperty.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, productproperty.ProductTable, productproperty.ProductPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductPropertyClient) Hooks() []Hook {
	return c.hooks.ProductProperty
}

// Interceptors returns the client interceptors.
func (c *ProductPropertyClient) Interceptors() []Interceptor {
	return c.inters.ProductProperty
}

func (c *ProductPropertyClient) mutate(ctx context.Context, m *ProductPropertyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductProperty mutation op: %q", m.Op())
	}
}

// ProductPropertyVenueClient is a client for the ProductPropertyVenue schema.
type ProductPropertyVenueClient struct {
	config
}

// NewProductPropertyVenueClient returns a client for the ProductPropertyVenue from the given config.
func NewProductPropertyVenueClient(c config) *ProductPropertyVenueClient {
	return &ProductPropertyVenueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productpropertyvenue.Hooks(f(g(h())))`.
func (c *ProductPropertyVenueClient) Use(hooks ...Hook) {
	c.hooks.ProductPropertyVenue = append(c.hooks.ProductPropertyVenue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productpropertyvenue.Intercept(f(g(h())))`.
func (c *ProductPropertyVenueClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductPropertyVenue = append(c.inters.ProductPropertyVenue, interceptors...)
}

// Create returns a builder for creating a ProductPropertyVenue entity.
func (c *ProductPropertyVenueClient) Create() *ProductPropertyVenueCreate {
	mutation := newProductPropertyVenueMutation(c.config, OpCreate)
	return &ProductPropertyVenueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductPropertyVenue entities.
func (c *ProductPropertyVenueClient) CreateBulk(builders ...*ProductPropertyVenueCreate) *ProductPropertyVenueCreateBulk {
	return &ProductPropertyVenueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductPropertyVenueClient) MapCreateBulk(slice any, setFunc func(*ProductPropertyVenueCreate, int)) *ProductPropertyVenueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductPropertyVenueCreateBulk{err: fmt.Errorf("calling to ProductPropertyVenueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductPropertyVenueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductPropertyVenueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductPropertyVenue.
func (c *ProductPropertyVenueClient) Update() *ProductPropertyVenueUpdate {
	mutation := newProductPropertyVenueMutation(c.config, OpUpdate)
	return &ProductPropertyVenueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductPropertyVenueClient) UpdateOne(ppv *ProductPropertyVenue) *ProductPropertyVenueUpdateOne {
	mutation := newProductPropertyVenueMutation(c.config, OpUpdateOne, withProductPropertyVenue(ppv))
	return &ProductPropertyVenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductPropertyVenueClient) UpdateOneID(id int64) *ProductPropertyVenueUpdateOne {
	mutation := newProductPropertyVenueMutation(c.config, OpUpdateOne, withProductPropertyVenueID(id))
	return &ProductPropertyVenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductPropertyVenue.
func (c *ProductPropertyVenueClient) Delete() *ProductPropertyVenueDelete {
	mutation := newProductPropertyVenueMutation(c.config, OpDelete)
	return &ProductPropertyVenueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductPropertyVenueClient) DeleteOne(ppv *ProductPropertyVenue) *ProductPropertyVenueDeleteOne {
	return c.DeleteOneID(ppv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductPropertyVenueClient) DeleteOneID(id int64) *ProductPropertyVenueDeleteOne {
	builder := c.Delete().Where(productpropertyvenue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductPropertyVenueDeleteOne{builder}
}

// Query returns a query builder for ProductPropertyVenue.
func (c *ProductPropertyVenueClient) Query() *ProductPropertyVenueQuery {
	return &ProductPropertyVenueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductPropertyVenue},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductPropertyVenue entity by its id.
func (c *ProductPropertyVenueClient) Get(ctx context.Context, id int64) (*ProductPropertyVenue, error) {
	return c.Query().Where(productpropertyvenue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductPropertyVenueClient) GetX(ctx context.Context, id int64) *ProductPropertyVenue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductPropertyVenueClient) Hooks() []Hook {
	return c.hooks.ProductPropertyVenue
}

// Interceptors returns the client interceptors.
func (c *ProductPropertyVenueClient) Interceptors() []Interceptor {
	return c.inters.ProductPropertyVenue
}

func (c *ProductPropertyVenueClient) mutate(ctx context.Context, m *ProductPropertyVenueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductPropertyVenueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductPropertyVenueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductPropertyVenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductPropertyVenueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductPropertyVenue mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int64) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id int64) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int64) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int64) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenus queries the menus edge of a Role.
func (c *RoleClient) QueryMenus(r *Role) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.MenusTable, role.MenusPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id int64) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id int64) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id int64) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id int64) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Token.
func (c *TokenClient) QueryOwner(t *Token) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, token.OwnerTable, token.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryToken queries the token edge of a User.
func (c *UserClient) QueryToken(u *User) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.TokenTable, user.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VenueClient is a client for the Venue schema.
type VenueClient struct {
	config
}

// NewVenueClient returns a client for the Venue from the given config.
func NewVenueClient(c config) *VenueClient {
	return &VenueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venue.Hooks(f(g(h())))`.
func (c *VenueClient) Use(hooks ...Hook) {
	c.hooks.Venue = append(c.hooks.Venue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venue.Intercept(f(g(h())))`.
func (c *VenueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Venue = append(c.inters.Venue, interceptors...)
}

// Create returns a builder for creating a Venue entity.
func (c *VenueClient) Create() *VenueCreate {
	mutation := newVenueMutation(c.config, OpCreate)
	return &VenueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Venue entities.
func (c *VenueClient) CreateBulk(builders ...*VenueCreate) *VenueCreateBulk {
	return &VenueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenueClient) MapCreateBulk(slice any, setFunc func(*VenueCreate, int)) *VenueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenueCreateBulk{err: fmt.Errorf("calling to VenueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Venue.
func (c *VenueClient) Update() *VenueUpdate {
	mutation := newVenueMutation(c.config, OpUpdate)
	return &VenueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenueClient) UpdateOne(v *Venue) *VenueUpdateOne {
	mutation := newVenueMutation(c.config, OpUpdateOne, withVenue(v))
	return &VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenueClient) UpdateOneID(id int64) *VenueUpdateOne {
	mutation := newVenueMutation(c.config, OpUpdateOne, withVenueID(id))
	return &VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Venue.
func (c *VenueClient) Delete() *VenueDelete {
	mutation := newVenueMutation(c.config, OpDelete)
	return &VenueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenueClient) DeleteOne(v *Venue) *VenueDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenueClient) DeleteOneID(id int64) *VenueDeleteOne {
	builder := c.Delete().Where(venue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenueDeleteOne{builder}
}

// Query returns a query builder for Venue.
func (c *VenueClient) Query() *VenueQuery {
	return &VenueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenue},
		inters: c.Interceptors(),
	}
}

// Get returns a Venue entity by its id.
func (c *VenueClient) Get(ctx context.Context, id int64) (*Venue, error) {
	return c.Query().Where(venue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenueClient) GetX(ctx context.Context, id int64) *Venue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlaces queries the places edge of a Venue.
func (c *VenueClient) QueryPlaces(v *Venue) *VenuePlaceQuery {
	query := (&VenuePlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(venueplace.Table, venueplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.PlacesTable, venue.PlacesColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenueClient) Hooks() []Hook {
	return c.hooks.Venue
}

// Interceptors returns the client interceptors.
func (c *VenueClient) Interceptors() []Interceptor {
	return c.inters.Venue
}

func (c *VenueClient) mutate(ctx context.Context, m *VenueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Venue mutation op: %q", m.Op())
	}
}

// VenuePlaceClient is a client for the VenuePlace schema.
type VenuePlaceClient struct {
	config
}

// NewVenuePlaceClient returns a client for the VenuePlace from the given config.
func NewVenuePlaceClient(c config) *VenuePlaceClient {
	return &VenuePlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venueplace.Hooks(f(g(h())))`.
func (c *VenuePlaceClient) Use(hooks ...Hook) {
	c.hooks.VenuePlace = append(c.hooks.VenuePlace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venueplace.Intercept(f(g(h())))`.
func (c *VenuePlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.VenuePlace = append(c.inters.VenuePlace, interceptors...)
}

// Create returns a builder for creating a VenuePlace entity.
func (c *VenuePlaceClient) Create() *VenuePlaceCreate {
	mutation := newVenuePlaceMutation(c.config, OpCreate)
	return &VenuePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VenuePlace entities.
func (c *VenuePlaceClient) CreateBulk(builders ...*VenuePlaceCreate) *VenuePlaceCreateBulk {
	return &VenuePlaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenuePlaceClient) MapCreateBulk(slice any, setFunc func(*VenuePlaceCreate, int)) *VenuePlaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenuePlaceCreateBulk{err: fmt.Errorf("calling to VenuePlaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenuePlaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenuePlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VenuePlace.
func (c *VenuePlaceClient) Update() *VenuePlaceUpdate {
	mutation := newVenuePlaceMutation(c.config, OpUpdate)
	return &VenuePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenuePlaceClient) UpdateOne(vp *VenuePlace) *VenuePlaceUpdateOne {
	mutation := newVenuePlaceMutation(c.config, OpUpdateOne, withVenuePlace(vp))
	return &VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenuePlaceClient) UpdateOneID(id int64) *VenuePlaceUpdateOne {
	mutation := newVenuePlaceMutation(c.config, OpUpdateOne, withVenuePlaceID(id))
	return &VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VenuePlace.
func (c *VenuePlaceClient) Delete() *VenuePlaceDelete {
	mutation := newVenuePlaceMutation(c.config, OpDelete)
	return &VenuePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenuePlaceClient) DeleteOne(vp *VenuePlace) *VenuePlaceDeleteOne {
	return c.DeleteOneID(vp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenuePlaceClient) DeleteOneID(id int64) *VenuePlaceDeleteOne {
	builder := c.Delete().Where(venueplace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenuePlaceDeleteOne{builder}
}

// Query returns a query builder for VenuePlace.
func (c *VenuePlaceClient) Query() *VenuePlaceQuery {
	return &VenuePlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenuePlace},
		inters: c.Interceptors(),
	}
}

// Get returns a VenuePlace entity by its id.
func (c *VenuePlaceClient) Get(ctx context.Context, id int64) (*VenuePlace, error) {
	return c.Query().Where(venueplace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenuePlaceClient) GetX(ctx context.Context, id int64) *VenuePlace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVenue queries the venue edge of a VenuePlace.
func (c *VenuePlaceClient) QueryVenue(vp *VenuePlace) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venueplace.Table, venueplace.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, venueplace.VenueTable, venueplace.VenueColumn),
		)
		fromV = sqlgraph.Neighbors(vp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenuePlaceClient) Hooks() []Hook {
	return c.hooks.VenuePlace
}

// Interceptors returns the client interceptors.
func (c *VenuePlaceClient) Interceptors() []Interceptor {
	return c.inters.VenuePlace
}

func (c *VenuePlaceClient) mutate(ctx context.Context, m *VenuePlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenuePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenuePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenuePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VenuePlace mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		API, CourseRecordCoach, CourseRecordMember, CourseRecordSchedule, Dictionary,
		DictionaryDetail, EntryLogs, Logs, Member, MemberDetails, MemberNote,
		MemberProduct, MemberProductProperty, MemberProductPropertyVenue, Menu,
		MenuParam, Order, OrderAmount, OrderItem, OrderPay, OrderSales, Product,
		ProductProperty, ProductPropertyVenue, Role, Token, User, Venue,
		VenuePlace []ent.Hook
	}
	inters struct {
		API, CourseRecordCoach, CourseRecordMember, CourseRecordSchedule, Dictionary,
		DictionaryDetail, EntryLogs, Logs, Member, MemberDetails, MemberNote,
		MemberProduct, MemberProductProperty, MemberProductPropertyVenue, Menu,
		MenuParam, Order, OrderAmount, OrderItem, OrderPay, OrderSales, Product,
		ProductProperty, ProductPropertyVenue, Role, Token, User, Venue,
		VenuePlace []ent.Interceptor
	}
)
