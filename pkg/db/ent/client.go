// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"saas/pkg/db/ent/migrate"

	"saas/pkg/db/ent/api"
	"saas/pkg/db/ent/contest"
	"saas/pkg/db/ent/contestparticipant"
	"saas/pkg/db/ent/contract"
	"saas/pkg/db/ent/dictionary"
	"saas/pkg/db/ent/dictionarydetail"
	"saas/pkg/db/ent/entrylogs"
	"saas/pkg/db/ent/logs"
	"saas/pkg/db/ent/member"
	"saas/pkg/db/ent/membercontract"
	"saas/pkg/db/ent/membercontractcontent"
	"saas/pkg/db/ent/memberdetails"
	"saas/pkg/db/ent/membernote"
	"saas/pkg/db/ent/menu"
	"saas/pkg/db/ent/menuparam"
	"saas/pkg/db/ent/messages"
	"saas/pkg/db/ent/order"
	"saas/pkg/db/ent/orderamount"
	"saas/pkg/db/ent/orderitem"
	"saas/pkg/db/ent/orderpay"
	"saas/pkg/db/ent/ordersales"
	"saas/pkg/db/ent/role"
	"saas/pkg/db/ent/token"
	"saas/pkg/db/ent/user"
	"saas/pkg/db/ent/venue"
	"saas/pkg/db/ent/venueplace"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// API is the client for interacting with the API builders.
	API *APIClient
	// Contest is the client for interacting with the Contest builders.
	Contest *ContestClient
	// ContestParticipant is the client for interacting with the ContestParticipant builders.
	ContestParticipant *ContestParticipantClient
	// Contract is the client for interacting with the Contract builders.
	Contract *ContractClient
	// Dictionary is the client for interacting with the Dictionary builders.
	Dictionary *DictionaryClient
	// DictionaryDetail is the client for interacting with the DictionaryDetail builders.
	DictionaryDetail *DictionaryDetailClient
	// EntryLogs is the client for interacting with the EntryLogs builders.
	EntryLogs *EntryLogsClient
	// Logs is the client for interacting with the Logs builders.
	Logs *LogsClient
	// Member is the client for interacting with the Member builders.
	Member *MemberClient
	// MemberContract is the client for interacting with the MemberContract builders.
	MemberContract *MemberContractClient
	// MemberContractContent is the client for interacting with the MemberContractContent builders.
	MemberContractContent *MemberContractContentClient
	// MemberDetails is the client for interacting with the MemberDetails builders.
	MemberDetails *MemberDetailsClient
	// MemberNote is the client for interacting with the MemberNote builders.
	MemberNote *MemberNoteClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// MenuParam is the client for interacting with the MenuParam builders.
	MenuParam *MenuParamClient
	// Messages is the client for interacting with the Messages builders.
	Messages *MessagesClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderAmount is the client for interacting with the OrderAmount builders.
	OrderAmount *OrderAmountClient
	// OrderItem is the client for interacting with the OrderItem builders.
	OrderItem *OrderItemClient
	// OrderPay is the client for interacting with the OrderPay builders.
	OrderPay *OrderPayClient
	// OrderSales is the client for interacting with the OrderSales builders.
	OrderSales *OrderSalesClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Venue is the client for interacting with the Venue builders.
	Venue *VenueClient
	// VenuePlace is the client for interacting with the VenuePlace builders.
	VenuePlace *VenuePlaceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.API = NewAPIClient(c.config)
	c.Contest = NewContestClient(c.config)
	c.ContestParticipant = NewContestParticipantClient(c.config)
	c.Contract = NewContractClient(c.config)
	c.Dictionary = NewDictionaryClient(c.config)
	c.DictionaryDetail = NewDictionaryDetailClient(c.config)
	c.EntryLogs = NewEntryLogsClient(c.config)
	c.Logs = NewLogsClient(c.config)
	c.Member = NewMemberClient(c.config)
	c.MemberContract = NewMemberContractClient(c.config)
	c.MemberContractContent = NewMemberContractContentClient(c.config)
	c.MemberDetails = NewMemberDetailsClient(c.config)
	c.MemberNote = NewMemberNoteClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.MenuParam = NewMenuParamClient(c.config)
	c.Messages = NewMessagesClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderAmount = NewOrderAmountClient(c.config)
	c.OrderItem = NewOrderItemClient(c.config)
	c.OrderPay = NewOrderPayClient(c.config)
	c.OrderSales = NewOrderSalesClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.User = NewUserClient(c.config)
	c.Venue = NewVenueClient(c.config)
	c.VenuePlace = NewVenuePlaceClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		API:                   NewAPIClient(cfg),
		Contest:               NewContestClient(cfg),
		ContestParticipant:    NewContestParticipantClient(cfg),
		Contract:              NewContractClient(cfg),
		Dictionary:            NewDictionaryClient(cfg),
		DictionaryDetail:      NewDictionaryDetailClient(cfg),
		EntryLogs:             NewEntryLogsClient(cfg),
		Logs:                  NewLogsClient(cfg),
		Member:                NewMemberClient(cfg),
		MemberContract:        NewMemberContractClient(cfg),
		MemberContractContent: NewMemberContractContentClient(cfg),
		MemberDetails:         NewMemberDetailsClient(cfg),
		MemberNote:            NewMemberNoteClient(cfg),
		Menu:                  NewMenuClient(cfg),
		MenuParam:             NewMenuParamClient(cfg),
		Messages:              NewMessagesClient(cfg),
		Order:                 NewOrderClient(cfg),
		OrderAmount:           NewOrderAmountClient(cfg),
		OrderItem:             NewOrderItemClient(cfg),
		OrderPay:              NewOrderPayClient(cfg),
		OrderSales:            NewOrderSalesClient(cfg),
		Role:                  NewRoleClient(cfg),
		Token:                 NewTokenClient(cfg),
		User:                  NewUserClient(cfg),
		Venue:                 NewVenueClient(cfg),
		VenuePlace:            NewVenuePlaceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		API:                   NewAPIClient(cfg),
		Contest:               NewContestClient(cfg),
		ContestParticipant:    NewContestParticipantClient(cfg),
		Contract:              NewContractClient(cfg),
		Dictionary:            NewDictionaryClient(cfg),
		DictionaryDetail:      NewDictionaryDetailClient(cfg),
		EntryLogs:             NewEntryLogsClient(cfg),
		Logs:                  NewLogsClient(cfg),
		Member:                NewMemberClient(cfg),
		MemberContract:        NewMemberContractClient(cfg),
		MemberContractContent: NewMemberContractContentClient(cfg),
		MemberDetails:         NewMemberDetailsClient(cfg),
		MemberNote:            NewMemberNoteClient(cfg),
		Menu:                  NewMenuClient(cfg),
		MenuParam:             NewMenuParamClient(cfg),
		Messages:              NewMessagesClient(cfg),
		Order:                 NewOrderClient(cfg),
		OrderAmount:           NewOrderAmountClient(cfg),
		OrderItem:             NewOrderItemClient(cfg),
		OrderPay:              NewOrderPayClient(cfg),
		OrderSales:            NewOrderSalesClient(cfg),
		Role:                  NewRoleClient(cfg),
		Token:                 NewTokenClient(cfg),
		User:                  NewUserClient(cfg),
		Venue:                 NewVenueClient(cfg),
		VenuePlace:            NewVenuePlaceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		API.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.API, c.Contest, c.ContestParticipant, c.Contract, c.Dictionary,
		c.DictionaryDetail, c.EntryLogs, c.Logs, c.Member, c.MemberContract,
		c.MemberContractContent, c.MemberDetails, c.MemberNote, c.Menu, c.MenuParam,
		c.Messages, c.Order, c.OrderAmount, c.OrderItem, c.OrderPay, c.OrderSales,
		c.Role, c.Token, c.User, c.Venue, c.VenuePlace,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.API, c.Contest, c.ContestParticipant, c.Contract, c.Dictionary,
		c.DictionaryDetail, c.EntryLogs, c.Logs, c.Member, c.MemberContract,
		c.MemberContractContent, c.MemberDetails, c.MemberNote, c.Menu, c.MenuParam,
		c.Messages, c.Order, c.OrderAmount, c.OrderItem, c.OrderPay, c.OrderSales,
		c.Role, c.Token, c.User, c.Venue, c.VenuePlace,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIMutation:
		return c.API.mutate(ctx, m)
	case *ContestMutation:
		return c.Contest.mutate(ctx, m)
	case *ContestParticipantMutation:
		return c.ContestParticipant.mutate(ctx, m)
	case *ContractMutation:
		return c.Contract.mutate(ctx, m)
	case *DictionaryMutation:
		return c.Dictionary.mutate(ctx, m)
	case *DictionaryDetailMutation:
		return c.DictionaryDetail.mutate(ctx, m)
	case *EntryLogsMutation:
		return c.EntryLogs.mutate(ctx, m)
	case *LogsMutation:
		return c.Logs.mutate(ctx, m)
	case *MemberMutation:
		return c.Member.mutate(ctx, m)
	case *MemberContractMutation:
		return c.MemberContract.mutate(ctx, m)
	case *MemberContractContentMutation:
		return c.MemberContractContent.mutate(ctx, m)
	case *MemberDetailsMutation:
		return c.MemberDetails.mutate(ctx, m)
	case *MemberNoteMutation:
		return c.MemberNote.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *MenuParamMutation:
		return c.MenuParam.mutate(ctx, m)
	case *MessagesMutation:
		return c.Messages.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderAmountMutation:
		return c.OrderAmount.mutate(ctx, m)
	case *OrderItemMutation:
		return c.OrderItem.mutate(ctx, m)
	case *OrderPayMutation:
		return c.OrderPay.mutate(ctx, m)
	case *OrderSalesMutation:
		return c.OrderSales.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VenueMutation:
		return c.Venue.mutate(ctx, m)
	case *VenuePlaceMutation:
		return c.VenuePlace.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIClient is a client for the API schema.
type APIClient struct {
	config
}

// NewAPIClient returns a client for the API from the given config.
func NewAPIClient(c config) *APIClient {
	return &APIClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `api.Hooks(f(g(h())))`.
func (c *APIClient) Use(hooks ...Hook) {
	c.hooks.API = append(c.hooks.API, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `api.Intercept(f(g(h())))`.
func (c *APIClient) Intercept(interceptors ...Interceptor) {
	c.inters.API = append(c.inters.API, interceptors...)
}

// Create returns a builder for creating a API entity.
func (c *APIClient) Create() *APICreate {
	mutation := newAPIMutation(c.config, OpCreate)
	return &APICreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of API entities.
func (c *APIClient) CreateBulk(builders ...*APICreate) *APICreateBulk {
	return &APICreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIClient) MapCreateBulk(slice any, setFunc func(*APICreate, int)) *APICreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APICreateBulk{err: fmt.Errorf("calling to APIClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APICreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APICreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for API.
func (c *APIClient) Update() *APIUpdate {
	mutation := newAPIMutation(c.config, OpUpdate)
	return &APIUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIClient) UpdateOne(a *API) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withAPI(a))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIClient) UpdateOneID(id int64) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withAPIID(id))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for API.
func (c *APIClient) Delete() *APIDelete {
	mutation := newAPIMutation(c.config, OpDelete)
	return &APIDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIClient) DeleteOne(a *API) *APIDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIClient) DeleteOneID(id int64) *APIDeleteOne {
	builder := c.Delete().Where(api.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIDeleteOne{builder}
}

// Query returns a query builder for API.
func (c *APIClient) Query() *APIQuery {
	return &APIQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPI},
		inters: c.Interceptors(),
	}
}

// Get returns a API entity by its id.
func (c *APIClient) Get(ctx context.Context, id int64) (*API, error) {
	return c.Query().Where(api.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIClient) GetX(ctx context.Context, id int64) *API {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *APIClient) Hooks() []Hook {
	return c.hooks.API
}

// Interceptors returns the client interceptors.
func (c *APIClient) Interceptors() []Interceptor {
	return c.inters.API
}

func (c *APIClient) mutate(ctx context.Context, m *APIMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APICreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown API mutation op: %q", m.Op())
	}
}

// ContestClient is a client for the Contest schema.
type ContestClient struct {
	config
}

// NewContestClient returns a client for the Contest from the given config.
func NewContestClient(c config) *ContestClient {
	return &ContestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contest.Hooks(f(g(h())))`.
func (c *ContestClient) Use(hooks ...Hook) {
	c.hooks.Contest = append(c.hooks.Contest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contest.Intercept(f(g(h())))`.
func (c *ContestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contest = append(c.inters.Contest, interceptors...)
}

// Create returns a builder for creating a Contest entity.
func (c *ContestClient) Create() *ContestCreate {
	mutation := newContestMutation(c.config, OpCreate)
	return &ContestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contest entities.
func (c *ContestClient) CreateBulk(builders ...*ContestCreate) *ContestCreateBulk {
	return &ContestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContestClient) MapCreateBulk(slice any, setFunc func(*ContestCreate, int)) *ContestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContestCreateBulk{err: fmt.Errorf("calling to ContestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contest.
func (c *ContestClient) Update() *ContestUpdate {
	mutation := newContestMutation(c.config, OpUpdate)
	return &ContestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContestClient) UpdateOne(co *Contest) *ContestUpdateOne {
	mutation := newContestMutation(c.config, OpUpdateOne, withContest(co))
	return &ContestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContestClient) UpdateOneID(id int64) *ContestUpdateOne {
	mutation := newContestMutation(c.config, OpUpdateOne, withContestID(id))
	return &ContestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contest.
func (c *ContestClient) Delete() *ContestDelete {
	mutation := newContestMutation(c.config, OpDelete)
	return &ContestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContestClient) DeleteOne(co *Contest) *ContestDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContestClient) DeleteOneID(id int64) *ContestDeleteOne {
	builder := c.Delete().Where(contest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContestDeleteOne{builder}
}

// Query returns a query builder for Contest.
func (c *ContestClient) Query() *ContestQuery {
	return &ContestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContest},
		inters: c.Interceptors(),
	}
}

// Get returns a Contest entity by its id.
func (c *ContestClient) Get(ctx context.Context, id int64) (*Contest, error) {
	return c.Query().Where(contest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContestClient) GetX(ctx context.Context, id int64) *Contest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ContestClient) Hooks() []Hook {
	return c.hooks.Contest
}

// Interceptors returns the client interceptors.
func (c *ContestClient) Interceptors() []Interceptor {
	return c.inters.Contest
}

func (c *ContestClient) mutate(ctx context.Context, m *ContestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Contest mutation op: %q", m.Op())
	}
}

// ContestParticipantClient is a client for the ContestParticipant schema.
type ContestParticipantClient struct {
	config
}

// NewContestParticipantClient returns a client for the ContestParticipant from the given config.
func NewContestParticipantClient(c config) *ContestParticipantClient {
	return &ContestParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contestparticipant.Hooks(f(g(h())))`.
func (c *ContestParticipantClient) Use(hooks ...Hook) {
	c.hooks.ContestParticipant = append(c.hooks.ContestParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contestparticipant.Intercept(f(g(h())))`.
func (c *ContestParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.ContestParticipant = append(c.inters.ContestParticipant, interceptors...)
}

// Create returns a builder for creating a ContestParticipant entity.
func (c *ContestParticipantClient) Create() *ContestParticipantCreate {
	mutation := newContestParticipantMutation(c.config, OpCreate)
	return &ContestParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ContestParticipant entities.
func (c *ContestParticipantClient) CreateBulk(builders ...*ContestParticipantCreate) *ContestParticipantCreateBulk {
	return &ContestParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContestParticipantClient) MapCreateBulk(slice any, setFunc func(*ContestParticipantCreate, int)) *ContestParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContestParticipantCreateBulk{err: fmt.Errorf("calling to ContestParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContestParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContestParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ContestParticipant.
func (c *ContestParticipantClient) Update() *ContestParticipantUpdate {
	mutation := newContestParticipantMutation(c.config, OpUpdate)
	return &ContestParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContestParticipantClient) UpdateOne(cp *ContestParticipant) *ContestParticipantUpdateOne {
	mutation := newContestParticipantMutation(c.config, OpUpdateOne, withContestParticipant(cp))
	return &ContestParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContestParticipantClient) UpdateOneID(id int64) *ContestParticipantUpdateOne {
	mutation := newContestParticipantMutation(c.config, OpUpdateOne, withContestParticipantID(id))
	return &ContestParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ContestParticipant.
func (c *ContestParticipantClient) Delete() *ContestParticipantDelete {
	mutation := newContestParticipantMutation(c.config, OpDelete)
	return &ContestParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContestParticipantClient) DeleteOne(cp *ContestParticipant) *ContestParticipantDeleteOne {
	return c.DeleteOneID(cp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContestParticipantClient) DeleteOneID(id int64) *ContestParticipantDeleteOne {
	builder := c.Delete().Where(contestparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContestParticipantDeleteOne{builder}
}

// Query returns a query builder for ContestParticipant.
func (c *ContestParticipantClient) Query() *ContestParticipantQuery {
	return &ContestParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContestParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a ContestParticipant entity by its id.
func (c *ContestParticipantClient) Get(ctx context.Context, id int64) (*ContestParticipant, error) {
	return c.Query().Where(contestparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContestParticipantClient) GetX(ctx context.Context, id int64) *ContestParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ContestParticipantClient) Hooks() []Hook {
	return c.hooks.ContestParticipant
}

// Interceptors returns the client interceptors.
func (c *ContestParticipantClient) Interceptors() []Interceptor {
	return c.inters.ContestParticipant
}

func (c *ContestParticipantClient) mutate(ctx context.Context, m *ContestParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContestParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContestParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContestParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContestParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ContestParticipant mutation op: %q", m.Op())
	}
}

// ContractClient is a client for the Contract schema.
type ContractClient struct {
	config
}

// NewContractClient returns a client for the Contract from the given config.
func NewContractClient(c config) *ContractClient {
	return &ContractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contract.Hooks(f(g(h())))`.
func (c *ContractClient) Use(hooks ...Hook) {
	c.hooks.Contract = append(c.hooks.Contract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contract.Intercept(f(g(h())))`.
func (c *ContractClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contract = append(c.inters.Contract, interceptors...)
}

// Create returns a builder for creating a Contract entity.
func (c *ContractClient) Create() *ContractCreate {
	mutation := newContractMutation(c.config, OpCreate)
	return &ContractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contract entities.
func (c *ContractClient) CreateBulk(builders ...*ContractCreate) *ContractCreateBulk {
	return &ContractCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContractClient) MapCreateBulk(slice any, setFunc func(*ContractCreate, int)) *ContractCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContractCreateBulk{err: fmt.Errorf("calling to ContractClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContractCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contract.
func (c *ContractClient) Update() *ContractUpdate {
	mutation := newContractMutation(c.config, OpUpdate)
	return &ContractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContractClient) UpdateOne(co *Contract) *ContractUpdateOne {
	mutation := newContractMutation(c.config, OpUpdateOne, withContract(co))
	return &ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContractClient) UpdateOneID(id int64) *ContractUpdateOne {
	mutation := newContractMutation(c.config, OpUpdateOne, withContractID(id))
	return &ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contract.
func (c *ContractClient) Delete() *ContractDelete {
	mutation := newContractMutation(c.config, OpDelete)
	return &ContractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContractClient) DeleteOne(co *Contract) *ContractDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContractClient) DeleteOneID(id int64) *ContractDeleteOne {
	builder := c.Delete().Where(contract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContractDeleteOne{builder}
}

// Query returns a query builder for Contract.
func (c *ContractClient) Query() *ContractQuery {
	return &ContractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContract},
		inters: c.Interceptors(),
	}
}

// Get returns a Contract entity by its id.
func (c *ContractClient) Get(ctx context.Context, id int64) (*Contract, error) {
	return c.Query().Where(contract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContractClient) GetX(ctx context.Context, id int64) *Contract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ContractClient) Hooks() []Hook {
	return c.hooks.Contract
}

// Interceptors returns the client interceptors.
func (c *ContractClient) Interceptors() []Interceptor {
	return c.inters.Contract
}

func (c *ContractClient) mutate(ctx context.Context, m *ContractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Contract mutation op: %q", m.Op())
	}
}

// DictionaryClient is a client for the Dictionary schema.
type DictionaryClient struct {
	config
}

// NewDictionaryClient returns a client for the Dictionary from the given config.
func NewDictionaryClient(c config) *DictionaryClient {
	return &DictionaryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionary.Hooks(f(g(h())))`.
func (c *DictionaryClient) Use(hooks ...Hook) {
	c.hooks.Dictionary = append(c.hooks.Dictionary, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionary.Intercept(f(g(h())))`.
func (c *DictionaryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dictionary = append(c.inters.Dictionary, interceptors...)
}

// Create returns a builder for creating a Dictionary entity.
func (c *DictionaryClient) Create() *DictionaryCreate {
	mutation := newDictionaryMutation(c.config, OpCreate)
	return &DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dictionary entities.
func (c *DictionaryClient) CreateBulk(builders ...*DictionaryCreate) *DictionaryCreateBulk {
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryClient) MapCreateBulk(slice any, setFunc func(*DictionaryCreate, int)) *DictionaryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryCreateBulk{err: fmt.Errorf("calling to DictionaryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dictionary.
func (c *DictionaryClient) Update() *DictionaryUpdate {
	mutation := newDictionaryMutation(c.config, OpUpdate)
	return &DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryClient) UpdateOne(d *Dictionary) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionary(d))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryClient) UpdateOneID(id int64) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionaryID(id))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dictionary.
func (c *DictionaryClient) Delete() *DictionaryDelete {
	mutation := newDictionaryMutation(c.config, OpDelete)
	return &DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryClient) DeleteOne(d *Dictionary) *DictionaryDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryClient) DeleteOneID(id int64) *DictionaryDeleteOne {
	builder := c.Delete().Where(dictionary.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryDeleteOne{builder}
}

// Query returns a query builder for Dictionary.
func (c *DictionaryClient) Query() *DictionaryQuery {
	return &DictionaryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionary},
		inters: c.Interceptors(),
	}
}

// Get returns a Dictionary entity by its id.
func (c *DictionaryClient) Get(ctx context.Context, id int64) (*Dictionary, error) {
	return c.Query().Where(dictionary.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryClient) GetX(ctx context.Context, id int64) *Dictionary {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDictionaryDetails queries the dictionary_details edge of a Dictionary.
func (c *DictionaryClient) QueryDictionaryDetails(d *Dictionary) *DictionaryDetailQuery {
	query := (&DictionaryDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionary.Table, dictionary.FieldID, id),
			sqlgraph.To(dictionarydetail.Table, dictionarydetail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dictionary.DictionaryDetailsTable, dictionary.DictionaryDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryClient) Hooks() []Hook {
	return c.hooks.Dictionary
}

// Interceptors returns the client interceptors.
func (c *DictionaryClient) Interceptors() []Interceptor {
	return c.inters.Dictionary
}

func (c *DictionaryClient) mutate(ctx context.Context, m *DictionaryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dictionary mutation op: %q", m.Op())
	}
}

// DictionaryDetailClient is a client for the DictionaryDetail schema.
type DictionaryDetailClient struct {
	config
}

// NewDictionaryDetailClient returns a client for the DictionaryDetail from the given config.
func NewDictionaryDetailClient(c config) *DictionaryDetailClient {
	return &DictionaryDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionarydetail.Hooks(f(g(h())))`.
func (c *DictionaryDetailClient) Use(hooks ...Hook) {
	c.hooks.DictionaryDetail = append(c.hooks.DictionaryDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionarydetail.Intercept(f(g(h())))`.
func (c *DictionaryDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.DictionaryDetail = append(c.inters.DictionaryDetail, interceptors...)
}

// Create returns a builder for creating a DictionaryDetail entity.
func (c *DictionaryDetailClient) Create() *DictionaryDetailCreate {
	mutation := newDictionaryDetailMutation(c.config, OpCreate)
	return &DictionaryDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DictionaryDetail entities.
func (c *DictionaryDetailClient) CreateBulk(builders ...*DictionaryDetailCreate) *DictionaryDetailCreateBulk {
	return &DictionaryDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryDetailClient) MapCreateBulk(slice any, setFunc func(*DictionaryDetailCreate, int)) *DictionaryDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryDetailCreateBulk{err: fmt.Errorf("calling to DictionaryDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DictionaryDetail.
func (c *DictionaryDetailClient) Update() *DictionaryDetailUpdate {
	mutation := newDictionaryDetailMutation(c.config, OpUpdate)
	return &DictionaryDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryDetailClient) UpdateOne(dd *DictionaryDetail) *DictionaryDetailUpdateOne {
	mutation := newDictionaryDetailMutation(c.config, OpUpdateOne, withDictionaryDetail(dd))
	return &DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryDetailClient) UpdateOneID(id int64) *DictionaryDetailUpdateOne {
	mutation := newDictionaryDetailMutation(c.config, OpUpdateOne, withDictionaryDetailID(id))
	return &DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DictionaryDetail.
func (c *DictionaryDetailClient) Delete() *DictionaryDetailDelete {
	mutation := newDictionaryDetailMutation(c.config, OpDelete)
	return &DictionaryDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryDetailClient) DeleteOne(dd *DictionaryDetail) *DictionaryDetailDeleteOne {
	return c.DeleteOneID(dd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryDetailClient) DeleteOneID(id int64) *DictionaryDetailDeleteOne {
	builder := c.Delete().Where(dictionarydetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryDetailDeleteOne{builder}
}

// Query returns a query builder for DictionaryDetail.
func (c *DictionaryDetailClient) Query() *DictionaryDetailQuery {
	return &DictionaryDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionaryDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a DictionaryDetail entity by its id.
func (c *DictionaryDetailClient) Get(ctx context.Context, id int64) (*DictionaryDetail, error) {
	return c.Query().Where(dictionarydetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryDetailClient) GetX(ctx context.Context, id int64) *DictionaryDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDictionary queries the dictionary edge of a DictionaryDetail.
func (c *DictionaryDetailClient) QueryDictionary(dd *DictionaryDetail) *DictionaryQuery {
	query := (&DictionaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionarydetail.Table, dictionarydetail.FieldID, id),
			sqlgraph.To(dictionary.Table, dictionary.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dictionarydetail.DictionaryTable, dictionarydetail.DictionaryColumn),
		)
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a DictionaryDetail.
func (c *DictionaryDetailClient) QueryUsers(dd *DictionaryDetail) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionarydetail.Table, dictionarydetail.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, dictionarydetail.UsersTable, dictionarydetail.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryDetailClient) Hooks() []Hook {
	return c.hooks.DictionaryDetail
}

// Interceptors returns the client interceptors.
func (c *DictionaryDetailClient) Interceptors() []Interceptor {
	return c.inters.DictionaryDetail
}

func (c *DictionaryDetailClient) mutate(ctx context.Context, m *DictionaryDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DictionaryDetail mutation op: %q", m.Op())
	}
}

// EntryLogsClient is a client for the EntryLogs schema.
type EntryLogsClient struct {
	config
}

// NewEntryLogsClient returns a client for the EntryLogs from the given config.
func NewEntryLogsClient(c config) *EntryLogsClient {
	return &EntryLogsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entrylogs.Hooks(f(g(h())))`.
func (c *EntryLogsClient) Use(hooks ...Hook) {
	c.hooks.EntryLogs = append(c.hooks.EntryLogs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entrylogs.Intercept(f(g(h())))`.
func (c *EntryLogsClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntryLogs = append(c.inters.EntryLogs, interceptors...)
}

// Create returns a builder for creating a EntryLogs entity.
func (c *EntryLogsClient) Create() *EntryLogsCreate {
	mutation := newEntryLogsMutation(c.config, OpCreate)
	return &EntryLogsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntryLogs entities.
func (c *EntryLogsClient) CreateBulk(builders ...*EntryLogsCreate) *EntryLogsCreateBulk {
	return &EntryLogsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntryLogsClient) MapCreateBulk(slice any, setFunc func(*EntryLogsCreate, int)) *EntryLogsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntryLogsCreateBulk{err: fmt.Errorf("calling to EntryLogsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntryLogsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntryLogsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntryLogs.
func (c *EntryLogsClient) Update() *EntryLogsUpdate {
	mutation := newEntryLogsMutation(c.config, OpUpdate)
	return &EntryLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntryLogsClient) UpdateOne(el *EntryLogs) *EntryLogsUpdateOne {
	mutation := newEntryLogsMutation(c.config, OpUpdateOne, withEntryLogs(el))
	return &EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntryLogsClient) UpdateOneID(id int64) *EntryLogsUpdateOne {
	mutation := newEntryLogsMutation(c.config, OpUpdateOne, withEntryLogsID(id))
	return &EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntryLogs.
func (c *EntryLogsClient) Delete() *EntryLogsDelete {
	mutation := newEntryLogsMutation(c.config, OpDelete)
	return &EntryLogsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntryLogsClient) DeleteOne(el *EntryLogs) *EntryLogsDeleteOne {
	return c.DeleteOneID(el.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntryLogsClient) DeleteOneID(id int64) *EntryLogsDeleteOne {
	builder := c.Delete().Where(entrylogs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntryLogsDeleteOne{builder}
}

// Query returns a query builder for EntryLogs.
func (c *EntryLogsClient) Query() *EntryLogsQuery {
	return &EntryLogsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntryLogs},
		inters: c.Interceptors(),
	}
}

// Get returns a EntryLogs entity by its id.
func (c *EntryLogsClient) Get(ctx context.Context, id int64) (*EntryLogs, error) {
	return c.Query().Where(entrylogs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntryLogsClient) GetX(ctx context.Context, id int64) *EntryLogs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVenues queries the venues edge of a EntryLogs.
func (c *EntryLogsClient) QueryVenues(el *EntryLogs) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := el.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entrylogs.Table, entrylogs.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entrylogs.VenuesTable, entrylogs.VenuesColumn),
		)
		fromV = sqlgraph.Neighbors(el.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a EntryLogs.
func (c *EntryLogsClient) QueryMembers(el *EntryLogs) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := el.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entrylogs.Table, entrylogs.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entrylogs.MembersTable, entrylogs.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(el.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a EntryLogs.
func (c *EntryLogsClient) QueryUsers(el *EntryLogs) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := el.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entrylogs.Table, entrylogs.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entrylogs.UsersTable, entrylogs.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(el.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntryLogsClient) Hooks() []Hook {
	return c.hooks.EntryLogs
}

// Interceptors returns the client interceptors.
func (c *EntryLogsClient) Interceptors() []Interceptor {
	return c.inters.EntryLogs
}

func (c *EntryLogsClient) mutate(ctx context.Context, m *EntryLogsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntryLogsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntryLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntryLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntryLogsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EntryLogs mutation op: %q", m.Op())
	}
}

// LogsClient is a client for the Logs schema.
type LogsClient struct {
	config
}

// NewLogsClient returns a client for the Logs from the given config.
func NewLogsClient(c config) *LogsClient {
	return &LogsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logs.Hooks(f(g(h())))`.
func (c *LogsClient) Use(hooks ...Hook) {
	c.hooks.Logs = append(c.hooks.Logs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logs.Intercept(f(g(h())))`.
func (c *LogsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Logs = append(c.inters.Logs, interceptors...)
}

// Create returns a builder for creating a Logs entity.
func (c *LogsClient) Create() *LogsCreate {
	mutation := newLogsMutation(c.config, OpCreate)
	return &LogsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Logs entities.
func (c *LogsClient) CreateBulk(builders ...*LogsCreate) *LogsCreateBulk {
	return &LogsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LogsClient) MapCreateBulk(slice any, setFunc func(*LogsCreate, int)) *LogsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LogsCreateBulk{err: fmt.Errorf("calling to LogsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LogsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LogsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Logs.
func (c *LogsClient) Update() *LogsUpdate {
	mutation := newLogsMutation(c.config, OpUpdate)
	return &LogsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogsClient) UpdateOne(l *Logs) *LogsUpdateOne {
	mutation := newLogsMutation(c.config, OpUpdateOne, withLogs(l))
	return &LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogsClient) UpdateOneID(id int64) *LogsUpdateOne {
	mutation := newLogsMutation(c.config, OpUpdateOne, withLogsID(id))
	return &LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Logs.
func (c *LogsClient) Delete() *LogsDelete {
	mutation := newLogsMutation(c.config, OpDelete)
	return &LogsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LogsClient) DeleteOne(l *Logs) *LogsDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LogsClient) DeleteOneID(id int64) *LogsDeleteOne {
	builder := c.Delete().Where(logs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogsDeleteOne{builder}
}

// Query returns a query builder for Logs.
func (c *LogsClient) Query() *LogsQuery {
	return &LogsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogs},
		inters: c.Interceptors(),
	}
}

// Get returns a Logs entity by its id.
func (c *LogsClient) Get(ctx context.Context, id int64) (*Logs, error) {
	return c.Query().Where(logs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogsClient) GetX(ctx context.Context, id int64) *Logs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LogsClient) Hooks() []Hook {
	return c.hooks.Logs
}

// Interceptors returns the client interceptors.
func (c *LogsClient) Interceptors() []Interceptor {
	return c.inters.Logs
}

func (c *LogsClient) mutate(ctx context.Context, m *LogsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LogsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LogsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LogsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Logs mutation op: %q", m.Op())
	}
}

// MemberClient is a client for the Member schema.
type MemberClient struct {
	config
}

// NewMemberClient returns a client for the Member from the given config.
func NewMemberClient(c config) *MemberClient {
	return &MemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `member.Hooks(f(g(h())))`.
func (c *MemberClient) Use(hooks ...Hook) {
	c.hooks.Member = append(c.hooks.Member, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `member.Intercept(f(g(h())))`.
func (c *MemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.Member = append(c.inters.Member, interceptors...)
}

// Create returns a builder for creating a Member entity.
func (c *MemberClient) Create() *MemberCreate {
	mutation := newMemberMutation(c.config, OpCreate)
	return &MemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Member entities.
func (c *MemberClient) CreateBulk(builders ...*MemberCreate) *MemberCreateBulk {
	return &MemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberClient) MapCreateBulk(slice any, setFunc func(*MemberCreate, int)) *MemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberCreateBulk{err: fmt.Errorf("calling to MemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Member.
func (c *MemberClient) Update() *MemberUpdate {
	mutation := newMemberMutation(c.config, OpUpdate)
	return &MemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberClient) UpdateOne(m *Member) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMember(m))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberClient) UpdateOneID(id int64) *MemberUpdateOne {
	mutation := newMemberMutation(c.config, OpUpdateOne, withMemberID(id))
	return &MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Member.
func (c *MemberClient) Delete() *MemberDelete {
	mutation := newMemberMutation(c.config, OpDelete)
	return &MemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberClient) DeleteOne(m *Member) *MemberDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberClient) DeleteOneID(id int64) *MemberDeleteOne {
	builder := c.Delete().Where(member.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberDeleteOne{builder}
}

// Query returns a query builder for Member.
func (c *MemberClient) Query() *MemberQuery {
	return &MemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMember},
		inters: c.Interceptors(),
	}
}

// Get returns a Member entity by its id.
func (c *MemberClient) Get(ctx context.Context, id int64) (*Member, error) {
	return c.Query().Where(member.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberClient) GetX(ctx context.Context, id int64) *Member {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemberDetails queries the member_details edge of a Member.
func (c *MemberClient) QueryMemberDetails(m *Member) *MemberDetailsQuery {
	query := (&MemberDetailsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(memberdetails.Table, memberdetails.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberDetailsTable, member.MemberDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberNotes queries the member_notes edge of a Member.
func (c *MemberClient) QueryMemberNotes(m *Member) *MemberNoteQuery {
	query := (&MemberNoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(membernote.Table, membernote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberNotesTable, member.MemberNotesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberOrders queries the member_orders edge of a Member.
func (c *MemberClient) QueryMemberOrders(m *Member) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberOrdersTable, member.MemberOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberEntry queries the member_entry edge of a Member.
func (c *MemberClient) QueryMemberEntry(m *Member) *EntryLogsQuery {
	query := (&EntryLogsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(entrylogs.Table, entrylogs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberEntryTable, member.MemberEntryColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemberContents queries the member_contents edge of a Member.
func (c *MemberClient) QueryMemberContents(m *Member) *MemberContractQuery {
	query := (&MemberContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(member.Table, member.FieldID, id),
			sqlgraph.To(membercontract.Table, membercontract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, member.MemberContentsTable, member.MemberContentsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberClient) Hooks() []Hook {
	return c.hooks.Member
}

// Interceptors returns the client interceptors.
func (c *MemberClient) Interceptors() []Interceptor {
	return c.inters.Member
}

func (c *MemberClient) mutate(ctx context.Context, m *MemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Member mutation op: %q", m.Op())
	}
}

// MemberContractClient is a client for the MemberContract schema.
type MemberContractClient struct {
	config
}

// NewMemberContractClient returns a client for the MemberContract from the given config.
func NewMemberContractClient(c config) *MemberContractClient {
	return &MemberContractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membercontract.Hooks(f(g(h())))`.
func (c *MemberContractClient) Use(hooks ...Hook) {
	c.hooks.MemberContract = append(c.hooks.MemberContract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membercontract.Intercept(f(g(h())))`.
func (c *MemberContractClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberContract = append(c.inters.MemberContract, interceptors...)
}

// Create returns a builder for creating a MemberContract entity.
func (c *MemberContractClient) Create() *MemberContractCreate {
	mutation := newMemberContractMutation(c.config, OpCreate)
	return &MemberContractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberContract entities.
func (c *MemberContractClient) CreateBulk(builders ...*MemberContractCreate) *MemberContractCreateBulk {
	return &MemberContractCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberContractClient) MapCreateBulk(slice any, setFunc func(*MemberContractCreate, int)) *MemberContractCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberContractCreateBulk{err: fmt.Errorf("calling to MemberContractClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberContractCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberContractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberContract.
func (c *MemberContractClient) Update() *MemberContractUpdate {
	mutation := newMemberContractMutation(c.config, OpUpdate)
	return &MemberContractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberContractClient) UpdateOne(mc *MemberContract) *MemberContractUpdateOne {
	mutation := newMemberContractMutation(c.config, OpUpdateOne, withMemberContract(mc))
	return &MemberContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberContractClient) UpdateOneID(id int64) *MemberContractUpdateOne {
	mutation := newMemberContractMutation(c.config, OpUpdateOne, withMemberContractID(id))
	return &MemberContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberContract.
func (c *MemberContractClient) Delete() *MemberContractDelete {
	mutation := newMemberContractMutation(c.config, OpDelete)
	return &MemberContractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberContractClient) DeleteOne(mc *MemberContract) *MemberContractDeleteOne {
	return c.DeleteOneID(mc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberContractClient) DeleteOneID(id int64) *MemberContractDeleteOne {
	builder := c.Delete().Where(membercontract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberContractDeleteOne{builder}
}

// Query returns a query builder for MemberContract.
func (c *MemberContractClient) Query() *MemberContractQuery {
	return &MemberContractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberContract},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberContract entity by its id.
func (c *MemberContractClient) Get(ctx context.Context, id int64) (*MemberContract, error) {
	return c.Query().Where(membercontract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberContractClient) GetX(ctx context.Context, id int64) *MemberContract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContent queries the content edge of a MemberContract.
func (c *MemberContractClient) QueryContent(mc *MemberContract) *MemberContractContentQuery {
	query := (&MemberContractContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontract.Table, membercontract.FieldID, id),
			sqlgraph.To(membercontractcontent.Table, membercontractcontent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, membercontract.ContentTable, membercontract.ContentColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMember queries the member edge of a MemberContract.
func (c *MemberContractClient) QueryMember(mc *MemberContract) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontract.Table, membercontract.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membercontract.MemberTable, membercontract.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrder queries the order edge of a MemberContract.
func (c *MemberContractClient) QueryOrder(mc *MemberContract) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontract.Table, membercontract.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membercontract.OrderTable, membercontract.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberContractClient) Hooks() []Hook {
	return c.hooks.MemberContract
}

// Interceptors returns the client interceptors.
func (c *MemberContractClient) Interceptors() []Interceptor {
	return c.inters.MemberContract
}

func (c *MemberContractClient) mutate(ctx context.Context, m *MemberContractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberContractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberContractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberContractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberContract mutation op: %q", m.Op())
	}
}

// MemberContractContentClient is a client for the MemberContractContent schema.
type MemberContractContentClient struct {
	config
}

// NewMemberContractContentClient returns a client for the MemberContractContent from the given config.
func NewMemberContractContentClient(c config) *MemberContractContentClient {
	return &MemberContractContentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membercontractcontent.Hooks(f(g(h())))`.
func (c *MemberContractContentClient) Use(hooks ...Hook) {
	c.hooks.MemberContractContent = append(c.hooks.MemberContractContent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membercontractcontent.Intercept(f(g(h())))`.
func (c *MemberContractContentClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberContractContent = append(c.inters.MemberContractContent, interceptors...)
}

// Create returns a builder for creating a MemberContractContent entity.
func (c *MemberContractContentClient) Create() *MemberContractContentCreate {
	mutation := newMemberContractContentMutation(c.config, OpCreate)
	return &MemberContractContentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberContractContent entities.
func (c *MemberContractContentClient) CreateBulk(builders ...*MemberContractContentCreate) *MemberContractContentCreateBulk {
	return &MemberContractContentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberContractContentClient) MapCreateBulk(slice any, setFunc func(*MemberContractContentCreate, int)) *MemberContractContentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberContractContentCreateBulk{err: fmt.Errorf("calling to MemberContractContentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberContractContentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberContractContentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberContractContent.
func (c *MemberContractContentClient) Update() *MemberContractContentUpdate {
	mutation := newMemberContractContentMutation(c.config, OpUpdate)
	return &MemberContractContentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberContractContentClient) UpdateOne(mcc *MemberContractContent) *MemberContractContentUpdateOne {
	mutation := newMemberContractContentMutation(c.config, OpUpdateOne, withMemberContractContent(mcc))
	return &MemberContractContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberContractContentClient) UpdateOneID(id int64) *MemberContractContentUpdateOne {
	mutation := newMemberContractContentMutation(c.config, OpUpdateOne, withMemberContractContentID(id))
	return &MemberContractContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberContractContent.
func (c *MemberContractContentClient) Delete() *MemberContractContentDelete {
	mutation := newMemberContractContentMutation(c.config, OpDelete)
	return &MemberContractContentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberContractContentClient) DeleteOne(mcc *MemberContractContent) *MemberContractContentDeleteOne {
	return c.DeleteOneID(mcc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberContractContentClient) DeleteOneID(id int64) *MemberContractContentDeleteOne {
	builder := c.Delete().Where(membercontractcontent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberContractContentDeleteOne{builder}
}

// Query returns a query builder for MemberContractContent.
func (c *MemberContractContentClient) Query() *MemberContractContentQuery {
	return &MemberContractContentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberContractContent},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberContractContent entity by its id.
func (c *MemberContractContentClient) Get(ctx context.Context, id int64) (*MemberContractContent, error) {
	return c.Query().Where(membercontractcontent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberContractContentClient) GetX(ctx context.Context, id int64) *MemberContractContent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContract queries the contract edge of a MemberContractContent.
func (c *MemberContractContentClient) QueryContract(mcc *MemberContractContent) *MemberContractQuery {
	query := (&MemberContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mcc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membercontractcontent.Table, membercontractcontent.FieldID, id),
			sqlgraph.To(membercontract.Table, membercontract.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membercontractcontent.ContractTable, membercontractcontent.ContractColumn),
		)
		fromV = sqlgraph.Neighbors(mcc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberContractContentClient) Hooks() []Hook {
	return c.hooks.MemberContractContent
}

// Interceptors returns the client interceptors.
func (c *MemberContractContentClient) Interceptors() []Interceptor {
	return c.inters.MemberContractContent
}

func (c *MemberContractContentClient) mutate(ctx context.Context, m *MemberContractContentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberContractContentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberContractContentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberContractContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberContractContentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberContractContent mutation op: %q", m.Op())
	}
}

// MemberDetailsClient is a client for the MemberDetails schema.
type MemberDetailsClient struct {
	config
}

// NewMemberDetailsClient returns a client for the MemberDetails from the given config.
func NewMemberDetailsClient(c config) *MemberDetailsClient {
	return &MemberDetailsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberdetails.Hooks(f(g(h())))`.
func (c *MemberDetailsClient) Use(hooks ...Hook) {
	c.hooks.MemberDetails = append(c.hooks.MemberDetails, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberdetails.Intercept(f(g(h())))`.
func (c *MemberDetailsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberDetails = append(c.inters.MemberDetails, interceptors...)
}

// Create returns a builder for creating a MemberDetails entity.
func (c *MemberDetailsClient) Create() *MemberDetailsCreate {
	mutation := newMemberDetailsMutation(c.config, OpCreate)
	return &MemberDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberDetails entities.
func (c *MemberDetailsClient) CreateBulk(builders ...*MemberDetailsCreate) *MemberDetailsCreateBulk {
	return &MemberDetailsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberDetailsClient) MapCreateBulk(slice any, setFunc func(*MemberDetailsCreate, int)) *MemberDetailsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberDetailsCreateBulk{err: fmt.Errorf("calling to MemberDetailsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberDetailsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberDetailsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberDetails.
func (c *MemberDetailsClient) Update() *MemberDetailsUpdate {
	mutation := newMemberDetailsMutation(c.config, OpUpdate)
	return &MemberDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberDetailsClient) UpdateOne(md *MemberDetails) *MemberDetailsUpdateOne {
	mutation := newMemberDetailsMutation(c.config, OpUpdateOne, withMemberDetails(md))
	return &MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberDetailsClient) UpdateOneID(id int64) *MemberDetailsUpdateOne {
	mutation := newMemberDetailsMutation(c.config, OpUpdateOne, withMemberDetailsID(id))
	return &MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberDetails.
func (c *MemberDetailsClient) Delete() *MemberDetailsDelete {
	mutation := newMemberDetailsMutation(c.config, OpDelete)
	return &MemberDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberDetailsClient) DeleteOne(md *MemberDetails) *MemberDetailsDeleteOne {
	return c.DeleteOneID(md.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberDetailsClient) DeleteOneID(id int64) *MemberDetailsDeleteOne {
	builder := c.Delete().Where(memberdetails.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberDetailsDeleteOne{builder}
}

// Query returns a query builder for MemberDetails.
func (c *MemberDetailsClient) Query() *MemberDetailsQuery {
	return &MemberDetailsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberDetails},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberDetails entity by its id.
func (c *MemberDetailsClient) Get(ctx context.Context, id int64) (*MemberDetails, error) {
	return c.Query().Where(memberdetails.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberDetailsClient) GetX(ctx context.Context, id int64) *MemberDetails {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInfo queries the info edge of a MemberDetails.
func (c *MemberDetailsClient) QueryInfo(md *MemberDetails) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := md.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberdetails.Table, memberdetails.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberdetails.InfoTable, memberdetails.InfoColumn),
		)
		fromV = sqlgraph.Neighbors(md.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberDetailsClient) Hooks() []Hook {
	return c.hooks.MemberDetails
}

// Interceptors returns the client interceptors.
func (c *MemberDetailsClient) Interceptors() []Interceptor {
	return c.inters.MemberDetails
}

func (c *MemberDetailsClient) mutate(ctx context.Context, m *MemberDetailsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberDetails mutation op: %q", m.Op())
	}
}

// MemberNoteClient is a client for the MemberNote schema.
type MemberNoteClient struct {
	config
}

// NewMemberNoteClient returns a client for the MemberNote from the given config.
func NewMemberNoteClient(c config) *MemberNoteClient {
	return &MemberNoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `membernote.Hooks(f(g(h())))`.
func (c *MemberNoteClient) Use(hooks ...Hook) {
	c.hooks.MemberNote = append(c.hooks.MemberNote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `membernote.Intercept(f(g(h())))`.
func (c *MemberNoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberNote = append(c.inters.MemberNote, interceptors...)
}

// Create returns a builder for creating a MemberNote entity.
func (c *MemberNoteClient) Create() *MemberNoteCreate {
	mutation := newMemberNoteMutation(c.config, OpCreate)
	return &MemberNoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberNote entities.
func (c *MemberNoteClient) CreateBulk(builders ...*MemberNoteCreate) *MemberNoteCreateBulk {
	return &MemberNoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberNoteClient) MapCreateBulk(slice any, setFunc func(*MemberNoteCreate, int)) *MemberNoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberNoteCreateBulk{err: fmt.Errorf("calling to MemberNoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberNoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberNoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberNote.
func (c *MemberNoteClient) Update() *MemberNoteUpdate {
	mutation := newMemberNoteMutation(c.config, OpUpdate)
	return &MemberNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberNoteClient) UpdateOne(mn *MemberNote) *MemberNoteUpdateOne {
	mutation := newMemberNoteMutation(c.config, OpUpdateOne, withMemberNote(mn))
	return &MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberNoteClient) UpdateOneID(id int64) *MemberNoteUpdateOne {
	mutation := newMemberNoteMutation(c.config, OpUpdateOne, withMemberNoteID(id))
	return &MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberNote.
func (c *MemberNoteClient) Delete() *MemberNoteDelete {
	mutation := newMemberNoteMutation(c.config, OpDelete)
	return &MemberNoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberNoteClient) DeleteOne(mn *MemberNote) *MemberNoteDeleteOne {
	return c.DeleteOneID(mn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberNoteClient) DeleteOneID(id int64) *MemberNoteDeleteOne {
	builder := c.Delete().Where(membernote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberNoteDeleteOne{builder}
}

// Query returns a query builder for MemberNote.
func (c *MemberNoteClient) Query() *MemberNoteQuery {
	return &MemberNoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberNote},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberNote entity by its id.
func (c *MemberNoteClient) Get(ctx context.Context, id int64) (*MemberNote, error) {
	return c.Query().Where(membernote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberNoteClient) GetX(ctx context.Context, id int64) *MemberNote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNotes queries the notes edge of a MemberNote.
func (c *MemberNoteClient) QueryNotes(mn *MemberNote) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(membernote.Table, membernote.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, membernote.NotesTable, membernote.NotesColumn),
		)
		fromV = sqlgraph.Neighbors(mn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberNoteClient) Hooks() []Hook {
	return c.hooks.MemberNote
}

// Interceptors returns the client interceptors.
func (c *MemberNoteClient) Interceptors() []Interceptor {
	return c.inters.MemberNote
}

func (c *MemberNoteClient) mutate(ctx context.Context, m *MemberNoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberNoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberNoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberNote mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuClient) MapCreateBulk(slice any, setFunc func(*MenuCreate, int)) *MenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuCreateBulk{err: fmt.Errorf("calling to MenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id int64) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id int64) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id int64) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id int64) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Menu.
func (c *MenuClient) QueryRoles(m *Menu) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, menu.RolesTable, menu.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Menu.
func (c *MenuClient) QueryParent(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menu.ParentTable, menu.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Menu.
func (c *MenuClient) QueryChildren(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ChildrenTable, menu.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParams queries the params edge of a Menu.
func (c *MenuClient) QueryParams(m *Menu) *MenuParamQuery {
	query := (&MenuParamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menuparam.Table, menuparam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ParamsTable, menu.ParamsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// MenuParamClient is a client for the MenuParam schema.
type MenuParamClient struct {
	config
}

// NewMenuParamClient returns a client for the MenuParam from the given config.
func NewMenuParamClient(c config) *MenuParamClient {
	return &MenuParamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menuparam.Hooks(f(g(h())))`.
func (c *MenuParamClient) Use(hooks ...Hook) {
	c.hooks.MenuParam = append(c.hooks.MenuParam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menuparam.Intercept(f(g(h())))`.
func (c *MenuParamClient) Intercept(interceptors ...Interceptor) {
	c.inters.MenuParam = append(c.inters.MenuParam, interceptors...)
}

// Create returns a builder for creating a MenuParam entity.
func (c *MenuParamClient) Create() *MenuParamCreate {
	mutation := newMenuParamMutation(c.config, OpCreate)
	return &MenuParamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MenuParam entities.
func (c *MenuParamClient) CreateBulk(builders ...*MenuParamCreate) *MenuParamCreateBulk {
	return &MenuParamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuParamClient) MapCreateBulk(slice any, setFunc func(*MenuParamCreate, int)) *MenuParamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuParamCreateBulk{err: fmt.Errorf("calling to MenuParamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuParamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuParamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MenuParam.
func (c *MenuParamClient) Update() *MenuParamUpdate {
	mutation := newMenuParamMutation(c.config, OpUpdate)
	return &MenuParamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuParamClient) UpdateOne(mp *MenuParam) *MenuParamUpdateOne {
	mutation := newMenuParamMutation(c.config, OpUpdateOne, withMenuParam(mp))
	return &MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuParamClient) UpdateOneID(id int64) *MenuParamUpdateOne {
	mutation := newMenuParamMutation(c.config, OpUpdateOne, withMenuParamID(id))
	return &MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MenuParam.
func (c *MenuParamClient) Delete() *MenuParamDelete {
	mutation := newMenuParamMutation(c.config, OpDelete)
	return &MenuParamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuParamClient) DeleteOne(mp *MenuParam) *MenuParamDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuParamClient) DeleteOneID(id int64) *MenuParamDeleteOne {
	builder := c.Delete().Where(menuparam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuParamDeleteOne{builder}
}

// Query returns a query builder for MenuParam.
func (c *MenuParamClient) Query() *MenuParamQuery {
	return &MenuParamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenuParam},
		inters: c.Interceptors(),
	}
}

// Get returns a MenuParam entity by its id.
func (c *MenuParamClient) Get(ctx context.Context, id int64) (*MenuParam, error) {
	return c.Query().Where(menuparam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuParamClient) GetX(ctx context.Context, id int64) *MenuParam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenus queries the menus edge of a MenuParam.
func (c *MenuParamClient) QueryMenus(mp *MenuParam) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuparam.Table, menuparam.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menuparam.MenusTable, menuparam.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuParamClient) Hooks() []Hook {
	return c.hooks.MenuParam
}

// Interceptors returns the client interceptors.
func (c *MenuParamClient) Interceptors() []Interceptor {
	return c.inters.MenuParam
}

func (c *MenuParamClient) mutate(ctx context.Context, m *MenuParamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuParamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuParamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuParamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuParamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MenuParam mutation op: %q", m.Op())
	}
}

// MessagesClient is a client for the Messages schema.
type MessagesClient struct {
	config
}

// NewMessagesClient returns a client for the Messages from the given config.
func NewMessagesClient(c config) *MessagesClient {
	return &MessagesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messages.Hooks(f(g(h())))`.
func (c *MessagesClient) Use(hooks ...Hook) {
	c.hooks.Messages = append(c.hooks.Messages, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messages.Intercept(f(g(h())))`.
func (c *MessagesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Messages = append(c.inters.Messages, interceptors...)
}

// Create returns a builder for creating a Messages entity.
func (c *MessagesClient) Create() *MessagesCreate {
	mutation := newMessagesMutation(c.config, OpCreate)
	return &MessagesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Messages entities.
func (c *MessagesClient) CreateBulk(builders ...*MessagesCreate) *MessagesCreateBulk {
	return &MessagesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessagesClient) MapCreateBulk(slice any, setFunc func(*MessagesCreate, int)) *MessagesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessagesCreateBulk{err: fmt.Errorf("calling to MessagesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessagesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessagesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Messages.
func (c *MessagesClient) Update() *MessagesUpdate {
	mutation := newMessagesMutation(c.config, OpUpdate)
	return &MessagesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessagesClient) UpdateOne(m *Messages) *MessagesUpdateOne {
	mutation := newMessagesMutation(c.config, OpUpdateOne, withMessages(m))
	return &MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessagesClient) UpdateOneID(id int64) *MessagesUpdateOne {
	mutation := newMessagesMutation(c.config, OpUpdateOne, withMessagesID(id))
	return &MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Messages.
func (c *MessagesClient) Delete() *MessagesDelete {
	mutation := newMessagesMutation(c.config, OpDelete)
	return &MessagesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessagesClient) DeleteOne(m *Messages) *MessagesDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessagesClient) DeleteOneID(id int64) *MessagesDeleteOne {
	builder := c.Delete().Where(messages.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessagesDeleteOne{builder}
}

// Query returns a query builder for Messages.
func (c *MessagesClient) Query() *MessagesQuery {
	return &MessagesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessages},
		inters: c.Interceptors(),
	}
}

// Get returns a Messages entity by its id.
func (c *MessagesClient) Get(ctx context.Context, id int64) (*Messages, error) {
	return c.Query().Where(messages.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessagesClient) GetX(ctx context.Context, id int64) *Messages {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessagesClient) Hooks() []Hook {
	return c.hooks.Messages
}

// Interceptors returns the client interceptors.
func (c *MessagesClient) Interceptors() []Interceptor {
	return c.inters.Messages
}

func (c *MessagesClient) mutate(ctx context.Context, m *MessagesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessagesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessagesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessagesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Messages mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id int64) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id int64) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id int64) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id int64) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAmount queries the amount edge of a Order.
func (c *OrderClient) QueryAmount(o *Order) *OrderAmountQuery {
	query := (&OrderAmountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderamount.Table, orderamount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.AmountTable, order.AmountColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItem queries the item edge of a Order.
func (c *OrderClient) QueryItem(o *Order) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.ItemTable, order.ItemColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPay queries the pay edge of a Order.
func (c *OrderClient) QueryPay(o *Order) *OrderPayQuery {
	query := (&OrderPayClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderpay.Table, orderpay.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.PayTable, order.PayColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderContents queries the order_contents edge of a Order.
func (c *OrderClient) QueryOrderContents(o *Order) *MemberContractQuery {
	query := (&MemberContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(membercontract.Table, membercontract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.OrderContentsTable, order.OrderContentsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySales queries the sales edge of a Order.
func (c *OrderClient) QuerySales(o *Order) *OrderSalesQuery {
	query := (&OrderSalesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(ordersales.Table, ordersales.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.SalesTable, order.SalesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderVenues queries the order_venues edge of a Order.
func (c *OrderClient) QueryOrderVenues(o *Order) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.OrderVenuesTable, order.OrderVenuesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderMembers queries the order_members edge of a Order.
func (c *OrderClient) QueryOrderMembers(o *Order) *MemberQuery {
	query := (&MemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(member.Table, member.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.OrderMembersTable, order.OrderMembersColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderCreates queries the order_creates edge of a Order.
func (c *OrderClient) QueryOrderCreates(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.OrderCreatesTable, order.OrderCreatesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderAmountClient is a client for the OrderAmount schema.
type OrderAmountClient struct {
	config
}

// NewOrderAmountClient returns a client for the OrderAmount from the given config.
func NewOrderAmountClient(c config) *OrderAmountClient {
	return &OrderAmountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderamount.Hooks(f(g(h())))`.
func (c *OrderAmountClient) Use(hooks ...Hook) {
	c.hooks.OrderAmount = append(c.hooks.OrderAmount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderamount.Intercept(f(g(h())))`.
func (c *OrderAmountClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderAmount = append(c.inters.OrderAmount, interceptors...)
}

// Create returns a builder for creating a OrderAmount entity.
func (c *OrderAmountClient) Create() *OrderAmountCreate {
	mutation := newOrderAmountMutation(c.config, OpCreate)
	return &OrderAmountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderAmount entities.
func (c *OrderAmountClient) CreateBulk(builders ...*OrderAmountCreate) *OrderAmountCreateBulk {
	return &OrderAmountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderAmountClient) MapCreateBulk(slice any, setFunc func(*OrderAmountCreate, int)) *OrderAmountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderAmountCreateBulk{err: fmt.Errorf("calling to OrderAmountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderAmountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderAmountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderAmount.
func (c *OrderAmountClient) Update() *OrderAmountUpdate {
	mutation := newOrderAmountMutation(c.config, OpUpdate)
	return &OrderAmountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderAmountClient) UpdateOne(oa *OrderAmount) *OrderAmountUpdateOne {
	mutation := newOrderAmountMutation(c.config, OpUpdateOne, withOrderAmount(oa))
	return &OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderAmountClient) UpdateOneID(id int64) *OrderAmountUpdateOne {
	mutation := newOrderAmountMutation(c.config, OpUpdateOne, withOrderAmountID(id))
	return &OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderAmount.
func (c *OrderAmountClient) Delete() *OrderAmountDelete {
	mutation := newOrderAmountMutation(c.config, OpDelete)
	return &OrderAmountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderAmountClient) DeleteOne(oa *OrderAmount) *OrderAmountDeleteOne {
	return c.DeleteOneID(oa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderAmountClient) DeleteOneID(id int64) *OrderAmountDeleteOne {
	builder := c.Delete().Where(orderamount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderAmountDeleteOne{builder}
}

// Query returns a query builder for OrderAmount.
func (c *OrderAmountClient) Query() *OrderAmountQuery {
	return &OrderAmountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderAmount},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderAmount entity by its id.
func (c *OrderAmountClient) Get(ctx context.Context, id int64) (*OrderAmount, error) {
	return c.Query().Where(orderamount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderAmountClient) GetX(ctx context.Context, id int64) *OrderAmount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderAmount.
func (c *OrderAmountClient) QueryOrder(oa *OrderAmount) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderamount.Table, orderamount.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderamount.OrderTable, orderamount.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderAmountClient) Hooks() []Hook {
	return c.hooks.OrderAmount
}

// Interceptors returns the client interceptors.
func (c *OrderAmountClient) Interceptors() []Interceptor {
	return c.inters.OrderAmount
}

func (c *OrderAmountClient) mutate(ctx context.Context, m *OrderAmountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderAmountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderAmountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderAmountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderAmountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderAmount mutation op: %q", m.Op())
	}
}

// OrderItemClient is a client for the OrderItem schema.
type OrderItemClient struct {
	config
}

// NewOrderItemClient returns a client for the OrderItem from the given config.
func NewOrderItemClient(c config) *OrderItemClient {
	return &OrderItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderitem.Hooks(f(g(h())))`.
func (c *OrderItemClient) Use(hooks ...Hook) {
	c.hooks.OrderItem = append(c.hooks.OrderItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderitem.Intercept(f(g(h())))`.
func (c *OrderItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderItem = append(c.inters.OrderItem, interceptors...)
}

// Create returns a builder for creating a OrderItem entity.
func (c *OrderItemClient) Create() *OrderItemCreate {
	mutation := newOrderItemMutation(c.config, OpCreate)
	return &OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderItem entities.
func (c *OrderItemClient) CreateBulk(builders ...*OrderItemCreate) *OrderItemCreateBulk {
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderItemClient) MapCreateBulk(slice any, setFunc func(*OrderItemCreate, int)) *OrderItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderItemCreateBulk{err: fmt.Errorf("calling to OrderItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderItem.
func (c *OrderItemClient) Update() *OrderItemUpdate {
	mutation := newOrderItemMutation(c.config, OpUpdate)
	return &OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderItemClient) UpdateOne(oi *OrderItem) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItem(oi))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderItemClient) UpdateOneID(id int64) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItemID(id))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderItem.
func (c *OrderItemClient) Delete() *OrderItemDelete {
	mutation := newOrderItemMutation(c.config, OpDelete)
	return &OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderItemClient) DeleteOne(oi *OrderItem) *OrderItemDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderItemClient) DeleteOneID(id int64) *OrderItemDeleteOne {
	builder := c.Delete().Where(orderitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderItemDeleteOne{builder}
}

// Query returns a query builder for OrderItem.
func (c *OrderItemClient) Query() *OrderItemQuery {
	return &OrderItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderItem entity by its id.
func (c *OrderItemClient) Get(ctx context.Context, id int64) (*OrderItem, error) {
	return c.Query().Where(orderitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderItemClient) GetX(ctx context.Context, id int64) *OrderItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderItem.
func (c *OrderItemClient) QueryOrder(oi *OrderItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderitem.OrderTable, orderitem.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderItemClient) Hooks() []Hook {
	return c.hooks.OrderItem
}

// Interceptors returns the client interceptors.
func (c *OrderItemClient) Interceptors() []Interceptor {
	return c.inters.OrderItem
}

func (c *OrderItemClient) mutate(ctx context.Context, m *OrderItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderItem mutation op: %q", m.Op())
	}
}

// OrderPayClient is a client for the OrderPay schema.
type OrderPayClient struct {
	config
}

// NewOrderPayClient returns a client for the OrderPay from the given config.
func NewOrderPayClient(c config) *OrderPayClient {
	return &OrderPayClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderpay.Hooks(f(g(h())))`.
func (c *OrderPayClient) Use(hooks ...Hook) {
	c.hooks.OrderPay = append(c.hooks.OrderPay, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderpay.Intercept(f(g(h())))`.
func (c *OrderPayClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderPay = append(c.inters.OrderPay, interceptors...)
}

// Create returns a builder for creating a OrderPay entity.
func (c *OrderPayClient) Create() *OrderPayCreate {
	mutation := newOrderPayMutation(c.config, OpCreate)
	return &OrderPayCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderPay entities.
func (c *OrderPayClient) CreateBulk(builders ...*OrderPayCreate) *OrderPayCreateBulk {
	return &OrderPayCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderPayClient) MapCreateBulk(slice any, setFunc func(*OrderPayCreate, int)) *OrderPayCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderPayCreateBulk{err: fmt.Errorf("calling to OrderPayClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderPayCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderPayCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderPay.
func (c *OrderPayClient) Update() *OrderPayUpdate {
	mutation := newOrderPayMutation(c.config, OpUpdate)
	return &OrderPayUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderPayClient) UpdateOne(op *OrderPay) *OrderPayUpdateOne {
	mutation := newOrderPayMutation(c.config, OpUpdateOne, withOrderPay(op))
	return &OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderPayClient) UpdateOneID(id int64) *OrderPayUpdateOne {
	mutation := newOrderPayMutation(c.config, OpUpdateOne, withOrderPayID(id))
	return &OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderPay.
func (c *OrderPayClient) Delete() *OrderPayDelete {
	mutation := newOrderPayMutation(c.config, OpDelete)
	return &OrderPayDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderPayClient) DeleteOne(op *OrderPay) *OrderPayDeleteOne {
	return c.DeleteOneID(op.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderPayClient) DeleteOneID(id int64) *OrderPayDeleteOne {
	builder := c.Delete().Where(orderpay.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderPayDeleteOne{builder}
}

// Query returns a query builder for OrderPay.
func (c *OrderPayClient) Query() *OrderPayQuery {
	return &OrderPayQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderPay},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderPay entity by its id.
func (c *OrderPayClient) Get(ctx context.Context, id int64) (*OrderPay, error) {
	return c.Query().Where(orderpay.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderPayClient) GetX(ctx context.Context, id int64) *OrderPay {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderPay.
func (c *OrderPayClient) QueryOrder(op *OrderPay) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := op.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderpay.Table, orderpay.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderpay.OrderTable, orderpay.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(op.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderPayClient) Hooks() []Hook {
	return c.hooks.OrderPay
}

// Interceptors returns the client interceptors.
func (c *OrderPayClient) Interceptors() []Interceptor {
	return c.inters.OrderPay
}

func (c *OrderPayClient) mutate(ctx context.Context, m *OrderPayMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderPayCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderPayUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderPayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderPayDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderPay mutation op: %q", m.Op())
	}
}

// OrderSalesClient is a client for the OrderSales schema.
type OrderSalesClient struct {
	config
}

// NewOrderSalesClient returns a client for the OrderSales from the given config.
func NewOrderSalesClient(c config) *OrderSalesClient {
	return &OrderSalesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ordersales.Hooks(f(g(h())))`.
func (c *OrderSalesClient) Use(hooks ...Hook) {
	c.hooks.OrderSales = append(c.hooks.OrderSales, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ordersales.Intercept(f(g(h())))`.
func (c *OrderSalesClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderSales = append(c.inters.OrderSales, interceptors...)
}

// Create returns a builder for creating a OrderSales entity.
func (c *OrderSalesClient) Create() *OrderSalesCreate {
	mutation := newOrderSalesMutation(c.config, OpCreate)
	return &OrderSalesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderSales entities.
func (c *OrderSalesClient) CreateBulk(builders ...*OrderSalesCreate) *OrderSalesCreateBulk {
	return &OrderSalesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderSalesClient) MapCreateBulk(slice any, setFunc func(*OrderSalesCreate, int)) *OrderSalesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderSalesCreateBulk{err: fmt.Errorf("calling to OrderSalesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderSalesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderSalesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderSales.
func (c *OrderSalesClient) Update() *OrderSalesUpdate {
	mutation := newOrderSalesMutation(c.config, OpUpdate)
	return &OrderSalesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderSalesClient) UpdateOne(os *OrderSales) *OrderSalesUpdateOne {
	mutation := newOrderSalesMutation(c.config, OpUpdateOne, withOrderSales(os))
	return &OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderSalesClient) UpdateOneID(id int64) *OrderSalesUpdateOne {
	mutation := newOrderSalesMutation(c.config, OpUpdateOne, withOrderSalesID(id))
	return &OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderSales.
func (c *OrderSalesClient) Delete() *OrderSalesDelete {
	mutation := newOrderSalesMutation(c.config, OpDelete)
	return &OrderSalesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderSalesClient) DeleteOne(os *OrderSales) *OrderSalesDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderSalesClient) DeleteOneID(id int64) *OrderSalesDeleteOne {
	builder := c.Delete().Where(ordersales.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderSalesDeleteOne{builder}
}

// Query returns a query builder for OrderSales.
func (c *OrderSalesClient) Query() *OrderSalesQuery {
	return &OrderSalesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderSales},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderSales entity by its id.
func (c *OrderSalesClient) Get(ctx context.Context, id int64) (*OrderSales, error) {
	return c.Query().Where(ordersales.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderSalesClient) GetX(ctx context.Context, id int64) *OrderSales {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderSales.
func (c *OrderSalesClient) QueryOrder(os *OrderSales) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordersales.Table, ordersales.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ordersales.OrderTable, ordersales.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderSalesClient) Hooks() []Hook {
	return c.hooks.OrderSales
}

// Interceptors returns the client interceptors.
func (c *OrderSalesClient) Interceptors() []Interceptor {
	return c.inters.OrderSales
}

func (c *OrderSalesClient) mutate(ctx context.Context, m *OrderSalesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderSalesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderSalesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderSalesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderSalesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderSales mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int64) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id int64) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int64) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int64) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenus queries the menus edge of a Role.
func (c *RoleClient) QueryMenus(r *Role) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.MenusTable, role.MenusPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id int64) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id int64) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id int64) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id int64) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Token.
func (c *TokenClient) QueryOwner(t *Token) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, token.OwnerTable, token.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryToken queries the token edge of a User.
func (c *UserClient) QueryToken(u *User) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.TokenTable, user.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a User.
func (c *UserClient) QueryTags(u *User) *DictionaryDetailQuery {
	query := (&DictionaryDetailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(dictionarydetail.Table, dictionarydetail.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.TagsTable, user.TagsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedOrders queries the created_orders edge of a User.
func (c *UserClient) QueryCreatedOrders(u *User) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedOrdersTable, user.CreatedOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserEntry queries the user_entry edge of a User.
func (c *UserClient) QueryUserEntry(u *User) *EntryLogsQuery {
	query := (&EntryLogsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(entrylogs.Table, entrylogs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserEntryTable, user.UserEntryColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VenueClient is a client for the Venue schema.
type VenueClient struct {
	config
}

// NewVenueClient returns a client for the Venue from the given config.
func NewVenueClient(c config) *VenueClient {
	return &VenueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venue.Hooks(f(g(h())))`.
func (c *VenueClient) Use(hooks ...Hook) {
	c.hooks.Venue = append(c.hooks.Venue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venue.Intercept(f(g(h())))`.
func (c *VenueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Venue = append(c.inters.Venue, interceptors...)
}

// Create returns a builder for creating a Venue entity.
func (c *VenueClient) Create() *VenueCreate {
	mutation := newVenueMutation(c.config, OpCreate)
	return &VenueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Venue entities.
func (c *VenueClient) CreateBulk(builders ...*VenueCreate) *VenueCreateBulk {
	return &VenueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenueClient) MapCreateBulk(slice any, setFunc func(*VenueCreate, int)) *VenueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenueCreateBulk{err: fmt.Errorf("calling to VenueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Venue.
func (c *VenueClient) Update() *VenueUpdate {
	mutation := newVenueMutation(c.config, OpUpdate)
	return &VenueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenueClient) UpdateOne(v *Venue) *VenueUpdateOne {
	mutation := newVenueMutation(c.config, OpUpdateOne, withVenue(v))
	return &VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenueClient) UpdateOneID(id int64) *VenueUpdateOne {
	mutation := newVenueMutation(c.config, OpUpdateOne, withVenueID(id))
	return &VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Venue.
func (c *VenueClient) Delete() *VenueDelete {
	mutation := newVenueMutation(c.config, OpDelete)
	return &VenueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenueClient) DeleteOne(v *Venue) *VenueDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenueClient) DeleteOneID(id int64) *VenueDeleteOne {
	builder := c.Delete().Where(venue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenueDeleteOne{builder}
}

// Query returns a query builder for Venue.
func (c *VenueClient) Query() *VenueQuery {
	return &VenueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenue},
		inters: c.Interceptors(),
	}
}

// Get returns a Venue entity by its id.
func (c *VenueClient) Get(ctx context.Context, id int64) (*Venue, error) {
	return c.Query().Where(venue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenueClient) GetX(ctx context.Context, id int64) *Venue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlaces queries the places edge of a Venue.
func (c *VenueClient) QueryPlaces(v *Venue) *VenuePlaceQuery {
	query := (&VenuePlaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(venueplace.Table, venueplace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.PlacesTable, venue.PlacesColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVenueOrders queries the venue_orders edge of a Venue.
func (c *VenueClient) QueryVenueOrders(v *Venue) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.VenueOrdersTable, venue.VenueOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVenueEntry queries the venue_entry edge of a Venue.
func (c *VenueClient) QueryVenueEntry(v *Venue) *EntryLogsQuery {
	query := (&EntryLogsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venue.Table, venue.FieldID, id),
			sqlgraph.To(entrylogs.Table, entrylogs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, venue.VenueEntryTable, venue.VenueEntryColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenueClient) Hooks() []Hook {
	return c.hooks.Venue
}

// Interceptors returns the client interceptors.
func (c *VenueClient) Interceptors() []Interceptor {
	return c.inters.Venue
}

func (c *VenueClient) mutate(ctx context.Context, m *VenueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Venue mutation op: %q", m.Op())
	}
}

// VenuePlaceClient is a client for the VenuePlace schema.
type VenuePlaceClient struct {
	config
}

// NewVenuePlaceClient returns a client for the VenuePlace from the given config.
func NewVenuePlaceClient(c config) *VenuePlaceClient {
	return &VenuePlaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `venueplace.Hooks(f(g(h())))`.
func (c *VenuePlaceClient) Use(hooks ...Hook) {
	c.hooks.VenuePlace = append(c.hooks.VenuePlace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `venueplace.Intercept(f(g(h())))`.
func (c *VenuePlaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.VenuePlace = append(c.inters.VenuePlace, interceptors...)
}

// Create returns a builder for creating a VenuePlace entity.
func (c *VenuePlaceClient) Create() *VenuePlaceCreate {
	mutation := newVenuePlaceMutation(c.config, OpCreate)
	return &VenuePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VenuePlace entities.
func (c *VenuePlaceClient) CreateBulk(builders ...*VenuePlaceCreate) *VenuePlaceCreateBulk {
	return &VenuePlaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VenuePlaceClient) MapCreateBulk(slice any, setFunc func(*VenuePlaceCreate, int)) *VenuePlaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VenuePlaceCreateBulk{err: fmt.Errorf("calling to VenuePlaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VenuePlaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VenuePlaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VenuePlace.
func (c *VenuePlaceClient) Update() *VenuePlaceUpdate {
	mutation := newVenuePlaceMutation(c.config, OpUpdate)
	return &VenuePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VenuePlaceClient) UpdateOne(vp *VenuePlace) *VenuePlaceUpdateOne {
	mutation := newVenuePlaceMutation(c.config, OpUpdateOne, withVenuePlace(vp))
	return &VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VenuePlaceClient) UpdateOneID(id int64) *VenuePlaceUpdateOne {
	mutation := newVenuePlaceMutation(c.config, OpUpdateOne, withVenuePlaceID(id))
	return &VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VenuePlace.
func (c *VenuePlaceClient) Delete() *VenuePlaceDelete {
	mutation := newVenuePlaceMutation(c.config, OpDelete)
	return &VenuePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VenuePlaceClient) DeleteOne(vp *VenuePlace) *VenuePlaceDeleteOne {
	return c.DeleteOneID(vp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VenuePlaceClient) DeleteOneID(id int64) *VenuePlaceDeleteOne {
	builder := c.Delete().Where(venueplace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VenuePlaceDeleteOne{builder}
}

// Query returns a query builder for VenuePlace.
func (c *VenuePlaceClient) Query() *VenuePlaceQuery {
	return &VenuePlaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVenuePlace},
		inters: c.Interceptors(),
	}
}

// Get returns a VenuePlace entity by its id.
func (c *VenuePlaceClient) Get(ctx context.Context, id int64) (*VenuePlace, error) {
	return c.Query().Where(venueplace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VenuePlaceClient) GetX(ctx context.Context, id int64) *VenuePlace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVenue queries the venue edge of a VenuePlace.
func (c *VenuePlaceClient) QueryVenue(vp *VenuePlace) *VenueQuery {
	query := (&VenueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(venueplace.Table, venueplace.FieldID, id),
			sqlgraph.To(venue.Table, venue.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, venueplace.VenueTable, venueplace.VenueColumn),
		)
		fromV = sqlgraph.Neighbors(vp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VenuePlaceClient) Hooks() []Hook {
	return c.hooks.VenuePlace
}

// Interceptors returns the client interceptors.
func (c *VenuePlaceClient) Interceptors() []Interceptor {
	return c.inters.VenuePlace
}

func (c *VenuePlaceClient) mutate(ctx context.Context, m *VenuePlaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VenuePlaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VenuePlaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VenuePlaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VenuePlaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VenuePlace mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		API, Contest, ContestParticipant, Contract, Dictionary, DictionaryDetail,
		EntryLogs, Logs, Member, MemberContract, MemberContractContent, MemberDetails,
		MemberNote, Menu, MenuParam, Messages, Order, OrderAmount, OrderItem, OrderPay,
		OrderSales, Role, Token, User, Venue, VenuePlace []ent.Hook
	}
	inters struct {
		API, Contest, ContestParticipant, Contract, Dictionary, DictionaryDetail,
		EntryLogs, Logs, Member, MemberContract, MemberContractContent, MemberDetails,
		MemberNote, Menu, MenuParam, Messages, Order, OrderAmount, OrderItem, OrderPay,
		OrderSales, Role, Token, User, Venue, VenuePlace []ent.Interceptor
	}
)
