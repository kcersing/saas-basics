// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"saas/pkg/db/ent/api"
	"saas/pkg/db/ent/contract"
	"saas/pkg/db/ent/dictionary"
	"saas/pkg/db/ent/dictionarydetail"
	"saas/pkg/db/ent/entrylogs"
	"saas/pkg/db/ent/logs"
	"saas/pkg/db/ent/member"
	"saas/pkg/db/ent/membercontract"
	"saas/pkg/db/ent/membercontractcontent"
	"saas/pkg/db/ent/memberdetails"
	"saas/pkg/db/ent/membernote"
	"saas/pkg/db/ent/memberproduct"
	"saas/pkg/db/ent/memberproductproperty"
	"saas/pkg/db/ent/menu"
	"saas/pkg/db/ent/menuparam"
	"saas/pkg/db/ent/messages"
	"saas/pkg/db/ent/order"
	"saas/pkg/db/ent/orderamount"
	"saas/pkg/db/ent/orderitem"
	"saas/pkg/db/ent/orderpay"
	"saas/pkg/db/ent/ordersales"
	"saas/pkg/db/ent/predicate"
	"saas/pkg/db/ent/product"
	"saas/pkg/db/ent/productproperty"
	"saas/pkg/db/ent/role"
	"saas/pkg/db/ent/schedule"
	"saas/pkg/db/ent/schedulecoach"
	"saas/pkg/db/ent/schedulemember"
	"saas/pkg/db/ent/token"
	"saas/pkg/db/ent/user"
	"saas/pkg/db/ent/venue"
	"saas/pkg/db/ent/venueplace"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI                   = "API"
	TypeContract              = "Contract"
	TypeDictionary            = "Dictionary"
	TypeDictionaryDetail      = "DictionaryDetail"
	TypeEntryLogs             = "EntryLogs"
	TypeLogs                  = "Logs"
	TypeMember                = "Member"
	TypeMemberContract        = "MemberContract"
	TypeMemberContractContent = "MemberContractContent"
	TypeMemberDetails         = "MemberDetails"
	TypeMemberNote            = "MemberNote"
	TypeMemberProduct         = "MemberProduct"
	TypeMemberProductProperty = "MemberProductProperty"
	TypeMenu                  = "Menu"
	TypeMenuParam             = "MenuParam"
	TypeMessages              = "Messages"
	TypeOrder                 = "Order"
	TypeOrderAmount           = "OrderAmount"
	TypeOrderItem             = "OrderItem"
	TypeOrderPay              = "OrderPay"
	TypeOrderSales            = "OrderSales"
	TypeProduct               = "Product"
	TypeProductProperty       = "ProductProperty"
	TypeRole                  = "Role"
	TypeSchedule              = "Schedule"
	TypeScheduleCoach         = "ScheduleCoach"
	TypeScheduleMember        = "ScheduleMember"
	TypeToken                 = "Token"
	TypeUser                  = "User"
	TypeVenue                 = "Venue"
	TypeVenuePlace            = "VenuePlace"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_path         *string
	description   *string
	api_group     *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldPath:
		return m.Path()
	case api.FieldDescription:
		return m.Description()
	case api.FieldAPIGroup:
		return m.APIGroup()
	case api.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int64
	addstatus     *int64
	name          *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Contract, error)
	predicates    []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id int64) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contract entities.
func (m *ContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[contract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[contract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, contract.FieldStatus)
}

// SetName sets the "name" field.
func (m *ContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[contract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[contract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contract.FieldName)
}

// SetContent sets the "content" field.
func (m *ContractMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ContractMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ContractMutation) ClearContent() {
	m.content = nil
	m.clearedFields[contract.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ContractMutation) ContentCleared() bool {
	_, ok := m.clearedFields[contract.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ContractMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, contract.FieldContent)
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, contract.FieldName)
	}
	if m.content != nil {
		fields = append(fields, contract.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldStatus:
		return m.Status()
	case contract.FieldName:
		return m.Name()
	case contract.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldStatus:
		return m.OldStatus(ctx)
	case contract.FieldName:
		return m.OldName(ctx)
	case contract.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contract.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, contract.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldStatus) {
		fields = append(fields, contract.FieldStatus)
	}
	if m.FieldCleared(contract.FieldName) {
		fields = append(fields, contract.FieldName)
	}
	if m.FieldCleared(contract.FieldContent) {
		fields = append(fields, contract.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldStatus:
		m.ClearStatus()
		return nil
	case contract.FieldName:
		m.ClearName()
		return nil
	case contract.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldStatus:
		m.ResetStatus()
		return nil
	case contract.FieldName:
		m.ResetName()
		return nil
	case contract.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Contract edge %s", name)
}

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	created_at                *time.Time
	updated_at                *time.Time
	status                    *int64
	addstatus                 *int64
	title                     *string
	name                      *string
	description               *string
	clearedFields             map[string]struct{}
	dictionary_details        map[int64]struct{}
	removeddictionary_details map[int64]struct{}
	cleareddictionary_details bool
	done                      bool
	oldValue                  func(context.Context) (*Dictionary, error)
	predicates                []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id int64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DictionaryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictionaryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DictionaryMutation) ResetDescription() {
	m.description = nil
}

// AddDictionaryDetailIDs adds the "dictionary_details" edge to the DictionaryDetail entity by ids.
func (m *DictionaryMutation) AddDictionaryDetailIDs(ids ...int64) {
	if m.dictionary_details == nil {
		m.dictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.dictionary_details[ids[i]] = struct{}{}
	}
}

// ClearDictionaryDetails clears the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) ClearDictionaryDetails() {
	m.cleareddictionary_details = true
}

// DictionaryDetailsCleared reports if the "dictionary_details" edge to the DictionaryDetail entity was cleared.
func (m *DictionaryMutation) DictionaryDetailsCleared() bool {
	return m.cleareddictionary_details
}

// RemoveDictionaryDetailIDs removes the "dictionary_details" edge to the DictionaryDetail entity by IDs.
func (m *DictionaryMutation) RemoveDictionaryDetailIDs(ids ...int64) {
	if m.removeddictionary_details == nil {
		m.removeddictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.dictionary_details, ids[i])
		m.removeddictionary_details[ids[i]] = struct{}{}
	}
}

// RemovedDictionaryDetails returns the removed IDs of the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) RemovedDictionaryDetailsIDs() (ids []int64) {
	for id := range m.removeddictionary_details {
		ids = append(ids, id)
	}
	return
}

// DictionaryDetailsIDs returns the "dictionary_details" edge IDs in the mutation.
func (m *DictionaryMutation) DictionaryDetailsIDs() (ids []int64) {
	for id := range m.dictionary_details {
		ids = append(ids, id)
	}
	return
}

// ResetDictionaryDetails resets all changes to the "dictionary_details" edge.
func (m *DictionaryMutation) ResetDictionaryDetails() {
	m.dictionary_details = nil
	m.cleareddictionary_details = false
	m.removeddictionary_details = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionary.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dictionary.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldTitle:
		return m.Title()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldTitle:
		return m.OldTitle(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.dictionary_details))
		for id := range m.dictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.removeddictionary_details))
		for id := range m.removeddictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary_details {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		return m.cleareddictionary_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		m.ResetDictionaryDetails()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryDetailMutation represents an operation that mutates the DictionaryDetail nodes in the graph.
type DictionaryDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	status            *int64
	addstatus         *int64
	title             *string
	key               *string
	value             *string
	clearedFields     map[string]struct{}
	dictionary        *int64
	cleareddictionary bool
	done              bool
	oldValue          func(context.Context) (*DictionaryDetail, error)
	predicates        []predicate.DictionaryDetail
}

var _ ent.Mutation = (*DictionaryDetailMutation)(nil)

// dictionarydetailOption allows management of the mutation configuration using functional options.
type dictionarydetailOption func(*DictionaryDetailMutation)

// newDictionaryDetailMutation creates new mutation for the DictionaryDetail entity.
func newDictionaryDetailMutation(c config, op Op, opts ...dictionarydetailOption) *DictionaryDetailMutation {
	m := &DictionaryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryDetailID sets the ID field of the mutation.
func withDictionaryDetailID(id int64) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DictionaryDetail
		)
		m.oldValue = func(ctx context.Context) (*DictionaryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictionaryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionaryDetail sets the old DictionaryDetail of the mutation.
func withDictionaryDetail(node *DictionaryDetail) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		m.oldValue = func(context.Context) (*DictionaryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictionaryDetail entities.
func (m *DictionaryDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictionaryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryDetailMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryDetailMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryDetailMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryDetailMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryDetailMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionarydetail.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryDetailMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionarydetail.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetKey sets the "key" field.
func (m *DictionaryDetailMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DictionaryDetailMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DictionaryDetailMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DictionaryDetailMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryDetailMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryDetailMutation) ResetValue() {
	m.value = nil
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryDetailMutation) SetDictionaryID(i int64) {
	m.dictionary = &i
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryDetailMutation) DictionaryID() (r int64, exists bool) {
	v := m.dictionary
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDictionaryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ClearDictionaryID clears the value of the "dictionary_id" field.
func (m *DictionaryDetailMutation) ClearDictionaryID() {
	m.dictionary = nil
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryIDCleared returns if the "dictionary_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DictionaryIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDictionaryID]
	return ok
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryDetailMutation) ResetDictionaryID() {
	m.dictionary = nil
	delete(m.clearedFields, dictionarydetail.FieldDictionaryID)
}

// ClearDictionary clears the "dictionary" edge to the Dictionary entity.
func (m *DictionaryDetailMutation) ClearDictionary() {
	m.cleareddictionary = true
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryCleared reports if the "dictionary" edge to the Dictionary entity was cleared.
func (m *DictionaryDetailMutation) DictionaryCleared() bool {
	return m.DictionaryIDCleared() || m.cleareddictionary
}

// DictionaryIDs returns the "dictionary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionaryID instead. It exists only for internal usage by the builders.
func (m *DictionaryDetailMutation) DictionaryIDs() (ids []int64) {
	if id := m.dictionary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionary resets all changes to the "dictionary" edge.
func (m *DictionaryDetailMutation) ResetDictionary() {
	m.dictionary = nil
	m.cleareddictionary = false
}

// Where appends a list predicates to the DictionaryDetailMutation builder.
func (m *DictionaryDetailMutation) Where(ps ...predicate.DictionaryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictionaryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictionaryDetail).
func (m *DictionaryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryDetailMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionarydetail.FieldTitle)
	}
	if m.key != nil {
		fields = append(fields, dictionarydetail.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dictionarydetail.FieldValue)
	}
	if m.dictionary != nil {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case dictionarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionarydetail.FieldStatus:
		return m.Status()
	case dictionarydetail.FieldTitle:
		return m.Title()
	case dictionarydetail.FieldKey:
		return m.Key()
	case dictionarydetail.FieldValue:
		return m.Value()
	case dictionarydetail.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionarydetail.FieldStatus:
		return m.OldStatus(ctx)
	case dictionarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case dictionarydetail.FieldKey:
		return m.OldKey(ctx)
	case dictionarydetail.FieldValue:
		return m.OldValue(ctx)
	case dictionarydetail.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionarydetail.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dictionarydetail.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionarydetail.FieldDictionaryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryDetailMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionarydetail.FieldStatus) {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.FieldCleared(dictionarydetail.FieldDictionaryID) {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ClearField(name string) error {
	switch name {
	case dictionarydetail.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ClearDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ResetField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionarydetail.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionarydetail.FieldKey:
		m.ResetKey()
		return nil
	case dictionarydetail.FieldValue:
		m.ResetValue()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary != nil {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeDictionary:
		if id := m.dictionary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionarydetail.EdgeDictionary:
		return m.cleareddictionary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryDetailMutation) ClearEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ClearDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryDetailMutation) ResetEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ResetDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail edge %s", name)
}

// EntryLogsMutation represents an operation that mutates the EntryLogs nodes in the graph.
type EntryLogsMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	member_property_id     *int64
	addmember_property_id  *int64
	entry_time             *time.Time
	leaving_time           *time.Time
	clearedFields          map[string]struct{}
	venues                 *int64
	clearedvenues          bool
	members                *int64
	clearedmembers         bool
	users                  *int64
	clearedusers           bool
	member_products        *int64
	clearedmember_products bool
	done                   bool
	oldValue               func(context.Context) (*EntryLogs, error)
	predicates             []predicate.EntryLogs
}

var _ ent.Mutation = (*EntryLogsMutation)(nil)

// entrylogsOption allows management of the mutation configuration using functional options.
type entrylogsOption func(*EntryLogsMutation)

// newEntryLogsMutation creates new mutation for the EntryLogs entity.
func newEntryLogsMutation(c config, op Op, opts ...entrylogsOption) *EntryLogsMutation {
	m := &EntryLogsMutation{
		config:        c,
		op:            op,
		typ:           TypeEntryLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryLogsID sets the ID field of the mutation.
func withEntryLogsID(id int64) entrylogsOption {
	return func(m *EntryLogsMutation) {
		var (
			err   error
			once  sync.Once
			value *EntryLogs
		)
		m.oldValue = func(ctx context.Context) (*EntryLogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntryLogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntryLogs sets the old EntryLogs of the mutation.
func withEntryLogs(node *EntryLogs) entrylogsOption {
	return func(m *EntryLogsMutation) {
		m.oldValue = func(context.Context) (*EntryLogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryLogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryLogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntryLogs entities.
func (m *EntryLogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntryLogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntryLogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntryLogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntryLogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntryLogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntryLogsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntryLogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntryLogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntryLogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMemberID sets the "member_id" field.
func (m *EntryLogsMutation) SetMemberID(i int64) {
	m.members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *EntryLogsMutation) MemberID() (r int64, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *EntryLogsMutation) ClearMemberID() {
	m.members = nil
	m.clearedFields[entrylogs.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *EntryLogsMutation) ResetMemberID() {
	m.members = nil
	delete(m.clearedFields, entrylogs.FieldMemberID)
}

// SetUserID sets the "user_id" field.
func (m *EntryLogsMutation) SetUserID(i int64) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EntryLogsMutation) UserID() (r int64, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *EntryLogsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[entrylogs.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *EntryLogsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EntryLogsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, entrylogs.FieldUserID)
}

// SetVenueID sets the "venue_id" field.
func (m *EntryLogsMutation) SetVenueID(i int64) {
	m.venues = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *EntryLogsMutation) VenueID() (r int64, exists bool) {
	v := m.venues
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *EntryLogsMutation) ClearVenueID() {
	m.venues = nil
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *EntryLogsMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *EntryLogsMutation) ResetVenueID() {
	m.venues = nil
	delete(m.clearedFields, entrylogs.FieldVenueID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *EntryLogsMutation) SetMemberProductID(i int64) {
	m.member_products = &i
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *EntryLogsMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_products
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *EntryLogsMutation) ClearMemberProductID() {
	m.member_products = nil
	m.clearedFields[entrylogs.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *EntryLogsMutation) ResetMemberProductID() {
	m.member_products = nil
	delete(m.clearedFields, entrylogs.FieldMemberProductID)
}

// SetMemberPropertyID sets the "member_property_id" field.
func (m *EntryLogsMutation) SetMemberPropertyID(i int64) {
	m.member_property_id = &i
	m.addmember_property_id = nil
}

// MemberPropertyID returns the value of the "member_property_id" field in the mutation.
func (m *EntryLogsMutation) MemberPropertyID() (r int64, exists bool) {
	v := m.member_property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberPropertyID returns the old "member_property_id" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldMemberPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberPropertyID: %w", err)
	}
	return oldValue.MemberPropertyID, nil
}

// AddMemberPropertyID adds i to the "member_property_id" field.
func (m *EntryLogsMutation) AddMemberPropertyID(i int64) {
	if m.addmember_property_id != nil {
		*m.addmember_property_id += i
	} else {
		m.addmember_property_id = &i
	}
}

// AddedMemberPropertyID returns the value that was added to the "member_property_id" field in this mutation.
func (m *EntryLogsMutation) AddedMemberPropertyID() (r int64, exists bool) {
	v := m.addmember_property_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberPropertyID clears the value of the "member_property_id" field.
func (m *EntryLogsMutation) ClearMemberPropertyID() {
	m.member_property_id = nil
	m.addmember_property_id = nil
	m.clearedFields[entrylogs.FieldMemberPropertyID] = struct{}{}
}

// MemberPropertyIDCleared returns if the "member_property_id" field was cleared in this mutation.
func (m *EntryLogsMutation) MemberPropertyIDCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldMemberPropertyID]
	return ok
}

// ResetMemberPropertyID resets all changes to the "member_property_id" field.
func (m *EntryLogsMutation) ResetMemberPropertyID() {
	m.member_property_id = nil
	m.addmember_property_id = nil
	delete(m.clearedFields, entrylogs.FieldMemberPropertyID)
}

// SetEntryTime sets the "entry_time" field.
func (m *EntryLogsMutation) SetEntryTime(t time.Time) {
	m.entry_time = &t
}

// EntryTime returns the value of the "entry_time" field in the mutation.
func (m *EntryLogsMutation) EntryTime() (r time.Time, exists bool) {
	v := m.entry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryTime returns the old "entry_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldEntryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryTime: %w", err)
	}
	return oldValue.EntryTime, nil
}

// ClearEntryTime clears the value of the "entry_time" field.
func (m *EntryLogsMutation) ClearEntryTime() {
	m.entry_time = nil
	m.clearedFields[entrylogs.FieldEntryTime] = struct{}{}
}

// EntryTimeCleared returns if the "entry_time" field was cleared in this mutation.
func (m *EntryLogsMutation) EntryTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldEntryTime]
	return ok
}

// ResetEntryTime resets all changes to the "entry_time" field.
func (m *EntryLogsMutation) ResetEntryTime() {
	m.entry_time = nil
	delete(m.clearedFields, entrylogs.FieldEntryTime)
}

// SetLeavingTime sets the "leaving_time" field.
func (m *EntryLogsMutation) SetLeavingTime(t time.Time) {
	m.leaving_time = &t
}

// LeavingTime returns the value of the "leaving_time" field in the mutation.
func (m *EntryLogsMutation) LeavingTime() (r time.Time, exists bool) {
	v := m.leaving_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLeavingTime returns the old "leaving_time" field's value of the EntryLogs entity.
// If the EntryLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryLogsMutation) OldLeavingTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeavingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeavingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeavingTime: %w", err)
	}
	return oldValue.LeavingTime, nil
}

// ClearLeavingTime clears the value of the "leaving_time" field.
func (m *EntryLogsMutation) ClearLeavingTime() {
	m.leaving_time = nil
	m.clearedFields[entrylogs.FieldLeavingTime] = struct{}{}
}

// LeavingTimeCleared returns if the "leaving_time" field was cleared in this mutation.
func (m *EntryLogsMutation) LeavingTimeCleared() bool {
	_, ok := m.clearedFields[entrylogs.FieldLeavingTime]
	return ok
}

// ResetLeavingTime resets all changes to the "leaving_time" field.
func (m *EntryLogsMutation) ResetLeavingTime() {
	m.leaving_time = nil
	delete(m.clearedFields, entrylogs.FieldLeavingTime)
}

// SetVenuesID sets the "venues" edge to the Venue entity by id.
func (m *EntryLogsMutation) SetVenuesID(id int64) {
	m.venues = &id
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *EntryLogsMutation) ClearVenues() {
	m.clearedvenues = true
	m.clearedFields[entrylogs.FieldVenueID] = struct{}{}
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *EntryLogsMutation) VenuesCleared() bool {
	return m.VenueIDCleared() || m.clearedvenues
}

// VenuesID returns the "venues" edge ID in the mutation.
func (m *EntryLogsMutation) VenuesID() (id int64, exists bool) {
	if m.venues != nil {
		return *m.venues, true
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenuesID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) VenuesIDs() (ids []int64) {
	if id := m.venues; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *EntryLogsMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
}

// SetMembersID sets the "members" edge to the Member entity by id.
func (m *EntryLogsMutation) SetMembersID(id int64) {
	m.members = &id
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *EntryLogsMutation) ClearMembers() {
	m.clearedmembers = true
	m.clearedFields[entrylogs.FieldMemberID] = struct{}{}
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *EntryLogsMutation) MembersCleared() bool {
	return m.MemberIDCleared() || m.clearedmembers
}

// MembersID returns the "members" edge ID in the mutation.
func (m *EntryLogsMutation) MembersID() (id int64, exists bool) {
	if m.members != nil {
		return *m.members, true
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MembersID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) MembersIDs() (ids []int64) {
	if id := m.members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *EntryLogsMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *EntryLogsMutation) SetUsersID(id int64) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *EntryLogsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[entrylogs.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *EntryLogsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *EntryLogsMutation) UsersID() (id int64, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) UsersIDs() (ids []int64) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *EntryLogsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetMemberProductsID sets the "member_products" edge to the MemberProduct entity by id.
func (m *EntryLogsMutation) SetMemberProductsID(id int64) {
	m.member_products = &id
}

// ClearMemberProducts clears the "member_products" edge to the MemberProduct entity.
func (m *EntryLogsMutation) ClearMemberProducts() {
	m.clearedmember_products = true
	m.clearedFields[entrylogs.FieldMemberProductID] = struct{}{}
}

// MemberProductsCleared reports if the "member_products" edge to the MemberProduct entity was cleared.
func (m *EntryLogsMutation) MemberProductsCleared() bool {
	return m.MemberProductIDCleared() || m.clearedmember_products
}

// MemberProductsID returns the "member_products" edge ID in the mutation.
func (m *EntryLogsMutation) MemberProductsID() (id int64, exists bool) {
	if m.member_products != nil {
		return *m.member_products, true
	}
	return
}

// MemberProductsIDs returns the "member_products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberProductsID instead. It exists only for internal usage by the builders.
func (m *EntryLogsMutation) MemberProductsIDs() (ids []int64) {
	if id := m.member_products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemberProducts resets all changes to the "member_products" edge.
func (m *EntryLogsMutation) ResetMemberProducts() {
	m.member_products = nil
	m.clearedmember_products = false
}

// Where appends a list predicates to the EntryLogsMutation builder.
func (m *EntryLogsMutation) Where(ps ...predicate.EntryLogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntryLogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntryLogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntryLogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntryLogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntryLogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntryLogs).
func (m *EntryLogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryLogsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, entrylogs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entrylogs.FieldUpdatedAt)
	}
	if m.members != nil {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.users != nil {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.venues != nil {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.member_products != nil {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.member_property_id != nil {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	if m.entry_time != nil {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.leaving_time != nil {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryLogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.CreatedAt()
	case entrylogs.FieldUpdatedAt:
		return m.UpdatedAt()
	case entrylogs.FieldMemberID:
		return m.MemberID()
	case entrylogs.FieldUserID:
		return m.UserID()
	case entrylogs.FieldVenueID:
		return m.VenueID()
	case entrylogs.FieldMemberProductID:
		return m.MemberProductID()
	case entrylogs.FieldMemberPropertyID:
		return m.MemberPropertyID()
	case entrylogs.FieldEntryTime:
		return m.EntryTime()
	case entrylogs.FieldLeavingTime:
		return m.LeavingTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryLogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entrylogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entrylogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entrylogs.FieldMemberID:
		return m.OldMemberID(ctx)
	case entrylogs.FieldUserID:
		return m.OldUserID(ctx)
	case entrylogs.FieldVenueID:
		return m.OldVenueID(ctx)
	case entrylogs.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case entrylogs.FieldMemberPropertyID:
		return m.OldMemberPropertyID(ctx)
	case entrylogs.FieldEntryTime:
		return m.OldEntryTime(ctx)
	case entrylogs.FieldLeavingTime:
		return m.OldLeavingTime(ctx)
	}
	return nil, fmt.Errorf("unknown EntryLogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entrylogs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entrylogs.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case entrylogs.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case entrylogs.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case entrylogs.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case entrylogs.FieldMemberPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberPropertyID(v)
		return nil
	case entrylogs.FieldEntryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryTime(v)
		return nil
	case entrylogs.FieldLeavingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeavingTime(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryLogsMutation) AddedFields() []string {
	var fields []string
	if m.addmember_property_id != nil {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryLogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entrylogs.FieldMemberPropertyID:
		return m.AddedMemberPropertyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryLogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entrylogs.FieldMemberPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberPropertyID(v)
		return nil
	}
	return fmt.Errorf("unknown EntryLogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryLogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entrylogs.FieldMemberID) {
		fields = append(fields, entrylogs.FieldMemberID)
	}
	if m.FieldCleared(entrylogs.FieldUserID) {
		fields = append(fields, entrylogs.FieldUserID)
	}
	if m.FieldCleared(entrylogs.FieldVenueID) {
		fields = append(fields, entrylogs.FieldVenueID)
	}
	if m.FieldCleared(entrylogs.FieldMemberProductID) {
		fields = append(fields, entrylogs.FieldMemberProductID)
	}
	if m.FieldCleared(entrylogs.FieldMemberPropertyID) {
		fields = append(fields, entrylogs.FieldMemberPropertyID)
	}
	if m.FieldCleared(entrylogs.FieldEntryTime) {
		fields = append(fields, entrylogs.FieldEntryTime)
	}
	if m.FieldCleared(entrylogs.FieldLeavingTime) {
		fields = append(fields, entrylogs.FieldLeavingTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryLogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryLogsMutation) ClearField(name string) error {
	switch name {
	case entrylogs.FieldMemberID:
		m.ClearMemberID()
		return nil
	case entrylogs.FieldUserID:
		m.ClearUserID()
		return nil
	case entrylogs.FieldVenueID:
		m.ClearVenueID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case entrylogs.FieldMemberPropertyID:
		m.ClearMemberPropertyID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ClearEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ClearLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryLogsMutation) ResetField(name string) error {
	switch name {
	case entrylogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entrylogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entrylogs.FieldMemberID:
		m.ResetMemberID()
		return nil
	case entrylogs.FieldUserID:
		m.ResetUserID()
		return nil
	case entrylogs.FieldVenueID:
		m.ResetVenueID()
		return nil
	case entrylogs.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case entrylogs.FieldMemberPropertyID:
		m.ResetMemberPropertyID()
		return nil
	case entrylogs.FieldEntryTime:
		m.ResetEntryTime()
		return nil
	case entrylogs.FieldLeavingTime:
		m.ResetLeavingTime()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryLogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.venues != nil {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	if m.members != nil {
		edges = append(edges, entrylogs.EdgeMembers)
	}
	if m.users != nil {
		edges = append(edges, entrylogs.EdgeUsers)
	}
	if m.member_products != nil {
		edges = append(edges, entrylogs.EdgeMemberProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryLogsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entrylogs.EdgeVenues:
		if id := m.venues; id != nil {
			return []ent.Value{*id}
		}
	case entrylogs.EdgeMembers:
		if id := m.members; id != nil {
			return []ent.Value{*id}
		}
	case entrylogs.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case entrylogs.EdgeMemberProducts:
		if id := m.member_products; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryLogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryLogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryLogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedvenues {
		edges = append(edges, entrylogs.EdgeVenues)
	}
	if m.clearedmembers {
		edges = append(edges, entrylogs.EdgeMembers)
	}
	if m.clearedusers {
		edges = append(edges, entrylogs.EdgeUsers)
	}
	if m.clearedmember_products {
		edges = append(edges, entrylogs.EdgeMemberProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryLogsMutation) EdgeCleared(name string) bool {
	switch name {
	case entrylogs.EdgeVenues:
		return m.clearedvenues
	case entrylogs.EdgeMembers:
		return m.clearedmembers
	case entrylogs.EdgeUsers:
		return m.clearedusers
	case entrylogs.EdgeMemberProducts:
		return m.clearedmember_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryLogsMutation) ClearEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ClearVenues()
		return nil
	case entrylogs.EdgeMembers:
		m.ClearMembers()
		return nil
	case entrylogs.EdgeUsers:
		m.ClearUsers()
		return nil
	case entrylogs.EdgeMemberProducts:
		m.ClearMemberProducts()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryLogsMutation) ResetEdge(name string) error {
	switch name {
	case entrylogs.EdgeVenues:
		m.ResetVenues()
		return nil
	case entrylogs.EdgeMembers:
		m.ResetMembers()
		return nil
	case entrylogs.EdgeUsers:
		m.ResetUsers()
		return nil
	case entrylogs.EdgeMemberProducts:
		m.ResetMemberProducts()
		return nil
	}
	return fmt.Errorf("unknown EntryLogs edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	method        *string
	api           *string
	success       *bool
	req_content   *string
	resp_content  *string
	ip            *string
	user_agent    *string
	operator      *string
	time          *int
	addtime       *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int64) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *LogsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LogsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LogsMutation) ResetType() {
	m._type = nil
}

// SetMethod sets the "method" field.
func (m *LogsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *LogsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *LogsMutation) ResetMethod() {
	m.method = nil
}

// SetAPI sets the "api" field.
func (m *LogsMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *LogsMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *LogsMutation) ResetAPI() {
	m.api = nil
}

// SetSuccess sets the "success" field.
func (m *LogsMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LogsMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LogsMutation) ResetSuccess() {
	m.success = nil
}

// SetReqContent sets the "req_content" field.
func (m *LogsMutation) SetReqContent(s string) {
	m.req_content = &s
}

// ReqContent returns the value of the "req_content" field in the mutation.
func (m *LogsMutation) ReqContent() (r string, exists bool) {
	v := m.req_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReqContent returns the old "req_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldReqContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqContent: %w", err)
	}
	return oldValue.ReqContent, nil
}

// ClearReqContent clears the value of the "req_content" field.
func (m *LogsMutation) ClearReqContent() {
	m.req_content = nil
	m.clearedFields[logs.FieldReqContent] = struct{}{}
}

// ReqContentCleared returns if the "req_content" field was cleared in this mutation.
func (m *LogsMutation) ReqContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldReqContent]
	return ok
}

// ResetReqContent resets all changes to the "req_content" field.
func (m *LogsMutation) ResetReqContent() {
	m.req_content = nil
	delete(m.clearedFields, logs.FieldReqContent)
}

// SetRespContent sets the "resp_content" field.
func (m *LogsMutation) SetRespContent(s string) {
	m.resp_content = &s
}

// RespContent returns the value of the "resp_content" field in the mutation.
func (m *LogsMutation) RespContent() (r string, exists bool) {
	v := m.resp_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRespContent returns the old "resp_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRespContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespContent: %w", err)
	}
	return oldValue.RespContent, nil
}

// ClearRespContent clears the value of the "resp_content" field.
func (m *LogsMutation) ClearRespContent() {
	m.resp_content = nil
	m.clearedFields[logs.FieldRespContent] = struct{}{}
}

// RespContentCleared returns if the "resp_content" field was cleared in this mutation.
func (m *LogsMutation) RespContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldRespContent]
	return ok
}

// ResetRespContent resets all changes to the "resp_content" field.
func (m *LogsMutation) ResetRespContent() {
	m.resp_content = nil
	delete(m.clearedFields, logs.FieldRespContent)
}

// SetIP sets the "ip" field.
func (m *LogsMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *LogsMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[logs.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *LogsMutation) IPCleared() bool {
	_, ok := m.clearedFields[logs.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *LogsMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, logs.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LogsMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LogsMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LogsMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[logs.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LogsMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LogsMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, logs.FieldUserAgent)
}

// SetOperator sets the "operator" field.
func (m *LogsMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the value of the "operator" field in the mutation.
func (m *LogsMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldOperator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ClearOperator clears the value of the "operator" field.
func (m *LogsMutation) ClearOperator() {
	m.operator = nil
	m.clearedFields[logs.FieldOperator] = struct{}{}
}

// OperatorCleared returns if the "operator" field was cleared in this mutation.
func (m *LogsMutation) OperatorCleared() bool {
	_, ok := m.clearedFields[logs.FieldOperator]
	return ok
}

// ResetOperator resets all changes to the "operator" field.
func (m *LogsMutation) ResetOperator() {
	m.operator = nil
	delete(m.clearedFields, logs.FieldOperator)
}

// SetTime sets the "time" field.
func (m *LogsMutation) SetTime(i int) {
	m.time = &i
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *LogsMutation) Time() (r int, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to the "time" field.
func (m *LogsMutation) AddTime(i int) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *LogsMutation) AddedTime() (r int, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *LogsMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[logs.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *LogsMutation) TimeCleared() bool {
	_, ok := m.clearedFields[logs.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *LogsMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, logs.FieldTime)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, logs.FieldType)
	}
	if m.method != nil {
		fields = append(fields, logs.FieldMethod)
	}
	if m.api != nil {
		fields = append(fields, logs.FieldAPI)
	}
	if m.success != nil {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.req_content != nil {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.resp_content != nil {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.ip != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.operator != nil {
		fields = append(fields, logs.FieldOperator)
	}
	if m.time != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldType:
		return m.GetType()
	case logs.FieldMethod:
		return m.Method()
	case logs.FieldAPI:
		return m.API()
	case logs.FieldSuccess:
		return m.Success()
	case logs.FieldReqContent:
		return m.ReqContent()
	case logs.FieldRespContent:
		return m.RespContent()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldUserAgent:
		return m.UserAgent()
	case logs.FieldOperator:
		return m.Operator()
	case logs.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldType:
		return m.OldType(ctx)
	case logs.FieldMethod:
		return m.OldMethod(ctx)
	case logs.FieldAPI:
		return m.OldAPI(ctx)
	case logs.FieldSuccess:
		return m.OldSuccess(ctx)
	case logs.FieldReqContent:
		return m.OldReqContent(ctx)
	case logs.FieldRespContent:
		return m.OldRespContent(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case logs.FieldOperator:
		return m.OldOperator(ctx)
	case logs.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case logs.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case logs.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case logs.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case logs.FieldReqContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqContent(v)
		return nil
	case logs.FieldRespContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespContent(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case logs.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.addtime != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldReqContent) {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.FieldCleared(logs.FieldRespContent) {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.FieldCleared(logs.FieldIP) {
		fields = append(fields, logs.FieldIP)
	}
	if m.FieldCleared(logs.FieldUserAgent) {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.FieldCleared(logs.FieldOperator) {
		fields = append(fields, logs.FieldOperator)
	}
	if m.FieldCleared(logs.FieldTime) {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldReqContent:
		m.ClearReqContent()
		return nil
	case logs.FieldRespContent:
		m.ClearRespContent()
		return nil
	case logs.FieldIP:
		m.ClearIP()
		return nil
	case logs.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case logs.FieldOperator:
		m.ClearOperator()
		return nil
	case logs.FieldTime:
		m.ClearTime()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldType:
		m.ResetType()
		return nil
	case logs.FieldMethod:
		m.ResetMethod()
		return nil
	case logs.FieldAPI:
		m.ResetAPI()
		return nil
	case logs.FieldSuccess:
		m.ResetSuccess()
		return nil
	case logs.FieldReqContent:
		m.ResetReqContent()
		return nil
	case logs.FieldRespContent:
		m.ResetRespContent()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case logs.FieldOperator:
		m.ResetOperator()
		return nil
	case logs.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	status                 *int64
	addstatus              *int64
	password               *string
	name                   *string
	mobile                 *string
	email                  *string
	wecom                  *string
	avatar                 *string
	condition              *int64
	addcondition           *int64
	create_id              *int64
	addcreate_id           *int64
	clearedFields          map[string]struct{}
	member_details         map[int64]struct{}
	removedmember_details  map[int64]struct{}
	clearedmember_details  bool
	member_notes           map[int64]struct{}
	removedmember_notes    map[int64]struct{}
	clearedmember_notes    bool
	member_orders          map[int64]struct{}
	removedmember_orders   map[int64]struct{}
	clearedmember_orders   bool
	member_products        map[int64]struct{}
	removedmember_products map[int64]struct{}
	clearedmember_products bool
	member_entry           map[int64]struct{}
	removedmember_entry    map[int64]struct{}
	clearedmember_entry    bool
	member_contents        map[int64]struct{}
	removedmember_contents map[int64]struct{}
	clearedmember_contents bool
	done                   bool
	oldValue               func(context.Context) (*Member, error)
	predicates             []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int64) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[member.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[member.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, member.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *MemberMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[member.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *MemberMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[member.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, member.FieldPassword)
}

// SetName sets the "name" field.
func (m *MemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberMutation) ClearName() {
	m.name = nil
	m.clearedFields[member.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberMutation) NameCleared() bool {
	_, ok := m.clearedFields[member.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, member.FieldName)
}

// SetMobile sets the "mobile" field.
func (m *MemberMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *MemberMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *MemberMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[member.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *MemberMutation) MobileCleared() bool {
	_, ok := m.clearedFields[member.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *MemberMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, member.FieldMobile)
}

// SetEmail sets the "email" field.
func (m *MemberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MemberMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[member.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MemberMutation) EmailCleared() bool {
	_, ok := m.clearedFields[member.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, member.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *MemberMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *MemberMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *MemberMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[member.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *MemberMutation) WecomCleared() bool {
	_, ok := m.clearedFields[member.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *MemberMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, member.FieldWecom)
}

// SetAvatar sets the "avatar" field.
func (m *MemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *MemberMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[member.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *MemberMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[member.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, member.FieldAvatar)
}

// SetCondition sets the "condition" field.
func (m *MemberMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *MemberMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *MemberMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *MemberMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *MemberMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[member.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *MemberMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[member.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *MemberMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, member.FieldCondition)
}

// SetCreateID sets the "create_id" field.
func (m *MemberMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *MemberMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *MemberMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *MemberMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *MemberMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[member.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *MemberMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[member.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *MemberMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, member.FieldCreateID)
}

// AddMemberDetailIDs adds the "member_details" edge to the MemberDetails entity by ids.
func (m *MemberMutation) AddMemberDetailIDs(ids ...int64) {
	if m.member_details == nil {
		m.member_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_details[ids[i]] = struct{}{}
	}
}

// ClearMemberDetails clears the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) ClearMemberDetails() {
	m.clearedmember_details = true
}

// MemberDetailsCleared reports if the "member_details" edge to the MemberDetails entity was cleared.
func (m *MemberMutation) MemberDetailsCleared() bool {
	return m.clearedmember_details
}

// RemoveMemberDetailIDs removes the "member_details" edge to the MemberDetails entity by IDs.
func (m *MemberMutation) RemoveMemberDetailIDs(ids ...int64) {
	if m.removedmember_details == nil {
		m.removedmember_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_details, ids[i])
		m.removedmember_details[ids[i]] = struct{}{}
	}
}

// RemovedMemberDetails returns the removed IDs of the "member_details" edge to the MemberDetails entity.
func (m *MemberMutation) RemovedMemberDetailsIDs() (ids []int64) {
	for id := range m.removedmember_details {
		ids = append(ids, id)
	}
	return
}

// MemberDetailsIDs returns the "member_details" edge IDs in the mutation.
func (m *MemberMutation) MemberDetailsIDs() (ids []int64) {
	for id := range m.member_details {
		ids = append(ids, id)
	}
	return
}

// ResetMemberDetails resets all changes to the "member_details" edge.
func (m *MemberMutation) ResetMemberDetails() {
	m.member_details = nil
	m.clearedmember_details = false
	m.removedmember_details = nil
}

// AddMemberNoteIDs adds the "member_notes" edge to the MemberNote entity by ids.
func (m *MemberMutation) AddMemberNoteIDs(ids ...int64) {
	if m.member_notes == nil {
		m.member_notes = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_notes[ids[i]] = struct{}{}
	}
}

// ClearMemberNotes clears the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) ClearMemberNotes() {
	m.clearedmember_notes = true
}

// MemberNotesCleared reports if the "member_notes" edge to the MemberNote entity was cleared.
func (m *MemberMutation) MemberNotesCleared() bool {
	return m.clearedmember_notes
}

// RemoveMemberNoteIDs removes the "member_notes" edge to the MemberNote entity by IDs.
func (m *MemberMutation) RemoveMemberNoteIDs(ids ...int64) {
	if m.removedmember_notes == nil {
		m.removedmember_notes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_notes, ids[i])
		m.removedmember_notes[ids[i]] = struct{}{}
	}
}

// RemovedMemberNotes returns the removed IDs of the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) RemovedMemberNotesIDs() (ids []int64) {
	for id := range m.removedmember_notes {
		ids = append(ids, id)
	}
	return
}

// MemberNotesIDs returns the "member_notes" edge IDs in the mutation.
func (m *MemberMutation) MemberNotesIDs() (ids []int64) {
	for id := range m.member_notes {
		ids = append(ids, id)
	}
	return
}

// ResetMemberNotes resets all changes to the "member_notes" edge.
func (m *MemberMutation) ResetMemberNotes() {
	m.member_notes = nil
	m.clearedmember_notes = false
	m.removedmember_notes = nil
}

// AddMemberOrderIDs adds the "member_orders" edge to the Order entity by ids.
func (m *MemberMutation) AddMemberOrderIDs(ids ...int64) {
	if m.member_orders == nil {
		m.member_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_orders[ids[i]] = struct{}{}
	}
}

// ClearMemberOrders clears the "member_orders" edge to the Order entity.
func (m *MemberMutation) ClearMemberOrders() {
	m.clearedmember_orders = true
}

// MemberOrdersCleared reports if the "member_orders" edge to the Order entity was cleared.
func (m *MemberMutation) MemberOrdersCleared() bool {
	return m.clearedmember_orders
}

// RemoveMemberOrderIDs removes the "member_orders" edge to the Order entity by IDs.
func (m *MemberMutation) RemoveMemberOrderIDs(ids ...int64) {
	if m.removedmember_orders == nil {
		m.removedmember_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_orders, ids[i])
		m.removedmember_orders[ids[i]] = struct{}{}
	}
}

// RemovedMemberOrders returns the removed IDs of the "member_orders" edge to the Order entity.
func (m *MemberMutation) RemovedMemberOrdersIDs() (ids []int64) {
	for id := range m.removedmember_orders {
		ids = append(ids, id)
	}
	return
}

// MemberOrdersIDs returns the "member_orders" edge IDs in the mutation.
func (m *MemberMutation) MemberOrdersIDs() (ids []int64) {
	for id := range m.member_orders {
		ids = append(ids, id)
	}
	return
}

// ResetMemberOrders resets all changes to the "member_orders" edge.
func (m *MemberMutation) ResetMemberOrders() {
	m.member_orders = nil
	m.clearedmember_orders = false
	m.removedmember_orders = nil
}

// AddMemberProductIDs adds the "member_products" edge to the MemberProduct entity by ids.
func (m *MemberMutation) AddMemberProductIDs(ids ...int64) {
	if m.member_products == nil {
		m.member_products = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_products[ids[i]] = struct{}{}
	}
}

// ClearMemberProducts clears the "member_products" edge to the MemberProduct entity.
func (m *MemberMutation) ClearMemberProducts() {
	m.clearedmember_products = true
}

// MemberProductsCleared reports if the "member_products" edge to the MemberProduct entity was cleared.
func (m *MemberMutation) MemberProductsCleared() bool {
	return m.clearedmember_products
}

// RemoveMemberProductIDs removes the "member_products" edge to the MemberProduct entity by IDs.
func (m *MemberMutation) RemoveMemberProductIDs(ids ...int64) {
	if m.removedmember_products == nil {
		m.removedmember_products = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_products, ids[i])
		m.removedmember_products[ids[i]] = struct{}{}
	}
}

// RemovedMemberProducts returns the removed IDs of the "member_products" edge to the MemberProduct entity.
func (m *MemberMutation) RemovedMemberProductsIDs() (ids []int64) {
	for id := range m.removedmember_products {
		ids = append(ids, id)
	}
	return
}

// MemberProductsIDs returns the "member_products" edge IDs in the mutation.
func (m *MemberMutation) MemberProductsIDs() (ids []int64) {
	for id := range m.member_products {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProducts resets all changes to the "member_products" edge.
func (m *MemberMutation) ResetMemberProducts() {
	m.member_products = nil
	m.clearedmember_products = false
	m.removedmember_products = nil
}

// AddMemberEntryIDs adds the "member_entry" edge to the EntryLogs entity by ids.
func (m *MemberMutation) AddMemberEntryIDs(ids ...int64) {
	if m.member_entry == nil {
		m.member_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_entry[ids[i]] = struct{}{}
	}
}

// ClearMemberEntry clears the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) ClearMemberEntry() {
	m.clearedmember_entry = true
}

// MemberEntryCleared reports if the "member_entry" edge to the EntryLogs entity was cleared.
func (m *MemberMutation) MemberEntryCleared() bool {
	return m.clearedmember_entry
}

// RemoveMemberEntryIDs removes the "member_entry" edge to the EntryLogs entity by IDs.
func (m *MemberMutation) RemoveMemberEntryIDs(ids ...int64) {
	if m.removedmember_entry == nil {
		m.removedmember_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_entry, ids[i])
		m.removedmember_entry[ids[i]] = struct{}{}
	}
}

// RemovedMemberEntry returns the removed IDs of the "member_entry" edge to the EntryLogs entity.
func (m *MemberMutation) RemovedMemberEntryIDs() (ids []int64) {
	for id := range m.removedmember_entry {
		ids = append(ids, id)
	}
	return
}

// MemberEntryIDs returns the "member_entry" edge IDs in the mutation.
func (m *MemberMutation) MemberEntryIDs() (ids []int64) {
	for id := range m.member_entry {
		ids = append(ids, id)
	}
	return
}

// ResetMemberEntry resets all changes to the "member_entry" edge.
func (m *MemberMutation) ResetMemberEntry() {
	m.member_entry = nil
	m.clearedmember_entry = false
	m.removedmember_entry = nil
}

// AddMemberContentIDs adds the "member_contents" edge to the MemberContract entity by ids.
func (m *MemberMutation) AddMemberContentIDs(ids ...int64) {
	if m.member_contents == nil {
		m.member_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_contents[ids[i]] = struct{}{}
	}
}

// ClearMemberContents clears the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) ClearMemberContents() {
	m.clearedmember_contents = true
}

// MemberContentsCleared reports if the "member_contents" edge to the MemberContract entity was cleared.
func (m *MemberMutation) MemberContentsCleared() bool {
	return m.clearedmember_contents
}

// RemoveMemberContentIDs removes the "member_contents" edge to the MemberContract entity by IDs.
func (m *MemberMutation) RemoveMemberContentIDs(ids ...int64) {
	if m.removedmember_contents == nil {
		m.removedmember_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_contents, ids[i])
		m.removedmember_contents[ids[i]] = struct{}{}
	}
}

// RemovedMemberContents returns the removed IDs of the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) RemovedMemberContentsIDs() (ids []int64) {
	for id := range m.removedmember_contents {
		ids = append(ids, id)
	}
	return
}

// MemberContentsIDs returns the "member_contents" edge IDs in the mutation.
func (m *MemberMutation) MemberContentsIDs() (ids []int64) {
	for id := range m.member_contents {
		ids = append(ids, id)
	}
	return
}

// ResetMemberContents resets all changes to the "member_contents" edge.
func (m *MemberMutation) ResetMemberContents() {
	m.member_contents = nil
	m.clearedmember_contents = false
	m.removedmember_contents = nil
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, member.FieldName)
	}
	if m.mobile != nil {
		fields = append(fields, member.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, member.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, member.FieldWecom)
	}
	if m.avatar != nil {
		fields = append(fields, member.FieldAvatar)
	}
	if m.condition != nil {
		fields = append(fields, member.FieldCondition)
	}
	if m.create_id != nil {
		fields = append(fields, member.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldStatus:
		return m.Status()
	case member.FieldPassword:
		return m.Password()
	case member.FieldName:
		return m.Name()
	case member.FieldMobile:
		return m.Mobile()
	case member.FieldEmail:
		return m.Email()
	case member.FieldWecom:
		return m.Wecom()
	case member.FieldAvatar:
		return m.Avatar()
	case member.FieldCondition:
		return m.Condition()
	case member.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldStatus:
		return m.OldStatus(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldName:
		return m.OldName(ctx)
	case member.FieldMobile:
		return m.OldMobile(ctx)
	case member.FieldEmail:
		return m.OldEmail(ctx)
	case member.FieldWecom:
		return m.OldWecom(ctx)
	case member.FieldAvatar:
		return m.OldAvatar(ctx)
	case member.FieldCondition:
		return m.OldCondition(ctx)
	case member.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case member.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case member.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case member.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case member.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case member.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.addcondition != nil {
		fields = append(fields, member.FieldCondition)
	}
	if m.addcreate_id != nil {
		fields = append(fields, member.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldStatus:
		return m.AddedStatus()
	case member.FieldCondition:
		return m.AddedCondition()
	case member.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	case member.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldStatus) {
		fields = append(fields, member.FieldStatus)
	}
	if m.FieldCleared(member.FieldPassword) {
		fields = append(fields, member.FieldPassword)
	}
	if m.FieldCleared(member.FieldName) {
		fields = append(fields, member.FieldName)
	}
	if m.FieldCleared(member.FieldMobile) {
		fields = append(fields, member.FieldMobile)
	}
	if m.FieldCleared(member.FieldEmail) {
		fields = append(fields, member.FieldEmail)
	}
	if m.FieldCleared(member.FieldWecom) {
		fields = append(fields, member.FieldWecom)
	}
	if m.FieldCleared(member.FieldAvatar) {
		fields = append(fields, member.FieldAvatar)
	}
	if m.FieldCleared(member.FieldCondition) {
		fields = append(fields, member.FieldCondition)
	}
	if m.FieldCleared(member.FieldCreateID) {
		fields = append(fields, member.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldStatus:
		m.ClearStatus()
		return nil
	case member.FieldPassword:
		m.ClearPassword()
		return nil
	case member.FieldName:
		m.ClearName()
		return nil
	case member.FieldMobile:
		m.ClearMobile()
		return nil
	case member.FieldEmail:
		m.ClearEmail()
		return nil
	case member.FieldWecom:
		m.ClearWecom()
		return nil
	case member.FieldAvatar:
		m.ClearAvatar()
		return nil
	case member.FieldCondition:
		m.ClearCondition()
		return nil
	case member.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldStatus:
		m.ResetStatus()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldName:
		m.ResetName()
		return nil
	case member.FieldMobile:
		m.ResetMobile()
		return nil
	case member.FieldEmail:
		m.ResetEmail()
		return nil
	case member.FieldWecom:
		m.ResetWecom()
		return nil
	case member.FieldAvatar:
		m.ResetAvatar()
		return nil
	case member.FieldCondition:
		m.ResetCondition()
		return nil
	case member.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.member_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.member_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.member_orders != nil {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.member_products != nil {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.member_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.member_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.member_details))
		for id := range m.member_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.member_notes))
		for id := range m.member_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberOrders:
		ids := make([]ent.Value, 0, len(m.member_orders))
		for id := range m.member_orders {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberProducts:
		ids := make([]ent.Value, 0, len(m.member_products))
		for id := range m.member_products {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.member_entry))
		for id := range m.member_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.member_contents))
		for id := range m.member_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmember_details != nil {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.removedmember_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.removedmember_orders != nil {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.removedmember_products != nil {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.removedmember_entry != nil {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.removedmember_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberDetails:
		ids := make([]ent.Value, 0, len(m.removedmember_details))
		for id := range m.removedmember_details {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.removedmember_notes))
		for id := range m.removedmember_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberOrders:
		ids := make([]ent.Value, 0, len(m.removedmember_orders))
		for id := range m.removedmember_orders {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberProducts:
		ids := make([]ent.Value, 0, len(m.removedmember_products))
		for id := range m.removedmember_products {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberEntry:
		ids := make([]ent.Value, 0, len(m.removedmember_entry))
		for id := range m.removedmember_entry {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.removedmember_contents))
		for id := range m.removedmember_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmember_details {
		edges = append(edges, member.EdgeMemberDetails)
	}
	if m.clearedmember_notes {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.clearedmember_orders {
		edges = append(edges, member.EdgeMemberOrders)
	}
	if m.clearedmember_products {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.clearedmember_entry {
		edges = append(edges, member.EdgeMemberEntry)
	}
	if m.clearedmember_contents {
		edges = append(edges, member.EdgeMemberContents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeMemberDetails:
		return m.clearedmember_details
	case member.EdgeMemberNotes:
		return m.clearedmember_notes
	case member.EdgeMemberOrders:
		return m.clearedmember_orders
	case member.EdgeMemberProducts:
		return m.clearedmember_products
	case member.EdgeMemberEntry:
		return m.clearedmember_entry
	case member.EdgeMemberContents:
		return m.clearedmember_contents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberDetails:
		m.ResetMemberDetails()
		return nil
	case member.EdgeMemberNotes:
		m.ResetMemberNotes()
		return nil
	case member.EdgeMemberOrders:
		m.ResetMemberOrders()
		return nil
	case member.EdgeMemberProducts:
		m.ResetMemberProducts()
		return nil
	case member.EdgeMemberEntry:
		m.ResetMemberEntry()
		return nil
	case member.EdgeMemberContents:
		m.ResetMemberContents()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// MemberContractMutation represents an operation that mutates the MemberContract nodes in the graph.
type MemberContractMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	status                *int64
	addstatus             *int64
	name                  *string
	sign                  *string
	clearedFields         map[string]struct{}
	content               map[int64]struct{}
	removedcontent        map[int64]struct{}
	clearedcontent        bool
	member                *int64
	clearedmember         bool
	_order                *int64
	cleared_order         bool
	member_product        *int64
	clearedmember_product bool
	done                  bool
	oldValue              func(context.Context) (*MemberContract, error)
	predicates            []predicate.MemberContract
}

var _ ent.Mutation = (*MemberContractMutation)(nil)

// membercontractOption allows management of the mutation configuration using functional options.
type membercontractOption func(*MemberContractMutation)

// newMemberContractMutation creates new mutation for the MemberContract entity.
func newMemberContractMutation(c config, op Op, opts ...membercontractOption) *MemberContractMutation {
	m := &MemberContractMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractID sets the ID field of the mutation.
func withMemberContractID(id int64) membercontractOption {
	return func(m *MemberContractMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContract
		)
		m.oldValue = func(ctx context.Context) (*MemberContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContract sets the old MemberContract of the mutation.
func withMemberContract(node *MemberContract) membercontractOption {
	return func(m *MemberContractMutation) {
		m.oldValue = func(context.Context) (*MemberContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContract entities.
func (m *MemberContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membercontract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membercontract.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberContractMutation) SetMemberID(i int64) {
	m.member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberContractMutation) MemberID() (r int64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberContractMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberContractMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, membercontract.FieldMemberID)
}

// SetOrderID sets the "order_id" field.
func (m *MemberContractMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MemberContractMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MemberContractMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[membercontract.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MemberContractMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MemberContractMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, membercontract.FieldOrderID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *MemberContractMutation) SetMemberProductID(i int64) {
	m.member_product = &i
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *MemberContractMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *MemberContractMutation) ClearMemberProductID() {
	m.member_product = nil
	m.clearedFields[membercontract.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *MemberContractMutation) ResetMemberProductID() {
	m.member_product = nil
	delete(m.clearedFields, membercontract.FieldMemberProductID)
}

// SetName sets the "name" field.
func (m *MemberContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[membercontract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, membercontract.FieldName)
}

// SetSign sets the "sign" field.
func (m *MemberContractMutation) SetSign(s string) {
	m.sign = &s
}

// Sign returns the value of the "sign" field in the mutation.
func (m *MemberContractMutation) Sign() (r string, exists bool) {
	v := m.sign
	if v == nil {
		return
	}
	return *v, true
}

// OldSign returns the old "sign" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldSign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSign: %w", err)
	}
	return oldValue.Sign, nil
}

// ClearSign clears the value of the "sign" field.
func (m *MemberContractMutation) ClearSign() {
	m.sign = nil
	m.clearedFields[membercontract.FieldSign] = struct{}{}
}

// SignCleared returns if the "sign" field was cleared in this mutation.
func (m *MemberContractMutation) SignCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldSign]
	return ok
}

// ResetSign resets all changes to the "sign" field.
func (m *MemberContractMutation) ResetSign() {
	m.sign = nil
	delete(m.clearedFields, membercontract.FieldSign)
}

// AddContentIDs adds the "content" edge to the MemberContractContent entity by ids.
func (m *MemberContractMutation) AddContentIDs(ids ...int64) {
	if m.content == nil {
		m.content = make(map[int64]struct{})
	}
	for i := range ids {
		m.content[ids[i]] = struct{}{}
	}
}

// ClearContent clears the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) ClearContent() {
	m.clearedcontent = true
}

// ContentCleared reports if the "content" edge to the MemberContractContent entity was cleared.
func (m *MemberContractMutation) ContentCleared() bool {
	return m.clearedcontent
}

// RemoveContentIDs removes the "content" edge to the MemberContractContent entity by IDs.
func (m *MemberContractMutation) RemoveContentIDs(ids ...int64) {
	if m.removedcontent == nil {
		m.removedcontent = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.content, ids[i])
		m.removedcontent[ids[i]] = struct{}{}
	}
}

// RemovedContent returns the removed IDs of the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) RemovedContentIDs() (ids []int64) {
	for id := range m.removedcontent {
		ids = append(ids, id)
	}
	return
}

// ContentIDs returns the "content" edge IDs in the mutation.
func (m *MemberContractMutation) ContentIDs() (ids []int64) {
	for id := range m.content {
		ids = append(ids, id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *MemberContractMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
	m.removedcontent = nil
}

// ClearMember clears the "member" edge to the Member entity.
func (m *MemberContractMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *MemberContractMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) MemberIDs() (ids []int64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *MemberContractMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *MemberContractMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[membercontract.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *MemberContractMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *MemberContractMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearMemberProduct clears the "member_product" edge to the MemberProduct entity.
func (m *MemberContractMutation) ClearMemberProduct() {
	m.clearedmember_product = true
	m.clearedFields[membercontract.FieldMemberProductID] = struct{}{}
}

// MemberProductCleared reports if the "member_product" edge to the MemberProduct entity was cleared.
func (m *MemberContractMutation) MemberProductCleared() bool {
	return m.MemberProductIDCleared() || m.clearedmember_product
}

// MemberProductIDs returns the "member_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberProductID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) MemberProductIDs() (ids []int64) {
	if id := m.member_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemberProduct resets all changes to the "member_product" edge.
func (m *MemberContractMutation) ResetMemberProduct() {
	m.member_product = nil
	m.clearedmember_product = false
}

// Where appends a list predicates to the MemberContractMutation builder.
func (m *MemberContractMutation) Where(ps ...predicate.MemberContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContract).
func (m *MemberContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, membercontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontract.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.member != nil {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m._order != nil {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.member_product != nil {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.name != nil {
		fields = append(fields, membercontract.FieldName)
	}
	if m.sign != nil {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.CreatedAt()
	case membercontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontract.FieldStatus:
		return m.Status()
	case membercontract.FieldMemberID:
		return m.MemberID()
	case membercontract.FieldOrderID:
		return m.OrderID()
	case membercontract.FieldMemberProductID:
		return m.MemberProductID()
	case membercontract.FieldName:
		return m.Name()
	case membercontract.FieldSign:
		return m.Sign()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontract.FieldStatus:
		return m.OldStatus(ctx)
	case membercontract.FieldMemberID:
		return m.OldMemberID(ctx)
	case membercontract.FieldOrderID:
		return m.OldOrderID(ctx)
	case membercontract.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case membercontract.FieldName:
		return m.OldName(ctx)
	case membercontract.FieldSign:
		return m.OldSign(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membercontract.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membercontract.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case membercontract.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case membercontract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case membercontract.FieldSign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSign(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontract.FieldStatus) {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.FieldCleared(membercontract.FieldMemberID) {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m.FieldCleared(membercontract.FieldOrderID) {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.FieldCleared(membercontract.FieldMemberProductID) {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.FieldCleared(membercontract.FieldName) {
		fields = append(fields, membercontract.FieldName)
	}
	if m.FieldCleared(membercontract.FieldSign) {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractMutation) ClearField(name string) error {
	switch name {
	case membercontract.FieldStatus:
		m.ClearStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membercontract.FieldOrderID:
		m.ClearOrderID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ClearName()
		return nil
	case membercontract.FieldSign:
		m.ClearSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractMutation) ResetField(name string) error {
	switch name {
	case membercontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontract.FieldStatus:
		m.ResetStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membercontract.FieldOrderID:
		m.ResetOrderID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ResetName()
		return nil
	case membercontract.FieldSign:
		m.ResetSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.content != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.member != nil {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m._order != nil {
		edges = append(edges, membercontract.EdgeOrder)
	}
	if m.member_product != nil {
		edges = append(edges, membercontract.EdgeMemberProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.content))
		for id := range m.content {
			ids = append(ids, id)
		}
		return ids
	case membercontract.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case membercontract.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case membercontract.EdgeMemberProduct:
		if id := m.member_product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcontent != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.removedcontent))
		for id := range m.removedcontent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcontent {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.clearedmember {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m.cleared_order {
		edges = append(edges, membercontract.EdgeOrder)
	}
	if m.clearedmember_product {
		edges = append(edges, membercontract.EdgeMemberProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontract.EdgeContent:
		return m.clearedcontent
	case membercontract.EdgeMember:
		return m.clearedmember
	case membercontract.EdgeOrder:
		return m.cleared_order
	case membercontract.EdgeMemberProduct:
		return m.clearedmember_product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractMutation) ClearEdge(name string) error {
	switch name {
	case membercontract.EdgeMember:
		m.ClearMember()
		return nil
	case membercontract.EdgeOrder:
		m.ClearOrder()
		return nil
	case membercontract.EdgeMemberProduct:
		m.ClearMemberProduct()
		return nil
	}
	return fmt.Errorf("unknown MemberContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractMutation) ResetEdge(name string) error {
	switch name {
	case membercontract.EdgeContent:
		m.ResetContent()
		return nil
	case membercontract.EdgeMember:
		m.ResetMember()
		return nil
	case membercontract.EdgeOrder:
		m.ResetOrder()
		return nil
	case membercontract.EdgeMemberProduct:
		m.ResetMemberProduct()
		return nil
	}
	return fmt.Errorf("unknown MemberContract edge %s", name)
}

// MemberContractContentMutation represents an operation that mutates the MemberContractContent nodes in the graph.
type MemberContractContentMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	content         *string
	sign_img        *string
	clearedFields   map[string]struct{}
	contract        *int64
	clearedcontract bool
	done            bool
	oldValue        func(context.Context) (*MemberContractContent, error)
	predicates      []predicate.MemberContractContent
}

var _ ent.Mutation = (*MemberContractContentMutation)(nil)

// membercontractcontentOption allows management of the mutation configuration using functional options.
type membercontractcontentOption func(*MemberContractContentMutation)

// newMemberContractContentMutation creates new mutation for the MemberContractContent entity.
func newMemberContractContentMutation(c config, op Op, opts ...membercontractcontentOption) *MemberContractContentMutation {
	m := &MemberContractContentMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContractContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractContentID sets the ID field of the mutation.
func withMemberContractContentID(id int64) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContractContent
		)
		m.oldValue = func(ctx context.Context) (*MemberContractContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContractContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContractContent sets the old MemberContractContent of the mutation.
func withMemberContractContent(node *MemberContractContent) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		m.oldValue = func(context.Context) (*MemberContractContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContractContent entities.
func (m *MemberContractContentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractContentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractContentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContractContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractContentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMemberContractID sets the "member_contract_id" field.
func (m *MemberContractContentMutation) SetMemberContractID(i int64) {
	m.contract = &i
}

// MemberContractID returns the value of the "member_contract_id" field in the mutation.
func (m *MemberContractContentMutation) MemberContractID() (r int64, exists bool) {
	v := m.contract
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberContractID returns the old "member_contract_id" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldMemberContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberContractID: %w", err)
	}
	return oldValue.MemberContractID, nil
}

// ClearMemberContractID clears the value of the "member_contract_id" field.
func (m *MemberContractContentMutation) ClearMemberContractID() {
	m.contract = nil
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// MemberContractIDCleared returns if the "member_contract_id" field was cleared in this mutation.
func (m *MemberContractContentMutation) MemberContractIDCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldMemberContractID]
	return ok
}

// ResetMemberContractID resets all changes to the "member_contract_id" field.
func (m *MemberContractContentMutation) ResetMemberContractID() {
	m.contract = nil
	delete(m.clearedFields, membercontractcontent.FieldMemberContractID)
}

// SetContent sets the "content" field.
func (m *MemberContractContentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MemberContractContentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MemberContractContentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[membercontractcontent.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MemberContractContentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MemberContractContentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, membercontractcontent.FieldContent)
}

// SetSignImg sets the "sign_img" field.
func (m *MemberContractContentMutation) SetSignImg(s string) {
	m.sign_img = &s
}

// SignImg returns the value of the "sign_img" field in the mutation.
func (m *MemberContractContentMutation) SignImg() (r string, exists bool) {
	v := m.sign_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSignImg returns the old "sign_img" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldSignImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignImg: %w", err)
	}
	return oldValue.SignImg, nil
}

// ClearSignImg clears the value of the "sign_img" field.
func (m *MemberContractContentMutation) ClearSignImg() {
	m.sign_img = nil
	m.clearedFields[membercontractcontent.FieldSignImg] = struct{}{}
}

// SignImgCleared returns if the "sign_img" field was cleared in this mutation.
func (m *MemberContractContentMutation) SignImgCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldSignImg]
	return ok
}

// ResetSignImg resets all changes to the "sign_img" field.
func (m *MemberContractContentMutation) ResetSignImg() {
	m.sign_img = nil
	delete(m.clearedFields, membercontractcontent.FieldSignImg)
}

// SetContractID sets the "contract" edge to the MemberContract entity by id.
func (m *MemberContractContentMutation) SetContractID(id int64) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the MemberContract entity.
func (m *MemberContractContentMutation) ClearContract() {
	m.clearedcontract = true
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// ContractCleared reports if the "contract" edge to the MemberContract entity was cleared.
func (m *MemberContractContentMutation) ContractCleared() bool {
	return m.MemberContractIDCleared() || m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *MemberContractContentMutation) ContractID() (id int64, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *MemberContractContentMutation) ContractIDs() (ids []int64) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *MemberContractContentMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// Where appends a list predicates to the MemberContractContentMutation builder.
func (m *MemberContractContentMutation) Where(ps ...predicate.MemberContractContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContractContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContractContent).
func (m *MemberContractContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractContentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, membercontractcontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontractcontent.FieldUpdatedAt)
	}
	if m.contract != nil {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.content != nil {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.sign_img != nil {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.CreatedAt()
	case membercontractcontent.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontractcontent.FieldMemberContractID:
		return m.MemberContractID()
	case membercontractcontent.FieldContent:
		return m.Content()
	case membercontractcontent.FieldSignImg:
		return m.SignImg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontractcontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontractcontent.FieldMemberContractID:
		return m.OldMemberContractID(ctx)
	case membercontractcontent.FieldContent:
		return m.OldContent(ctx)
	case membercontractcontent.FieldSignImg:
		return m.OldSignImg(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContractContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontractcontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontractcontent.FieldMemberContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberContractID(v)
		return nil
	case membercontractcontent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case membercontractcontent.FieldSignImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignImg(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractContentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractContentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MemberContractContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontractcontent.FieldMemberContractID) {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.FieldCleared(membercontractcontent.FieldContent) {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.FieldCleared(membercontractcontent.FieldSignImg) {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ClearField(name string) error {
	switch name {
	case membercontractcontent.FieldMemberContractID:
		m.ClearMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ClearContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ClearSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ResetField(name string) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontractcontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontractcontent.FieldMemberContractID:
		m.ResetMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ResetContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ResetSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contract != nil {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontractcontent.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontract {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractContentMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontractcontent.EdgeContract:
		return m.clearedcontract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractContentMutation) ClearEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractContentMutation) ResetEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ResetContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent edge %s", name)
}

// MemberDetailsMutation represents an operation that mutates the MemberDetails nodes in the graph.
type MemberDetailsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	nickname              *string
	gender                *int64
	addgender             *int64
	birthday              *time.Time
	identity_card         *string
	face_identity_card    *string
	back_identity_card    *string
	face_pic              *string
	face_eigenvalue       *string
	face_pic_updated_time *time.Time
	money_sum             *float64
	addmoney_sum          *float64
	product_id            *int64
	addproduct_id         *int64
	product_venue         *int64
	addproduct_venue      *int64
	entry_sum             *int64
	addentry_sum          *int64
	entry_last_time       *time.Time
	entry_deadline_time   *time.Time
	class_last_time       *time.Time
	relation_uid          *int64
	addrelation_uid       *int64
	relation_mid          *int64
	addrelation_mid       *int64
	clearedFields         map[string]struct{}
	info                  *int64
	clearedinfo           bool
	done                  bool
	oldValue              func(context.Context) (*MemberDetails, error)
	predicates            []predicate.MemberDetails
}

var _ ent.Mutation = (*MemberDetailsMutation)(nil)

// memberdetailsOption allows management of the mutation configuration using functional options.
type memberdetailsOption func(*MemberDetailsMutation)

// newMemberDetailsMutation creates new mutation for the MemberDetails entity.
func newMemberDetailsMutation(c config, op Op, opts ...memberdetailsOption) *MemberDetailsMutation {
	m := &MemberDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberDetailsID sets the ID field of the mutation.
func withMemberDetailsID(id int64) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberDetails
		)
		m.oldValue = func(ctx context.Context) (*MemberDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberDetails sets the old MemberDetails of the mutation.
func withMemberDetails(node *MemberDetails) memberdetailsOption {
	return func(m *MemberDetailsMutation) {
		m.oldValue = func(context.Context) (*MemberDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberDetails entities.
func (m *MemberDetailsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberDetailsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberDetailsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberDetailsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberDetailsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberDetailsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberDetailsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberDetailsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberDetailsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMemberID sets the "member_id" field.
func (m *MemberDetailsMutation) SetMemberID(i int64) {
	m.info = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberDetailsMutation) MemberID() (r int64, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberDetailsMutation) ClearMemberID() {
	m.info = nil
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberDetailsMutation) ResetMemberID() {
	m.info = nil
	delete(m.clearedFields, memberdetails.FieldMemberID)
}

// SetNickname sets the "nickname" field.
func (m *MemberDetailsMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *MemberDetailsMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *MemberDetailsMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[memberdetails.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *MemberDetailsMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *MemberDetailsMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, memberdetails.FieldNickname)
}

// SetGender sets the "gender" field.
func (m *MemberDetailsMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *MemberDetailsMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *MemberDetailsMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *MemberDetailsMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *MemberDetailsMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[memberdetails.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *MemberDetailsMutation) GenderCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *MemberDetailsMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, memberdetails.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *MemberDetailsMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *MemberDetailsMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *MemberDetailsMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[memberdetails.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *MemberDetailsMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *MemberDetailsMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, memberdetails.FieldBirthday)
}

// SetIdentityCard sets the "identity_card" field.
func (m *MemberDetailsMutation) SetIdentityCard(s string) {
	m.identity_card = &s
}

// IdentityCard returns the value of the "identity_card" field in the mutation.
func (m *MemberDetailsMutation) IdentityCard() (r string, exists bool) {
	v := m.identity_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityCard returns the old "identity_card" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldIdentityCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityCard: %w", err)
	}
	return oldValue.IdentityCard, nil
}

// ClearIdentityCard clears the value of the "identity_card" field.
func (m *MemberDetailsMutation) ClearIdentityCard() {
	m.identity_card = nil
	m.clearedFields[memberdetails.FieldIdentityCard] = struct{}{}
}

// IdentityCardCleared returns if the "identity_card" field was cleared in this mutation.
func (m *MemberDetailsMutation) IdentityCardCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldIdentityCard]
	return ok
}

// ResetIdentityCard resets all changes to the "identity_card" field.
func (m *MemberDetailsMutation) ResetIdentityCard() {
	m.identity_card = nil
	delete(m.clearedFields, memberdetails.FieldIdentityCard)
}

// SetFaceIdentityCard sets the "face_identity_card" field.
func (m *MemberDetailsMutation) SetFaceIdentityCard(s string) {
	m.face_identity_card = &s
}

// FaceIdentityCard returns the value of the "face_identity_card" field in the mutation.
func (m *MemberDetailsMutation) FaceIdentityCard() (r string, exists bool) {
	v := m.face_identity_card
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceIdentityCard returns the old "face_identity_card" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldFaceIdentityCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceIdentityCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceIdentityCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceIdentityCard: %w", err)
	}
	return oldValue.FaceIdentityCard, nil
}

// ClearFaceIdentityCard clears the value of the "face_identity_card" field.
func (m *MemberDetailsMutation) ClearFaceIdentityCard() {
	m.face_identity_card = nil
	m.clearedFields[memberdetails.FieldFaceIdentityCard] = struct{}{}
}

// FaceIdentityCardCleared returns if the "face_identity_card" field was cleared in this mutation.
func (m *MemberDetailsMutation) FaceIdentityCardCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldFaceIdentityCard]
	return ok
}

// ResetFaceIdentityCard resets all changes to the "face_identity_card" field.
func (m *MemberDetailsMutation) ResetFaceIdentityCard() {
	m.face_identity_card = nil
	delete(m.clearedFields, memberdetails.FieldFaceIdentityCard)
}

// SetBackIdentityCard sets the "back_identity_card" field.
func (m *MemberDetailsMutation) SetBackIdentityCard(s string) {
	m.back_identity_card = &s
}

// BackIdentityCard returns the value of the "back_identity_card" field in the mutation.
func (m *MemberDetailsMutation) BackIdentityCard() (r string, exists bool) {
	v := m.back_identity_card
	if v == nil {
		return
	}
	return *v, true
}

// OldBackIdentityCard returns the old "back_identity_card" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldBackIdentityCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackIdentityCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackIdentityCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackIdentityCard: %w", err)
	}
	return oldValue.BackIdentityCard, nil
}

// ClearBackIdentityCard clears the value of the "back_identity_card" field.
func (m *MemberDetailsMutation) ClearBackIdentityCard() {
	m.back_identity_card = nil
	m.clearedFields[memberdetails.FieldBackIdentityCard] = struct{}{}
}

// BackIdentityCardCleared returns if the "back_identity_card" field was cleared in this mutation.
func (m *MemberDetailsMutation) BackIdentityCardCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldBackIdentityCard]
	return ok
}

// ResetBackIdentityCard resets all changes to the "back_identity_card" field.
func (m *MemberDetailsMutation) ResetBackIdentityCard() {
	m.back_identity_card = nil
	delete(m.clearedFields, memberdetails.FieldBackIdentityCard)
}

// SetFacePic sets the "face_pic" field.
func (m *MemberDetailsMutation) SetFacePic(s string) {
	m.face_pic = &s
}

// FacePic returns the value of the "face_pic" field in the mutation.
func (m *MemberDetailsMutation) FacePic() (r string, exists bool) {
	v := m.face_pic
	if v == nil {
		return
	}
	return *v, true
}

// OldFacePic returns the old "face_pic" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldFacePic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacePic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacePic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacePic: %w", err)
	}
	return oldValue.FacePic, nil
}

// ClearFacePic clears the value of the "face_pic" field.
func (m *MemberDetailsMutation) ClearFacePic() {
	m.face_pic = nil
	m.clearedFields[memberdetails.FieldFacePic] = struct{}{}
}

// FacePicCleared returns if the "face_pic" field was cleared in this mutation.
func (m *MemberDetailsMutation) FacePicCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldFacePic]
	return ok
}

// ResetFacePic resets all changes to the "face_pic" field.
func (m *MemberDetailsMutation) ResetFacePic() {
	m.face_pic = nil
	delete(m.clearedFields, memberdetails.FieldFacePic)
}

// SetFaceEigenvalue sets the "face_eigenvalue" field.
func (m *MemberDetailsMutation) SetFaceEigenvalue(s string) {
	m.face_eigenvalue = &s
}

// FaceEigenvalue returns the value of the "face_eigenvalue" field in the mutation.
func (m *MemberDetailsMutation) FaceEigenvalue() (r string, exists bool) {
	v := m.face_eigenvalue
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceEigenvalue returns the old "face_eigenvalue" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldFaceEigenvalue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceEigenvalue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceEigenvalue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceEigenvalue: %w", err)
	}
	return oldValue.FaceEigenvalue, nil
}

// ClearFaceEigenvalue clears the value of the "face_eigenvalue" field.
func (m *MemberDetailsMutation) ClearFaceEigenvalue() {
	m.face_eigenvalue = nil
	m.clearedFields[memberdetails.FieldFaceEigenvalue] = struct{}{}
}

// FaceEigenvalueCleared returns if the "face_eigenvalue" field was cleared in this mutation.
func (m *MemberDetailsMutation) FaceEigenvalueCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldFaceEigenvalue]
	return ok
}

// ResetFaceEigenvalue resets all changes to the "face_eigenvalue" field.
func (m *MemberDetailsMutation) ResetFaceEigenvalue() {
	m.face_eigenvalue = nil
	delete(m.clearedFields, memberdetails.FieldFaceEigenvalue)
}

// SetFacePicUpdatedTime sets the "face_pic_updated_time" field.
func (m *MemberDetailsMutation) SetFacePicUpdatedTime(t time.Time) {
	m.face_pic_updated_time = &t
}

// FacePicUpdatedTime returns the value of the "face_pic_updated_time" field in the mutation.
func (m *MemberDetailsMutation) FacePicUpdatedTime() (r time.Time, exists bool) {
	v := m.face_pic_updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFacePicUpdatedTime returns the old "face_pic_updated_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldFacePicUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacePicUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacePicUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacePicUpdatedTime: %w", err)
	}
	return oldValue.FacePicUpdatedTime, nil
}

// ResetFacePicUpdatedTime resets all changes to the "face_pic_updated_time" field.
func (m *MemberDetailsMutation) ResetFacePicUpdatedTime() {
	m.face_pic_updated_time = nil
}

// SetMoneySum sets the "money_sum" field.
func (m *MemberDetailsMutation) SetMoneySum(f float64) {
	m.money_sum = &f
	m.addmoney_sum = nil
}

// MoneySum returns the value of the "money_sum" field in the mutation.
func (m *MemberDetailsMutation) MoneySum() (r float64, exists bool) {
	v := m.money_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldMoneySum returns the old "money_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldMoneySum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoneySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoneySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoneySum: %w", err)
	}
	return oldValue.MoneySum, nil
}

// AddMoneySum adds f to the "money_sum" field.
func (m *MemberDetailsMutation) AddMoneySum(f float64) {
	if m.addmoney_sum != nil {
		*m.addmoney_sum += f
	} else {
		m.addmoney_sum = &f
	}
}

// AddedMoneySum returns the value that was added to the "money_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedMoneySum() (r float64, exists bool) {
	v := m.addmoney_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearMoneySum clears the value of the "money_sum" field.
func (m *MemberDetailsMutation) ClearMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	m.clearedFields[memberdetails.FieldMoneySum] = struct{}{}
}

// MoneySumCleared returns if the "money_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) MoneySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldMoneySum]
	return ok
}

// ResetMoneySum resets all changes to the "money_sum" field.
func (m *MemberDetailsMutation) ResetMoneySum() {
	m.money_sum = nil
	m.addmoney_sum = nil
	delete(m.clearedFields, memberdetails.FieldMoneySum)
}

// SetProductID sets the "product_id" field.
func (m *MemberDetailsMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MemberDetailsMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *MemberDetailsMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *MemberDetailsMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *MemberDetailsMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[memberdetails.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MemberDetailsMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, memberdetails.FieldProductID)
}

// SetProductVenue sets the "product_venue" field.
func (m *MemberDetailsMutation) SetProductVenue(i int64) {
	m.product_venue = &i
	m.addproduct_venue = nil
}

// ProductVenue returns the value of the "product_venue" field in the mutation.
func (m *MemberDetailsMutation) ProductVenue() (r int64, exists bool) {
	v := m.product_venue
	if v == nil {
		return
	}
	return *v, true
}

// OldProductVenue returns the old "product_venue" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldProductVenue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductVenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductVenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductVenue: %w", err)
	}
	return oldValue.ProductVenue, nil
}

// AddProductVenue adds i to the "product_venue" field.
func (m *MemberDetailsMutation) AddProductVenue(i int64) {
	if m.addproduct_venue != nil {
		*m.addproduct_venue += i
	} else {
		m.addproduct_venue = &i
	}
}

// AddedProductVenue returns the value that was added to the "product_venue" field in this mutation.
func (m *MemberDetailsMutation) AddedProductVenue() (r int64, exists bool) {
	v := m.addproduct_venue
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductVenue clears the value of the "product_venue" field.
func (m *MemberDetailsMutation) ClearProductVenue() {
	m.product_venue = nil
	m.addproduct_venue = nil
	m.clearedFields[memberdetails.FieldProductVenue] = struct{}{}
}

// ProductVenueCleared returns if the "product_venue" field was cleared in this mutation.
func (m *MemberDetailsMutation) ProductVenueCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldProductVenue]
	return ok
}

// ResetProductVenue resets all changes to the "product_venue" field.
func (m *MemberDetailsMutation) ResetProductVenue() {
	m.product_venue = nil
	m.addproduct_venue = nil
	delete(m.clearedFields, memberdetails.FieldProductVenue)
}

// SetEntrySum sets the "entry_sum" field.
func (m *MemberDetailsMutation) SetEntrySum(i int64) {
	m.entry_sum = &i
	m.addentry_sum = nil
}

// EntrySum returns the value of the "entry_sum" field in the mutation.
func (m *MemberDetailsMutation) EntrySum() (r int64, exists bool) {
	v := m.entry_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldEntrySum returns the old "entry_sum" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntrySum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntrySum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntrySum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntrySum: %w", err)
	}
	return oldValue.EntrySum, nil
}

// AddEntrySum adds i to the "entry_sum" field.
func (m *MemberDetailsMutation) AddEntrySum(i int64) {
	if m.addentry_sum != nil {
		*m.addentry_sum += i
	} else {
		m.addentry_sum = &i
	}
}

// AddedEntrySum returns the value that was added to the "entry_sum" field in this mutation.
func (m *MemberDetailsMutation) AddedEntrySum() (r int64, exists bool) {
	v := m.addentry_sum
	if v == nil {
		return
	}
	return *v, true
}

// ClearEntrySum clears the value of the "entry_sum" field.
func (m *MemberDetailsMutation) ClearEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	m.clearedFields[memberdetails.FieldEntrySum] = struct{}{}
}

// EntrySumCleared returns if the "entry_sum" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntrySumCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntrySum]
	return ok
}

// ResetEntrySum resets all changes to the "entry_sum" field.
func (m *MemberDetailsMutation) ResetEntrySum() {
	m.entry_sum = nil
	m.addentry_sum = nil
	delete(m.clearedFields, memberdetails.FieldEntrySum)
}

// SetEntryLastTime sets the "entry_last_time" field.
func (m *MemberDetailsMutation) SetEntryLastTime(t time.Time) {
	m.entry_last_time = &t
}

// EntryLastTime returns the value of the "entry_last_time" field in the mutation.
func (m *MemberDetailsMutation) EntryLastTime() (r time.Time, exists bool) {
	v := m.entry_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryLastTime returns the old "entry_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryLastTime: %w", err)
	}
	return oldValue.EntryLastTime, nil
}

// ClearEntryLastTime clears the value of the "entry_last_time" field.
func (m *MemberDetailsMutation) ClearEntryLastTime() {
	m.entry_last_time = nil
	m.clearedFields[memberdetails.FieldEntryLastTime] = struct{}{}
}

// EntryLastTimeCleared returns if the "entry_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryLastTime]
	return ok
}

// ResetEntryLastTime resets all changes to the "entry_last_time" field.
func (m *MemberDetailsMutation) ResetEntryLastTime() {
	m.entry_last_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryLastTime)
}

// SetEntryDeadlineTime sets the "entry_deadline_time" field.
func (m *MemberDetailsMutation) SetEntryDeadlineTime(t time.Time) {
	m.entry_deadline_time = &t
}

// EntryDeadlineTime returns the value of the "entry_deadline_time" field in the mutation.
func (m *MemberDetailsMutation) EntryDeadlineTime() (r time.Time, exists bool) {
	v := m.entry_deadline_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryDeadlineTime returns the old "entry_deadline_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldEntryDeadlineTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryDeadlineTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryDeadlineTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryDeadlineTime: %w", err)
	}
	return oldValue.EntryDeadlineTime, nil
}

// ClearEntryDeadlineTime clears the value of the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ClearEntryDeadlineTime() {
	m.entry_deadline_time = nil
	m.clearedFields[memberdetails.FieldEntryDeadlineTime] = struct{}{}
}

// EntryDeadlineTimeCleared returns if the "entry_deadline_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) EntryDeadlineTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldEntryDeadlineTime]
	return ok
}

// ResetEntryDeadlineTime resets all changes to the "entry_deadline_time" field.
func (m *MemberDetailsMutation) ResetEntryDeadlineTime() {
	m.entry_deadline_time = nil
	delete(m.clearedFields, memberdetails.FieldEntryDeadlineTime)
}

// SetClassLastTime sets the "class_last_time" field.
func (m *MemberDetailsMutation) SetClassLastTime(t time.Time) {
	m.class_last_time = &t
}

// ClassLastTime returns the value of the "class_last_time" field in the mutation.
func (m *MemberDetailsMutation) ClassLastTime() (r time.Time, exists bool) {
	v := m.class_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClassLastTime returns the old "class_last_time" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldClassLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassLastTime: %w", err)
	}
	return oldValue.ClassLastTime, nil
}

// ClearClassLastTime clears the value of the "class_last_time" field.
func (m *MemberDetailsMutation) ClearClassLastTime() {
	m.class_last_time = nil
	m.clearedFields[memberdetails.FieldClassLastTime] = struct{}{}
}

// ClassLastTimeCleared returns if the "class_last_time" field was cleared in this mutation.
func (m *MemberDetailsMutation) ClassLastTimeCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldClassLastTime]
	return ok
}

// ResetClassLastTime resets all changes to the "class_last_time" field.
func (m *MemberDetailsMutation) ResetClassLastTime() {
	m.class_last_time = nil
	delete(m.clearedFields, memberdetails.FieldClassLastTime)
}

// SetRelationUID sets the "relation_uid" field.
func (m *MemberDetailsMutation) SetRelationUID(i int64) {
	m.relation_uid = &i
	m.addrelation_uid = nil
}

// RelationUID returns the value of the "relation_uid" field in the mutation.
func (m *MemberDetailsMutation) RelationUID() (r int64, exists bool) {
	v := m.relation_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationUID returns the old "relation_uid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationUID: %w", err)
	}
	return oldValue.RelationUID, nil
}

// AddRelationUID adds i to the "relation_uid" field.
func (m *MemberDetailsMutation) AddRelationUID(i int64) {
	if m.addrelation_uid != nil {
		*m.addrelation_uid += i
	} else {
		m.addrelation_uid = &i
	}
}

// AddedRelationUID returns the value that was added to the "relation_uid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationUID() (r int64, exists bool) {
	v := m.addrelation_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationUID clears the value of the "relation_uid" field.
func (m *MemberDetailsMutation) ClearRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	m.clearedFields[memberdetails.FieldRelationUID] = struct{}{}
}

// RelationUIDCleared returns if the "relation_uid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationUIDCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationUID]
	return ok
}

// ResetRelationUID resets all changes to the "relation_uid" field.
func (m *MemberDetailsMutation) ResetRelationUID() {
	m.relation_uid = nil
	m.addrelation_uid = nil
	delete(m.clearedFields, memberdetails.FieldRelationUID)
}

// SetRelationMid sets the "relation_mid" field.
func (m *MemberDetailsMutation) SetRelationMid(i int64) {
	m.relation_mid = &i
	m.addrelation_mid = nil
}

// RelationMid returns the value of the "relation_mid" field in the mutation.
func (m *MemberDetailsMutation) RelationMid() (r int64, exists bool) {
	v := m.relation_mid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMid returns the old "relation_mid" field's value of the MemberDetails entity.
// If the MemberDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberDetailsMutation) OldRelationMid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMid: %w", err)
	}
	return oldValue.RelationMid, nil
}

// AddRelationMid adds i to the "relation_mid" field.
func (m *MemberDetailsMutation) AddRelationMid(i int64) {
	if m.addrelation_mid != nil {
		*m.addrelation_mid += i
	} else {
		m.addrelation_mid = &i
	}
}

// AddedRelationMid returns the value that was added to the "relation_mid" field in this mutation.
func (m *MemberDetailsMutation) AddedRelationMid() (r int64, exists bool) {
	v := m.addrelation_mid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationMid clears the value of the "relation_mid" field.
func (m *MemberDetailsMutation) ClearRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	m.clearedFields[memberdetails.FieldRelationMid] = struct{}{}
}

// RelationMidCleared returns if the "relation_mid" field was cleared in this mutation.
func (m *MemberDetailsMutation) RelationMidCleared() bool {
	_, ok := m.clearedFields[memberdetails.FieldRelationMid]
	return ok
}

// ResetRelationMid resets all changes to the "relation_mid" field.
func (m *MemberDetailsMutation) ResetRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	delete(m.clearedFields, memberdetails.FieldRelationMid)
}

// SetInfoID sets the "info" edge to the Member entity by id.
func (m *MemberDetailsMutation) SetInfoID(id int64) {
	m.info = &id
}

// ClearInfo clears the "info" edge to the Member entity.
func (m *MemberDetailsMutation) ClearInfo() {
	m.clearedinfo = true
	m.clearedFields[memberdetails.FieldMemberID] = struct{}{}
}

// InfoCleared reports if the "info" edge to the Member entity was cleared.
func (m *MemberDetailsMutation) InfoCleared() bool {
	return m.MemberIDCleared() || m.clearedinfo
}

// InfoID returns the "info" edge ID in the mutation.
func (m *MemberDetailsMutation) InfoID() (id int64, exists bool) {
	if m.info != nil {
		return *m.info, true
	}
	return
}

// InfoIDs returns the "info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InfoID instead. It exists only for internal usage by the builders.
func (m *MemberDetailsMutation) InfoIDs() (ids []int64) {
	if id := m.info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInfo resets all changes to the "info" edge.
func (m *MemberDetailsMutation) ResetInfo() {
	m.info = nil
	m.clearedinfo = false
}

// Where appends a list predicates to the MemberDetailsMutation builder.
func (m *MemberDetailsMutation) Where(ps ...predicate.MemberDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberDetails).
func (m *MemberDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberDetailsMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, memberdetails.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberdetails.FieldUpdatedAt)
	}
	if m.info != nil {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.nickname != nil {
		fields = append(fields, memberdetails.FieldNickname)
	}
	if m.gender != nil {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, memberdetails.FieldBirthday)
	}
	if m.identity_card != nil {
		fields = append(fields, memberdetails.FieldIdentityCard)
	}
	if m.face_identity_card != nil {
		fields = append(fields, memberdetails.FieldFaceIdentityCard)
	}
	if m.back_identity_card != nil {
		fields = append(fields, memberdetails.FieldBackIdentityCard)
	}
	if m.face_pic != nil {
		fields = append(fields, memberdetails.FieldFacePic)
	}
	if m.face_eigenvalue != nil {
		fields = append(fields, memberdetails.FieldFaceEigenvalue)
	}
	if m.face_pic_updated_time != nil {
		fields = append(fields, memberdetails.FieldFacePicUpdatedTime)
	}
	if m.money_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.product_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.product_venue != nil {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.entry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.entry_last_time != nil {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.entry_deadline_time != nil {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.class_last_time != nil {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.relation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.relation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.CreatedAt()
	case memberdetails.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberdetails.FieldMemberID:
		return m.MemberID()
	case memberdetails.FieldNickname:
		return m.Nickname()
	case memberdetails.FieldGender:
		return m.Gender()
	case memberdetails.FieldBirthday:
		return m.Birthday()
	case memberdetails.FieldIdentityCard:
		return m.IdentityCard()
	case memberdetails.FieldFaceIdentityCard:
		return m.FaceIdentityCard()
	case memberdetails.FieldBackIdentityCard:
		return m.BackIdentityCard()
	case memberdetails.FieldFacePic:
		return m.FacePic()
	case memberdetails.FieldFaceEigenvalue:
		return m.FaceEigenvalue()
	case memberdetails.FieldFacePicUpdatedTime:
		return m.FacePicUpdatedTime()
	case memberdetails.FieldMoneySum:
		return m.MoneySum()
	case memberdetails.FieldProductID:
		return m.ProductID()
	case memberdetails.FieldProductVenue:
		return m.ProductVenue()
	case memberdetails.FieldEntrySum:
		return m.EntrySum()
	case memberdetails.FieldEntryLastTime:
		return m.EntryLastTime()
	case memberdetails.FieldEntryDeadlineTime:
		return m.EntryDeadlineTime()
	case memberdetails.FieldClassLastTime:
		return m.ClassLastTime()
	case memberdetails.FieldRelationUID:
		return m.RelationUID()
	case memberdetails.FieldRelationMid:
		return m.RelationMid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberdetails.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberdetails.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberdetails.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberdetails.FieldNickname:
		return m.OldNickname(ctx)
	case memberdetails.FieldGender:
		return m.OldGender(ctx)
	case memberdetails.FieldBirthday:
		return m.OldBirthday(ctx)
	case memberdetails.FieldIdentityCard:
		return m.OldIdentityCard(ctx)
	case memberdetails.FieldFaceIdentityCard:
		return m.OldFaceIdentityCard(ctx)
	case memberdetails.FieldBackIdentityCard:
		return m.OldBackIdentityCard(ctx)
	case memberdetails.FieldFacePic:
		return m.OldFacePic(ctx)
	case memberdetails.FieldFaceEigenvalue:
		return m.OldFaceEigenvalue(ctx)
	case memberdetails.FieldFacePicUpdatedTime:
		return m.OldFacePicUpdatedTime(ctx)
	case memberdetails.FieldMoneySum:
		return m.OldMoneySum(ctx)
	case memberdetails.FieldProductID:
		return m.OldProductID(ctx)
	case memberdetails.FieldProductVenue:
		return m.OldProductVenue(ctx)
	case memberdetails.FieldEntrySum:
		return m.OldEntrySum(ctx)
	case memberdetails.FieldEntryLastTime:
		return m.OldEntryLastTime(ctx)
	case memberdetails.FieldEntryDeadlineTime:
		return m.OldEntryDeadlineTime(ctx)
	case memberdetails.FieldClassLastTime:
		return m.OldClassLastTime(ctx)
	case memberdetails.FieldRelationUID:
		return m.OldRelationUID(ctx)
	case memberdetails.FieldRelationMid:
		return m.OldRelationMid(ctx)
	}
	return nil, fmt.Errorf("unknown MemberDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberdetails.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberdetails.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberdetails.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case memberdetails.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case memberdetails.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case memberdetails.FieldIdentityCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityCard(v)
		return nil
	case memberdetails.FieldFaceIdentityCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceIdentityCard(v)
		return nil
	case memberdetails.FieldBackIdentityCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackIdentityCard(v)
		return nil
	case memberdetails.FieldFacePic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacePic(v)
		return nil
	case memberdetails.FieldFaceEigenvalue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceEigenvalue(v)
		return nil
	case memberdetails.FieldFacePicUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacePicUpdatedTime(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case memberdetails.FieldProductVenue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductVenue(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntrySum(v)
		return nil
	case memberdetails.FieldEntryLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryLastTime(v)
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryDeadlineTime(v)
		return nil
	case memberdetails.FieldClassLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassLastTime(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationUID(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMid(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberDetailsMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.addmoney_sum != nil {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.addproduct_id != nil {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.addproduct_venue != nil {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.addentry_sum != nil {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.addrelation_uid != nil {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.addrelation_mid != nil {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberdetails.FieldGender:
		return m.AddedGender()
	case memberdetails.FieldMoneySum:
		return m.AddedMoneySum()
	case memberdetails.FieldProductID:
		return m.AddedProductID()
	case memberdetails.FieldProductVenue:
		return m.AddedProductVenue()
	case memberdetails.FieldEntrySum:
		return m.AddedEntrySum()
	case memberdetails.FieldRelationUID:
		return m.AddedRelationUID()
	case memberdetails.FieldRelationMid:
		return m.AddedRelationMid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberdetails.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case memberdetails.FieldMoneySum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMoneySum(v)
		return nil
	case memberdetails.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case memberdetails.FieldProductVenue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductVenue(v)
		return nil
	case memberdetails.FieldEntrySum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntrySum(v)
		return nil
	case memberdetails.FieldRelationUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationUID(v)
		return nil
	case memberdetails.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationMid(v)
		return nil
	}
	return fmt.Errorf("unknown MemberDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberdetails.FieldMemberID) {
		fields = append(fields, memberdetails.FieldMemberID)
	}
	if m.FieldCleared(memberdetails.FieldNickname) {
		fields = append(fields, memberdetails.FieldNickname)
	}
	if m.FieldCleared(memberdetails.FieldGender) {
		fields = append(fields, memberdetails.FieldGender)
	}
	if m.FieldCleared(memberdetails.FieldBirthday) {
		fields = append(fields, memberdetails.FieldBirthday)
	}
	if m.FieldCleared(memberdetails.FieldIdentityCard) {
		fields = append(fields, memberdetails.FieldIdentityCard)
	}
	if m.FieldCleared(memberdetails.FieldFaceIdentityCard) {
		fields = append(fields, memberdetails.FieldFaceIdentityCard)
	}
	if m.FieldCleared(memberdetails.FieldBackIdentityCard) {
		fields = append(fields, memberdetails.FieldBackIdentityCard)
	}
	if m.FieldCleared(memberdetails.FieldFacePic) {
		fields = append(fields, memberdetails.FieldFacePic)
	}
	if m.FieldCleared(memberdetails.FieldFaceEigenvalue) {
		fields = append(fields, memberdetails.FieldFaceEigenvalue)
	}
	if m.FieldCleared(memberdetails.FieldMoneySum) {
		fields = append(fields, memberdetails.FieldMoneySum)
	}
	if m.FieldCleared(memberdetails.FieldProductID) {
		fields = append(fields, memberdetails.FieldProductID)
	}
	if m.FieldCleared(memberdetails.FieldProductVenue) {
		fields = append(fields, memberdetails.FieldProductVenue)
	}
	if m.FieldCleared(memberdetails.FieldEntrySum) {
		fields = append(fields, memberdetails.FieldEntrySum)
	}
	if m.FieldCleared(memberdetails.FieldEntryLastTime) {
		fields = append(fields, memberdetails.FieldEntryLastTime)
	}
	if m.FieldCleared(memberdetails.FieldEntryDeadlineTime) {
		fields = append(fields, memberdetails.FieldEntryDeadlineTime)
	}
	if m.FieldCleared(memberdetails.FieldClassLastTime) {
		fields = append(fields, memberdetails.FieldClassLastTime)
	}
	if m.FieldCleared(memberdetails.FieldRelationUID) {
		fields = append(fields, memberdetails.FieldRelationUID)
	}
	if m.FieldCleared(memberdetails.FieldRelationMid) {
		fields = append(fields, memberdetails.FieldRelationMid)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ClearField(name string) error {
	switch name {
	case memberdetails.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberdetails.FieldNickname:
		m.ClearNickname()
		return nil
	case memberdetails.FieldGender:
		m.ClearGender()
		return nil
	case memberdetails.FieldBirthday:
		m.ClearBirthday()
		return nil
	case memberdetails.FieldIdentityCard:
		m.ClearIdentityCard()
		return nil
	case memberdetails.FieldFaceIdentityCard:
		m.ClearFaceIdentityCard()
		return nil
	case memberdetails.FieldBackIdentityCard:
		m.ClearBackIdentityCard()
		return nil
	case memberdetails.FieldFacePic:
		m.ClearFacePic()
		return nil
	case memberdetails.FieldFaceEigenvalue:
		m.ClearFaceEigenvalue()
		return nil
	case memberdetails.FieldMoneySum:
		m.ClearMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ClearProductID()
		return nil
	case memberdetails.FieldProductVenue:
		m.ClearProductVenue()
		return nil
	case memberdetails.FieldEntrySum:
		m.ClearEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ClearEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ClearEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ClearClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ClearRelationUID()
		return nil
	case memberdetails.FieldRelationMid:
		m.ClearRelationMid()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberDetailsMutation) ResetField(name string) error {
	switch name {
	case memberdetails.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberdetails.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberdetails.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberdetails.FieldNickname:
		m.ResetNickname()
		return nil
	case memberdetails.FieldGender:
		m.ResetGender()
		return nil
	case memberdetails.FieldBirthday:
		m.ResetBirthday()
		return nil
	case memberdetails.FieldIdentityCard:
		m.ResetIdentityCard()
		return nil
	case memberdetails.FieldFaceIdentityCard:
		m.ResetFaceIdentityCard()
		return nil
	case memberdetails.FieldBackIdentityCard:
		m.ResetBackIdentityCard()
		return nil
	case memberdetails.FieldFacePic:
		m.ResetFacePic()
		return nil
	case memberdetails.FieldFaceEigenvalue:
		m.ResetFaceEigenvalue()
		return nil
	case memberdetails.FieldFacePicUpdatedTime:
		m.ResetFacePicUpdatedTime()
		return nil
	case memberdetails.FieldMoneySum:
		m.ResetMoneySum()
		return nil
	case memberdetails.FieldProductID:
		m.ResetProductID()
		return nil
	case memberdetails.FieldProductVenue:
		m.ResetProductVenue()
		return nil
	case memberdetails.FieldEntrySum:
		m.ResetEntrySum()
		return nil
	case memberdetails.FieldEntryLastTime:
		m.ResetEntryLastTime()
		return nil
	case memberdetails.FieldEntryDeadlineTime:
		m.ResetEntryDeadlineTime()
		return nil
	case memberdetails.FieldClassLastTime:
		m.ResetClassLastTime()
		return nil
	case memberdetails.FieldRelationUID:
		m.ResetRelationUID()
		return nil
	case memberdetails.FieldRelationMid:
		m.ResetRelationMid()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.info != nil {
		edges = append(edges, memberdetails.EdgeInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberdetails.EdgeInfo:
		if id := m.info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinfo {
		edges = append(edges, memberdetails.EdgeInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case memberdetails.EdgeInfo:
		return m.clearedinfo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberDetailsMutation) ClearEdge(name string) error {
	switch name {
	case memberdetails.EdgeInfo:
		m.ClearInfo()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberDetailsMutation) ResetEdge(name string) error {
	switch name {
	case memberdetails.EdgeInfo:
		m.ResetInfo()
		return nil
	}
	return fmt.Errorf("unknown MemberDetails edge %s", name)
}

// MemberNoteMutation represents an operation that mutates the MemberNote nodes in the graph.
type MemberNoteMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int64
	addstatus     *int64
	note          *string
	clearedFields map[string]struct{}
	notes         *int64
	clearednotes  bool
	done          bool
	oldValue      func(context.Context) (*MemberNote, error)
	predicates    []predicate.MemberNote
}

var _ ent.Mutation = (*MemberNoteMutation)(nil)

// membernoteOption allows management of the mutation configuration using functional options.
type membernoteOption func(*MemberNoteMutation)

// newMemberNoteMutation creates new mutation for the MemberNote entity.
func newMemberNoteMutation(c config, op Op, opts ...membernoteOption) *MemberNoteMutation {
	m := &MemberNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberNoteID sets the ID field of the mutation.
func withMemberNoteID(id int64) membernoteOption {
	return func(m *MemberNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberNote
		)
		m.oldValue = func(ctx context.Context) (*MemberNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberNote sets the old MemberNote of the mutation.
func withMemberNote(node *MemberNote) membernoteOption {
	return func(m *MemberNoteMutation) {
		m.oldValue = func(context.Context) (*MemberNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberNote entities.
func (m *MemberNoteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberNoteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberNoteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberNoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberNoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberNoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberNoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberNoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberNoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberNoteMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberNoteMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberNoteMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberNoteMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberNoteMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membernote.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberNoteMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membernote.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberNoteMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membernote.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberNoteMutation) SetMemberID(i int64) {
	m.notes = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberNoteMutation) MemberID() (r int64, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberNoteMutation) ClearMemberID() {
	m.notes = nil
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberNoteMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberNoteMutation) ResetMemberID() {
	m.notes = nil
	delete(m.clearedFields, membernote.FieldMemberID)
}

// SetNote sets the "note" field.
func (m *MemberNoteMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MemberNoteMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *MemberNoteMutation) ClearNote() {
	m.note = nil
	m.clearedFields[membernote.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *MemberNoteMutation) NoteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *MemberNoteMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, membernote.FieldNote)
}

// SetNotesID sets the "notes" edge to the Member entity by id.
func (m *MemberNoteMutation) SetNotesID(id int64) {
	m.notes = &id
}

// ClearNotes clears the "notes" edge to the Member entity.
func (m *MemberNoteMutation) ClearNotes() {
	m.clearednotes = true
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// NotesCleared reports if the "notes" edge to the Member entity was cleared.
func (m *MemberNoteMutation) NotesCleared() bool {
	return m.MemberIDCleared() || m.clearednotes
}

// NotesID returns the "notes" edge ID in the mutation.
func (m *MemberNoteMutation) NotesID() (id int64, exists bool) {
	if m.notes != nil {
		return *m.notes, true
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotesID instead. It exists only for internal usage by the builders.
func (m *MemberNoteMutation) NotesIDs() (ids []int64) {
	if id := m.notes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *MemberNoteMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
}

// Where appends a list predicates to the MemberNoteMutation builder.
func (m *MemberNoteMutation) Where(ps ...predicate.MemberNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberNote).
func (m *MemberNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberNoteMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.note != nil {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.CreatedAt()
	case membernote.FieldUpdatedAt:
		return m.UpdatedAt()
	case membernote.FieldStatus:
		return m.Status()
	case membernote.FieldMemberID:
		return m.MemberID()
	case membernote.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membernote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membernote.FieldStatus:
		return m.OldStatus(ctx)
	case membernote.FieldMemberID:
		return m.OldMemberID(ctx)
	case membernote.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown MemberNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membernote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membernote.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membernote.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberNoteMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberNoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberNoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membernote.FieldStatus) {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.FieldCleared(membernote.FieldMemberID) {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.FieldCleared(membernote.FieldNote) {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberNoteMutation) ClearField(name string) error {
	switch name {
	case membernote.FieldStatus:
		m.ClearStatus()
		return nil
	case membernote.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membernote.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberNoteMutation) ResetField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membernote.FieldStatus:
		m.ResetStatus()
		return nil
	case membernote.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membernote.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.notes != nil {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membernote.EdgeNotes:
		if id := m.notes; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednotes {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case membernote.EdgeNotes:
		return m.clearednotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberNoteMutation) ClearEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberNoteMutation) ResetEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote edge %s", name)
}

// MemberProductMutation represents an operation that mutates the MemberProduct nodes in the graph.
type MemberProductMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	created_at                      *time.Time
	updated_at                      *time.Time
	status                          *int64
	addstatus                       *int64
	sn                              *string
	_type                           *string
	product_id                      *int64
	addproduct_id                   *int64
	venue_id                        *int64
	addvenue_id                     *int64
	order_id                        *int64
	addorder_id                     *int64
	name                            *string
	price                           *float64
	addprice                        *float64
	validity_at                     *time.Time
	cancel_at                       *time.Time
	clearedFields                   map[string]struct{}
	members                         *int64
	clearedmembers                  bool
	member_product_propertys        map[int64]struct{}
	removedmember_product_propertys map[int64]struct{}
	clearedmember_product_propertys bool
	member_product_entry            map[int64]struct{}
	removedmember_product_entry     map[int64]struct{}
	clearedmember_product_entry     bool
	member_product_contents         map[int64]struct{}
	removedmember_product_contents  map[int64]struct{}
	clearedmember_product_contents  bool
	done                            bool
	oldValue                        func(context.Context) (*MemberProduct, error)
	predicates                      []predicate.MemberProduct
}

var _ ent.Mutation = (*MemberProductMutation)(nil)

// memberproductOption allows management of the mutation configuration using functional options.
type memberproductOption func(*MemberProductMutation)

// newMemberProductMutation creates new mutation for the MemberProduct entity.
func newMemberProductMutation(c config, op Op, opts ...memberproductOption) *MemberProductMutation {
	m := &MemberProductMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProductID sets the ID field of the mutation.
func withMemberProductID(id int64) memberproductOption {
	return func(m *MemberProductMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProduct
		)
		m.oldValue = func(ctx context.Context) (*MemberProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProduct sets the old MemberProduct of the mutation.
func withMemberProduct(node *MemberProduct) memberproductOption {
	return func(m *MemberProductMutation) {
		m.oldValue = func(context.Context) (*MemberProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProduct entities.
func (m *MemberProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberProductMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberProductMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberProductMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberProductMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberProductMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[memberproduct.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberProductMutation) StatusCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, memberproduct.FieldStatus)
}

// SetSn sets the "sn" field.
func (m *MemberProductMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *MemberProductMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *MemberProductMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[memberproduct.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *MemberProductMutation) SnCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *MemberProductMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, memberproduct.FieldSn)
}

// SetType sets the "type" field.
func (m *MemberProductMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MemberProductMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MemberProductMutation) ClearType() {
	m._type = nil
	m.clearedFields[memberproduct.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MemberProductMutation) TypeCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MemberProductMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, memberproduct.FieldType)
}

// SetMemberID sets the "member_id" field.
func (m *MemberProductMutation) SetMemberID(i int64) {
	m.members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberProductMutation) MemberID() (r int64, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberProductMutation) ClearMemberID() {
	m.members = nil
	m.clearedFields[memberproduct.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberProductMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberProductMutation) ResetMemberID() {
	m.members = nil
	delete(m.clearedFields, memberproduct.FieldMemberID)
}

// SetProductID sets the "product_id" field.
func (m *MemberProductMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MemberProductMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *MemberProductMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *MemberProductMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *MemberProductMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[memberproduct.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *MemberProductMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MemberProductMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, memberproduct.FieldProductID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberProductMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberProductMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberProductMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberProductMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberProductMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[memberproduct.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberProductMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberProductMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, memberproduct.FieldVenueID)
}

// SetOrderID sets the "order_id" field.
func (m *MemberProductMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MemberProductMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *MemberProductMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *MemberProductMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MemberProductMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[memberproduct.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MemberProductMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MemberProductMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, memberproduct.FieldOrderID)
}

// SetName sets the "name" field.
func (m *MemberProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[memberproduct.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, memberproduct.FieldName)
}

// SetPrice sets the "price" field.
func (m *MemberProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MemberProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MemberProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MemberProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *MemberProductMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[memberproduct.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *MemberProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *MemberProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, memberproduct.FieldPrice)
}

// SetValidityAt sets the "validity_at" field.
func (m *MemberProductMutation) SetValidityAt(t time.Time) {
	m.validity_at = &t
}

// ValidityAt returns the value of the "validity_at" field in the mutation.
func (m *MemberProductMutation) ValidityAt() (r time.Time, exists bool) {
	v := m.validity_at
	if v == nil {
		return
	}
	return *v, true
}

// OldValidityAt returns the old "validity_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldValidityAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidityAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidityAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidityAt: %w", err)
	}
	return oldValue.ValidityAt, nil
}

// ClearValidityAt clears the value of the "validity_at" field.
func (m *MemberProductMutation) ClearValidityAt() {
	m.validity_at = nil
	m.clearedFields[memberproduct.FieldValidityAt] = struct{}{}
}

// ValidityAtCleared returns if the "validity_at" field was cleared in this mutation.
func (m *MemberProductMutation) ValidityAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldValidityAt]
	return ok
}

// ResetValidityAt resets all changes to the "validity_at" field.
func (m *MemberProductMutation) ResetValidityAt() {
	m.validity_at = nil
	delete(m.clearedFields, memberproduct.FieldValidityAt)
}

// SetCancelAt sets the "cancel_at" field.
func (m *MemberProductMutation) SetCancelAt(t time.Time) {
	m.cancel_at = &t
}

// CancelAt returns the value of the "cancel_at" field in the mutation.
func (m *MemberProductMutation) CancelAt() (r time.Time, exists bool) {
	v := m.cancel_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelAt returns the old "cancel_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCancelAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelAt: %w", err)
	}
	return oldValue.CancelAt, nil
}

// ClearCancelAt clears the value of the "cancel_at" field.
func (m *MemberProductMutation) ClearCancelAt() {
	m.cancel_at = nil
	m.clearedFields[memberproduct.FieldCancelAt] = struct{}{}
}

// CancelAtCleared returns if the "cancel_at" field was cleared in this mutation.
func (m *MemberProductMutation) CancelAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCancelAt]
	return ok
}

// ResetCancelAt resets all changes to the "cancel_at" field.
func (m *MemberProductMutation) ResetCancelAt() {
	m.cancel_at = nil
	delete(m.clearedFields, memberproduct.FieldCancelAt)
}

// SetMembersID sets the "members" edge to the Member entity by id.
func (m *MemberProductMutation) SetMembersID(id int64) {
	m.members = &id
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *MemberProductMutation) ClearMembers() {
	m.clearedmembers = true
	m.clearedFields[memberproduct.FieldMemberID] = struct{}{}
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *MemberProductMutation) MembersCleared() bool {
	return m.MemberIDCleared() || m.clearedmembers
}

// MembersID returns the "members" edge ID in the mutation.
func (m *MemberProductMutation) MembersID() (id int64, exists bool) {
	if m.members != nil {
		return *m.members, true
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MembersID instead. It exists only for internal usage by the builders.
func (m *MemberProductMutation) MembersIDs() (ids []int64) {
	if id := m.members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *MemberProductMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
}

// AddMemberProductPropertyIDs adds the "member_product_propertys" edge to the MemberProductProperty entity by ids.
func (m *MemberProductMutation) AddMemberProductPropertyIDs(ids ...int64) {
	if m.member_product_propertys == nil {
		m.member_product_propertys = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_product_propertys[ids[i]] = struct{}{}
	}
}

// ClearMemberProductPropertys clears the "member_product_propertys" edge to the MemberProductProperty entity.
func (m *MemberProductMutation) ClearMemberProductPropertys() {
	m.clearedmember_product_propertys = true
}

// MemberProductPropertysCleared reports if the "member_product_propertys" edge to the MemberProductProperty entity was cleared.
func (m *MemberProductMutation) MemberProductPropertysCleared() bool {
	return m.clearedmember_product_propertys
}

// RemoveMemberProductPropertyIDs removes the "member_product_propertys" edge to the MemberProductProperty entity by IDs.
func (m *MemberProductMutation) RemoveMemberProductPropertyIDs(ids ...int64) {
	if m.removedmember_product_propertys == nil {
		m.removedmember_product_propertys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_product_propertys, ids[i])
		m.removedmember_product_propertys[ids[i]] = struct{}{}
	}
}

// RemovedMemberProductPropertys returns the removed IDs of the "member_product_propertys" edge to the MemberProductProperty entity.
func (m *MemberProductMutation) RemovedMemberProductPropertysIDs() (ids []int64) {
	for id := range m.removedmember_product_propertys {
		ids = append(ids, id)
	}
	return
}

// MemberProductPropertysIDs returns the "member_product_propertys" edge IDs in the mutation.
func (m *MemberProductMutation) MemberProductPropertysIDs() (ids []int64) {
	for id := range m.member_product_propertys {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProductPropertys resets all changes to the "member_product_propertys" edge.
func (m *MemberProductMutation) ResetMemberProductPropertys() {
	m.member_product_propertys = nil
	m.clearedmember_product_propertys = false
	m.removedmember_product_propertys = nil
}

// AddMemberProductEntryIDs adds the "member_product_entry" edge to the EntryLogs entity by ids.
func (m *MemberProductMutation) AddMemberProductEntryIDs(ids ...int64) {
	if m.member_product_entry == nil {
		m.member_product_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_product_entry[ids[i]] = struct{}{}
	}
}

// ClearMemberProductEntry clears the "member_product_entry" edge to the EntryLogs entity.
func (m *MemberProductMutation) ClearMemberProductEntry() {
	m.clearedmember_product_entry = true
}

// MemberProductEntryCleared reports if the "member_product_entry" edge to the EntryLogs entity was cleared.
func (m *MemberProductMutation) MemberProductEntryCleared() bool {
	return m.clearedmember_product_entry
}

// RemoveMemberProductEntryIDs removes the "member_product_entry" edge to the EntryLogs entity by IDs.
func (m *MemberProductMutation) RemoveMemberProductEntryIDs(ids ...int64) {
	if m.removedmember_product_entry == nil {
		m.removedmember_product_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_product_entry, ids[i])
		m.removedmember_product_entry[ids[i]] = struct{}{}
	}
}

// RemovedMemberProductEntry returns the removed IDs of the "member_product_entry" edge to the EntryLogs entity.
func (m *MemberProductMutation) RemovedMemberProductEntryIDs() (ids []int64) {
	for id := range m.removedmember_product_entry {
		ids = append(ids, id)
	}
	return
}

// MemberProductEntryIDs returns the "member_product_entry" edge IDs in the mutation.
func (m *MemberProductMutation) MemberProductEntryIDs() (ids []int64) {
	for id := range m.member_product_entry {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProductEntry resets all changes to the "member_product_entry" edge.
func (m *MemberProductMutation) ResetMemberProductEntry() {
	m.member_product_entry = nil
	m.clearedmember_product_entry = false
	m.removedmember_product_entry = nil
}

// AddMemberProductContentIDs adds the "member_product_contents" edge to the MemberContract entity by ids.
func (m *MemberProductMutation) AddMemberProductContentIDs(ids ...int64) {
	if m.member_product_contents == nil {
		m.member_product_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_product_contents[ids[i]] = struct{}{}
	}
}

// ClearMemberProductContents clears the "member_product_contents" edge to the MemberContract entity.
func (m *MemberProductMutation) ClearMemberProductContents() {
	m.clearedmember_product_contents = true
}

// MemberProductContentsCleared reports if the "member_product_contents" edge to the MemberContract entity was cleared.
func (m *MemberProductMutation) MemberProductContentsCleared() bool {
	return m.clearedmember_product_contents
}

// RemoveMemberProductContentIDs removes the "member_product_contents" edge to the MemberContract entity by IDs.
func (m *MemberProductMutation) RemoveMemberProductContentIDs(ids ...int64) {
	if m.removedmember_product_contents == nil {
		m.removedmember_product_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_product_contents, ids[i])
		m.removedmember_product_contents[ids[i]] = struct{}{}
	}
}

// RemovedMemberProductContents returns the removed IDs of the "member_product_contents" edge to the MemberContract entity.
func (m *MemberProductMutation) RemovedMemberProductContentsIDs() (ids []int64) {
	for id := range m.removedmember_product_contents {
		ids = append(ids, id)
	}
	return
}

// MemberProductContentsIDs returns the "member_product_contents" edge IDs in the mutation.
func (m *MemberProductMutation) MemberProductContentsIDs() (ids []int64) {
	for id := range m.member_product_contents {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProductContents resets all changes to the "member_product_contents" edge.
func (m *MemberProductMutation) ResetMemberProductContents() {
	m.member_product_contents = nil
	m.clearedmember_product_contents = false
	m.removedmember_product_contents = nil
}

// Where appends a list predicates to the MemberProductMutation builder.
func (m *MemberProductMutation) Where(ps ...predicate.MemberProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProduct).
func (m *MemberProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProductMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, memberproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberproduct.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.sn != nil {
		fields = append(fields, memberproduct.FieldSn)
	}
	if m._type != nil {
		fields = append(fields, memberproduct.FieldType)
	}
	if m.members != nil {
		fields = append(fields, memberproduct.FieldMemberID)
	}
	if m.product_id != nil {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.venue_id != nil {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.order_id != nil {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.name != nil {
		fields = append(fields, memberproduct.FieldName)
	}
	if m.price != nil {
		fields = append(fields, memberproduct.FieldPrice)
	}
	if m.validity_at != nil {
		fields = append(fields, memberproduct.FieldValidityAt)
	}
	if m.cancel_at != nil {
		fields = append(fields, memberproduct.FieldCancelAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberproduct.FieldCreatedAt:
		return m.CreatedAt()
	case memberproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberproduct.FieldStatus:
		return m.Status()
	case memberproduct.FieldSn:
		return m.Sn()
	case memberproduct.FieldType:
		return m.GetType()
	case memberproduct.FieldMemberID:
		return m.MemberID()
	case memberproduct.FieldProductID:
		return m.ProductID()
	case memberproduct.FieldVenueID:
		return m.VenueID()
	case memberproduct.FieldOrderID:
		return m.OrderID()
	case memberproduct.FieldName:
		return m.Name()
	case memberproduct.FieldPrice:
		return m.Price()
	case memberproduct.FieldValidityAt:
		return m.ValidityAt()
	case memberproduct.FieldCancelAt:
		return m.CancelAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberproduct.FieldStatus:
		return m.OldStatus(ctx)
	case memberproduct.FieldSn:
		return m.OldSn(ctx)
	case memberproduct.FieldType:
		return m.OldType(ctx)
	case memberproduct.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberproduct.FieldProductID:
		return m.OldProductID(ctx)
	case memberproduct.FieldVenueID:
		return m.OldVenueID(ctx)
	case memberproduct.FieldOrderID:
		return m.OldOrderID(ctx)
	case memberproduct.FieldName:
		return m.OldName(ctx)
	case memberproduct.FieldPrice:
		return m.OldPrice(ctx)
	case memberproduct.FieldValidityAt:
		return m.OldValidityAt(ctx)
	case memberproduct.FieldCancelAt:
		return m.OldCancelAt(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberproduct.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case memberproduct.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case memberproduct.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case memberproduct.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberproduct.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case memberproduct.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case memberproduct.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case memberproduct.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case memberproduct.FieldValidityAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidityAt(v)
		return nil
	case memberproduct.FieldCancelAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelAt(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProductMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.addproduct_id != nil {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.addvenue_id != nil {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.addorder_id != nil {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.addprice != nil {
		fields = append(fields, memberproduct.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberproduct.FieldStatus:
		return m.AddedStatus()
	case memberproduct.FieldProductID:
		return m.AddedProductID()
	case memberproduct.FieldVenueID:
		return m.AddedVenueID()
	case memberproduct.FieldOrderID:
		return m.AddedOrderID()
	case memberproduct.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberproduct.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case memberproduct.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case memberproduct.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case memberproduct.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case memberproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberproduct.FieldStatus) {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.FieldCleared(memberproduct.FieldSn) {
		fields = append(fields, memberproduct.FieldSn)
	}
	if m.FieldCleared(memberproduct.FieldType) {
		fields = append(fields, memberproduct.FieldType)
	}
	if m.FieldCleared(memberproduct.FieldMemberID) {
		fields = append(fields, memberproduct.FieldMemberID)
	}
	if m.FieldCleared(memberproduct.FieldProductID) {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.FieldCleared(memberproduct.FieldVenueID) {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.FieldCleared(memberproduct.FieldOrderID) {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.FieldCleared(memberproduct.FieldName) {
		fields = append(fields, memberproduct.FieldName)
	}
	if m.FieldCleared(memberproduct.FieldPrice) {
		fields = append(fields, memberproduct.FieldPrice)
	}
	if m.FieldCleared(memberproduct.FieldValidityAt) {
		fields = append(fields, memberproduct.FieldValidityAt)
	}
	if m.FieldCleared(memberproduct.FieldCancelAt) {
		fields = append(fields, memberproduct.FieldCancelAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProductMutation) ClearField(name string) error {
	switch name {
	case memberproduct.FieldStatus:
		m.ClearStatus()
		return nil
	case memberproduct.FieldSn:
		m.ClearSn()
		return nil
	case memberproduct.FieldType:
		m.ClearType()
		return nil
	case memberproduct.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberproduct.FieldProductID:
		m.ClearProductID()
		return nil
	case memberproduct.FieldVenueID:
		m.ClearVenueID()
		return nil
	case memberproduct.FieldOrderID:
		m.ClearOrderID()
		return nil
	case memberproduct.FieldName:
		m.ClearName()
		return nil
	case memberproduct.FieldPrice:
		m.ClearPrice()
		return nil
	case memberproduct.FieldValidityAt:
		m.ClearValidityAt()
		return nil
	case memberproduct.FieldCancelAt:
		m.ClearCancelAt()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProductMutation) ResetField(name string) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberproduct.FieldStatus:
		m.ResetStatus()
		return nil
	case memberproduct.FieldSn:
		m.ResetSn()
		return nil
	case memberproduct.FieldType:
		m.ResetType()
		return nil
	case memberproduct.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberproduct.FieldProductID:
		m.ResetProductID()
		return nil
	case memberproduct.FieldVenueID:
		m.ResetVenueID()
		return nil
	case memberproduct.FieldOrderID:
		m.ResetOrderID()
		return nil
	case memberproduct.FieldName:
		m.ResetName()
		return nil
	case memberproduct.FieldPrice:
		m.ResetPrice()
		return nil
	case memberproduct.FieldValidityAt:
		m.ResetValidityAt()
		return nil
	case memberproduct.FieldCancelAt:
		m.ResetCancelAt()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.members != nil {
		edges = append(edges, memberproduct.EdgeMembers)
	}
	if m.member_product_propertys != nil {
		edges = append(edges, memberproduct.EdgeMemberProductPropertys)
	}
	if m.member_product_entry != nil {
		edges = append(edges, memberproduct.EdgeMemberProductEntry)
	}
	if m.member_product_contents != nil {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberproduct.EdgeMembers:
		if id := m.members; id != nil {
			return []ent.Value{*id}
		}
	case memberproduct.EdgeMemberProductPropertys:
		ids := make([]ent.Value, 0, len(m.member_product_propertys))
		for id := range m.member_product_propertys {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductEntry:
		ids := make([]ent.Value, 0, len(m.member_product_entry))
		for id := range m.member_product_entry {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductContents:
		ids := make([]ent.Value, 0, len(m.member_product_contents))
		for id := range m.member_product_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmember_product_propertys != nil {
		edges = append(edges, memberproduct.EdgeMemberProductPropertys)
	}
	if m.removedmember_product_entry != nil {
		edges = append(edges, memberproduct.EdgeMemberProductEntry)
	}
	if m.removedmember_product_contents != nil {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case memberproduct.EdgeMemberProductPropertys:
		ids := make([]ent.Value, 0, len(m.removedmember_product_propertys))
		for id := range m.removedmember_product_propertys {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductEntry:
		ids := make([]ent.Value, 0, len(m.removedmember_product_entry))
		for id := range m.removedmember_product_entry {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductContents:
		ids := make([]ent.Value, 0, len(m.removedmember_product_contents))
		for id := range m.removedmember_product_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmembers {
		edges = append(edges, memberproduct.EdgeMembers)
	}
	if m.clearedmember_product_propertys {
		edges = append(edges, memberproduct.EdgeMemberProductPropertys)
	}
	if m.clearedmember_product_entry {
		edges = append(edges, memberproduct.EdgeMemberProductEntry)
	}
	if m.clearedmember_product_contents {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProductMutation) EdgeCleared(name string) bool {
	switch name {
	case memberproduct.EdgeMembers:
		return m.clearedmembers
	case memberproduct.EdgeMemberProductPropertys:
		return m.clearedmember_product_propertys
	case memberproduct.EdgeMemberProductEntry:
		return m.clearedmember_product_entry
	case memberproduct.EdgeMemberProductContents:
		return m.clearedmember_product_contents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProductMutation) ClearEdge(name string) error {
	switch name {
	case memberproduct.EdgeMembers:
		m.ClearMembers()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProductMutation) ResetEdge(name string) error {
	switch name {
	case memberproduct.EdgeMembers:
		m.ResetMembers()
		return nil
	case memberproduct.EdgeMemberProductPropertys:
		m.ResetMemberProductPropertys()
		return nil
	case memberproduct.EdgeMemberProductEntry:
		m.ResetMemberProductEntry()
		return nil
	case memberproduct.EdgeMemberProductContents:
		m.ResetMemberProductContents()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct edge %s", name)
}

// MemberProductPropertyMutation represents an operation that mutates the MemberProductProperty nodes in the graph.
type MemberProductPropertyMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	status           *int64
	addstatus        *int64
	member_id        *int64
	addmember_id     *int64
	property_id      *int64
	addproperty_id   *int64
	_type            *string
	name             *string
	duration         *int64
	addduration      *int64
	length           *int64
	addlength        *int64
	count            *int64
	addcount         *int64
	count_surplus    *int64
	addcount_surplus *int64
	price            *float64
	addprice         *float64
	clearedFields    map[string]struct{}
	owner            *int64
	clearedowner     bool
	venues           map[int64]struct{}
	removedvenues    map[int64]struct{}
	clearedvenues    bool
	done             bool
	oldValue         func(context.Context) (*MemberProductProperty, error)
	predicates       []predicate.MemberProductProperty
}

var _ ent.Mutation = (*MemberProductPropertyMutation)(nil)

// memberproductpropertyOption allows management of the mutation configuration using functional options.
type memberproductpropertyOption func(*MemberProductPropertyMutation)

// newMemberProductPropertyMutation creates new mutation for the MemberProductProperty entity.
func newMemberProductPropertyMutation(c config, op Op, opts ...memberproductpropertyOption) *MemberProductPropertyMutation {
	m := &MemberProductPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProductProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProductPropertyID sets the ID field of the mutation.
func withMemberProductPropertyID(id int64) memberproductpropertyOption {
	return func(m *MemberProductPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProductProperty
		)
		m.oldValue = func(ctx context.Context) (*MemberProductProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProductProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProductProperty sets the old MemberProductProperty of the mutation.
func withMemberProductProperty(node *MemberProductProperty) memberproductpropertyOption {
	return func(m *MemberProductPropertyMutation) {
		m.oldValue = func(context.Context) (*MemberProductProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProductPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProductPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProductProperty entities.
func (m *MemberProductPropertyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProductPropertyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProductPropertyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProductProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProductPropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProductPropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProductPropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProductPropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProductPropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProductPropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *MemberProductPropertyMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberProductPropertyMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberProductPropertyMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberProductPropertyMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberProductPropertyMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[memberproductproperty.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberProductPropertyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, memberproductproperty.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberProductPropertyMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberProductPropertyMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *MemberProductPropertyMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *MemberProductPropertyMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberProductPropertyMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[memberproductproperty.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberProductPropertyMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, memberproductproperty.FieldMemberID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *MemberProductPropertyMutation) SetMemberProductID(i int64) {
	m.owner = &i
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *MemberProductPropertyMutation) MemberProductID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *MemberProductPropertyMutation) ClearMemberProductID() {
	m.owner = nil
	m.clearedFields[memberproductproperty.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *MemberProductPropertyMutation) ResetMemberProductID() {
	m.owner = nil
	delete(m.clearedFields, memberproductproperty.FieldMemberProductID)
}

// SetPropertyID sets the "property_id" field.
func (m *MemberProductPropertyMutation) SetPropertyID(i int64) {
	m.property_id = &i
	m.addproperty_id = nil
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *MemberProductPropertyMutation) PropertyID() (r int64, exists bool) {
	v := m.property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// AddPropertyID adds i to the "property_id" field.
func (m *MemberProductPropertyMutation) AddPropertyID(i int64) {
	if m.addproperty_id != nil {
		*m.addproperty_id += i
	} else {
		m.addproperty_id = &i
	}
}

// AddedPropertyID returns the value that was added to the "property_id" field in this mutation.
func (m *MemberProductPropertyMutation) AddedPropertyID() (r int64, exists bool) {
	v := m.addproperty_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPropertyID clears the value of the "property_id" field.
func (m *MemberProductPropertyMutation) ClearPropertyID() {
	m.property_id = nil
	m.addproperty_id = nil
	m.clearedFields[memberproductproperty.FieldPropertyID] = struct{}{}
}

// PropertyIDCleared returns if the "property_id" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) PropertyIDCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldPropertyID]
	return ok
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *MemberProductPropertyMutation) ResetPropertyID() {
	m.property_id = nil
	m.addproperty_id = nil
	delete(m.clearedFields, memberproductproperty.FieldPropertyID)
}

// SetType sets the "type" field.
func (m *MemberProductPropertyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MemberProductPropertyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MemberProductPropertyMutation) ClearType() {
	m._type = nil
	m.clearedFields[memberproductproperty.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) TypeCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MemberProductPropertyMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, memberproductproperty.FieldType)
}

// SetName sets the "name" field.
func (m *MemberProductPropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberProductPropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberProductPropertyMutation) ClearName() {
	m.name = nil
	m.clearedFields[memberproductproperty.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) NameCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberProductPropertyMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, memberproductproperty.FieldName)
}

// SetDuration sets the "duration" field.
func (m *MemberProductPropertyMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *MemberProductPropertyMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *MemberProductPropertyMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *MemberProductPropertyMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *MemberProductPropertyMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[memberproductproperty.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) DurationCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *MemberProductPropertyMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, memberproductproperty.FieldDuration)
}

// SetLength sets the "length" field.
func (m *MemberProductPropertyMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *MemberProductPropertyMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *MemberProductPropertyMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *MemberProductPropertyMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *MemberProductPropertyMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[memberproductproperty.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) LengthCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *MemberProductPropertyMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, memberproductproperty.FieldLength)
}

// SetCount sets the "count" field.
func (m *MemberProductPropertyMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *MemberProductPropertyMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *MemberProductPropertyMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *MemberProductPropertyMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *MemberProductPropertyMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[memberproductproperty.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) CountCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *MemberProductPropertyMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, memberproductproperty.FieldCount)
}

// SetCountSurplus sets the "count_surplus" field.
func (m *MemberProductPropertyMutation) SetCountSurplus(i int64) {
	m.count_surplus = &i
	m.addcount_surplus = nil
}

// CountSurplus returns the value of the "count_surplus" field in the mutation.
func (m *MemberProductPropertyMutation) CountSurplus() (r int64, exists bool) {
	v := m.count_surplus
	if v == nil {
		return
	}
	return *v, true
}

// OldCountSurplus returns the old "count_surplus" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCountSurplus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountSurplus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountSurplus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountSurplus: %w", err)
	}
	return oldValue.CountSurplus, nil
}

// AddCountSurplus adds i to the "count_surplus" field.
func (m *MemberProductPropertyMutation) AddCountSurplus(i int64) {
	if m.addcount_surplus != nil {
		*m.addcount_surplus += i
	} else {
		m.addcount_surplus = &i
	}
}

// AddedCountSurplus returns the value that was added to the "count_surplus" field in this mutation.
func (m *MemberProductPropertyMutation) AddedCountSurplus() (r int64, exists bool) {
	v := m.addcount_surplus
	if v == nil {
		return
	}
	return *v, true
}

// ClearCountSurplus clears the value of the "count_surplus" field.
func (m *MemberProductPropertyMutation) ClearCountSurplus() {
	m.count_surplus = nil
	m.addcount_surplus = nil
	m.clearedFields[memberproductproperty.FieldCountSurplus] = struct{}{}
}

// CountSurplusCleared returns if the "count_surplus" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) CountSurplusCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldCountSurplus]
	return ok
}

// ResetCountSurplus resets all changes to the "count_surplus" field.
func (m *MemberProductPropertyMutation) ResetCountSurplus() {
	m.count_surplus = nil
	m.addcount_surplus = nil
	delete(m.clearedFields, memberproductproperty.FieldCountSurplus)
}

// SetPrice sets the "price" field.
func (m *MemberProductPropertyMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MemberProductPropertyMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MemberProductPropertyMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MemberProductPropertyMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *MemberProductPropertyMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[memberproductproperty.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) PriceCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *MemberProductPropertyMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, memberproductproperty.FieldPrice)
}

// SetOwnerID sets the "owner" edge to the MemberProduct entity by id.
func (m *MemberProductPropertyMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the MemberProduct entity.
func (m *MemberProductPropertyMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[memberproductproperty.FieldMemberProductID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the MemberProduct entity was cleared.
func (m *MemberProductPropertyMutation) OwnerCleared() bool {
	return m.MemberProductIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MemberProductPropertyMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MemberProductPropertyMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MemberProductPropertyMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddVenueIDs adds the "venues" edge to the Venue entity by ids.
func (m *MemberProductPropertyMutation) AddVenueIDs(ids ...int64) {
	if m.venues == nil {
		m.venues = make(map[int64]struct{})
	}
	for i := range ids {
		m.venues[ids[i]] = struct{}{}
	}
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *MemberProductPropertyMutation) ClearVenues() {
	m.clearedvenues = true
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *MemberProductPropertyMutation) VenuesCleared() bool {
	return m.clearedvenues
}

// RemoveVenueIDs removes the "venues" edge to the Venue entity by IDs.
func (m *MemberProductPropertyMutation) RemoveVenueIDs(ids ...int64) {
	if m.removedvenues == nil {
		m.removedvenues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venues, ids[i])
		m.removedvenues[ids[i]] = struct{}{}
	}
}

// RemovedVenues returns the removed IDs of the "venues" edge to the Venue entity.
func (m *MemberProductPropertyMutation) RemovedVenuesIDs() (ids []int64) {
	for id := range m.removedvenues {
		ids = append(ids, id)
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
func (m *MemberProductPropertyMutation) VenuesIDs() (ids []int64) {
	for id := range m.venues {
		ids = append(ids, id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *MemberProductPropertyMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
	m.removedvenues = nil
}

// Where appends a list predicates to the MemberProductPropertyMutation builder.
func (m *MemberProductPropertyMutation) Where(ps ...predicate.MemberProductProperty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProductPropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProductPropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProductProperty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProductPropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProductPropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProductProperty).
func (m *MemberProductPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProductPropertyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, memberproductproperty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberproductproperty.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, memberproductproperty.FieldStatus)
	}
	if m.member_id != nil {
		fields = append(fields, memberproductproperty.FieldMemberID)
	}
	if m.owner != nil {
		fields = append(fields, memberproductproperty.FieldMemberProductID)
	}
	if m.property_id != nil {
		fields = append(fields, memberproductproperty.FieldPropertyID)
	}
	if m._type != nil {
		fields = append(fields, memberproductproperty.FieldType)
	}
	if m.name != nil {
		fields = append(fields, memberproductproperty.FieldName)
	}
	if m.duration != nil {
		fields = append(fields, memberproductproperty.FieldDuration)
	}
	if m.length != nil {
		fields = append(fields, memberproductproperty.FieldLength)
	}
	if m.count != nil {
		fields = append(fields, memberproductproperty.FieldCount)
	}
	if m.count_surplus != nil {
		fields = append(fields, memberproductproperty.FieldCountSurplus)
	}
	if m.price != nil {
		fields = append(fields, memberproductproperty.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProductPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		return m.CreatedAt()
	case memberproductproperty.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberproductproperty.FieldStatus:
		return m.Status()
	case memberproductproperty.FieldMemberID:
		return m.MemberID()
	case memberproductproperty.FieldMemberProductID:
		return m.MemberProductID()
	case memberproductproperty.FieldPropertyID:
		return m.PropertyID()
	case memberproductproperty.FieldType:
		return m.GetType()
	case memberproductproperty.FieldName:
		return m.Name()
	case memberproductproperty.FieldDuration:
		return m.Duration()
	case memberproductproperty.FieldLength:
		return m.Length()
	case memberproductproperty.FieldCount:
		return m.Count()
	case memberproductproperty.FieldCountSurplus:
		return m.CountSurplus()
	case memberproductproperty.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProductPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberproductproperty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberproductproperty.FieldStatus:
		return m.OldStatus(ctx)
	case memberproductproperty.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberproductproperty.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case memberproductproperty.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case memberproductproperty.FieldType:
		return m.OldType(ctx)
	case memberproductproperty.FieldName:
		return m.OldName(ctx)
	case memberproductproperty.FieldDuration:
		return m.OldDuration(ctx)
	case memberproductproperty.FieldLength:
		return m.OldLength(ctx)
	case memberproductproperty.FieldCount:
		return m.OldCount(ctx)
	case memberproductproperty.FieldCountSurplus:
		return m.OldCountSurplus(ctx)
	case memberproductproperty.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProductProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberproductproperty.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberproductproperty.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case memberproductproperty.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberproductproperty.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case memberproductproperty.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case memberproductproperty.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case memberproductproperty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberproductproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case memberproductproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case memberproductproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case memberproductproperty.FieldCountSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountSurplus(v)
		return nil
	case memberproductproperty.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProductPropertyMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, memberproductproperty.FieldStatus)
	}
	if m.addmember_id != nil {
		fields = append(fields, memberproductproperty.FieldMemberID)
	}
	if m.addproperty_id != nil {
		fields = append(fields, memberproductproperty.FieldPropertyID)
	}
	if m.addduration != nil {
		fields = append(fields, memberproductproperty.FieldDuration)
	}
	if m.addlength != nil {
		fields = append(fields, memberproductproperty.FieldLength)
	}
	if m.addcount != nil {
		fields = append(fields, memberproductproperty.FieldCount)
	}
	if m.addcount_surplus != nil {
		fields = append(fields, memberproductproperty.FieldCountSurplus)
	}
	if m.addprice != nil {
		fields = append(fields, memberproductproperty.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProductPropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberproductproperty.FieldStatus:
		return m.AddedStatus()
	case memberproductproperty.FieldMemberID:
		return m.AddedMemberID()
	case memberproductproperty.FieldPropertyID:
		return m.AddedPropertyID()
	case memberproductproperty.FieldDuration:
		return m.AddedDuration()
	case memberproductproperty.FieldLength:
		return m.AddedLength()
	case memberproductproperty.FieldCount:
		return m.AddedCount()
	case memberproductproperty.FieldCountSurplus:
		return m.AddedCountSurplus()
	case memberproductproperty.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberproductproperty.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case memberproductproperty.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case memberproductproperty.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPropertyID(v)
		return nil
	case memberproductproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case memberproductproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case memberproductproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case memberproductproperty.FieldCountSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCountSurplus(v)
		return nil
	case memberproductproperty.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProductPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberproductproperty.FieldStatus) {
		fields = append(fields, memberproductproperty.FieldStatus)
	}
	if m.FieldCleared(memberproductproperty.FieldMemberID) {
		fields = append(fields, memberproductproperty.FieldMemberID)
	}
	if m.FieldCleared(memberproductproperty.FieldMemberProductID) {
		fields = append(fields, memberproductproperty.FieldMemberProductID)
	}
	if m.FieldCleared(memberproductproperty.FieldPropertyID) {
		fields = append(fields, memberproductproperty.FieldPropertyID)
	}
	if m.FieldCleared(memberproductproperty.FieldType) {
		fields = append(fields, memberproductproperty.FieldType)
	}
	if m.FieldCleared(memberproductproperty.FieldName) {
		fields = append(fields, memberproductproperty.FieldName)
	}
	if m.FieldCleared(memberproductproperty.FieldDuration) {
		fields = append(fields, memberproductproperty.FieldDuration)
	}
	if m.FieldCleared(memberproductproperty.FieldLength) {
		fields = append(fields, memberproductproperty.FieldLength)
	}
	if m.FieldCleared(memberproductproperty.FieldCount) {
		fields = append(fields, memberproductproperty.FieldCount)
	}
	if m.FieldCleared(memberproductproperty.FieldCountSurplus) {
		fields = append(fields, memberproductproperty.FieldCountSurplus)
	}
	if m.FieldCleared(memberproductproperty.FieldPrice) {
		fields = append(fields, memberproductproperty.FieldPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProductPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProductPropertyMutation) ClearField(name string) error {
	switch name {
	case memberproductproperty.FieldStatus:
		m.ClearStatus()
		return nil
	case memberproductproperty.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberproductproperty.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case memberproductproperty.FieldPropertyID:
		m.ClearPropertyID()
		return nil
	case memberproductproperty.FieldType:
		m.ClearType()
		return nil
	case memberproductproperty.FieldName:
		m.ClearName()
		return nil
	case memberproductproperty.FieldDuration:
		m.ClearDuration()
		return nil
	case memberproductproperty.FieldLength:
		m.ClearLength()
		return nil
	case memberproductproperty.FieldCount:
		m.ClearCount()
		return nil
	case memberproductproperty.FieldCountSurplus:
		m.ClearCountSurplus()
		return nil
	case memberproductproperty.FieldPrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProductPropertyMutation) ResetField(name string) error {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberproductproperty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberproductproperty.FieldStatus:
		m.ResetStatus()
		return nil
	case memberproductproperty.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberproductproperty.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case memberproductproperty.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case memberproductproperty.FieldType:
		m.ResetType()
		return nil
	case memberproductproperty.FieldName:
		m.ResetName()
		return nil
	case memberproductproperty.FieldDuration:
		m.ResetDuration()
		return nil
	case memberproductproperty.FieldLength:
		m.ResetLength()
		return nil
	case memberproductproperty.FieldCount:
		m.ResetCount()
		return nil
	case memberproductproperty.FieldCountSurplus:
		m.ResetCountSurplus()
		return nil
	case memberproductproperty.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProductPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, memberproductproperty.EdgeOwner)
	}
	if m.venues != nil {
		edges = append(edges, memberproductproperty.EdgeVenues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProductPropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberproductproperty.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case memberproductproperty.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.venues))
		for id := range m.venues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProductPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvenues != nil {
		edges = append(edges, memberproductproperty.EdgeVenues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProductPropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case memberproductproperty.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.removedvenues))
		for id := range m.removedvenues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProductPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, memberproductproperty.EdgeOwner)
	}
	if m.clearedvenues {
		edges = append(edges, memberproductproperty.EdgeVenues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProductPropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case memberproductproperty.EdgeOwner:
		return m.clearedowner
	case memberproductproperty.EdgeVenues:
		return m.clearedvenues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProductPropertyMutation) ClearEdge(name string) error {
	switch name {
	case memberproductproperty.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProductPropertyMutation) ResetEdge(name string) error {
	switch name {
	case memberproductproperty.EdgeOwner:
		m.ResetOwner()
		return nil
	case memberproductproperty.EdgeVenues:
		m.ResetVenues()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	_path           *string
	name            *string
	order_no        *int32
	addorder_no     *int32
	disabled        *int32
	adddisabled     *int32
	clearedFields   map[string]struct{}
	roles           map[int64]struct{}
	removedroles    map[int64]struct{}
	clearedroles    bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	params          map[int64]struct{}
	removedparams   map[int64]struct{}
	clearedparams   bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetOrderNo sets the "order_no" field.
func (m *MenuMutation) SetOrderNo(i int32) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *MenuMutation) OrderNo() (r int32, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldOrderNo(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *MenuMutation) AddOrderNo(i int32) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *MenuMutation) AddedOrderNo() (r int32, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *MenuMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetDisabled sets the "disabled" field.
func (m *MenuMutation) SetDisabled(i int32) {
	m.disabled = &i
	m.adddisabled = nil
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *MenuMutation) Disabled() (r int32, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDisabled(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// AddDisabled adds i to the "disabled" field.
func (m *MenuMutation) AddDisabled(i int32) {
	if m.adddisabled != nil {
		*m.adddisabled += i
	} else {
		m.adddisabled = &i
	}
}

// AddedDisabled returns the value that was added to the "disabled" field in this mutation.
func (m *MenuMutation) AddedDisabled() (r int32, exists bool) {
	v := m.adddisabled
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisabled clears the value of the "disabled" field.
func (m *MenuMutation) ClearDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	m.clearedFields[menu.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *MenuMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[menu.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *MenuMutation) ResetDisabled() {
	m.disabled = nil
	m.adddisabled = nil
	delete(m.clearedFields, menu.FieldDisabled)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddParamIDs adds the "params" edge to the MenuParam entity by ids.
func (m *MenuMutation) AddParamIDs(ids ...int64) {
	if m.params == nil {
		m.params = make(map[int64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the MenuParam entity.
func (m *MenuMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the MenuParam entity was cleared.
func (m *MenuMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the MenuParam entity by IDs.
func (m *MenuMutation) RemoveParamIDs(ids ...int64) {
	if m.removedparams == nil {
		m.removedparams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the MenuParam entity.
func (m *MenuMutation) RemovedParamsIDs() (ids []int64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *MenuMutation) ParamsIDs() (ids []int64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *MenuMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.order_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.disabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldOrderNo:
		return m.OrderNo()
	case menu.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case menu.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addorder_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.adddisabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldOrderNo:
		return m.AddedOrderNo()
	case menu.FieldDisabled:
		return m.AddedDisabled()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldDisabled) {
		fields = append(fields, menu.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case menu.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.params != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedparams != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedparams {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeParams:
		return m.clearedparams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuParamMutation represents an operation that mutates the MenuParam nodes in the graph.
type MenuParamMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	key           *string
	value         *string
	clearedFields map[string]struct{}
	menus         *int64
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*MenuParam, error)
	predicates    []predicate.MenuParam
}

var _ ent.Mutation = (*MenuParamMutation)(nil)

// menuparamOption allows management of the mutation configuration using functional options.
type menuparamOption func(*MenuParamMutation)

// newMenuParamMutation creates new mutation for the MenuParam entity.
func newMenuParamMutation(c config, op Op, opts ...menuparamOption) *MenuParamMutation {
	m := &MenuParamMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuParamID sets the ID field of the mutation.
func withMenuParamID(id int64) menuparamOption {
	return func(m *MenuParamMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuParam
		)
		m.oldValue = func(ctx context.Context) (*MenuParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuParam sets the old MenuParam of the mutation.
func withMenuParam(node *MenuParam) menuparamOption {
	return func(m *MenuParamMutation) {
		m.oldValue = func(context.Context) (*MenuParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuParam entities.
func (m *MenuParamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuParamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuParamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuParamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *MenuParamMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuParamMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MenuParamMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *MenuParamMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *MenuParamMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *MenuParamMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *MenuParamMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MenuParamMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MenuParamMutation) ResetValue() {
	m.value = nil
}

// SetMenusID sets the "menus" edge to the Menu entity by id.
func (m *MenuParamMutation) SetMenusID(id int64) {
	m.menus = &id
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *MenuParamMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *MenuParamMutation) MenusCleared() bool {
	return m.clearedmenus
}

// MenusID returns the "menus" edge ID in the mutation.
func (m *MenuParamMutation) MenusID() (id int64, exists bool) {
	if m.menus != nil {
		return *m.menus, true
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenusID instead. It exists only for internal usage by the builders.
func (m *MenuParamMutation) MenusIDs() (ids []int64) {
	if id := m.menus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *MenuParamMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
}

// Where appends a list predicates to the MenuParamMutation builder.
func (m *MenuParamMutation) Where(ps ...predicate.MenuParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuParam).
func (m *MenuParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuParamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, menuparam.FieldType)
	}
	if m.key != nil {
		fields = append(fields, menuparam.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, menuparam.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.CreatedAt()
	case menuparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuparam.FieldType:
		return m.GetType()
	case menuparam.FieldKey:
		return m.Key()
	case menuparam.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuparam.FieldType:
		return m.OldType(ctx)
	case menuparam.FieldKey:
		return m.OldKey(ctx)
	case menuparam.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown MenuParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuparam.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menuparam.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case menuparam.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuParamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuParamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MenuParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuParamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuParamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MenuParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuParamMutation) ResetField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuparam.FieldType:
		m.ResetType()
		return nil
	case menuparam.FieldKey:
		m.ResetKey()
		return nil
	case menuparam.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuparam.EdgeMenus:
		if id := m.menus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuParamMutation) EdgeCleared(name string) bool {
	switch name {
	case menuparam.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuParamMutation) ClearEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ClearMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuParamMutation) ResetEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam edge %s", name)
}

// MessagesMutation represents an operation that mutates the Messages nodes in the graph.
type MessagesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	to_user_id    *string
	from_user_id  *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Messages, error)
	predicates    []predicate.Messages
}

var _ ent.Mutation = (*MessagesMutation)(nil)

// messagesOption allows management of the mutation configuration using functional options.
type messagesOption func(*MessagesMutation)

// newMessagesMutation creates new mutation for the Messages entity.
func newMessagesMutation(c config, op Op, opts ...messagesOption) *MessagesMutation {
	m := &MessagesMutation{
		config:        c,
		op:            op,
		typ:           TypeMessages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesID sets the ID field of the mutation.
func withMessagesID(id int64) messagesOption {
	return func(m *MessagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Messages
		)
		m.oldValue = func(ctx context.Context) (*Messages, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Messages.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessages sets the old Messages of the mutation.
func withMessages(node *Messages) messagesOption {
	return func(m *MessagesMutation) {
		m.oldValue = func(context.Context) (*Messages, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Messages entities.
func (m *MessagesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Messages.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *MessagesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessagesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessagesMutation) ResetType() {
	m._type = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *MessagesMutation) SetToUserID(s string) {
	m.to_user_id = &s
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *MessagesMutation) ToUserID() (r string, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldToUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *MessagesMutation) ResetToUserID() {
	m.to_user_id = nil
}

// SetFromUserID sets the "from_user_id" field.
func (m *MessagesMutation) SetFromUserID(s string) {
	m.from_user_id = &s
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *MessagesMutation) FromUserID() (r string, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldFromUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *MessagesMutation) ResetFromUserID() {
	m.from_user_id = nil
}

// SetContent sets the "content" field.
func (m *MessagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessagesMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the MessagesMutation builder.
func (m *MessagesMutation) Where(ps ...predicate.Messages) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Messages, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Messages).
func (m *MessagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, messages.FieldType)
	}
	if m.to_user_id != nil {
		fields = append(fields, messages.FieldToUserID)
	}
	if m.from_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.content != nil {
		fields = append(fields, messages.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldCreatedAt:
		return m.CreatedAt()
	case messages.FieldUpdatedAt:
		return m.UpdatedAt()
	case messages.FieldType:
		return m.GetType()
	case messages.FieldToUserID:
		return m.ToUserID()
	case messages.FieldFromUserID:
		return m.FromUserID()
	case messages.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messages.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messages.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messages.FieldType:
		return m.OldType(ctx)
	case messages.FieldToUserID:
		return m.OldToUserID(ctx)
	case messages.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case messages.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Messages field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messages.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messages.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messages.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case messages.FieldToUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case messages.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Messages numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Messages nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesMutation) ResetField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messages.FieldType:
		m.ResetType()
		return nil
	case messages.FieldToUserID:
		m.ResetToUserID()
		return nil
	case messages.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case messages.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Messages unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Messages edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	order_sn              *string
	member_product_id     *int64
	addmember_product_id  *int64
	status                *int64
	addstatus             *int64
	source                *string
	device                *string
	nature                *int64
	addnature             *int64
	completion_at         *time.Time
	clearedFields         map[string]struct{}
	amount                map[int64]struct{}
	removedamount         map[int64]struct{}
	clearedamount         bool
	item                  map[int64]struct{}
	removeditem           map[int64]struct{}
	cleareditem           bool
	pay                   map[int64]struct{}
	removedpay            map[int64]struct{}
	clearedpay            bool
	order_contents        map[int64]struct{}
	removedorder_contents map[int64]struct{}
	clearedorder_contents bool
	sales                 map[int64]struct{}
	removedsales          map[int64]struct{}
	clearedsales          bool
	order_venues          *int64
	clearedorder_venues   bool
	order_members         *int64
	clearedorder_members  bool
	order_creates         *int64
	clearedorder_creates  bool
	done                  bool
	oldValue              func(context.Context) (*Order, error)
	predicates            []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderSn sets the "order_sn" field.
func (m *OrderMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *OrderMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *OrderMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[order.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *OrderMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[order.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *OrderMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, order.FieldOrderSn)
}

// SetVenueID sets the "venue_id" field.
func (m *OrderMutation) SetVenueID(i int64) {
	m.order_venues = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *OrderMutation) VenueID() (r int64, exists bool) {
	v := m.order_venues
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *OrderMutation) ClearVenueID() {
	m.order_venues = nil
	m.clearedFields[order.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *OrderMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[order.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *OrderMutation) ResetVenueID() {
	m.order_venues = nil
	delete(m.clearedFields, order.FieldVenueID)
}

// SetMemberID sets the "member_id" field.
func (m *OrderMutation) SetMemberID(i int64) {
	m.order_members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OrderMutation) MemberID() (r int64, exists bool) {
	v := m.order_members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *OrderMutation) ClearMemberID() {
	m.order_members = nil
	m.clearedFields[order.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *OrderMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[order.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OrderMutation) ResetMemberID() {
	m.order_members = nil
	delete(m.clearedFields, order.FieldMemberID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *OrderMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *OrderMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *OrderMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *OrderMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *OrderMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[order.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *OrderMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[order.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *OrderMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, order.FieldMemberProductID)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[order.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[order.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, order.FieldStatus)
}

// SetSource sets the "source" field.
func (m *OrderMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *OrderMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *OrderMutation) ClearSource() {
	m.source = nil
	m.clearedFields[order.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *OrderMutation) SourceCleared() bool {
	_, ok := m.clearedFields[order.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *OrderMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, order.FieldSource)
}

// SetDevice sets the "device" field.
func (m *OrderMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *OrderMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *OrderMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[order.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *OrderMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[order.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *OrderMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, order.FieldDevice)
}

// SetNature sets the "nature" field.
func (m *OrderMutation) SetNature(i int64) {
	m.nature = &i
	m.addnature = nil
}

// Nature returns the value of the "nature" field in the mutation.
func (m *OrderMutation) Nature() (r int64, exists bool) {
	v := m.nature
	if v == nil {
		return
	}
	return *v, true
}

// OldNature returns the old "nature" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNature(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNature: %w", err)
	}
	return oldValue.Nature, nil
}

// AddNature adds i to the "nature" field.
func (m *OrderMutation) AddNature(i int64) {
	if m.addnature != nil {
		*m.addnature += i
	} else {
		m.addnature = &i
	}
}

// AddedNature returns the value that was added to the "nature" field in this mutation.
func (m *OrderMutation) AddedNature() (r int64, exists bool) {
	v := m.addnature
	if v == nil {
		return
	}
	return *v, true
}

// ClearNature clears the value of the "nature" field.
func (m *OrderMutation) ClearNature() {
	m.nature = nil
	m.addnature = nil
	m.clearedFields[order.FieldNature] = struct{}{}
}

// NatureCleared returns if the "nature" field was cleared in this mutation.
func (m *OrderMutation) NatureCleared() bool {
	_, ok := m.clearedFields[order.FieldNature]
	return ok
}

// ResetNature resets all changes to the "nature" field.
func (m *OrderMutation) ResetNature() {
	m.nature = nil
	m.addnature = nil
	delete(m.clearedFields, order.FieldNature)
}

// SetCompletionAt sets the "completion_at" field.
func (m *OrderMutation) SetCompletionAt(t time.Time) {
	m.completion_at = &t
}

// CompletionAt returns the value of the "completion_at" field in the mutation.
func (m *OrderMutation) CompletionAt() (r time.Time, exists bool) {
	v := m.completion_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAt returns the old "completion_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCompletionAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAt: %w", err)
	}
	return oldValue.CompletionAt, nil
}

// ClearCompletionAt clears the value of the "completion_at" field.
func (m *OrderMutation) ClearCompletionAt() {
	m.completion_at = nil
	m.clearedFields[order.FieldCompletionAt] = struct{}{}
}

// CompletionAtCleared returns if the "completion_at" field was cleared in this mutation.
func (m *OrderMutation) CompletionAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCompletionAt]
	return ok
}

// ResetCompletionAt resets all changes to the "completion_at" field.
func (m *OrderMutation) ResetCompletionAt() {
	m.completion_at = nil
	delete(m.clearedFields, order.FieldCompletionAt)
}

// SetCreateID sets the "create_id" field.
func (m *OrderMutation) SetCreateID(i int64) {
	m.order_creates = &i
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *OrderMutation) CreateID() (r int64, exists bool) {
	v := m.order_creates
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// ClearCreateID clears the value of the "create_id" field.
func (m *OrderMutation) ClearCreateID() {
	m.order_creates = nil
	m.clearedFields[order.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *OrderMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[order.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *OrderMutation) ResetCreateID() {
	m.order_creates = nil
	delete(m.clearedFields, order.FieldCreateID)
}

// AddAmountIDs adds the "amount" edge to the OrderAmount entity by ids.
func (m *OrderMutation) AddAmountIDs(ids ...int64) {
	if m.amount == nil {
		m.amount = make(map[int64]struct{})
	}
	for i := range ids {
		m.amount[ids[i]] = struct{}{}
	}
}

// ClearAmount clears the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) ClearAmount() {
	m.clearedamount = true
}

// AmountCleared reports if the "amount" edge to the OrderAmount entity was cleared.
func (m *OrderMutation) AmountCleared() bool {
	return m.clearedamount
}

// RemoveAmountIDs removes the "amount" edge to the OrderAmount entity by IDs.
func (m *OrderMutation) RemoveAmountIDs(ids ...int64) {
	if m.removedamount == nil {
		m.removedamount = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.amount, ids[i])
		m.removedamount[ids[i]] = struct{}{}
	}
}

// RemovedAmount returns the removed IDs of the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) RemovedAmountIDs() (ids []int64) {
	for id := range m.removedamount {
		ids = append(ids, id)
	}
	return
}

// AmountIDs returns the "amount" edge IDs in the mutation.
func (m *OrderMutation) AmountIDs() (ids []int64) {
	for id := range m.amount {
		ids = append(ids, id)
	}
	return
}

// ResetAmount resets all changes to the "amount" edge.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.clearedamount = false
	m.removedamount = nil
}

// AddItemIDs adds the "item" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddItemIDs(ids ...int64) {
	if m.item == nil {
		m.item = make(map[int64]struct{})
	}
	for i := range ids {
		m.item[ids[i]] = struct{}{}
	}
}

// ClearItem clears the "item" edge to the OrderItem entity.
func (m *OrderMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the OrderItem entity was cleared.
func (m *OrderMutation) ItemCleared() bool {
	return m.cleareditem
}

// RemoveItemIDs removes the "item" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveItemIDs(ids ...int64) {
	if m.removeditem == nil {
		m.removeditem = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.item, ids[i])
		m.removeditem[ids[i]] = struct{}{}
	}
}

// RemovedItem returns the removed IDs of the "item" edge to the OrderItem entity.
func (m *OrderMutation) RemovedItemIDs() (ids []int64) {
	for id := range m.removeditem {
		ids = append(ids, id)
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
func (m *OrderMutation) ItemIDs() (ids []int64) {
	for id := range m.item {
		ids = append(ids, id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *OrderMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
	m.removeditem = nil
}

// AddPayIDs adds the "pay" edge to the OrderPay entity by ids.
func (m *OrderMutation) AddPayIDs(ids ...int64) {
	if m.pay == nil {
		m.pay = make(map[int64]struct{})
	}
	for i := range ids {
		m.pay[ids[i]] = struct{}{}
	}
}

// ClearPay clears the "pay" edge to the OrderPay entity.
func (m *OrderMutation) ClearPay() {
	m.clearedpay = true
}

// PayCleared reports if the "pay" edge to the OrderPay entity was cleared.
func (m *OrderMutation) PayCleared() bool {
	return m.clearedpay
}

// RemovePayIDs removes the "pay" edge to the OrderPay entity by IDs.
func (m *OrderMutation) RemovePayIDs(ids ...int64) {
	if m.removedpay == nil {
		m.removedpay = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.pay, ids[i])
		m.removedpay[ids[i]] = struct{}{}
	}
}

// RemovedPay returns the removed IDs of the "pay" edge to the OrderPay entity.
func (m *OrderMutation) RemovedPayIDs() (ids []int64) {
	for id := range m.removedpay {
		ids = append(ids, id)
	}
	return
}

// PayIDs returns the "pay" edge IDs in the mutation.
func (m *OrderMutation) PayIDs() (ids []int64) {
	for id := range m.pay {
		ids = append(ids, id)
	}
	return
}

// ResetPay resets all changes to the "pay" edge.
func (m *OrderMutation) ResetPay() {
	m.pay = nil
	m.clearedpay = false
	m.removedpay = nil
}

// AddOrderContentIDs adds the "order_contents" edge to the MemberContract entity by ids.
func (m *OrderMutation) AddOrderContentIDs(ids ...int64) {
	if m.order_contents == nil {
		m.order_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_contents[ids[i]] = struct{}{}
	}
}

// ClearOrderContents clears the "order_contents" edge to the MemberContract entity.
func (m *OrderMutation) ClearOrderContents() {
	m.clearedorder_contents = true
}

// OrderContentsCleared reports if the "order_contents" edge to the MemberContract entity was cleared.
func (m *OrderMutation) OrderContentsCleared() bool {
	return m.clearedorder_contents
}

// RemoveOrderContentIDs removes the "order_contents" edge to the MemberContract entity by IDs.
func (m *OrderMutation) RemoveOrderContentIDs(ids ...int64) {
	if m.removedorder_contents == nil {
		m.removedorder_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_contents, ids[i])
		m.removedorder_contents[ids[i]] = struct{}{}
	}
}

// RemovedOrderContents returns the removed IDs of the "order_contents" edge to the MemberContract entity.
func (m *OrderMutation) RemovedOrderContentsIDs() (ids []int64) {
	for id := range m.removedorder_contents {
		ids = append(ids, id)
	}
	return
}

// OrderContentsIDs returns the "order_contents" edge IDs in the mutation.
func (m *OrderMutation) OrderContentsIDs() (ids []int64) {
	for id := range m.order_contents {
		ids = append(ids, id)
	}
	return
}

// ResetOrderContents resets all changes to the "order_contents" edge.
func (m *OrderMutation) ResetOrderContents() {
	m.order_contents = nil
	m.clearedorder_contents = false
	m.removedorder_contents = nil
}

// AddSaleIDs adds the "sales" edge to the OrderSales entity by ids.
func (m *OrderMutation) AddSaleIDs(ids ...int64) {
	if m.sales == nil {
		m.sales = make(map[int64]struct{})
	}
	for i := range ids {
		m.sales[ids[i]] = struct{}{}
	}
}

// ClearSales clears the "sales" edge to the OrderSales entity.
func (m *OrderMutation) ClearSales() {
	m.clearedsales = true
}

// SalesCleared reports if the "sales" edge to the OrderSales entity was cleared.
func (m *OrderMutation) SalesCleared() bool {
	return m.clearedsales
}

// RemoveSaleIDs removes the "sales" edge to the OrderSales entity by IDs.
func (m *OrderMutation) RemoveSaleIDs(ids ...int64) {
	if m.removedsales == nil {
		m.removedsales = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sales, ids[i])
		m.removedsales[ids[i]] = struct{}{}
	}
}

// RemovedSales returns the removed IDs of the "sales" edge to the OrderSales entity.
func (m *OrderMutation) RemovedSalesIDs() (ids []int64) {
	for id := range m.removedsales {
		ids = append(ids, id)
	}
	return
}

// SalesIDs returns the "sales" edge IDs in the mutation.
func (m *OrderMutation) SalesIDs() (ids []int64) {
	for id := range m.sales {
		ids = append(ids, id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *OrderMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
	m.removedsales = nil
}

// SetOrderVenuesID sets the "order_venues" edge to the Venue entity by id.
func (m *OrderMutation) SetOrderVenuesID(id int64) {
	m.order_venues = &id
}

// ClearOrderVenues clears the "order_venues" edge to the Venue entity.
func (m *OrderMutation) ClearOrderVenues() {
	m.clearedorder_venues = true
	m.clearedFields[order.FieldVenueID] = struct{}{}
}

// OrderVenuesCleared reports if the "order_venues" edge to the Venue entity was cleared.
func (m *OrderMutation) OrderVenuesCleared() bool {
	return m.VenueIDCleared() || m.clearedorder_venues
}

// OrderVenuesID returns the "order_venues" edge ID in the mutation.
func (m *OrderMutation) OrderVenuesID() (id int64, exists bool) {
	if m.order_venues != nil {
		return *m.order_venues, true
	}
	return
}

// OrderVenuesIDs returns the "order_venues" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderVenuesID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderVenuesIDs() (ids []int64) {
	if id := m.order_venues; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderVenues resets all changes to the "order_venues" edge.
func (m *OrderMutation) ResetOrderVenues() {
	m.order_venues = nil
	m.clearedorder_venues = false
}

// SetOrderMembersID sets the "order_members" edge to the Member entity by id.
func (m *OrderMutation) SetOrderMembersID(id int64) {
	m.order_members = &id
}

// ClearOrderMembers clears the "order_members" edge to the Member entity.
func (m *OrderMutation) ClearOrderMembers() {
	m.clearedorder_members = true
	m.clearedFields[order.FieldMemberID] = struct{}{}
}

// OrderMembersCleared reports if the "order_members" edge to the Member entity was cleared.
func (m *OrderMutation) OrderMembersCleared() bool {
	return m.MemberIDCleared() || m.clearedorder_members
}

// OrderMembersID returns the "order_members" edge ID in the mutation.
func (m *OrderMutation) OrderMembersID() (id int64, exists bool) {
	if m.order_members != nil {
		return *m.order_members, true
	}
	return
}

// OrderMembersIDs returns the "order_members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderMembersID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderMembersIDs() (ids []int64) {
	if id := m.order_members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderMembers resets all changes to the "order_members" edge.
func (m *OrderMutation) ResetOrderMembers() {
	m.order_members = nil
	m.clearedorder_members = false
}

// SetOrderCreatesID sets the "order_creates" edge to the User entity by id.
func (m *OrderMutation) SetOrderCreatesID(id int64) {
	m.order_creates = &id
}

// ClearOrderCreates clears the "order_creates" edge to the User entity.
func (m *OrderMutation) ClearOrderCreates() {
	m.clearedorder_creates = true
	m.clearedFields[order.FieldCreateID] = struct{}{}
}

// OrderCreatesCleared reports if the "order_creates" edge to the User entity was cleared.
func (m *OrderMutation) OrderCreatesCleared() bool {
	return m.CreateIDCleared() || m.clearedorder_creates
}

// OrderCreatesID returns the "order_creates" edge ID in the mutation.
func (m *OrderMutation) OrderCreatesID() (id int64, exists bool) {
	if m.order_creates != nil {
		return *m.order_creates, true
	}
	return
}

// OrderCreatesIDs returns the "order_creates" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderCreatesID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderCreatesIDs() (ids []int64) {
	if id := m.order_creates; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderCreates resets all changes to the "order_creates" edge.
func (m *OrderMutation) ResetOrderCreates() {
	m.order_creates = nil
	m.clearedorder_creates = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.order_sn != nil {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.order_venues != nil {
		fields = append(fields, order.FieldVenueID)
	}
	if m.order_members != nil {
		fields = append(fields, order.FieldMemberID)
	}
	if m.member_product_id != nil {
		fields = append(fields, order.FieldMemberProductID)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, order.FieldSource)
	}
	if m.device != nil {
		fields = append(fields, order.FieldDevice)
	}
	if m.nature != nil {
		fields = append(fields, order.FieldNature)
	}
	if m.completion_at != nil {
		fields = append(fields, order.FieldCompletionAt)
	}
	if m.order_creates != nil {
		fields = append(fields, order.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldOrderSn:
		return m.OrderSn()
	case order.FieldVenueID:
		return m.VenueID()
	case order.FieldMemberID:
		return m.MemberID()
	case order.FieldMemberProductID:
		return m.MemberProductID()
	case order.FieldStatus:
		return m.Status()
	case order.FieldSource:
		return m.Source()
	case order.FieldDevice:
		return m.Device()
	case order.FieldNature:
		return m.Nature()
	case order.FieldCompletionAt:
		return m.CompletionAt()
	case order.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case order.FieldVenueID:
		return m.OldVenueID(ctx)
	case order.FieldMemberID:
		return m.OldMemberID(ctx)
	case order.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldSource:
		return m.OldSource(ctx)
	case order.FieldDevice:
		return m.OldDevice(ctx)
	case order.FieldNature:
		return m.OldNature(ctx)
	case order.FieldCompletionAt:
		return m.OldCompletionAt(ctx)
	case order.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case order.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case order.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case order.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case order.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case order.FieldNature:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNature(v)
		return nil
	case order.FieldCompletionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAt(v)
		return nil
	case order.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addmember_product_id != nil {
		fields = append(fields, order.FieldMemberProductID)
	}
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.addnature != nil {
		fields = append(fields, order.FieldNature)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldMemberProductID:
		return m.AddedMemberProductID()
	case order.FieldStatus:
		return m.AddedStatus()
	case order.FieldNature:
		return m.AddedNature()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case order.FieldNature:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNature(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldOrderSn) {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.FieldCleared(order.FieldVenueID) {
		fields = append(fields, order.FieldVenueID)
	}
	if m.FieldCleared(order.FieldMemberID) {
		fields = append(fields, order.FieldMemberID)
	}
	if m.FieldCleared(order.FieldMemberProductID) {
		fields = append(fields, order.FieldMemberProductID)
	}
	if m.FieldCleared(order.FieldStatus) {
		fields = append(fields, order.FieldStatus)
	}
	if m.FieldCleared(order.FieldSource) {
		fields = append(fields, order.FieldSource)
	}
	if m.FieldCleared(order.FieldDevice) {
		fields = append(fields, order.FieldDevice)
	}
	if m.FieldCleared(order.FieldNature) {
		fields = append(fields, order.FieldNature)
	}
	if m.FieldCleared(order.FieldCompletionAt) {
		fields = append(fields, order.FieldCompletionAt)
	}
	if m.FieldCleared(order.FieldCreateID) {
		fields = append(fields, order.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case order.FieldVenueID:
		m.ClearVenueID()
		return nil
	case order.FieldMemberID:
		m.ClearMemberID()
		return nil
	case order.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case order.FieldStatus:
		m.ClearStatus()
		return nil
	case order.FieldSource:
		m.ClearSource()
		return nil
	case order.FieldDevice:
		m.ClearDevice()
		return nil
	case order.FieldNature:
		m.ClearNature()
		return nil
	case order.FieldCompletionAt:
		m.ClearCompletionAt()
		return nil
	case order.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case order.FieldVenueID:
		m.ResetVenueID()
		return nil
	case order.FieldMemberID:
		m.ResetMemberID()
		return nil
	case order.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldSource:
		m.ResetSource()
		return nil
	case order.FieldDevice:
		m.ResetDevice()
		return nil
	case order.FieldNature:
		m.ResetNature()
		return nil
	case order.FieldCompletionAt:
		m.ResetCompletionAt()
		return nil
	case order.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.amount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.item != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.pay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.order_contents != nil {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.sales != nil {
		edges = append(edges, order.EdgeSales)
	}
	if m.order_venues != nil {
		edges = append(edges, order.EdgeOrderVenues)
	}
	if m.order_members != nil {
		edges = append(edges, order.EdgeOrderMembers)
	}
	if m.order_creates != nil {
		edges = append(edges, order.EdgeOrderCreates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.amount))
		for id := range m.amount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.item))
		for id := range m.item {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.pay))
		for id := range m.pay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderContents:
		ids := make([]ent.Value, 0, len(m.order_contents))
		for id := range m.order_contents {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.sales))
		for id := range m.sales {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderVenues:
		if id := m.order_venues; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderMembers:
		if id := m.order_members; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderCreates:
		if id := m.order_creates; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedamount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.removeditem != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.removedpay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.removedorder_contents != nil {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.removedsales != nil {
		edges = append(edges, order.EdgeSales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.removedamount))
		for id := range m.removedamount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.removeditem))
		for id := range m.removeditem {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.removedpay))
		for id := range m.removedpay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderContents:
		ids := make([]ent.Value, 0, len(m.removedorder_contents))
		for id := range m.removedorder_contents {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.removedsales))
		for id := range m.removedsales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedamount {
		edges = append(edges, order.EdgeAmount)
	}
	if m.cleareditem {
		edges = append(edges, order.EdgeItem)
	}
	if m.clearedpay {
		edges = append(edges, order.EdgePay)
	}
	if m.clearedorder_contents {
		edges = append(edges, order.EdgeOrderContents)
	}
	if m.clearedsales {
		edges = append(edges, order.EdgeSales)
	}
	if m.clearedorder_venues {
		edges = append(edges, order.EdgeOrderVenues)
	}
	if m.clearedorder_members {
		edges = append(edges, order.EdgeOrderMembers)
	}
	if m.clearedorder_creates {
		edges = append(edges, order.EdgeOrderCreates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeAmount:
		return m.clearedamount
	case order.EdgeItem:
		return m.cleareditem
	case order.EdgePay:
		return m.clearedpay
	case order.EdgeOrderContents:
		return m.clearedorder_contents
	case order.EdgeSales:
		return m.clearedsales
	case order.EdgeOrderVenues:
		return m.clearedorder_venues
	case order.EdgeOrderMembers:
		return m.clearedorder_members
	case order.EdgeOrderCreates:
		return m.clearedorder_creates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeOrderVenues:
		m.ClearOrderVenues()
		return nil
	case order.EdgeOrderMembers:
		m.ClearOrderMembers()
		return nil
	case order.EdgeOrderCreates:
		m.ClearOrderCreates()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeAmount:
		m.ResetAmount()
		return nil
	case order.EdgeItem:
		m.ResetItem()
		return nil
	case order.EdgePay:
		m.ResetPay()
		return nil
	case order.EdgeOrderContents:
		m.ResetOrderContents()
		return nil
	case order.EdgeSales:
		m.ResetSales()
		return nil
	case order.EdgeOrderVenues:
		m.ResetOrderVenues()
		return nil
	case order.EdgeOrderMembers:
		m.ResetOrderMembers()
		return nil
	case order.EdgeOrderCreates:
		m.ResetOrderCreates()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderAmountMutation represents an operation that mutates the OrderAmount nodes in the graph.
type OrderAmountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	total         *float64
	addtotal      *float64
	actual        *float64
	addactual     *float64
	residue       *float64
	addresidue    *float64
	remission     *float64
	addremission  *float64
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderAmount, error)
	predicates    []predicate.OrderAmount
}

var _ ent.Mutation = (*OrderAmountMutation)(nil)

// orderamountOption allows management of the mutation configuration using functional options.
type orderamountOption func(*OrderAmountMutation)

// newOrderAmountMutation creates new mutation for the OrderAmount entity.
func newOrderAmountMutation(c config, op Op, opts ...orderamountOption) *OrderAmountMutation {
	m := &OrderAmountMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAmount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAmountID sets the ID field of the mutation.
func withOrderAmountID(id int64) orderamountOption {
	return func(m *OrderAmountMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAmount
		)
		m.oldValue = func(ctx context.Context) (*OrderAmount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAmount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAmount sets the old OrderAmount of the mutation.
func withOrderAmount(node *OrderAmount) orderamountOption {
	return func(m *OrderAmountMutation) {
		m.oldValue = func(context.Context) (*OrderAmount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAmountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAmountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderAmount entities.
func (m *OrderAmountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAmountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderAmountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderAmount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderAmountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderAmountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderAmountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderAmountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderAmountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderAmountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderAmountMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderAmountMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderAmountMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderAmountMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderAmountMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderamount.FieldOrderID)
}

// SetTotal sets the "total" field.
func (m *OrderAmountMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderAmountMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *OrderAmountMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *OrderAmountMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *OrderAmountMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[orderamount.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *OrderAmountMutation) TotalCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderAmountMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, orderamount.FieldTotal)
}

// SetActual sets the "actual" field.
func (m *OrderAmountMutation) SetActual(f float64) {
	m.actual = &f
	m.addactual = nil
}

// Actual returns the value of the "actual" field in the mutation.
func (m *OrderAmountMutation) Actual() (r float64, exists bool) {
	v := m.actual
	if v == nil {
		return
	}
	return *v, true
}

// OldActual returns the old "actual" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldActual(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActual: %w", err)
	}
	return oldValue.Actual, nil
}

// AddActual adds f to the "actual" field.
func (m *OrderAmountMutation) AddActual(f float64) {
	if m.addactual != nil {
		*m.addactual += f
	} else {
		m.addactual = &f
	}
}

// AddedActual returns the value that was added to the "actual" field in this mutation.
func (m *OrderAmountMutation) AddedActual() (r float64, exists bool) {
	v := m.addactual
	if v == nil {
		return
	}
	return *v, true
}

// ClearActual clears the value of the "actual" field.
func (m *OrderAmountMutation) ClearActual() {
	m.actual = nil
	m.addactual = nil
	m.clearedFields[orderamount.FieldActual] = struct{}{}
}

// ActualCleared returns if the "actual" field was cleared in this mutation.
func (m *OrderAmountMutation) ActualCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldActual]
	return ok
}

// ResetActual resets all changes to the "actual" field.
func (m *OrderAmountMutation) ResetActual() {
	m.actual = nil
	m.addactual = nil
	delete(m.clearedFields, orderamount.FieldActual)
}

// SetResidue sets the "residue" field.
func (m *OrderAmountMutation) SetResidue(f float64) {
	m.residue = &f
	m.addresidue = nil
}

// Residue returns the value of the "residue" field in the mutation.
func (m *OrderAmountMutation) Residue() (r float64, exists bool) {
	v := m.residue
	if v == nil {
		return
	}
	return *v, true
}

// OldResidue returns the old "residue" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldResidue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResidue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResidue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResidue: %w", err)
	}
	return oldValue.Residue, nil
}

// AddResidue adds f to the "residue" field.
func (m *OrderAmountMutation) AddResidue(f float64) {
	if m.addresidue != nil {
		*m.addresidue += f
	} else {
		m.addresidue = &f
	}
}

// AddedResidue returns the value that was added to the "residue" field in this mutation.
func (m *OrderAmountMutation) AddedResidue() (r float64, exists bool) {
	v := m.addresidue
	if v == nil {
		return
	}
	return *v, true
}

// ClearResidue clears the value of the "residue" field.
func (m *OrderAmountMutation) ClearResidue() {
	m.residue = nil
	m.addresidue = nil
	m.clearedFields[orderamount.FieldResidue] = struct{}{}
}

// ResidueCleared returns if the "residue" field was cleared in this mutation.
func (m *OrderAmountMutation) ResidueCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldResidue]
	return ok
}

// ResetResidue resets all changes to the "residue" field.
func (m *OrderAmountMutation) ResetResidue() {
	m.residue = nil
	m.addresidue = nil
	delete(m.clearedFields, orderamount.FieldResidue)
}

// SetRemission sets the "remission" field.
func (m *OrderAmountMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderAmountMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderAmountMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderAmountMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderAmountMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderamount.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderAmountMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderAmountMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderamount.FieldRemission)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderAmountMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderAmountMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderAmountMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderAmountMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderAmountMutation builder.
func (m *OrderAmountMutation) Where(ps ...predicate.OrderAmount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderAmountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderAmountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderAmount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderAmountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderAmountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderAmount).
func (m *OrderAmountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAmountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, orderamount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderamount.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.total != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.actual != nil {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.residue != nil {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.remission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAmountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.CreatedAt()
	case orderamount.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderamount.FieldOrderID:
		return m.OrderID()
	case orderamount.FieldTotal:
		return m.Total()
	case orderamount.FieldActual:
		return m.Actual()
	case orderamount.FieldResidue:
		return m.Residue()
	case orderamount.FieldRemission:
		return m.Remission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAmountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderamount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderamount.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderamount.FieldTotal:
		return m.OldTotal(ctx)
	case orderamount.FieldActual:
		return m.OldActual(ctx)
	case orderamount.FieldResidue:
		return m.OldResidue(ctx)
	case orderamount.FieldRemission:
		return m.OldRemission(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAmount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderamount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderamount.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case orderamount.FieldActual:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActual(v)
		return nil
	case orderamount.FieldResidue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResidue(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAmountMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.addactual != nil {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.addresidue != nil {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.addremission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAmountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldTotal:
		return m.AddedTotal()
	case orderamount.FieldActual:
		return m.AddedActual()
	case orderamount.FieldResidue:
		return m.AddedResidue()
	case orderamount.FieldRemission:
		return m.AddedRemission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case orderamount.FieldActual:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActual(v)
		return nil
	case orderamount.FieldResidue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResidue(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAmountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderamount.FieldOrderID) {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.FieldCleared(orderamount.FieldTotal) {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.FieldCleared(orderamount.FieldActual) {
		fields = append(fields, orderamount.FieldActual)
	}
	if m.FieldCleared(orderamount.FieldResidue) {
		fields = append(fields, orderamount.FieldResidue)
	}
	if m.FieldCleared(orderamount.FieldRemission) {
		fields = append(fields, orderamount.FieldRemission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAmountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAmountMutation) ClearField(name string) error {
	switch name {
	case orderamount.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ClearTotal()
		return nil
	case orderamount.FieldActual:
		m.ClearActual()
		return nil
	case orderamount.FieldResidue:
		m.ClearResidue()
		return nil
	case orderamount.FieldRemission:
		m.ClearRemission()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAmountMutation) ResetField(name string) error {
	switch name {
	case orderamount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderamount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderamount.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ResetTotal()
		return nil
	case orderamount.FieldActual:
		m.ResetActual()
		return nil
	case orderamount.FieldResidue:
		m.ResetResidue()
		return nil
	case orderamount.FieldRemission:
		m.ResetRemission()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAmountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderamount.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAmountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderamount.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAmountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAmountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAmountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderamount.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAmountMutation) EdgeCleared(name string) bool {
	switch name {
	case orderamount.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAmountMutation) ClearEdge(name string) error {
	switch name {
	case orderamount.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAmountMutation) ResetEdge(name string) error {
	switch name {
	case orderamount.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	product_id                 *int64
	addproduct_id              *int64
	related_user_product_id    *int64
	addrelated_user_product_id *int64
	data                       *string
	clearedFields              map[string]struct{}
	_order                     *int64
	cleared_order              bool
	done                       bool
	oldValue                   func(context.Context) (*OrderItem, error)
	predicates                 []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int64) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderItemMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderitem.FieldOrderID)
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, orderitem.FieldProductID)
}

// SetRelatedUserProductID sets the "related_user_product_id" field.
func (m *OrderItemMutation) SetRelatedUserProductID(i int64) {
	m.related_user_product_id = &i
	m.addrelated_user_product_id = nil
}

// RelatedUserProductID returns the value of the "related_user_product_id" field in the mutation.
func (m *OrderItemMutation) RelatedUserProductID() (r int64, exists bool) {
	v := m.related_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedUserProductID returns the old "related_user_product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRelatedUserProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedUserProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedUserProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedUserProductID: %w", err)
	}
	return oldValue.RelatedUserProductID, nil
}

// AddRelatedUserProductID adds i to the "related_user_product_id" field.
func (m *OrderItemMutation) AddRelatedUserProductID(i int64) {
	if m.addrelated_user_product_id != nil {
		*m.addrelated_user_product_id += i
	} else {
		m.addrelated_user_product_id = &i
	}
}

// AddedRelatedUserProductID returns the value that was added to the "related_user_product_id" field in this mutation.
func (m *OrderItemMutation) AddedRelatedUserProductID() (r int64, exists bool) {
	v := m.addrelated_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelatedUserProductID clears the value of the "related_user_product_id" field.
func (m *OrderItemMutation) ClearRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	m.clearedFields[orderitem.FieldRelatedUserProductID] = struct{}{}
}

// RelatedUserProductIDCleared returns if the "related_user_product_id" field was cleared in this mutation.
func (m *OrderItemMutation) RelatedUserProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldRelatedUserProductID]
	return ok
}

// ResetRelatedUserProductID resets all changes to the "related_user_product_id" field.
func (m *OrderItemMutation) ResetRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	delete(m.clearedFields, orderitem.FieldRelatedUserProductID)
}

// SetData sets the "data" field.
func (m *OrderItemMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *OrderItemMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *OrderItemMutation) ClearData() {
	m.data = nil
	m.clearedFields[orderitem.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *OrderItemMutation) DataCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *OrderItemMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, orderitem.FieldData)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.related_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.data != nil {
		fields = append(fields, orderitem.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldRelatedUserProductID:
		return m.RelatedUserProductID()
	case orderitem.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldRelatedUserProductID:
		return m.OldRelatedUserProductID(ctx)
	case orderitem.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedUserProductID(v)
		return nil
	case orderitem.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.addrelated_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldProductID:
		return m.AddedProductID()
	case orderitem.FieldRelatedUserProductID:
		return m.AddedRelatedUserProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedUserProductID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldOrderID) {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.FieldCleared(orderitem.FieldProductID) {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.FieldCleared(orderitem.FieldRelatedUserProductID) {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.FieldCleared(orderitem.FieldData) {
		fields = append(fields, orderitem.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ClearProductID()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ClearRelatedUserProductID()
		return nil
	case orderitem.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ResetRelatedUserProductID()
		return nil
	case orderitem.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderPayMutation represents an operation that mutates the OrderPay nodes in the graph.
type OrderPayMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	remission     *float64
	addremission  *float64
	pay           *float64
	addpay        *float64
	note          *string
	pay_way       *string
	create_id     *int64
	addcreate_id  *int64
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderPay, error)
	predicates    []predicate.OrderPay
}

var _ ent.Mutation = (*OrderPayMutation)(nil)

// orderpayOption allows management of the mutation configuration using functional options.
type orderpayOption func(*OrderPayMutation)

// newOrderPayMutation creates new mutation for the OrderPay entity.
func newOrderPayMutation(c config, op Op, opts ...orderpayOption) *OrderPayMutation {
	m := &OrderPayMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPayID sets the ID field of the mutation.
func withOrderPayID(id int64) orderpayOption {
	return func(m *OrderPayMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPay
		)
		m.oldValue = func(ctx context.Context) (*OrderPay, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPay sets the old OrderPay of the mutation.
func withOrderPay(node *OrderPay) orderpayOption {
	return func(m *OrderPayMutation) {
		m.oldValue = func(context.Context) (*OrderPay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderPay entities.
func (m *OrderPayMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPayMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderPayMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderPay.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderPayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderPayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderPayMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderPayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderPayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderPayMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderPayMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderPayMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderPayMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderPayMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderPayMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderpay.FieldOrderID)
}

// SetRemission sets the "remission" field.
func (m *OrderPayMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderPayMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderPayMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderPayMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderPayMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderpay.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderPayMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderPayMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderpay.FieldRemission)
}

// SetPay sets the "pay" field.
func (m *OrderPayMutation) SetPay(f float64) {
	m.pay = &f
	m.addpay = nil
}

// Pay returns the value of the "pay" field in the mutation.
func (m *OrderPayMutation) Pay() (r float64, exists bool) {
	v := m.pay
	if v == nil {
		return
	}
	return *v, true
}

// OldPay returns the old "pay" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPay: %w", err)
	}
	return oldValue.Pay, nil
}

// AddPay adds f to the "pay" field.
func (m *OrderPayMutation) AddPay(f float64) {
	if m.addpay != nil {
		*m.addpay += f
	} else {
		m.addpay = &f
	}
}

// AddedPay returns the value that was added to the "pay" field in this mutation.
func (m *OrderPayMutation) AddedPay() (r float64, exists bool) {
	v := m.addpay
	if v == nil {
		return
	}
	return *v, true
}

// ClearPay clears the value of the "pay" field.
func (m *OrderPayMutation) ClearPay() {
	m.pay = nil
	m.addpay = nil
	m.clearedFields[orderpay.FieldPay] = struct{}{}
}

// PayCleared returns if the "pay" field was cleared in this mutation.
func (m *OrderPayMutation) PayCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPay]
	return ok
}

// ResetPay resets all changes to the "pay" field.
func (m *OrderPayMutation) ResetPay() {
	m.pay = nil
	m.addpay = nil
	delete(m.clearedFields, orderpay.FieldPay)
}

// SetNote sets the "note" field.
func (m *OrderPayMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderPayMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OrderPayMutation) ClearNote() {
	m.note = nil
	m.clearedFields[orderpay.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OrderPayMutation) NoteCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OrderPayMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, orderpay.FieldNote)
}

// SetPayWay sets the "pay_way" field.
func (m *OrderPayMutation) SetPayWay(s string) {
	m.pay_way = &s
}

// PayWay returns the value of the "pay_way" field in the mutation.
func (m *OrderPayMutation) PayWay() (r string, exists bool) {
	v := m.pay_way
	if v == nil {
		return
	}
	return *v, true
}

// OldPayWay returns the old "pay_way" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPayWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayWay: %w", err)
	}
	return oldValue.PayWay, nil
}

// ClearPayWay clears the value of the "pay_way" field.
func (m *OrderPayMutation) ClearPayWay() {
	m.pay_way = nil
	m.clearedFields[orderpay.FieldPayWay] = struct{}{}
}

// PayWayCleared returns if the "pay_way" field was cleared in this mutation.
func (m *OrderPayMutation) PayWayCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPayWay]
	return ok
}

// ResetPayWay resets all changes to the "pay_way" field.
func (m *OrderPayMutation) ResetPayWay() {
	m.pay_way = nil
	delete(m.clearedFields, orderpay.FieldPayWay)
}

// SetCreateID sets the "create_id" field.
func (m *OrderPayMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *OrderPayMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *OrderPayMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *OrderPayMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *OrderPayMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[orderpay.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *OrderPayMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *OrderPayMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, orderpay.FieldCreateID)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderPayMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderPayMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderPayMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderPayMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderPayMutation builder.
func (m *OrderPayMutation) Where(ps ...predicate.OrderPay) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderPayMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderPayMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderPay, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderPayMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderPayMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderPay).
func (m *OrderPayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPayMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.remission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.pay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.note != nil {
		fields = append(fields, orderpay.FieldNote)
	}
	if m.pay_way != nil {
		fields = append(fields, orderpay.FieldPayWay)
	}
	if m.create_id != nil {
		fields = append(fields, orderpay.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.CreatedAt()
	case orderpay.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderpay.FieldOrderID:
		return m.OrderID()
	case orderpay.FieldRemission:
		return m.Remission()
	case orderpay.FieldPay:
		return m.Pay()
	case orderpay.FieldNote:
		return m.Note()
	case orderpay.FieldPayWay:
		return m.PayWay()
	case orderpay.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderpay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderpay.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderpay.FieldRemission:
		return m.OldRemission(ctx)
	case orderpay.FieldPay:
		return m.OldPay(ctx)
	case orderpay.FieldNote:
		return m.OldNote(ctx)
	case orderpay.FieldPayWay:
		return m.OldPayWay(ctx)
	case orderpay.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderpay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderpay.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPay(v)
		return nil
	case orderpay.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case orderpay.FieldPayWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayWay(v)
		return nil
	case orderpay.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPayMutation) AddedFields() []string {
	var fields []string
	if m.addremission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.addpay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.addcreate_id != nil {
		fields = append(fields, orderpay.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldRemission:
		return m.AddedRemission()
	case orderpay.FieldPay:
		return m.AddedPay()
	case orderpay.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPay(v)
		return nil
	case orderpay.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpay.FieldOrderID) {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.FieldCleared(orderpay.FieldRemission) {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.FieldCleared(orderpay.FieldPay) {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.FieldCleared(orderpay.FieldNote) {
		fields = append(fields, orderpay.FieldNote)
	}
	if m.FieldCleared(orderpay.FieldPayWay) {
		fields = append(fields, orderpay.FieldPayWay)
	}
	if m.FieldCleared(orderpay.FieldCreateID) {
		fields = append(fields, orderpay.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPayMutation) ClearField(name string) error {
	switch name {
	case orderpay.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderpay.FieldRemission:
		m.ClearRemission()
		return nil
	case orderpay.FieldPay:
		m.ClearPay()
		return nil
	case orderpay.FieldNote:
		m.ClearNote()
		return nil
	case orderpay.FieldPayWay:
		m.ClearPayWay()
		return nil
	case orderpay.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown OrderPay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPayMutation) ResetField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderpay.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderpay.FieldRemission:
		m.ResetRemission()
		return nil
	case orderpay.FieldPay:
		m.ResetPay()
		return nil
	case orderpay.FieldNote:
		m.ResetNote()
		return nil
	case orderpay.FieldPayWay:
		m.ResetPayWay()
		return nil
	case orderpay.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderpay.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderpay.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPayMutation) EdgeCleared(name string) bool {
	switch name {
	case orderpay.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPayMutation) ClearEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPayMutation) ResetEdge(name string) error {
	switch name {
	case orderpay.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderPay edge %s", name)
}

// OrderSalesMutation represents an operation that mutates the OrderSales nodes in the graph.
type OrderSalesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int64
	addstatus     *int64
	member_id     *int64
	addmember_id  *int64
	sales_id      *int64
	addsales_id   *int64
	ratio         *int64
	addratio      *int64
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderSales, error)
	predicates    []predicate.OrderSales
}

var _ ent.Mutation = (*OrderSalesMutation)(nil)

// ordersalesOption allows management of the mutation configuration using functional options.
type ordersalesOption func(*OrderSalesMutation)

// newOrderSalesMutation creates new mutation for the OrderSales entity.
func newOrderSalesMutation(c config, op Op, opts ...ordersalesOption) *OrderSalesMutation {
	m := &OrderSalesMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSales,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSalesID sets the ID field of the mutation.
func withOrderSalesID(id int64) ordersalesOption {
	return func(m *OrderSalesMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSales
		)
		m.oldValue = func(ctx context.Context) (*OrderSales, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSales.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSales sets the old OrderSales of the mutation.
func withOrderSales(node *OrderSales) ordersalesOption {
	return func(m *OrderSalesMutation) {
		m.oldValue = func(context.Context) (*OrderSales, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSalesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSalesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderSales entities.
func (m *OrderSalesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSalesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderSalesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderSales.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderSalesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderSalesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderSalesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderSalesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderSalesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderSalesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OrderSalesMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderSalesMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderSalesMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderSalesMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderSalesMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[ordersales.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderSalesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderSalesMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, ordersales.FieldStatus)
}

// SetOrderID sets the "order_id" field.
func (m *OrderSalesMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderSalesMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderSalesMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderSalesMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderSalesMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, ordersales.FieldOrderID)
}

// SetMemberID sets the "member_id" field.
func (m *OrderSalesMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OrderSalesMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *OrderSalesMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *OrderSalesMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *OrderSalesMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[ordersales.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *OrderSalesMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OrderSalesMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, ordersales.FieldMemberID)
}

// SetSalesID sets the "sales_id" field.
func (m *OrderSalesMutation) SetSalesID(i int64) {
	m.sales_id = &i
	m.addsales_id = nil
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *OrderSalesMutation) SalesID() (r int64, exists bool) {
	v := m.sales_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldSalesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// AddSalesID adds i to the "sales_id" field.
func (m *OrderSalesMutation) AddSalesID(i int64) {
	if m.addsales_id != nil {
		*m.addsales_id += i
	} else {
		m.addsales_id = &i
	}
}

// AddedSalesID returns the value that was added to the "sales_id" field in this mutation.
func (m *OrderSalesMutation) AddedSalesID() (r int64, exists bool) {
	v := m.addsales_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *OrderSalesMutation) ClearSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	m.clearedFields[ordersales.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *OrderSalesMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *OrderSalesMutation) ResetSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	delete(m.clearedFields, ordersales.FieldSalesID)
}

// SetRatio sets the "ratio" field.
func (m *OrderSalesMutation) SetRatio(i int64) {
	m.ratio = &i
	m.addratio = nil
}

// Ratio returns the value of the "ratio" field in the mutation.
func (m *OrderSalesMutation) Ratio() (r int64, exists bool) {
	v := m.ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldRatio returns the old "ratio" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldRatio(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatio: %w", err)
	}
	return oldValue.Ratio, nil
}

// AddRatio adds i to the "ratio" field.
func (m *OrderSalesMutation) AddRatio(i int64) {
	if m.addratio != nil {
		*m.addratio += i
	} else {
		m.addratio = &i
	}
}

// AddedRatio returns the value that was added to the "ratio" field in this mutation.
func (m *OrderSalesMutation) AddedRatio() (r int64, exists bool) {
	v := m.addratio
	if v == nil {
		return
	}
	return *v, true
}

// ClearRatio clears the value of the "ratio" field.
func (m *OrderSalesMutation) ClearRatio() {
	m.ratio = nil
	m.addratio = nil
	m.clearedFields[ordersales.FieldRatio] = struct{}{}
}

// RatioCleared returns if the "ratio" field was cleared in this mutation.
func (m *OrderSalesMutation) RatioCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldRatio]
	return ok
}

// ResetRatio resets all changes to the "ratio" field.
func (m *OrderSalesMutation) ResetRatio() {
	m.ratio = nil
	m.addratio = nil
	delete(m.clearedFields, ordersales.FieldRatio)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderSalesMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderSalesMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderSalesMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderSalesMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderSalesMutation builder.
func (m *OrderSalesMutation) Where(ps ...predicate.OrderSales) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderSalesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderSalesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderSales, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderSalesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderSalesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderSales).
func (m *OrderSalesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSalesMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, ordersales.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordersales.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m._order != nil {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.member_id != nil {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.sales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.ratio != nil {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSalesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.CreatedAt()
	case ordersales.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordersales.FieldStatus:
		return m.Status()
	case ordersales.FieldOrderID:
		return m.OrderID()
	case ordersales.FieldMemberID:
		return m.MemberID()
	case ordersales.FieldSalesID:
		return m.SalesID()
	case ordersales.FieldRatio:
		return m.Ratio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSalesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordersales.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordersales.FieldStatus:
		return m.OldStatus(ctx)
	case ordersales.FieldOrderID:
		return m.OldOrderID(ctx)
	case ordersales.FieldMemberID:
		return m.OldMemberID(ctx)
	case ordersales.FieldSalesID:
		return m.OldSalesID(ctx)
	case ordersales.FieldRatio:
		return m.OldRatio(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSales field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordersales.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordersales.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ordersales.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case ordersales.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	case ordersales.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatio(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSalesMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m.addmember_id != nil {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.addsales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.addratio != nil {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSalesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldStatus:
		return m.AddedStatus()
	case ordersales.FieldMemberID:
		return m.AddedMemberID()
	case ordersales.FieldSalesID:
		return m.AddedSalesID()
	case ordersales.FieldRatio:
		return m.AddedRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case ordersales.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesID(v)
		return nil
	case ordersales.FieldRatio:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatio(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSalesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersales.FieldStatus) {
		fields = append(fields, ordersales.FieldStatus)
	}
	if m.FieldCleared(ordersales.FieldOrderID) {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.FieldCleared(ordersales.FieldMemberID) {
		fields = append(fields, ordersales.FieldMemberID)
	}
	if m.FieldCleared(ordersales.FieldSalesID) {
		fields = append(fields, ordersales.FieldSalesID)
	}
	if m.FieldCleared(ordersales.FieldRatio) {
		fields = append(fields, ordersales.FieldRatio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSalesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSalesMutation) ClearField(name string) error {
	switch name {
	case ordersales.FieldStatus:
		m.ClearStatus()
		return nil
	case ordersales.FieldOrderID:
		m.ClearOrderID()
		return nil
	case ordersales.FieldMemberID:
		m.ClearMemberID()
		return nil
	case ordersales.FieldSalesID:
		m.ClearSalesID()
		return nil
	case ordersales.FieldRatio:
		m.ClearRatio()
		return nil
	}
	return fmt.Errorf("unknown OrderSales nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSalesMutation) ResetField(name string) error {
	switch name {
	case ordersales.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordersales.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordersales.FieldStatus:
		m.ResetStatus()
		return nil
	case ordersales.FieldOrderID:
		m.ResetOrderID()
		return nil
	case ordersales.FieldMemberID:
		m.ResetMemberID()
		return nil
	case ordersales.FieldSalesID:
		m.ResetSalesID()
		return nil
	case ordersales.FieldRatio:
		m.ResetRatio()
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSalesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, ordersales.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSalesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersales.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSalesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSalesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSalesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, ordersales.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSalesMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersales.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSalesMutation) ClearEdge(name string) error {
	switch name {
	case ordersales.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSales unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSalesMutation) ResetEdge(name string) error {
	switch name {
	case ordersales.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSales edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	status           *int64
	addstatus        *int64
	name             *string
	pic              *string
	description      *string
	price            *float64
	addprice         *float64
	stock            *int64
	addstock         *int64
	create_id        *int64
	addcreate_id     *int64
	clearedFields    map[string]struct{}
	propertys        map[int64]struct{}
	removedpropertys map[int64]struct{}
	clearedpropertys bool
	done             bool
	oldValue         func(context.Context) (*Product, error)
	predicates       []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int64) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ProductMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[product.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProductMutation) StatusCleared() bool {
	_, ok := m.clearedFields[product.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, product.FieldStatus)
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[product.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[product.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, product.FieldName)
}

// SetPic sets the "pic" field.
func (m *ProductMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *ProductMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *ProductMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[product.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *ProductMutation) PicCleared() bool {
	_, ok := m.clearedFields[product.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *ProductMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, product.FieldPic)
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ProductMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[product.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[product.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, product.FieldPrice)
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(i int64) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r int64, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductMutation) AddStock(i int64) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r int64, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ClearStock clears the value of the "stock" field.
func (m *ProductMutation) ClearStock() {
	m.stock = nil
	m.addstock = nil
	m.clearedFields[product.FieldStock] = struct{}{}
}

// StockCleared returns if the "stock" field was cleared in this mutation.
func (m *ProductMutation) StockCleared() bool {
	_, ok := m.clearedFields[product.FieldStock]
	return ok
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
	delete(m.clearedFields, product.FieldStock)
}

// SetCreateID sets the "create_id" field.
func (m *ProductMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *ProductMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *ProductMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *ProductMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *ProductMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[product.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *ProductMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[product.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *ProductMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, product.FieldCreateID)
}

// AddPropertyIDs adds the "propertys" edge to the ProductProperty entity by ids.
func (m *ProductMutation) AddPropertyIDs(ids ...int64) {
	if m.propertys == nil {
		m.propertys = make(map[int64]struct{})
	}
	for i := range ids {
		m.propertys[ids[i]] = struct{}{}
	}
}

// ClearPropertys clears the "propertys" edge to the ProductProperty entity.
func (m *ProductMutation) ClearPropertys() {
	m.clearedpropertys = true
}

// PropertysCleared reports if the "propertys" edge to the ProductProperty entity was cleared.
func (m *ProductMutation) PropertysCleared() bool {
	return m.clearedpropertys
}

// RemovePropertyIDs removes the "propertys" edge to the ProductProperty entity by IDs.
func (m *ProductMutation) RemovePropertyIDs(ids ...int64) {
	if m.removedpropertys == nil {
		m.removedpropertys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.propertys, ids[i])
		m.removedpropertys[ids[i]] = struct{}{}
	}
}

// RemovedPropertys returns the removed IDs of the "propertys" edge to the ProductProperty entity.
func (m *ProductMutation) RemovedPropertysIDs() (ids []int64) {
	for id := range m.removedpropertys {
		ids = append(ids, id)
	}
	return
}

// PropertysIDs returns the "propertys" edge IDs in the mutation.
func (m *ProductMutation) PropertysIDs() (ids []int64) {
	for id := range m.propertys {
		ids = append(ids, id)
	}
	return
}

// ResetPropertys resets all changes to the "propertys" edge.
func (m *ProductMutation) ResetPropertys() {
	m.propertys = nil
	m.clearedpropertys = false
	m.removedpropertys = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, product.FieldPic)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.create_id != nil {
		fields = append(fields, product.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldStatus:
		return m.Status()
	case product.FieldName:
		return m.Name()
	case product.FieldPic:
		return m.Pic()
	case product.FieldDescription:
		return m.Description()
	case product.FieldPrice:
		return m.Price()
	case product.FieldStock:
		return m.Stock()
	case product.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldPic:
		return m.OldPic(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	case product.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case product.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.addcreate_id != nil {
		fields = append(fields, product.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldStatus:
		return m.AddedStatus()
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldStock:
		return m.AddedStock()
	case product.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case product.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldStatus) {
		fields = append(fields, product.FieldStatus)
	}
	if m.FieldCleared(product.FieldName) {
		fields = append(fields, product.FieldName)
	}
	if m.FieldCleared(product.FieldPic) {
		fields = append(fields, product.FieldPic)
	}
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldPrice) {
		fields = append(fields, product.FieldPrice)
	}
	if m.FieldCleared(product.FieldStock) {
		fields = append(fields, product.FieldStock)
	}
	if m.FieldCleared(product.FieldCreateID) {
		fields = append(fields, product.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldStatus:
		m.ClearStatus()
		return nil
	case product.FieldName:
		m.ClearName()
		return nil
	case product.FieldPic:
		m.ClearPic()
		return nil
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldPrice:
		m.ClearPrice()
		return nil
	case product.FieldStock:
		m.ClearStock()
		return nil
	case product.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldPic:
		m.ResetPic()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	case product.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.propertys != nil {
		edges = append(edges, product.EdgePropertys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePropertys:
		ids := make([]ent.Value, 0, len(m.propertys))
		for id := range m.propertys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpropertys != nil {
		edges = append(edges, product.EdgePropertys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePropertys:
		ids := make([]ent.Value, 0, len(m.removedpropertys))
		for id := range m.removedpropertys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpropertys {
		edges = append(edges, product.EdgePropertys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgePropertys:
		return m.clearedpropertys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgePropertys:
		m.ResetPropertys()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductPropertyMutation represents an operation that mutates the ProductProperty nodes in the graph.
type ProductPropertyMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	status         *int64
	addstatus      *int64
	_type          *string
	name           *string
	duration       *int64
	addduration    *int64
	length         *int64
	addlength      *int64
	count          *int64
	addcount       *int64
	price          *float64
	addprice       *float64
	data           *string
	create_id      *int64
	addcreate_id   *int64
	clearedFields  map[string]struct{}
	product        map[int64]struct{}
	removedproduct map[int64]struct{}
	clearedproduct bool
	venues         map[int64]struct{}
	removedvenues  map[int64]struct{}
	clearedvenues  bool
	done           bool
	oldValue       func(context.Context) (*ProductProperty, error)
	predicates     []predicate.ProductProperty
}

var _ ent.Mutation = (*ProductPropertyMutation)(nil)

// productpropertyOption allows management of the mutation configuration using functional options.
type productpropertyOption func(*ProductPropertyMutation)

// newProductPropertyMutation creates new mutation for the ProductProperty entity.
func newProductPropertyMutation(c config, op Op, opts ...productpropertyOption) *ProductPropertyMutation {
	m := &ProductPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProductProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPropertyID sets the ID field of the mutation.
func withProductPropertyID(id int64) productpropertyOption {
	return func(m *ProductPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductProperty
		)
		m.oldValue = func(ctx context.Context) (*ProductProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductProperty sets the old ProductProperty of the mutation.
func withProductProperty(node *ProductProperty) productpropertyOption {
	return func(m *ProductPropertyMutation) {
		m.oldValue = func(context.Context) (*ProductProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductProperty entities.
func (m *ProductPropertyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPropertyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductPropertyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductPropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductPropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductPropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductPropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductPropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductPropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ProductPropertyMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductPropertyMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductPropertyMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductPropertyMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ProductPropertyMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[productproperty.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProductPropertyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductPropertyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, productproperty.FieldStatus)
}

// SetType sets the "type" field.
func (m *ProductPropertyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductPropertyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ProductPropertyMutation) ClearType() {
	m._type = nil
	m.clearedFields[productproperty.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ProductPropertyMutation) TypeCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ProductPropertyMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, productproperty.FieldType)
}

// SetName sets the "name" field.
func (m *ProductPropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductPropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductPropertyMutation) ClearName() {
	m.name = nil
	m.clearedFields[productproperty.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductPropertyMutation) NameCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductPropertyMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, productproperty.FieldName)
}

// SetDuration sets the "duration" field.
func (m *ProductPropertyMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProductPropertyMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ProductPropertyMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ProductPropertyMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ProductPropertyMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[productproperty.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ProductPropertyMutation) DurationCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProductPropertyMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, productproperty.FieldDuration)
}

// SetLength sets the "length" field.
func (m *ProductPropertyMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ProductPropertyMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *ProductPropertyMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ProductPropertyMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *ProductPropertyMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[productproperty.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *ProductPropertyMutation) LengthCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *ProductPropertyMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, productproperty.FieldLength)
}

// SetCount sets the "count" field.
func (m *ProductPropertyMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *ProductPropertyMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *ProductPropertyMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *ProductPropertyMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *ProductPropertyMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[productproperty.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *ProductPropertyMutation) CountCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *ProductPropertyMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, productproperty.FieldCount)
}

// SetPrice sets the "price" field.
func (m *ProductPropertyMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductPropertyMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductPropertyMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductPropertyMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ProductPropertyMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[productproperty.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ProductPropertyMutation) PriceCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductPropertyMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, productproperty.FieldPrice)
}

// SetData sets the "data" field.
func (m *ProductPropertyMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *ProductPropertyMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *ProductPropertyMutation) ClearData() {
	m.data = nil
	m.clearedFields[productproperty.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *ProductPropertyMutation) DataCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *ProductPropertyMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, productproperty.FieldData)
}

// SetCreateID sets the "create_id" field.
func (m *ProductPropertyMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *ProductPropertyMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *ProductPropertyMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *ProductPropertyMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *ProductPropertyMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[productproperty.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *ProductPropertyMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *ProductPropertyMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, productproperty.FieldCreateID)
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *ProductPropertyMutation) AddProductIDs(ids ...int64) {
	if m.product == nil {
		m.product = make(map[int64]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductPropertyMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductPropertyMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *ProductPropertyMutation) RemoveProductIDs(ids ...int64) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *ProductPropertyMutation) RemovedProductIDs() (ids []int64) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *ProductPropertyMutation) ProductIDs() (ids []int64) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductPropertyMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// AddVenueIDs adds the "venues" edge to the Venue entity by ids.
func (m *ProductPropertyMutation) AddVenueIDs(ids ...int64) {
	if m.venues == nil {
		m.venues = make(map[int64]struct{})
	}
	for i := range ids {
		m.venues[ids[i]] = struct{}{}
	}
}

// ClearVenues clears the "venues" edge to the Venue entity.
func (m *ProductPropertyMutation) ClearVenues() {
	m.clearedvenues = true
}

// VenuesCleared reports if the "venues" edge to the Venue entity was cleared.
func (m *ProductPropertyMutation) VenuesCleared() bool {
	return m.clearedvenues
}

// RemoveVenueIDs removes the "venues" edge to the Venue entity by IDs.
func (m *ProductPropertyMutation) RemoveVenueIDs(ids ...int64) {
	if m.removedvenues == nil {
		m.removedvenues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venues, ids[i])
		m.removedvenues[ids[i]] = struct{}{}
	}
}

// RemovedVenues returns the removed IDs of the "venues" edge to the Venue entity.
func (m *ProductPropertyMutation) RemovedVenuesIDs() (ids []int64) {
	for id := range m.removedvenues {
		ids = append(ids, id)
	}
	return
}

// VenuesIDs returns the "venues" edge IDs in the mutation.
func (m *ProductPropertyMutation) VenuesIDs() (ids []int64) {
	for id := range m.venues {
		ids = append(ids, id)
	}
	return
}

// ResetVenues resets all changes to the "venues" edge.
func (m *ProductPropertyMutation) ResetVenues() {
	m.venues = nil
	m.clearedvenues = false
	m.removedvenues = nil
}

// Where appends a list predicates to the ProductPropertyMutation builder.
func (m *ProductPropertyMutation) Where(ps ...predicate.ProductProperty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductPropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductPropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductProperty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductPropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductPropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductProperty).
func (m *ProductPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPropertyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, productproperty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productproperty.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, productproperty.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, productproperty.FieldType)
	}
	if m.name != nil {
		fields = append(fields, productproperty.FieldName)
	}
	if m.duration != nil {
		fields = append(fields, productproperty.FieldDuration)
	}
	if m.length != nil {
		fields = append(fields, productproperty.FieldLength)
	}
	if m.count != nil {
		fields = append(fields, productproperty.FieldCount)
	}
	if m.price != nil {
		fields = append(fields, productproperty.FieldPrice)
	}
	if m.data != nil {
		fields = append(fields, productproperty.FieldData)
	}
	if m.create_id != nil {
		fields = append(fields, productproperty.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productproperty.FieldCreatedAt:
		return m.CreatedAt()
	case productproperty.FieldUpdatedAt:
		return m.UpdatedAt()
	case productproperty.FieldStatus:
		return m.Status()
	case productproperty.FieldType:
		return m.GetType()
	case productproperty.FieldName:
		return m.Name()
	case productproperty.FieldDuration:
		return m.Duration()
	case productproperty.FieldLength:
		return m.Length()
	case productproperty.FieldCount:
		return m.Count()
	case productproperty.FieldPrice:
		return m.Price()
	case productproperty.FieldData:
		return m.Data()
	case productproperty.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productproperty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productproperty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productproperty.FieldStatus:
		return m.OldStatus(ctx)
	case productproperty.FieldType:
		return m.OldType(ctx)
	case productproperty.FieldName:
		return m.OldName(ctx)
	case productproperty.FieldDuration:
		return m.OldDuration(ctx)
	case productproperty.FieldLength:
		return m.OldLength(ctx)
	case productproperty.FieldCount:
		return m.OldCount(ctx)
	case productproperty.FieldPrice:
		return m.OldPrice(ctx)
	case productproperty.FieldData:
		return m.OldData(ctx)
	case productproperty.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productproperty.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productproperty.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productproperty.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case productproperty.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case productproperty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case productproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case productproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case productproperty.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case productproperty.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case productproperty.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPropertyMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, productproperty.FieldStatus)
	}
	if m.addduration != nil {
		fields = append(fields, productproperty.FieldDuration)
	}
	if m.addlength != nil {
		fields = append(fields, productproperty.FieldLength)
	}
	if m.addcount != nil {
		fields = append(fields, productproperty.FieldCount)
	}
	if m.addprice != nil {
		fields = append(fields, productproperty.FieldPrice)
	}
	if m.addcreate_id != nil {
		fields = append(fields, productproperty.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productproperty.FieldStatus:
		return m.AddedStatus()
	case productproperty.FieldDuration:
		return m.AddedDuration()
	case productproperty.FieldLength:
		return m.AddedLength()
	case productproperty.FieldCount:
		return m.AddedCount()
	case productproperty.FieldPrice:
		return m.AddedPrice()
	case productproperty.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productproperty.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case productproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case productproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case productproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case productproperty.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case productproperty.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productproperty.FieldStatus) {
		fields = append(fields, productproperty.FieldStatus)
	}
	if m.FieldCleared(productproperty.FieldType) {
		fields = append(fields, productproperty.FieldType)
	}
	if m.FieldCleared(productproperty.FieldName) {
		fields = append(fields, productproperty.FieldName)
	}
	if m.FieldCleared(productproperty.FieldDuration) {
		fields = append(fields, productproperty.FieldDuration)
	}
	if m.FieldCleared(productproperty.FieldLength) {
		fields = append(fields, productproperty.FieldLength)
	}
	if m.FieldCleared(productproperty.FieldCount) {
		fields = append(fields, productproperty.FieldCount)
	}
	if m.FieldCleared(productproperty.FieldPrice) {
		fields = append(fields, productproperty.FieldPrice)
	}
	if m.FieldCleared(productproperty.FieldData) {
		fields = append(fields, productproperty.FieldData)
	}
	if m.FieldCleared(productproperty.FieldCreateID) {
		fields = append(fields, productproperty.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPropertyMutation) ClearField(name string) error {
	switch name {
	case productproperty.FieldStatus:
		m.ClearStatus()
		return nil
	case productproperty.FieldType:
		m.ClearType()
		return nil
	case productproperty.FieldName:
		m.ClearName()
		return nil
	case productproperty.FieldDuration:
		m.ClearDuration()
		return nil
	case productproperty.FieldLength:
		m.ClearLength()
		return nil
	case productproperty.FieldCount:
		m.ClearCount()
		return nil
	case productproperty.FieldPrice:
		m.ClearPrice()
		return nil
	case productproperty.FieldData:
		m.ClearData()
		return nil
	case productproperty.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown ProductProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPropertyMutation) ResetField(name string) error {
	switch name {
	case productproperty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productproperty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productproperty.FieldStatus:
		m.ResetStatus()
		return nil
	case productproperty.FieldType:
		m.ResetType()
		return nil
	case productproperty.FieldName:
		m.ResetName()
		return nil
	case productproperty.FieldDuration:
		m.ResetDuration()
		return nil
	case productproperty.FieldLength:
		m.ResetLength()
		return nil
	case productproperty.FieldCount:
		m.ResetCount()
		return nil
	case productproperty.FieldPrice:
		m.ResetPrice()
		return nil
	case productproperty.FieldData:
		m.ResetData()
		return nil
	case productproperty.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown ProductProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, productproperty.EdgeProduct)
	}
	if m.venues != nil {
		edges = append(edges, productproperty.EdgeVenues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productproperty.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	case productproperty.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.venues))
		for id := range m.venues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproduct != nil {
		edges = append(edges, productproperty.EdgeProduct)
	}
	if m.removedvenues != nil {
		edges = append(edges, productproperty.EdgeVenues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productproperty.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	case productproperty.EdgeVenues:
		ids := make([]ent.Value, 0, len(m.removedvenues))
		for id := range m.removedvenues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, productproperty.EdgeProduct)
	}
	if m.clearedvenues {
		edges = append(edges, productproperty.EdgeVenues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case productproperty.EdgeProduct:
		return m.clearedproduct
	case productproperty.EdgeVenues:
		return m.clearedvenues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPropertyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPropertyMutation) ResetEdge(name string) error {
	switch name {
	case productproperty.EdgeProduct:
		m.ResetProduct()
		return nil
	case productproperty.EdgeVenues:
		m.ResetVenues()
		return nil
	}
	return fmt.Errorf("unknown ProductProperty edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	status         *int64
	addstatus      *int64
	name           *string
	value          *string
	default_router *string
	remark         *string
	order_no       *int32
	addorder_no    *int32
	clearedFields  map[string]struct{}
	menus          map[int64]struct{}
	removedmenus   map[int64]struct{}
	clearedmenus   bool
	done           bool
	oldValue       func(context.Context) (*Role, error)
	predicates     []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RoleMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RoleMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RoleMutation) ResetValue() {
	m.value = nil
}

// SetDefaultRouter sets the "default_router" field.
func (m *RoleMutation) SetDefaultRouter(s string) {
	m.default_router = &s
}

// DefaultRouter returns the value of the "default_router" field in the mutation.
func (m *RoleMutation) DefaultRouter() (r string, exists bool) {
	v := m.default_router
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRouter returns the old "default_router" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDefaultRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRouter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRouter: %w", err)
	}
	return oldValue.DefaultRouter, nil
}

// ResetDefaultRouter resets all changes to the "default_router" field.
func (m *RoleMutation) ResetDefaultRouter() {
	m.default_router = nil
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
}

// SetOrderNo sets the "order_no" field.
func (m *RoleMutation) SetOrderNo(i int32) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RoleMutation) OrderNo() (r int32, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrderNo(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *RoleMutation) AddOrderNo(i int32) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *RoleMutation) AddedOrderNo() (r int32, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RoleMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.value != nil {
		fields = append(fields, role.FieldValue)
	}
	if m.default_router != nil {
		fields = append(fields, role.FieldDefaultRouter)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.order_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldValue:
		return m.Value()
	case role.FieldDefaultRouter:
		return m.DefaultRouter()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldOrderNo:
		return m.OrderNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldValue:
		return m.OldValue(ctx)
	case role.FieldDefaultRouter:
		return m.OldDefaultRouter(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldOrderNo:
		return m.OldOrderNo(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case role.FieldDefaultRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRouter(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldOrderNo:
		return m.AddedOrderNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldValue:
		m.ResetValue()
		return nil
	case role.FieldDefaultRouter:
		m.ResetDefaultRouter()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	status         *int64
	addstatus      *int64
	_type          *string
	name           *string
	venue_id       *int64
	addvenue_id    *int64
	property_id    *int64
	addproperty_id *int64
	place_id       *int64
	addplace_id    *int64
	num            *int64
	addnum         *int64
	date           *time.Time
	start_time     *time.Time
	end_time       *time.Time
	price          *float64
	addprice       *float64
	remark         *string
	clearedFields  map[string]struct{}
	members        map[int64]struct{}
	removedmembers map[int64]struct{}
	clearedmembers bool
	coachs         map[int64]struct{}
	removedcoachs  map[int64]struct{}
	clearedcoachs  bool
	done           bool
	oldValue       func(context.Context) (*Schedule, error)
	predicates     []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id int64) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Schedule entities.
func (m *ScheduleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Schedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ScheduleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScheduleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScheduleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScheduleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ScheduleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[schedule.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ScheduleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[schedule.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ScheduleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, schedule.FieldStatus)
}

// SetType sets the "type" field.
func (m *ScheduleMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduleMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ScheduleMutation) ClearType() {
	m._type = nil
	m.clearedFields[schedule.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ScheduleMutation) TypeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ScheduleMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, schedule.FieldType)
}

// SetName sets the "name" field.
func (m *ScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ScheduleMutation) ClearName() {
	m.name = nil
	m.clearedFields[schedule.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ScheduleMutation) NameCleared() bool {
	_, ok := m.clearedFields[schedule.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ScheduleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, schedule.FieldName)
}

// SetVenueID sets the "venue_id" field.
func (m *ScheduleMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ScheduleMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ScheduleMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ScheduleMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ScheduleMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[schedule.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ScheduleMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[schedule.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ScheduleMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, schedule.FieldVenueID)
}

// SetPropertyID sets the "property_id" field.
func (m *ScheduleMutation) SetPropertyID(i int64) {
	m.property_id = &i
	m.addproperty_id = nil
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *ScheduleMutation) PropertyID() (r int64, exists bool) {
	v := m.property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// AddPropertyID adds i to the "property_id" field.
func (m *ScheduleMutation) AddPropertyID(i int64) {
	if m.addproperty_id != nil {
		*m.addproperty_id += i
	} else {
		m.addproperty_id = &i
	}
}

// AddedPropertyID returns the value that was added to the "property_id" field in this mutation.
func (m *ScheduleMutation) AddedPropertyID() (r int64, exists bool) {
	v := m.addproperty_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPropertyID clears the value of the "property_id" field.
func (m *ScheduleMutation) ClearPropertyID() {
	m.property_id = nil
	m.addproperty_id = nil
	m.clearedFields[schedule.FieldPropertyID] = struct{}{}
}

// PropertyIDCleared returns if the "property_id" field was cleared in this mutation.
func (m *ScheduleMutation) PropertyIDCleared() bool {
	_, ok := m.clearedFields[schedule.FieldPropertyID]
	return ok
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *ScheduleMutation) ResetPropertyID() {
	m.property_id = nil
	m.addproperty_id = nil
	delete(m.clearedFields, schedule.FieldPropertyID)
}

// SetPlaceID sets the "place_id" field.
func (m *ScheduleMutation) SetPlaceID(i int64) {
	m.place_id = &i
	m.addplace_id = nil
}

// PlaceID returns the value of the "place_id" field in the mutation.
func (m *ScheduleMutation) PlaceID() (r int64, exists bool) {
	v := m.place_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceID returns the old "place_id" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldPlaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceID: %w", err)
	}
	return oldValue.PlaceID, nil
}

// AddPlaceID adds i to the "place_id" field.
func (m *ScheduleMutation) AddPlaceID(i int64) {
	if m.addplace_id != nil {
		*m.addplace_id += i
	} else {
		m.addplace_id = &i
	}
}

// AddedPlaceID returns the value that was added to the "place_id" field in this mutation.
func (m *ScheduleMutation) AddedPlaceID() (r int64, exists bool) {
	v := m.addplace_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlaceID clears the value of the "place_id" field.
func (m *ScheduleMutation) ClearPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	m.clearedFields[schedule.FieldPlaceID] = struct{}{}
}

// PlaceIDCleared returns if the "place_id" field was cleared in this mutation.
func (m *ScheduleMutation) PlaceIDCleared() bool {
	_, ok := m.clearedFields[schedule.FieldPlaceID]
	return ok
}

// ResetPlaceID resets all changes to the "place_id" field.
func (m *ScheduleMutation) ResetPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	delete(m.clearedFields, schedule.FieldPlaceID)
}

// SetNum sets the "num" field.
func (m *ScheduleMutation) SetNum(i int64) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *ScheduleMutation) Num() (r int64, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *ScheduleMutation) AddNum(i int64) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *ScheduleMutation) AddedNum() (r int64, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ClearNum clears the value of the "num" field.
func (m *ScheduleMutation) ClearNum() {
	m.num = nil
	m.addnum = nil
	m.clearedFields[schedule.FieldNum] = struct{}{}
}

// NumCleared returns if the "num" field was cleared in this mutation.
func (m *ScheduleMutation) NumCleared() bool {
	_, ok := m.clearedFields[schedule.FieldNum]
	return ok
}

// ResetNum resets all changes to the "num" field.
func (m *ScheduleMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
	delete(m.clearedFields, schedule.FieldNum)
}

// SetDate sets the "date" field.
func (m *ScheduleMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *ScheduleMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *ScheduleMutation) ClearDate() {
	m.date = nil
	m.clearedFields[schedule.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *ScheduleMutation) DateCleared() bool {
	_, ok := m.clearedFields[schedule.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *ScheduleMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, schedule.FieldDate)
}

// SetStartTime sets the "start_time" field.
func (m *ScheduleMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ScheduleMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ScheduleMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[schedule.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ScheduleMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ScheduleMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, schedule.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ScheduleMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ScheduleMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ScheduleMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[schedule.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ScheduleMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ScheduleMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, schedule.FieldEndTime)
}

// SetPrice sets the "price" field.
func (m *ScheduleMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ScheduleMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ScheduleMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ScheduleMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ScheduleMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[schedule.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ScheduleMutation) PriceCleared() bool {
	_, ok := m.clearedFields[schedule.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ScheduleMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, schedule.FieldPrice)
}

// SetRemark sets the "remark" field.
func (m *ScheduleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ScheduleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ScheduleMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[schedule.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ScheduleMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[schedule.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ScheduleMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, schedule.FieldRemark)
}

// AddMemberIDs adds the "members" edge to the ScheduleMember entity by ids.
func (m *ScheduleMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the ScheduleMember entity.
func (m *ScheduleMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the ScheduleMember entity was cleared.
func (m *ScheduleMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the ScheduleMember entity by IDs.
func (m *ScheduleMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the ScheduleMember entity.
func (m *ScheduleMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ScheduleMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ScheduleMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddCoachIDs adds the "coachs" edge to the ScheduleCoach entity by ids.
func (m *ScheduleMutation) AddCoachIDs(ids ...int64) {
	if m.coachs == nil {
		m.coachs = make(map[int64]struct{})
	}
	for i := range ids {
		m.coachs[ids[i]] = struct{}{}
	}
}

// ClearCoachs clears the "coachs" edge to the ScheduleCoach entity.
func (m *ScheduleMutation) ClearCoachs() {
	m.clearedcoachs = true
}

// CoachsCleared reports if the "coachs" edge to the ScheduleCoach entity was cleared.
func (m *ScheduleMutation) CoachsCleared() bool {
	return m.clearedcoachs
}

// RemoveCoachIDs removes the "coachs" edge to the ScheduleCoach entity by IDs.
func (m *ScheduleMutation) RemoveCoachIDs(ids ...int64) {
	if m.removedcoachs == nil {
		m.removedcoachs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.coachs, ids[i])
		m.removedcoachs[ids[i]] = struct{}{}
	}
}

// RemovedCoachs returns the removed IDs of the "coachs" edge to the ScheduleCoach entity.
func (m *ScheduleMutation) RemovedCoachsIDs() (ids []int64) {
	for id := range m.removedcoachs {
		ids = append(ids, id)
	}
	return
}

// CoachsIDs returns the "coachs" edge IDs in the mutation.
func (m *ScheduleMutation) CoachsIDs() (ids []int64) {
	for id := range m.coachs {
		ids = append(ids, id)
	}
	return
}

// ResetCoachs resets all changes to the "coachs" edge.
func (m *ScheduleMutation) ResetCoachs() {
	m.coachs = nil
	m.clearedcoachs = false
	m.removedcoachs = nil
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Schedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, schedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, schedule.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, schedule.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, schedule.FieldType)
	}
	if m.name != nil {
		fields = append(fields, schedule.FieldName)
	}
	if m.venue_id != nil {
		fields = append(fields, schedule.FieldVenueID)
	}
	if m.property_id != nil {
		fields = append(fields, schedule.FieldPropertyID)
	}
	if m.place_id != nil {
		fields = append(fields, schedule.FieldPlaceID)
	}
	if m.num != nil {
		fields = append(fields, schedule.FieldNum)
	}
	if m.date != nil {
		fields = append(fields, schedule.FieldDate)
	}
	if m.start_time != nil {
		fields = append(fields, schedule.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, schedule.FieldEndTime)
	}
	if m.price != nil {
		fields = append(fields, schedule.FieldPrice)
	}
	if m.remark != nil {
		fields = append(fields, schedule.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldCreatedAt:
		return m.CreatedAt()
	case schedule.FieldUpdatedAt:
		return m.UpdatedAt()
	case schedule.FieldStatus:
		return m.Status()
	case schedule.FieldType:
		return m.GetType()
	case schedule.FieldName:
		return m.Name()
	case schedule.FieldVenueID:
		return m.VenueID()
	case schedule.FieldPropertyID:
		return m.PropertyID()
	case schedule.FieldPlaceID:
		return m.PlaceID()
	case schedule.FieldNum:
		return m.Num()
	case schedule.FieldDate:
		return m.Date()
	case schedule.FieldStartTime:
		return m.StartTime()
	case schedule.FieldEndTime:
		return m.EndTime()
	case schedule.FieldPrice:
		return m.Price()
	case schedule.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case schedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case schedule.FieldStatus:
		return m.OldStatus(ctx)
	case schedule.FieldType:
		return m.OldType(ctx)
	case schedule.FieldName:
		return m.OldName(ctx)
	case schedule.FieldVenueID:
		return m.OldVenueID(ctx)
	case schedule.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case schedule.FieldPlaceID:
		return m.OldPlaceID(ctx)
	case schedule.FieldNum:
		return m.OldNum(ctx)
	case schedule.FieldDate:
		return m.OldDate(ctx)
	case schedule.FieldStartTime:
		return m.OldStartTime(ctx)
	case schedule.FieldEndTime:
		return m.OldEndTime(ctx)
	case schedule.FieldPrice:
		return m.OldPrice(ctx)
	case schedule.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case schedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case schedule.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case schedule.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case schedule.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case schedule.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case schedule.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceID(v)
		return nil
	case schedule.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case schedule.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case schedule.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case schedule.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case schedule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case schedule.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, schedule.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, schedule.FieldVenueID)
	}
	if m.addproperty_id != nil {
		fields = append(fields, schedule.FieldPropertyID)
	}
	if m.addplace_id != nil {
		fields = append(fields, schedule.FieldPlaceID)
	}
	if m.addnum != nil {
		fields = append(fields, schedule.FieldNum)
	}
	if m.addprice != nil {
		fields = append(fields, schedule.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldStatus:
		return m.AddedStatus()
	case schedule.FieldVenueID:
		return m.AddedVenueID()
	case schedule.FieldPropertyID:
		return m.AddedPropertyID()
	case schedule.FieldPlaceID:
		return m.AddedPlaceID()
	case schedule.FieldNum:
		return m.AddedNum()
	case schedule.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case schedule.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case schedule.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPropertyID(v)
		return nil
	case schedule.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlaceID(v)
		return nil
	case schedule.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case schedule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedule.FieldStatus) {
		fields = append(fields, schedule.FieldStatus)
	}
	if m.FieldCleared(schedule.FieldType) {
		fields = append(fields, schedule.FieldType)
	}
	if m.FieldCleared(schedule.FieldName) {
		fields = append(fields, schedule.FieldName)
	}
	if m.FieldCleared(schedule.FieldVenueID) {
		fields = append(fields, schedule.FieldVenueID)
	}
	if m.FieldCleared(schedule.FieldPropertyID) {
		fields = append(fields, schedule.FieldPropertyID)
	}
	if m.FieldCleared(schedule.FieldPlaceID) {
		fields = append(fields, schedule.FieldPlaceID)
	}
	if m.FieldCleared(schedule.FieldNum) {
		fields = append(fields, schedule.FieldNum)
	}
	if m.FieldCleared(schedule.FieldDate) {
		fields = append(fields, schedule.FieldDate)
	}
	if m.FieldCleared(schedule.FieldStartTime) {
		fields = append(fields, schedule.FieldStartTime)
	}
	if m.FieldCleared(schedule.FieldEndTime) {
		fields = append(fields, schedule.FieldEndTime)
	}
	if m.FieldCleared(schedule.FieldPrice) {
		fields = append(fields, schedule.FieldPrice)
	}
	if m.FieldCleared(schedule.FieldRemark) {
		fields = append(fields, schedule.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	switch name {
	case schedule.FieldStatus:
		m.ClearStatus()
		return nil
	case schedule.FieldType:
		m.ClearType()
		return nil
	case schedule.FieldName:
		m.ClearName()
		return nil
	case schedule.FieldVenueID:
		m.ClearVenueID()
		return nil
	case schedule.FieldPropertyID:
		m.ClearPropertyID()
		return nil
	case schedule.FieldPlaceID:
		m.ClearPlaceID()
		return nil
	case schedule.FieldNum:
		m.ClearNum()
		return nil
	case schedule.FieldDate:
		m.ClearDate()
		return nil
	case schedule.FieldStartTime:
		m.ClearStartTime()
		return nil
	case schedule.FieldEndTime:
		m.ClearEndTime()
		return nil
	case schedule.FieldPrice:
		m.ClearPrice()
		return nil
	case schedule.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case schedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case schedule.FieldStatus:
		m.ResetStatus()
		return nil
	case schedule.FieldType:
		m.ResetType()
		return nil
	case schedule.FieldName:
		m.ResetName()
		return nil
	case schedule.FieldVenueID:
		m.ResetVenueID()
		return nil
	case schedule.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case schedule.FieldPlaceID:
		m.ResetPlaceID()
		return nil
	case schedule.FieldNum:
		m.ResetNum()
		return nil
	case schedule.FieldDate:
		m.ResetDate()
		return nil
	case schedule.FieldStartTime:
		m.ResetStartTime()
		return nil
	case schedule.FieldEndTime:
		m.ResetEndTime()
		return nil
	case schedule.FieldPrice:
		m.ResetPrice()
		return nil
	case schedule.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.members != nil {
		edges = append(edges, schedule.EdgeMembers)
	}
	if m.coachs != nil {
		edges = append(edges, schedule.EdgeCoachs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case schedule.EdgeCoachs:
		ids := make([]ent.Value, 0, len(m.coachs))
		for id := range m.coachs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, schedule.EdgeMembers)
	}
	if m.removedcoachs != nil {
		edges = append(edges, schedule.EdgeCoachs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case schedule.EdgeCoachs:
		ids := make([]ent.Value, 0, len(m.removedcoachs))
		for id := range m.removedcoachs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmembers {
		edges = append(edges, schedule.EdgeMembers)
	}
	if m.clearedcoachs {
		edges = append(edges, schedule.EdgeCoachs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeMembers:
		return m.clearedmembers
	case schedule.EdgeCoachs:
		return m.clearedcoachs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeMembers:
		m.ResetMembers()
		return nil
	case schedule.EdgeCoachs:
		m.ResetCoachs()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// ScheduleCoachMutation represents an operation that mutates the ScheduleCoach nodes in the graph.
type ScheduleCoachMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	status          *int64
	addstatus       *int64
	venue_id        *int64
	addvenue_id     *int64
	coach_id        *int64
	addcoach_id     *int64
	_type           *string
	start_time      *time.Time
	end_time        *time.Time
	sign_start_time *time.Time
	sign_end_time   *time.Time
	clearedFields   map[string]struct{}
	schedule        *int64
	clearedschedule bool
	done            bool
	oldValue        func(context.Context) (*ScheduleCoach, error)
	predicates      []predicate.ScheduleCoach
}

var _ ent.Mutation = (*ScheduleCoachMutation)(nil)

// schedulecoachOption allows management of the mutation configuration using functional options.
type schedulecoachOption func(*ScheduleCoachMutation)

// newScheduleCoachMutation creates new mutation for the ScheduleCoach entity.
func newScheduleCoachMutation(c config, op Op, opts ...schedulecoachOption) *ScheduleCoachMutation {
	m := &ScheduleCoachMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduleCoach,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleCoachID sets the ID field of the mutation.
func withScheduleCoachID(id int64) schedulecoachOption {
	return func(m *ScheduleCoachMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduleCoach
		)
		m.oldValue = func(ctx context.Context) (*ScheduleCoach, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduleCoach.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduleCoach sets the old ScheduleCoach of the mutation.
func withScheduleCoach(node *ScheduleCoach) schedulecoachOption {
	return func(m *ScheduleCoachMutation) {
		m.oldValue = func(context.Context) (*ScheduleCoach, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleCoachMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleCoachMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheduleCoach entities.
func (m *ScheduleCoachMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleCoachMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleCoachMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduleCoach.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduleCoachMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduleCoachMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduleCoachMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduleCoachMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduleCoachMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduleCoachMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ScheduleCoachMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScheduleCoachMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScheduleCoachMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScheduleCoachMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ScheduleCoachMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[schedulecoach.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ScheduleCoachMutation) StatusCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ScheduleCoachMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, schedulecoach.FieldStatus)
}

// SetVenueID sets the "venue_id" field.
func (m *ScheduleCoachMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ScheduleCoachMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ScheduleCoachMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ScheduleCoachMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ScheduleCoachMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[schedulecoach.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ScheduleCoachMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, schedulecoach.FieldVenueID)
}

// SetCoachID sets the "coach_id" field.
func (m *ScheduleCoachMutation) SetCoachID(i int64) {
	m.coach_id = &i
	m.addcoach_id = nil
}

// CoachID returns the value of the "coach_id" field in the mutation.
func (m *ScheduleCoachMutation) CoachID() (r int64, exists bool) {
	v := m.coach_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoachID returns the old "coach_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldCoachID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoachID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoachID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoachID: %w", err)
	}
	return oldValue.CoachID, nil
}

// AddCoachID adds i to the "coach_id" field.
func (m *ScheduleCoachMutation) AddCoachID(i int64) {
	if m.addcoach_id != nil {
		*m.addcoach_id += i
	} else {
		m.addcoach_id = &i
	}
}

// AddedCoachID returns the value that was added to the "coach_id" field in this mutation.
func (m *ScheduleCoachMutation) AddedCoachID() (r int64, exists bool) {
	v := m.addcoach_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoachID clears the value of the "coach_id" field.
func (m *ScheduleCoachMutation) ClearCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	m.clearedFields[schedulecoach.FieldCoachID] = struct{}{}
}

// CoachIDCleared returns if the "coach_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) CoachIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldCoachID]
	return ok
}

// ResetCoachID resets all changes to the "coach_id" field.
func (m *ScheduleCoachMutation) ResetCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	delete(m.clearedFields, schedulecoach.FieldCoachID)
}

// SetScheduleID sets the "schedule_id" field.
func (m *ScheduleCoachMutation) SetScheduleID(i int64) {
	m.schedule = &i
}

// ScheduleID returns the value of the "schedule_id" field in the mutation.
func (m *ScheduleCoachMutation) ScheduleID() (r int64, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleID returns the old "schedule_id" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldScheduleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleID: %w", err)
	}
	return oldValue.ScheduleID, nil
}

// ClearScheduleID clears the value of the "schedule_id" field.
func (m *ScheduleCoachMutation) ClearScheduleID() {
	m.schedule = nil
	m.clearedFields[schedulecoach.FieldScheduleID] = struct{}{}
}

// ScheduleIDCleared returns if the "schedule_id" field was cleared in this mutation.
func (m *ScheduleCoachMutation) ScheduleIDCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldScheduleID]
	return ok
}

// ResetScheduleID resets all changes to the "schedule_id" field.
func (m *ScheduleCoachMutation) ResetScheduleID() {
	m.schedule = nil
	delete(m.clearedFields, schedulecoach.FieldScheduleID)
}

// SetType sets the "type" field.
func (m *ScheduleCoachMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduleCoachMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ScheduleCoachMutation) ClearType() {
	m._type = nil
	m.clearedFields[schedulecoach.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ScheduleCoachMutation) TypeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ScheduleCoachMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, schedulecoach.FieldType)
}

// SetStartTime sets the "start_time" field.
func (m *ScheduleCoachMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ScheduleCoachMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ScheduleCoachMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[schedulecoach.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ScheduleCoachMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, schedulecoach.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ScheduleCoachMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ScheduleCoachMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ScheduleCoachMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[schedulecoach.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ScheduleCoachMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, schedulecoach.FieldEndTime)
}

// SetSignStartTime sets the "sign_start_time" field.
func (m *ScheduleCoachMutation) SetSignStartTime(t time.Time) {
	m.sign_start_time = &t
}

// SignStartTime returns the value of the "sign_start_time" field in the mutation.
func (m *ScheduleCoachMutation) SignStartTime() (r time.Time, exists bool) {
	v := m.sign_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartTime returns the old "sign_start_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldSignStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartTime: %w", err)
	}
	return oldValue.SignStartTime, nil
}

// ClearSignStartTime clears the value of the "sign_start_time" field.
func (m *ScheduleCoachMutation) ClearSignStartTime() {
	m.sign_start_time = nil
	m.clearedFields[schedulecoach.FieldSignStartTime] = struct{}{}
}

// SignStartTimeCleared returns if the "sign_start_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) SignStartTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldSignStartTime]
	return ok
}

// ResetSignStartTime resets all changes to the "sign_start_time" field.
func (m *ScheduleCoachMutation) ResetSignStartTime() {
	m.sign_start_time = nil
	delete(m.clearedFields, schedulecoach.FieldSignStartTime)
}

// SetSignEndTime sets the "sign_end_time" field.
func (m *ScheduleCoachMutation) SetSignEndTime(t time.Time) {
	m.sign_end_time = &t
}

// SignEndTime returns the value of the "sign_end_time" field in the mutation.
func (m *ScheduleCoachMutation) SignEndTime() (r time.Time, exists bool) {
	v := m.sign_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndTime returns the old "sign_end_time" field's value of the ScheduleCoach entity.
// If the ScheduleCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleCoachMutation) OldSignEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndTime: %w", err)
	}
	return oldValue.SignEndTime, nil
}

// ClearSignEndTime clears the value of the "sign_end_time" field.
func (m *ScheduleCoachMutation) ClearSignEndTime() {
	m.sign_end_time = nil
	m.clearedFields[schedulecoach.FieldSignEndTime] = struct{}{}
}

// SignEndTimeCleared returns if the "sign_end_time" field was cleared in this mutation.
func (m *ScheduleCoachMutation) SignEndTimeCleared() bool {
	_, ok := m.clearedFields[schedulecoach.FieldSignEndTime]
	return ok
}

// ResetSignEndTime resets all changes to the "sign_end_time" field.
func (m *ScheduleCoachMutation) ResetSignEndTime() {
	m.sign_end_time = nil
	delete(m.clearedFields, schedulecoach.FieldSignEndTime)
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *ScheduleCoachMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[schedulecoach.FieldScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *ScheduleCoachMutation) ScheduleCleared() bool {
	return m.ScheduleIDCleared() || m.clearedschedule
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ScheduleCoachMutation) ScheduleIDs() (ids []int64) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ScheduleCoachMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the ScheduleCoachMutation builder.
func (m *ScheduleCoachMutation) Where(ps ...predicate.ScheduleCoach) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleCoachMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleCoachMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheduleCoach, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleCoachMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleCoachMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheduleCoach).
func (m *ScheduleCoachMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleCoachMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, schedulecoach.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, schedulecoach.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, schedulecoach.FieldStatus)
	}
	if m.venue_id != nil {
		fields = append(fields, schedulecoach.FieldVenueID)
	}
	if m.coach_id != nil {
		fields = append(fields, schedulecoach.FieldCoachID)
	}
	if m.schedule != nil {
		fields = append(fields, schedulecoach.FieldScheduleID)
	}
	if m._type != nil {
		fields = append(fields, schedulecoach.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, schedulecoach.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, schedulecoach.FieldEndTime)
	}
	if m.sign_start_time != nil {
		fields = append(fields, schedulecoach.FieldSignStartTime)
	}
	if m.sign_end_time != nil {
		fields = append(fields, schedulecoach.FieldSignEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleCoachMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedulecoach.FieldCreatedAt:
		return m.CreatedAt()
	case schedulecoach.FieldUpdatedAt:
		return m.UpdatedAt()
	case schedulecoach.FieldStatus:
		return m.Status()
	case schedulecoach.FieldVenueID:
		return m.VenueID()
	case schedulecoach.FieldCoachID:
		return m.CoachID()
	case schedulecoach.FieldScheduleID:
		return m.ScheduleID()
	case schedulecoach.FieldType:
		return m.GetType()
	case schedulecoach.FieldStartTime:
		return m.StartTime()
	case schedulecoach.FieldEndTime:
		return m.EndTime()
	case schedulecoach.FieldSignStartTime:
		return m.SignStartTime()
	case schedulecoach.FieldSignEndTime:
		return m.SignEndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleCoachMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedulecoach.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case schedulecoach.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case schedulecoach.FieldStatus:
		return m.OldStatus(ctx)
	case schedulecoach.FieldVenueID:
		return m.OldVenueID(ctx)
	case schedulecoach.FieldCoachID:
		return m.OldCoachID(ctx)
	case schedulecoach.FieldScheduleID:
		return m.OldScheduleID(ctx)
	case schedulecoach.FieldType:
		return m.OldType(ctx)
	case schedulecoach.FieldStartTime:
		return m.OldStartTime(ctx)
	case schedulecoach.FieldEndTime:
		return m.OldEndTime(ctx)
	case schedulecoach.FieldSignStartTime:
		return m.OldSignStartTime(ctx)
	case schedulecoach.FieldSignEndTime:
		return m.OldSignEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduleCoach field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleCoachMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedulecoach.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case schedulecoach.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case schedulecoach.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case schedulecoach.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case schedulecoach.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoachID(v)
		return nil
	case schedulecoach.FieldScheduleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleID(v)
		return nil
	case schedulecoach.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schedulecoach.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case schedulecoach.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case schedulecoach.FieldSignStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartTime(v)
		return nil
	case schedulecoach.FieldSignEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleCoachMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, schedulecoach.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, schedulecoach.FieldVenueID)
	}
	if m.addcoach_id != nil {
		fields = append(fields, schedulecoach.FieldCoachID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleCoachMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedulecoach.FieldStatus:
		return m.AddedStatus()
	case schedulecoach.FieldVenueID:
		return m.AddedVenueID()
	case schedulecoach.FieldCoachID:
		return m.AddedCoachID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleCoachMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedulecoach.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case schedulecoach.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case schedulecoach.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoachID(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleCoachMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedulecoach.FieldStatus) {
		fields = append(fields, schedulecoach.FieldStatus)
	}
	if m.FieldCleared(schedulecoach.FieldVenueID) {
		fields = append(fields, schedulecoach.FieldVenueID)
	}
	if m.FieldCleared(schedulecoach.FieldCoachID) {
		fields = append(fields, schedulecoach.FieldCoachID)
	}
	if m.FieldCleared(schedulecoach.FieldScheduleID) {
		fields = append(fields, schedulecoach.FieldScheduleID)
	}
	if m.FieldCleared(schedulecoach.FieldType) {
		fields = append(fields, schedulecoach.FieldType)
	}
	if m.FieldCleared(schedulecoach.FieldStartTime) {
		fields = append(fields, schedulecoach.FieldStartTime)
	}
	if m.FieldCleared(schedulecoach.FieldEndTime) {
		fields = append(fields, schedulecoach.FieldEndTime)
	}
	if m.FieldCleared(schedulecoach.FieldSignStartTime) {
		fields = append(fields, schedulecoach.FieldSignStartTime)
	}
	if m.FieldCleared(schedulecoach.FieldSignEndTime) {
		fields = append(fields, schedulecoach.FieldSignEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleCoachMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleCoachMutation) ClearField(name string) error {
	switch name {
	case schedulecoach.FieldStatus:
		m.ClearStatus()
		return nil
	case schedulecoach.FieldVenueID:
		m.ClearVenueID()
		return nil
	case schedulecoach.FieldCoachID:
		m.ClearCoachID()
		return nil
	case schedulecoach.FieldScheduleID:
		m.ClearScheduleID()
		return nil
	case schedulecoach.FieldType:
		m.ClearType()
		return nil
	case schedulecoach.FieldStartTime:
		m.ClearStartTime()
		return nil
	case schedulecoach.FieldEndTime:
		m.ClearEndTime()
		return nil
	case schedulecoach.FieldSignStartTime:
		m.ClearSignStartTime()
		return nil
	case schedulecoach.FieldSignEndTime:
		m.ClearSignEndTime()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleCoachMutation) ResetField(name string) error {
	switch name {
	case schedulecoach.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case schedulecoach.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case schedulecoach.FieldStatus:
		m.ResetStatus()
		return nil
	case schedulecoach.FieldVenueID:
		m.ResetVenueID()
		return nil
	case schedulecoach.FieldCoachID:
		m.ResetCoachID()
		return nil
	case schedulecoach.FieldScheduleID:
		m.ResetScheduleID()
		return nil
	case schedulecoach.FieldType:
		m.ResetType()
		return nil
	case schedulecoach.FieldStartTime:
		m.ResetStartTime()
		return nil
	case schedulecoach.FieldEndTime:
		m.ResetEndTime()
		return nil
	case schedulecoach.FieldSignStartTime:
		m.ResetSignStartTime()
		return nil
	case schedulecoach.FieldSignEndTime:
		m.ResetSignEndTime()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleCoachMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.schedule != nil {
		edges = append(edges, schedulecoach.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleCoachMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedulecoach.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleCoachMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleCoachMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleCoachMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedschedule {
		edges = append(edges, schedulecoach.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleCoachMutation) EdgeCleared(name string) bool {
	switch name {
	case schedulecoach.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleCoachMutation) ClearEdge(name string) error {
	switch name {
	case schedulecoach.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleCoachMutation) ResetEdge(name string) error {
	switch name {
	case schedulecoach.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleCoach edge %s", name)
}

// ScheduleMemberMutation represents an operation that mutates the ScheduleMember nodes in the graph.
type ScheduleMemberMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	status                        *int64
	addstatus                     *int64
	venue_id                      *int64
	addvenue_id                   *int64
	member_id                     *int64
	addmember_id                  *int64
	member_product_id             *int64
	addmember_product_id          *int64
	member_product_property_id    *int64
	addmember_product_property_id *int64
	_type                         *string
	start_time                    *time.Time
	end_time                      *time.Time
	sign_start_time               *time.Time
	sign_end_time                 *time.Time
	clearedFields                 map[string]struct{}
	schedule                      *int64
	clearedschedule               bool
	done                          bool
	oldValue                      func(context.Context) (*ScheduleMember, error)
	predicates                    []predicate.ScheduleMember
}

var _ ent.Mutation = (*ScheduleMemberMutation)(nil)

// schedulememberOption allows management of the mutation configuration using functional options.
type schedulememberOption func(*ScheduleMemberMutation)

// newScheduleMemberMutation creates new mutation for the ScheduleMember entity.
func newScheduleMemberMutation(c config, op Op, opts ...schedulememberOption) *ScheduleMemberMutation {
	m := &ScheduleMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduleMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleMemberID sets the ID field of the mutation.
func withScheduleMemberID(id int64) schedulememberOption {
	return func(m *ScheduleMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduleMember
		)
		m.oldValue = func(ctx context.Context) (*ScheduleMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduleMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduleMember sets the old ScheduleMember of the mutation.
func withScheduleMember(node *ScheduleMember) schedulememberOption {
	return func(m *ScheduleMemberMutation) {
		m.oldValue = func(context.Context) (*ScheduleMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheduleMember entities.
func (m *ScheduleMemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduleMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduleMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduleMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduleMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduleMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduleMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduleMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ScheduleMemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScheduleMemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScheduleMemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScheduleMemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ScheduleMemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[schedulemember.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ScheduleMemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ScheduleMemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, schedulemember.FieldStatus)
}

// SetVenueID sets the "venue_id" field.
func (m *ScheduleMemberMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ScheduleMemberMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ScheduleMemberMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ScheduleMemberMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[schedulemember.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ScheduleMemberMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, schedulemember.FieldVenueID)
}

// SetScheduleID sets the "schedule_id" field.
func (m *ScheduleMemberMutation) SetScheduleID(i int64) {
	m.schedule = &i
}

// ScheduleID returns the value of the "schedule_id" field in the mutation.
func (m *ScheduleMemberMutation) ScheduleID() (r int64, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleID returns the old "schedule_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldScheduleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleID: %w", err)
	}
	return oldValue.ScheduleID, nil
}

// ClearScheduleID clears the value of the "schedule_id" field.
func (m *ScheduleMemberMutation) ClearScheduleID() {
	m.schedule = nil
	m.clearedFields[schedulemember.FieldScheduleID] = struct{}{}
}

// ScheduleIDCleared returns if the "schedule_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) ScheduleIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldScheduleID]
	return ok
}

// ResetScheduleID resets all changes to the "schedule_id" field.
func (m *ScheduleMemberMutation) ResetScheduleID() {
	m.schedule = nil
	delete(m.clearedFields, schedulemember.FieldScheduleID)
}

// SetMemberID sets the "member_id" field.
func (m *ScheduleMemberMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *ScheduleMemberMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *ScheduleMemberMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *ScheduleMemberMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[schedulemember.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *ScheduleMemberMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, schedulemember.FieldMemberID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *ScheduleMemberMutation) SetMemberProductID(i int64) {
	m.member_product_id = &i
	m.addmember_product_id = nil
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *ScheduleMemberMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// AddMemberProductID adds i to the "member_product_id" field.
func (m *ScheduleMemberMutation) AddMemberProductID(i int64) {
	if m.addmember_product_id != nil {
		*m.addmember_product_id += i
	} else {
		m.addmember_product_id = &i
	}
}

// AddedMemberProductID returns the value that was added to the "member_product_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedMemberProductID() (r int64, exists bool) {
	v := m.addmember_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *ScheduleMemberMutation) ClearMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	m.clearedFields[schedulemember.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *ScheduleMemberMutation) ResetMemberProductID() {
	m.member_product_id = nil
	m.addmember_product_id = nil
	delete(m.clearedFields, schedulemember.FieldMemberProductID)
}

// SetMemberProductPropertyID sets the "member_product_property_id" field.
func (m *ScheduleMemberMutation) SetMemberProductPropertyID(i int64) {
	m.member_product_property_id = &i
	m.addmember_product_property_id = nil
}

// MemberProductPropertyID returns the value of the "member_product_property_id" field in the mutation.
func (m *ScheduleMemberMutation) MemberProductPropertyID() (r int64, exists bool) {
	v := m.member_product_property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductPropertyID returns the old "member_product_property_id" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldMemberProductPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductPropertyID: %w", err)
	}
	return oldValue.MemberProductPropertyID, nil
}

// AddMemberProductPropertyID adds i to the "member_product_property_id" field.
func (m *ScheduleMemberMutation) AddMemberProductPropertyID(i int64) {
	if m.addmember_product_property_id != nil {
		*m.addmember_product_property_id += i
	} else {
		m.addmember_product_property_id = &i
	}
}

// AddedMemberProductPropertyID returns the value that was added to the "member_product_property_id" field in this mutation.
func (m *ScheduleMemberMutation) AddedMemberProductPropertyID() (r int64, exists bool) {
	v := m.addmember_product_property_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberProductPropertyID clears the value of the "member_product_property_id" field.
func (m *ScheduleMemberMutation) ClearMemberProductPropertyID() {
	m.member_product_property_id = nil
	m.addmember_product_property_id = nil
	m.clearedFields[schedulemember.FieldMemberProductPropertyID] = struct{}{}
}

// MemberProductPropertyIDCleared returns if the "member_product_property_id" field was cleared in this mutation.
func (m *ScheduleMemberMutation) MemberProductPropertyIDCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldMemberProductPropertyID]
	return ok
}

// ResetMemberProductPropertyID resets all changes to the "member_product_property_id" field.
func (m *ScheduleMemberMutation) ResetMemberProductPropertyID() {
	m.member_product_property_id = nil
	m.addmember_product_property_id = nil
	delete(m.clearedFields, schedulemember.FieldMemberProductPropertyID)
}

// SetType sets the "type" field.
func (m *ScheduleMemberMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduleMemberMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ScheduleMemberMutation) ClearType() {
	m._type = nil
	m.clearedFields[schedulemember.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ScheduleMemberMutation) TypeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ScheduleMemberMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, schedulemember.FieldType)
}

// SetStartTime sets the "start_time" field.
func (m *ScheduleMemberMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ScheduleMemberMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ScheduleMemberMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[schedulemember.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ScheduleMemberMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, schedulemember.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ScheduleMemberMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ScheduleMemberMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ScheduleMemberMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[schedulemember.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ScheduleMemberMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, schedulemember.FieldEndTime)
}

// SetSignStartTime sets the "sign_start_time" field.
func (m *ScheduleMemberMutation) SetSignStartTime(t time.Time) {
	m.sign_start_time = &t
}

// SignStartTime returns the value of the "sign_start_time" field in the mutation.
func (m *ScheduleMemberMutation) SignStartTime() (r time.Time, exists bool) {
	v := m.sign_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartTime returns the old "sign_start_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldSignStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartTime: %w", err)
	}
	return oldValue.SignStartTime, nil
}

// ClearSignStartTime clears the value of the "sign_start_time" field.
func (m *ScheduleMemberMutation) ClearSignStartTime() {
	m.sign_start_time = nil
	m.clearedFields[schedulemember.FieldSignStartTime] = struct{}{}
}

// SignStartTimeCleared returns if the "sign_start_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) SignStartTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldSignStartTime]
	return ok
}

// ResetSignStartTime resets all changes to the "sign_start_time" field.
func (m *ScheduleMemberMutation) ResetSignStartTime() {
	m.sign_start_time = nil
	delete(m.clearedFields, schedulemember.FieldSignStartTime)
}

// SetSignEndTime sets the "sign_end_time" field.
func (m *ScheduleMemberMutation) SetSignEndTime(t time.Time) {
	m.sign_end_time = &t
}

// SignEndTime returns the value of the "sign_end_time" field in the mutation.
func (m *ScheduleMemberMutation) SignEndTime() (r time.Time, exists bool) {
	v := m.sign_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignEndTime returns the old "sign_end_time" field's value of the ScheduleMember entity.
// If the ScheduleMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMemberMutation) OldSignEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignEndTime: %w", err)
	}
	return oldValue.SignEndTime, nil
}

// ClearSignEndTime clears the value of the "sign_end_time" field.
func (m *ScheduleMemberMutation) ClearSignEndTime() {
	m.sign_end_time = nil
	m.clearedFields[schedulemember.FieldSignEndTime] = struct{}{}
}

// SignEndTimeCleared returns if the "sign_end_time" field was cleared in this mutation.
func (m *ScheduleMemberMutation) SignEndTimeCleared() bool {
	_, ok := m.clearedFields[schedulemember.FieldSignEndTime]
	return ok
}

// ResetSignEndTime resets all changes to the "sign_end_time" field.
func (m *ScheduleMemberMutation) ResetSignEndTime() {
	m.sign_end_time = nil
	delete(m.clearedFields, schedulemember.FieldSignEndTime)
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *ScheduleMemberMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[schedulemember.FieldScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *ScheduleMemberMutation) ScheduleCleared() bool {
	return m.ScheduleIDCleared() || m.clearedschedule
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ScheduleMemberMutation) ScheduleIDs() (ids []int64) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ScheduleMemberMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the ScheduleMemberMutation builder.
func (m *ScheduleMemberMutation) Where(ps ...predicate.ScheduleMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheduleMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheduleMember).
func (m *ScheduleMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMemberMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, schedulemember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, schedulemember.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, schedulemember.FieldStatus)
	}
	if m.venue_id != nil {
		fields = append(fields, schedulemember.FieldVenueID)
	}
	if m.schedule != nil {
		fields = append(fields, schedulemember.FieldScheduleID)
	}
	if m.member_id != nil {
		fields = append(fields, schedulemember.FieldMemberID)
	}
	if m.member_product_id != nil {
		fields = append(fields, schedulemember.FieldMemberProductID)
	}
	if m.member_product_property_id != nil {
		fields = append(fields, schedulemember.FieldMemberProductPropertyID)
	}
	if m._type != nil {
		fields = append(fields, schedulemember.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, schedulemember.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, schedulemember.FieldEndTime)
	}
	if m.sign_start_time != nil {
		fields = append(fields, schedulemember.FieldSignStartTime)
	}
	if m.sign_end_time != nil {
		fields = append(fields, schedulemember.FieldSignEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedulemember.FieldCreatedAt:
		return m.CreatedAt()
	case schedulemember.FieldUpdatedAt:
		return m.UpdatedAt()
	case schedulemember.FieldStatus:
		return m.Status()
	case schedulemember.FieldVenueID:
		return m.VenueID()
	case schedulemember.FieldScheduleID:
		return m.ScheduleID()
	case schedulemember.FieldMemberID:
		return m.MemberID()
	case schedulemember.FieldMemberProductID:
		return m.MemberProductID()
	case schedulemember.FieldMemberProductPropertyID:
		return m.MemberProductPropertyID()
	case schedulemember.FieldType:
		return m.GetType()
	case schedulemember.FieldStartTime:
		return m.StartTime()
	case schedulemember.FieldEndTime:
		return m.EndTime()
	case schedulemember.FieldSignStartTime:
		return m.SignStartTime()
	case schedulemember.FieldSignEndTime:
		return m.SignEndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedulemember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case schedulemember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case schedulemember.FieldStatus:
		return m.OldStatus(ctx)
	case schedulemember.FieldVenueID:
		return m.OldVenueID(ctx)
	case schedulemember.FieldScheduleID:
		return m.OldScheduleID(ctx)
	case schedulemember.FieldMemberID:
		return m.OldMemberID(ctx)
	case schedulemember.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case schedulemember.FieldMemberProductPropertyID:
		return m.OldMemberProductPropertyID(ctx)
	case schedulemember.FieldType:
		return m.OldType(ctx)
	case schedulemember.FieldStartTime:
		return m.OldStartTime(ctx)
	case schedulemember.FieldEndTime:
		return m.OldEndTime(ctx)
	case schedulemember.FieldSignStartTime:
		return m.OldSignStartTime(ctx)
	case schedulemember.FieldSignEndTime:
		return m.OldSignEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduleMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedulemember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case schedulemember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case schedulemember.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case schedulemember.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case schedulemember.FieldScheduleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleID(v)
		return nil
	case schedulemember.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case schedulemember.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case schedulemember.FieldMemberProductPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductPropertyID(v)
		return nil
	case schedulemember.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schedulemember.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case schedulemember.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case schedulemember.FieldSignStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartTime(v)
		return nil
	case schedulemember.FieldSignEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMemberMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, schedulemember.FieldStatus)
	}
	if m.addvenue_id != nil {
		fields = append(fields, schedulemember.FieldVenueID)
	}
	if m.addmember_id != nil {
		fields = append(fields, schedulemember.FieldMemberID)
	}
	if m.addmember_product_id != nil {
		fields = append(fields, schedulemember.FieldMemberProductID)
	}
	if m.addmember_product_property_id != nil {
		fields = append(fields, schedulemember.FieldMemberProductPropertyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedulemember.FieldStatus:
		return m.AddedStatus()
	case schedulemember.FieldVenueID:
		return m.AddedVenueID()
	case schedulemember.FieldMemberID:
		return m.AddedMemberID()
	case schedulemember.FieldMemberProductID:
		return m.AddedMemberProductID()
	case schedulemember.FieldMemberProductPropertyID:
		return m.AddedMemberProductPropertyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedulemember.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case schedulemember.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case schedulemember.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case schedulemember.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductID(v)
		return nil
	case schedulemember.FieldMemberProductPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberProductPropertyID(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedulemember.FieldStatus) {
		fields = append(fields, schedulemember.FieldStatus)
	}
	if m.FieldCleared(schedulemember.FieldVenueID) {
		fields = append(fields, schedulemember.FieldVenueID)
	}
	if m.FieldCleared(schedulemember.FieldScheduleID) {
		fields = append(fields, schedulemember.FieldScheduleID)
	}
	if m.FieldCleared(schedulemember.FieldMemberID) {
		fields = append(fields, schedulemember.FieldMemberID)
	}
	if m.FieldCleared(schedulemember.FieldMemberProductID) {
		fields = append(fields, schedulemember.FieldMemberProductID)
	}
	if m.FieldCleared(schedulemember.FieldMemberProductPropertyID) {
		fields = append(fields, schedulemember.FieldMemberProductPropertyID)
	}
	if m.FieldCleared(schedulemember.FieldType) {
		fields = append(fields, schedulemember.FieldType)
	}
	if m.FieldCleared(schedulemember.FieldStartTime) {
		fields = append(fields, schedulemember.FieldStartTime)
	}
	if m.FieldCleared(schedulemember.FieldEndTime) {
		fields = append(fields, schedulemember.FieldEndTime)
	}
	if m.FieldCleared(schedulemember.FieldSignStartTime) {
		fields = append(fields, schedulemember.FieldSignStartTime)
	}
	if m.FieldCleared(schedulemember.FieldSignEndTime) {
		fields = append(fields, schedulemember.FieldSignEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMemberMutation) ClearField(name string) error {
	switch name {
	case schedulemember.FieldStatus:
		m.ClearStatus()
		return nil
	case schedulemember.FieldVenueID:
		m.ClearVenueID()
		return nil
	case schedulemember.FieldScheduleID:
		m.ClearScheduleID()
		return nil
	case schedulemember.FieldMemberID:
		m.ClearMemberID()
		return nil
	case schedulemember.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case schedulemember.FieldMemberProductPropertyID:
		m.ClearMemberProductPropertyID()
		return nil
	case schedulemember.FieldType:
		m.ClearType()
		return nil
	case schedulemember.FieldStartTime:
		m.ClearStartTime()
		return nil
	case schedulemember.FieldEndTime:
		m.ClearEndTime()
		return nil
	case schedulemember.FieldSignStartTime:
		m.ClearSignStartTime()
		return nil
	case schedulemember.FieldSignEndTime:
		m.ClearSignEndTime()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMemberMutation) ResetField(name string) error {
	switch name {
	case schedulemember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case schedulemember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case schedulemember.FieldStatus:
		m.ResetStatus()
		return nil
	case schedulemember.FieldVenueID:
		m.ResetVenueID()
		return nil
	case schedulemember.FieldScheduleID:
		m.ResetScheduleID()
		return nil
	case schedulemember.FieldMemberID:
		m.ResetMemberID()
		return nil
	case schedulemember.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case schedulemember.FieldMemberProductPropertyID:
		m.ResetMemberProductPropertyID()
		return nil
	case schedulemember.FieldType:
		m.ResetType()
		return nil
	case schedulemember.FieldStartTime:
		m.ResetStartTime()
		return nil
	case schedulemember.FieldEndTime:
		m.ResetEndTime()
		return nil
	case schedulemember.FieldSignStartTime:
		m.ResetSignStartTime()
		return nil
	case schedulemember.FieldSignEndTime:
		m.ResetSignEndTime()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.schedule != nil {
		edges = append(edges, schedulemember.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedulemember.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedschedule {
		edges = append(edges, schedulemember.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case schedulemember.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMemberMutation) ClearEdge(name string) error {
	switch name {
	case schedulemember.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMemberMutation) ResetEdge(name string) error {
	switch name {
	case schedulemember.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown ScheduleMember edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int64
	adduser_id    *int64
	token         *string
	source        *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int64) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TokenMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TokenMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetSource sets the "source" field.
func (m *TokenMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TokenMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TokenMutation) ResetSource() {
	m.source = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TokenMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TokenMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.source != nil {
		fields = append(fields, token.FieldSource)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldUserID:
		return m.UserID()
	case token.FieldToken:
		return m.Token()
	case token.FieldSource:
		return m.Source()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldSource:
		return m.OldSource(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldSource:
		m.ResetSource()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	status                *int64
	addstatus             *int64
	username              *string
	password              *string
	nickname              *string
	side_mode             *string
	base_color            *string
	active_color          *string
	role_id               *int64
	addrole_id            *int64
	mobile                *string
	email                 *string
	wecom                 *string
	job                   *string
	organization          *string
	avatar                *string
	clearedFields         map[string]struct{}
	token                 *int64
	clearedtoken          bool
	created_orders        map[int64]struct{}
	removedcreated_orders map[int64]struct{}
	clearedcreated_orders bool
	user_entry            map[int64]struct{}
	removeduser_entry     map[int64]struct{}
	cleareduser_entry     bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetSideMode sets the "side_mode" field.
func (m *UserMutation) SetSideMode(s string) {
	m.side_mode = &s
}

// SideMode returns the value of the "side_mode" field in the mutation.
func (m *UserMutation) SideMode() (r string, exists bool) {
	v := m.side_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSideMode returns the old "side_mode" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSideMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSideMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSideMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSideMode: %w", err)
	}
	return oldValue.SideMode, nil
}

// ClearSideMode clears the value of the "side_mode" field.
func (m *UserMutation) ClearSideMode() {
	m.side_mode = nil
	m.clearedFields[user.FieldSideMode] = struct{}{}
}

// SideModeCleared returns if the "side_mode" field was cleared in this mutation.
func (m *UserMutation) SideModeCleared() bool {
	_, ok := m.clearedFields[user.FieldSideMode]
	return ok
}

// ResetSideMode resets all changes to the "side_mode" field.
func (m *UserMutation) ResetSideMode() {
	m.side_mode = nil
	delete(m.clearedFields, user.FieldSideMode)
}

// SetBaseColor sets the "base_color" field.
func (m *UserMutation) SetBaseColor(s string) {
	m.base_color = &s
}

// BaseColor returns the value of the "base_color" field in the mutation.
func (m *UserMutation) BaseColor() (r string, exists bool) {
	v := m.base_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseColor returns the old "base_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBaseColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseColor: %w", err)
	}
	return oldValue.BaseColor, nil
}

// ClearBaseColor clears the value of the "base_color" field.
func (m *UserMutation) ClearBaseColor() {
	m.base_color = nil
	m.clearedFields[user.FieldBaseColor] = struct{}{}
}

// BaseColorCleared returns if the "base_color" field was cleared in this mutation.
func (m *UserMutation) BaseColorCleared() bool {
	_, ok := m.clearedFields[user.FieldBaseColor]
	return ok
}

// ResetBaseColor resets all changes to the "base_color" field.
func (m *UserMutation) ResetBaseColor() {
	m.base_color = nil
	delete(m.clearedFields, user.FieldBaseColor)
}

// SetActiveColor sets the "active_color" field.
func (m *UserMutation) SetActiveColor(s string) {
	m.active_color = &s
}

// ActiveColor returns the value of the "active_color" field in the mutation.
func (m *UserMutation) ActiveColor() (r string, exists bool) {
	v := m.active_color
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveColor returns the old "active_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActiveColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveColor: %w", err)
	}
	return oldValue.ActiveColor, nil
}

// ClearActiveColor clears the value of the "active_color" field.
func (m *UserMutation) ClearActiveColor() {
	m.active_color = nil
	m.clearedFields[user.FieldActiveColor] = struct{}{}
}

// ActiveColorCleared returns if the "active_color" field was cleared in this mutation.
func (m *UserMutation) ActiveColorCleared() bool {
	_, ok := m.clearedFields[user.FieldActiveColor]
	return ok
}

// ResetActiveColor resets all changes to the "active_color" field.
func (m *UserMutation) ResetActiveColor() {
	m.active_color = nil
	delete(m.clearedFields, user.FieldActiveColor)
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(i int64) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r int64, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *UserMutation) AddRoleID(i int64) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *UserMutation) AddedRoleID() (r int64, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, user.FieldRoleID)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *UserMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *UserMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *UserMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[user.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *UserMutation) WecomCleared() bool {
	_, ok := m.clearedFields[user.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *UserMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, user.FieldWecom)
}

// SetJob sets the "job" field.
func (m *UserMutation) SetJob(s string) {
	m.job = &s
}

// Job returns the value of the "job" field in the mutation.
func (m *UserMutation) Job() (r string, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJob returns the old "job" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJob(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJob: %w", err)
	}
	return oldValue.Job, nil
}

// ClearJob clears the value of the "job" field.
func (m *UserMutation) ClearJob() {
	m.job = nil
	m.clearedFields[user.FieldJob] = struct{}{}
}

// JobCleared returns if the "job" field was cleared in this mutation.
func (m *UserMutation) JobCleared() bool {
	_, ok := m.clearedFields[user.FieldJob]
	return ok
}

// ResetJob resets all changes to the "job" field.
func (m *UserMutation) ResetJob() {
	m.job = nil
	delete(m.clearedFields, user.FieldJob)
}

// SetOrganization sets the "organization" field.
func (m *UserMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *UserMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *UserMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[user.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *UserMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[user.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, user.FieldOrganization)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetTokenID sets the "token" edge to the Token entity by id.
func (m *UserMutation) SetTokenID(id int64) {
	m.token = &id
}

// ClearToken clears the "token" edge to the Token entity.
func (m *UserMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the Token entity was cleared.
func (m *UserMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the "token" edge ID in the mutation.
func (m *UserMutation) TokenID() (id int64, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TokenIDs() (ids []int64) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *UserMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// AddCreatedOrderIDs adds the "created_orders" edge to the Order entity by ids.
func (m *UserMutation) AddCreatedOrderIDs(ids ...int64) {
	if m.created_orders == nil {
		m.created_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.created_orders[ids[i]] = struct{}{}
	}
}

// ClearCreatedOrders clears the "created_orders" edge to the Order entity.
func (m *UserMutation) ClearCreatedOrders() {
	m.clearedcreated_orders = true
}

// CreatedOrdersCleared reports if the "created_orders" edge to the Order entity was cleared.
func (m *UserMutation) CreatedOrdersCleared() bool {
	return m.clearedcreated_orders
}

// RemoveCreatedOrderIDs removes the "created_orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveCreatedOrderIDs(ids ...int64) {
	if m.removedcreated_orders == nil {
		m.removedcreated_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.created_orders, ids[i])
		m.removedcreated_orders[ids[i]] = struct{}{}
	}
}

// RemovedCreatedOrders returns the removed IDs of the "created_orders" edge to the Order entity.
func (m *UserMutation) RemovedCreatedOrdersIDs() (ids []int64) {
	for id := range m.removedcreated_orders {
		ids = append(ids, id)
	}
	return
}

// CreatedOrdersIDs returns the "created_orders" edge IDs in the mutation.
func (m *UserMutation) CreatedOrdersIDs() (ids []int64) {
	for id := range m.created_orders {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedOrders resets all changes to the "created_orders" edge.
func (m *UserMutation) ResetCreatedOrders() {
	m.created_orders = nil
	m.clearedcreated_orders = false
	m.removedcreated_orders = nil
}

// AddUserEntryIDs adds the "user_entry" edge to the EntryLogs entity by ids.
func (m *UserMutation) AddUserEntryIDs(ids ...int64) {
	if m.user_entry == nil {
		m.user_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_entry[ids[i]] = struct{}{}
	}
}

// ClearUserEntry clears the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) ClearUserEntry() {
	m.cleareduser_entry = true
}

// UserEntryCleared reports if the "user_entry" edge to the EntryLogs entity was cleared.
func (m *UserMutation) UserEntryCleared() bool {
	return m.cleareduser_entry
}

// RemoveUserEntryIDs removes the "user_entry" edge to the EntryLogs entity by IDs.
func (m *UserMutation) RemoveUserEntryIDs(ids ...int64) {
	if m.removeduser_entry == nil {
		m.removeduser_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_entry, ids[i])
		m.removeduser_entry[ids[i]] = struct{}{}
	}
}

// RemovedUserEntry returns the removed IDs of the "user_entry" edge to the EntryLogs entity.
func (m *UserMutation) RemovedUserEntryIDs() (ids []int64) {
	for id := range m.removeduser_entry {
		ids = append(ids, id)
	}
	return
}

// UserEntryIDs returns the "user_entry" edge IDs in the mutation.
func (m *UserMutation) UserEntryIDs() (ids []int64) {
	for id := range m.user_entry {
		ids = append(ids, id)
	}
	return
}

// ResetUserEntry resets all changes to the "user_entry" edge.
func (m *UserMutation) ResetUserEntry() {
	m.user_entry = nil
	m.cleareduser_entry = false
	m.removeduser_entry = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.side_mode != nil {
		fields = append(fields, user.FieldSideMode)
	}
	if m.base_color != nil {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.active_color != nil {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.role_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, user.FieldWecom)
	}
	if m.job != nil {
		fields = append(fields, user.FieldJob)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganization)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldSideMode:
		return m.SideMode()
	case user.FieldBaseColor:
		return m.BaseColor()
	case user.FieldActiveColor:
		return m.ActiveColor()
	case user.FieldRoleID:
		return m.RoleID()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldEmail:
		return m.Email()
	case user.FieldWecom:
		return m.Wecom()
	case user.FieldJob:
		return m.Job()
	case user.FieldOrganization:
		return m.Organization()
	case user.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldSideMode:
		return m.OldSideMode(ctx)
	case user.FieldBaseColor:
		return m.OldBaseColor(ctx)
	case user.FieldActiveColor:
		return m.OldActiveColor(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldWecom:
		return m.OldWecom(ctx)
	case user.FieldJob:
		return m.OldJob(ctx)
	case user.FieldOrganization:
		return m.OldOrganization(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldSideMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSideMode(v)
		return nil
	case user.FieldBaseColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseColor(v)
		return nil
	case user.FieldActiveColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveColor(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case user.FieldJob:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJob(v)
		return nil
	case user.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addrole_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldRoleID:
		return m.AddedRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldSideMode) {
		fields = append(fields, user.FieldSideMode)
	}
	if m.FieldCleared(user.FieldBaseColor) {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.FieldCleared(user.FieldActiveColor) {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.FieldCleared(user.FieldRoleID) {
		fields = append(fields, user.FieldRoleID)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldWecom) {
		fields = append(fields, user.FieldWecom)
	}
	if m.FieldCleared(user.FieldJob) {
		fields = append(fields, user.FieldJob)
	}
	if m.FieldCleared(user.FieldOrganization) {
		fields = append(fields, user.FieldOrganization)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldSideMode:
		m.ClearSideMode()
		return nil
	case user.FieldBaseColor:
		m.ClearBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ClearActiveColor()
		return nil
	case user.FieldRoleID:
		m.ClearRoleID()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldWecom:
		m.ClearWecom()
		return nil
	case user.FieldJob:
		m.ClearJob()
		return nil
	case user.FieldOrganization:
		m.ClearOrganization()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldSideMode:
		m.ResetSideMode()
		return nil
	case user.FieldBaseColor:
		m.ResetBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ResetActiveColor()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldWecom:
		m.ResetWecom()
		return nil
	case user.FieldJob:
		m.ResetJob()
		return nil
	case user.FieldOrganization:
		m.ResetOrganization()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.token != nil {
		edges = append(edges, user.EdgeToken)
	}
	if m.created_orders != nil {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.user_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedOrders:
		ids := make([]ent.Value, 0, len(m.created_orders))
		for id := range m.created_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.user_entry))
		for id := range m.user_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcreated_orders != nil {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.removeduser_entry != nil {
		edges = append(edges, user.EdgeUserEntry)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCreatedOrders:
		ids := make([]ent.Value, 0, len(m.removedcreated_orders))
		for id := range m.removedcreated_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserEntry:
		ids := make([]ent.Value, 0, len(m.removeduser_entry))
		for id := range m.removeduser_entry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtoken {
		edges = append(edges, user.EdgeToken)
	}
	if m.clearedcreated_orders {
		edges = append(edges, user.EdgeCreatedOrders)
	}
	if m.cleareduser_entry {
		edges = append(edges, user.EdgeUserEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeToken:
		return m.clearedtoken
	case user.EdgeCreatedOrders:
		return m.clearedcreated_orders
	case user.EdgeUserEntry:
		return m.cleareduser_entry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ResetToken()
		return nil
	case user.EdgeCreatedOrders:
		m.ResetCreatedOrders()
		return nil
	case user.EdgeUserEntry:
		m.ResetUserEntry()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VenueMutation represents an operation that mutates the Venue nodes in the graph.
type VenueMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	status                        *int64
	addstatus                     *int64
	name                          *string
	address                       *string
	address_detail                *string
	latitude                      *string
	longitude                     *string
	mobile                        *string
	pic                           *string
	information                   *string
	clearedFields                 map[string]struct{}
	places                        map[int64]struct{}
	removedplaces                 map[int64]struct{}
	clearedplaces                 bool
	venue_orders                  map[int64]struct{}
	removedvenue_orders           map[int64]struct{}
	clearedvenue_orders           bool
	venue_entry                   map[int64]struct{}
	removedvenue_entry            map[int64]struct{}
	clearedvenue_entry            bool
	member_property_venues        map[int64]struct{}
	removedmember_property_venues map[int64]struct{}
	clearedmember_property_venues bool
	property_venues               map[int64]struct{}
	removedproperty_venues        map[int64]struct{}
	clearedproperty_venues        bool
	done                          bool
	oldValue                      func(context.Context) (*Venue, error)
	predicates                    []predicate.Venue
}

var _ ent.Mutation = (*VenueMutation)(nil)

// venueOption allows management of the mutation configuration using functional options.
type venueOption func(*VenueMutation)

// newVenueMutation creates new mutation for the Venue entity.
func newVenueMutation(c config, op Op, opts ...venueOption) *VenueMutation {
	m := &VenueMutation{
		config:        c,
		op:            op,
		typ:           TypeVenue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueID sets the ID field of the mutation.
func withVenueID(id int64) venueOption {
	return func(m *VenueMutation) {
		var (
			err   error
			once  sync.Once
			value *Venue
		)
		m.oldValue = func(ctx context.Context) (*Venue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Venue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenue sets the old Venue of the mutation.
func withVenue(node *Venue) venueOption {
	return func(m *VenueMutation) {
		m.oldValue = func(context.Context) (*Venue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Venue entities.
func (m *VenueMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Venue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *VenueMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenueMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenueMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenueMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenueMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venue.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenueMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venue.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenueMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venue.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenueMutation) ClearName() {
	m.name = nil
	m.clearedFields[venue.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenueMutation) NameCleared() bool {
	_, ok := m.clearedFields[venue.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenueMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venue.FieldName)
}

// SetAddress sets the "address" field.
func (m *VenueMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VenueMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VenueMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[venue.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VenueMutation) AddressCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VenueMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, venue.FieldAddress)
}

// SetAddressDetail sets the "address_detail" field.
func (m *VenueMutation) SetAddressDetail(s string) {
	m.address_detail = &s
}

// AddressDetail returns the value of the "address_detail" field in the mutation.
func (m *VenueMutation) AddressDetail() (r string, exists bool) {
	v := m.address_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "address_detail" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddressDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "address_detail" field.
func (m *VenueMutation) ClearAddressDetail() {
	m.address_detail = nil
	m.clearedFields[venue.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "address_detail" field was cleared in this mutation.
func (m *VenueMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "address_detail" field.
func (m *VenueMutation) ResetAddressDetail() {
	m.address_detail = nil
	delete(m.clearedFields, venue.FieldAddressDetail)
}

// SetLatitude sets the "latitude" field.
func (m *VenueMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *VenueMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *VenueMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[venue.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *VenueMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *VenueMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, venue.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *VenueMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *VenueMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *VenueMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[venue.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *VenueMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *VenueMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, venue.FieldLongitude)
}

// SetMobile sets the "mobile" field.
func (m *VenueMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *VenueMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *VenueMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[venue.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *VenueMutation) MobileCleared() bool {
	_, ok := m.clearedFields[venue.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *VenueMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, venue.FieldMobile)
}

// SetPic sets the "pic" field.
func (m *VenueMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenueMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenueMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venue.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenueMutation) PicCleared() bool {
	_, ok := m.clearedFields[venue.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenueMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venue.FieldPic)
}

// SetInformation sets the "information" field.
func (m *VenueMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the value of the "information" field in the mutation.
func (m *VenueMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old "information" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ClearInformation clears the value of the "information" field.
func (m *VenueMutation) ClearInformation() {
	m.information = nil
	m.clearedFields[venue.FieldInformation] = struct{}{}
}

// InformationCleared returns if the "information" field was cleared in this mutation.
func (m *VenueMutation) InformationCleared() bool {
	_, ok := m.clearedFields[venue.FieldInformation]
	return ok
}

// ResetInformation resets all changes to the "information" field.
func (m *VenueMutation) ResetInformation() {
	m.information = nil
	delete(m.clearedFields, venue.FieldInformation)
}

// AddPlaceIDs adds the "places" edge to the VenuePlace entity by ids.
func (m *VenueMutation) AddPlaceIDs(ids ...int64) {
	if m.places == nil {
		m.places = make(map[int64]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the VenuePlace entity.
func (m *VenueMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the VenuePlace entity was cleared.
func (m *VenueMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the VenuePlace entity by IDs.
func (m *VenueMutation) RemovePlaceIDs(ids ...int64) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the VenuePlace entity.
func (m *VenueMutation) RemovedPlacesIDs() (ids []int64) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *VenueMutation) PlacesIDs() (ids []int64) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *VenueMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// AddVenueOrderIDs adds the "venue_orders" edge to the Order entity by ids.
func (m *VenueMutation) AddVenueOrderIDs(ids ...int64) {
	if m.venue_orders == nil {
		m.venue_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.venue_orders[ids[i]] = struct{}{}
	}
}

// ClearVenueOrders clears the "venue_orders" edge to the Order entity.
func (m *VenueMutation) ClearVenueOrders() {
	m.clearedvenue_orders = true
}

// VenueOrdersCleared reports if the "venue_orders" edge to the Order entity was cleared.
func (m *VenueMutation) VenueOrdersCleared() bool {
	return m.clearedvenue_orders
}

// RemoveVenueOrderIDs removes the "venue_orders" edge to the Order entity by IDs.
func (m *VenueMutation) RemoveVenueOrderIDs(ids ...int64) {
	if m.removedvenue_orders == nil {
		m.removedvenue_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venue_orders, ids[i])
		m.removedvenue_orders[ids[i]] = struct{}{}
	}
}

// RemovedVenueOrders returns the removed IDs of the "venue_orders" edge to the Order entity.
func (m *VenueMutation) RemovedVenueOrdersIDs() (ids []int64) {
	for id := range m.removedvenue_orders {
		ids = append(ids, id)
	}
	return
}

// VenueOrdersIDs returns the "venue_orders" edge IDs in the mutation.
func (m *VenueMutation) VenueOrdersIDs() (ids []int64) {
	for id := range m.venue_orders {
		ids = append(ids, id)
	}
	return
}

// ResetVenueOrders resets all changes to the "venue_orders" edge.
func (m *VenueMutation) ResetVenueOrders() {
	m.venue_orders = nil
	m.clearedvenue_orders = false
	m.removedvenue_orders = nil
}

// AddVenueEntryIDs adds the "venue_entry" edge to the EntryLogs entity by ids.
func (m *VenueMutation) AddVenueEntryIDs(ids ...int64) {
	if m.venue_entry == nil {
		m.venue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		m.venue_entry[ids[i]] = struct{}{}
	}
}

// ClearVenueEntry clears the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) ClearVenueEntry() {
	m.clearedvenue_entry = true
}

// VenueEntryCleared reports if the "venue_entry" edge to the EntryLogs entity was cleared.
func (m *VenueMutation) VenueEntryCleared() bool {
	return m.clearedvenue_entry
}

// RemoveVenueEntryIDs removes the "venue_entry" edge to the EntryLogs entity by IDs.
func (m *VenueMutation) RemoveVenueEntryIDs(ids ...int64) {
	if m.removedvenue_entry == nil {
		m.removedvenue_entry = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.venue_entry, ids[i])
		m.removedvenue_entry[ids[i]] = struct{}{}
	}
}

// RemovedVenueEntry returns the removed IDs of the "venue_entry" edge to the EntryLogs entity.
func (m *VenueMutation) RemovedVenueEntryIDs() (ids []int64) {
	for id := range m.removedvenue_entry {
		ids = append(ids, id)
	}
	return
}

// VenueEntryIDs returns the "venue_entry" edge IDs in the mutation.
func (m *VenueMutation) VenueEntryIDs() (ids []int64) {
	for id := range m.venue_entry {
		ids = append(ids, id)
	}
	return
}

// ResetVenueEntry resets all changes to the "venue_entry" edge.
func (m *VenueMutation) ResetVenueEntry() {
	m.venue_entry = nil
	m.clearedvenue_entry = false
	m.removedvenue_entry = nil
}

// AddMemberPropertyVenueIDs adds the "member_property_venues" edge to the MemberProductProperty entity by ids.
func (m *VenueMutation) AddMemberPropertyVenueIDs(ids ...int64) {
	if m.member_property_venues == nil {
		m.member_property_venues = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_property_venues[ids[i]] = struct{}{}
	}
}

// ClearMemberPropertyVenues clears the "member_property_venues" edge to the MemberProductProperty entity.
func (m *VenueMutation) ClearMemberPropertyVenues() {
	m.clearedmember_property_venues = true
}

// MemberPropertyVenuesCleared reports if the "member_property_venues" edge to the MemberProductProperty entity was cleared.
func (m *VenueMutation) MemberPropertyVenuesCleared() bool {
	return m.clearedmember_property_venues
}

// RemoveMemberPropertyVenueIDs removes the "member_property_venues" edge to the MemberProductProperty entity by IDs.
func (m *VenueMutation) RemoveMemberPropertyVenueIDs(ids ...int64) {
	if m.removedmember_property_venues == nil {
		m.removedmember_property_venues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_property_venues, ids[i])
		m.removedmember_property_venues[ids[i]] = struct{}{}
	}
}

// RemovedMemberPropertyVenues returns the removed IDs of the "member_property_venues" edge to the MemberProductProperty entity.
func (m *VenueMutation) RemovedMemberPropertyVenuesIDs() (ids []int64) {
	for id := range m.removedmember_property_venues {
		ids = append(ids, id)
	}
	return
}

// MemberPropertyVenuesIDs returns the "member_property_venues" edge IDs in the mutation.
func (m *VenueMutation) MemberPropertyVenuesIDs() (ids []int64) {
	for id := range m.member_property_venues {
		ids = append(ids, id)
	}
	return
}

// ResetMemberPropertyVenues resets all changes to the "member_property_venues" edge.
func (m *VenueMutation) ResetMemberPropertyVenues() {
	m.member_property_venues = nil
	m.clearedmember_property_venues = false
	m.removedmember_property_venues = nil
}

// AddPropertyVenueIDs adds the "property_venues" edge to the ProductProperty entity by ids.
func (m *VenueMutation) AddPropertyVenueIDs(ids ...int64) {
	if m.property_venues == nil {
		m.property_venues = make(map[int64]struct{})
	}
	for i := range ids {
		m.property_venues[ids[i]] = struct{}{}
	}
}

// ClearPropertyVenues clears the "property_venues" edge to the ProductProperty entity.
func (m *VenueMutation) ClearPropertyVenues() {
	m.clearedproperty_venues = true
}

// PropertyVenuesCleared reports if the "property_venues" edge to the ProductProperty entity was cleared.
func (m *VenueMutation) PropertyVenuesCleared() bool {
	return m.clearedproperty_venues
}

// RemovePropertyVenueIDs removes the "property_venues" edge to the ProductProperty entity by IDs.
func (m *VenueMutation) RemovePropertyVenueIDs(ids ...int64) {
	if m.removedproperty_venues == nil {
		m.removedproperty_venues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.property_venues, ids[i])
		m.removedproperty_venues[ids[i]] = struct{}{}
	}
}

// RemovedPropertyVenues returns the removed IDs of the "property_venues" edge to the ProductProperty entity.
func (m *VenueMutation) RemovedPropertyVenuesIDs() (ids []int64) {
	for id := range m.removedproperty_venues {
		ids = append(ids, id)
	}
	return
}

// PropertyVenuesIDs returns the "property_venues" edge IDs in the mutation.
func (m *VenueMutation) PropertyVenuesIDs() (ids []int64) {
	for id := range m.property_venues {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyVenues resets all changes to the "property_venues" edge.
func (m *VenueMutation) ResetPropertyVenues() {
	m.property_venues = nil
	m.clearedproperty_venues = false
	m.removedproperty_venues = nil
}

// Where appends a list predicates to the VenueMutation builder.
func (m *VenueMutation) Where(ps ...predicate.Venue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Venue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Venue).
func (m *VenueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, venue.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venue.FieldName)
	}
	if m.address != nil {
		fields = append(fields, venue.FieldAddress)
	}
	if m.address_detail != nil {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.latitude != nil {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.mobile != nil {
		fields = append(fields, venue.FieldMobile)
	}
	if m.pic != nil {
		fields = append(fields, venue.FieldPic)
	}
	if m.information != nil {
		fields = append(fields, venue.FieldInformation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldCreatedAt:
		return m.CreatedAt()
	case venue.FieldUpdatedAt:
		return m.UpdatedAt()
	case venue.FieldStatus:
		return m.Status()
	case venue.FieldName:
		return m.Name()
	case venue.FieldAddress:
		return m.Address()
	case venue.FieldAddressDetail:
		return m.AddressDetail()
	case venue.FieldLatitude:
		return m.Latitude()
	case venue.FieldLongitude:
		return m.Longitude()
	case venue.FieldMobile:
		return m.Mobile()
	case venue.FieldPic:
		return m.Pic()
	case venue.FieldInformation:
		return m.Information()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venue.FieldStatus:
		return m.OldStatus(ctx)
	case venue.FieldName:
		return m.OldName(ctx)
	case venue.FieldAddress:
		return m.OldAddress(ctx)
	case venue.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case venue.FieldLatitude:
		return m.OldLatitude(ctx)
	case venue.FieldLongitude:
		return m.OldLongitude(ctx)
	case venue.FieldMobile:
		return m.OldMobile(ctx)
	case venue.FieldPic:
		return m.OldPic(ctx)
	case venue.FieldInformation:
		return m.OldInformation(ctx)
	}
	return nil, fmt.Errorf("unknown Venue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venue.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case venue.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case venue.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case venue.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case venue.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case venue.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venue.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, venue.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Venue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venue.FieldStatus) {
		fields = append(fields, venue.FieldStatus)
	}
	if m.FieldCleared(venue.FieldName) {
		fields = append(fields, venue.FieldName)
	}
	if m.FieldCleared(venue.FieldAddress) {
		fields = append(fields, venue.FieldAddress)
	}
	if m.FieldCleared(venue.FieldAddressDetail) {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.FieldCleared(venue.FieldLatitude) {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.FieldCleared(venue.FieldLongitude) {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.FieldCleared(venue.FieldMobile) {
		fields = append(fields, venue.FieldMobile)
	}
	if m.FieldCleared(venue.FieldPic) {
		fields = append(fields, venue.FieldPic)
	}
	if m.FieldCleared(venue.FieldInformation) {
		fields = append(fields, venue.FieldInformation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueMutation) ClearField(name string) error {
	switch name {
	case venue.FieldStatus:
		m.ClearStatus()
		return nil
	case venue.FieldName:
		m.ClearName()
		return nil
	case venue.FieldAddress:
		m.ClearAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ClearLatitude()
		return nil
	case venue.FieldLongitude:
		m.ClearLongitude()
		return nil
	case venue.FieldMobile:
		m.ClearMobile()
		return nil
	case venue.FieldPic:
		m.ClearPic()
		return nil
	case venue.FieldInformation:
		m.ClearInformation()
		return nil
	}
	return fmt.Errorf("unknown Venue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueMutation) ResetField(name string) error {
	switch name {
	case venue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venue.FieldStatus:
		m.ResetStatus()
		return nil
	case venue.FieldName:
		m.ResetName()
		return nil
	case venue.FieldAddress:
		m.ResetAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ResetLatitude()
		return nil
	case venue.FieldLongitude:
		m.ResetLongitude()
		return nil
	case venue.FieldMobile:
		m.ResetMobile()
		return nil
	case venue.FieldPic:
		m.ResetPic()
		return nil
	case venue.FieldInformation:
		m.ResetInformation()
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.places != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.venue_orders != nil {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.venue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	if m.member_property_venues != nil {
		edges = append(edges, venue.EdgeMemberPropertyVenues)
	}
	if m.property_venues != nil {
		edges = append(edges, venue.EdgePropertyVenues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueOrders:
		ids := make([]ent.Value, 0, len(m.venue_orders))
		for id := range m.venue_orders {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.venue_entry))
		for id := range m.venue_entry {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeMemberPropertyVenues:
		ids := make([]ent.Value, 0, len(m.member_property_venues))
		for id := range m.member_property_venues {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgePropertyVenues:
		ids := make([]ent.Value, 0, len(m.property_venues))
		for id := range m.property_venues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedplaces != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.removedvenue_orders != nil {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.removedvenue_entry != nil {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	if m.removedmember_property_venues != nil {
		edges = append(edges, venue.EdgeMemberPropertyVenues)
	}
	if m.removedproperty_venues != nil {
		edges = append(edges, venue.EdgePropertyVenues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueOrders:
		ids := make([]ent.Value, 0, len(m.removedvenue_orders))
		for id := range m.removedvenue_orders {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeVenueEntry:
		ids := make([]ent.Value, 0, len(m.removedvenue_entry))
		for id := range m.removedvenue_entry {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgeMemberPropertyVenues:
		ids := make([]ent.Value, 0, len(m.removedmember_property_venues))
		for id := range m.removedmember_property_venues {
			ids = append(ids, id)
		}
		return ids
	case venue.EdgePropertyVenues:
		ids := make([]ent.Value, 0, len(m.removedproperty_venues))
		for id := range m.removedproperty_venues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedplaces {
		edges = append(edges, venue.EdgePlaces)
	}
	if m.clearedvenue_orders {
		edges = append(edges, venue.EdgeVenueOrders)
	}
	if m.clearedvenue_entry {
		edges = append(edges, venue.EdgeVenueEntry)
	}
	if m.clearedmember_property_venues {
		edges = append(edges, venue.EdgeMemberPropertyVenues)
	}
	if m.clearedproperty_venues {
		edges = append(edges, venue.EdgePropertyVenues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueMutation) EdgeCleared(name string) bool {
	switch name {
	case venue.EdgePlaces:
		return m.clearedplaces
	case venue.EdgeVenueOrders:
		return m.clearedvenue_orders
	case venue.EdgeVenueEntry:
		return m.clearedvenue_entry
	case venue.EdgeMemberPropertyVenues:
		return m.clearedmember_property_venues
	case venue.EdgePropertyVenues:
		return m.clearedproperty_venues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Venue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueMutation) ResetEdge(name string) error {
	switch name {
	case venue.EdgePlaces:
		m.ResetPlaces()
		return nil
	case venue.EdgeVenueOrders:
		m.ResetVenueOrders()
		return nil
	case venue.EdgeVenueEntry:
		m.ResetVenueEntry()
		return nil
	case venue.EdgeMemberPropertyVenues:
		m.ResetMemberPropertyVenues()
		return nil
	case venue.EdgePropertyVenues:
		m.ResetPropertyVenues()
		return nil
	}
	return fmt.Errorf("unknown Venue edge %s", name)
}

// VenuePlaceMutation represents an operation that mutates the VenuePlace nodes in the graph.
type VenuePlaceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int64
	addstatus     *int64
	name          *string
	pic           *string
	clearedFields map[string]struct{}
	venue         *int64
	clearedvenue  bool
	done          bool
	oldValue      func(context.Context) (*VenuePlace, error)
	predicates    []predicate.VenuePlace
}

var _ ent.Mutation = (*VenuePlaceMutation)(nil)

// venueplaceOption allows management of the mutation configuration using functional options.
type venueplaceOption func(*VenuePlaceMutation)

// newVenuePlaceMutation creates new mutation for the VenuePlace entity.
func newVenuePlaceMutation(c config, op Op, opts ...venueplaceOption) *VenuePlaceMutation {
	m := &VenuePlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeVenuePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenuePlaceID sets the ID field of the mutation.
func withVenuePlaceID(id int64) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *VenuePlace
		)
		m.oldValue = func(ctx context.Context) (*VenuePlace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VenuePlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenuePlace sets the old VenuePlace of the mutation.
func withVenuePlace(node *VenuePlace) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		m.oldValue = func(context.Context) (*VenuePlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenuePlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenuePlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VenuePlace entities.
func (m *VenuePlaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenuePlaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenuePlaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VenuePlace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenuePlaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenuePlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenuePlaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenuePlaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenuePlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenuePlaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *VenuePlaceMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenuePlaceMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenuePlaceMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenuePlaceMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenuePlaceMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venueplace.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenuePlaceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenuePlaceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venueplace.FieldStatus)
}

// SetName sets the "name" field.
func (m *VenuePlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenuePlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenuePlaceMutation) ClearName() {
	m.name = nil
	m.clearedFields[venueplace.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenuePlaceMutation) NameCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenuePlaceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venueplace.FieldName)
}

// SetPic sets the "pic" field.
func (m *VenuePlaceMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenuePlaceMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenuePlaceMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venueplace.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenuePlaceMutation) PicCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenuePlaceMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venueplace.FieldPic)
}

// SetVenueID sets the "venue_id" field.
func (m *VenuePlaceMutation) SetVenueID(i int64) {
	m.venue = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenuePlaceMutation) VenueID() (r int64, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *VenuePlaceMutation) ClearVenueID() {
	m.venue = nil
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *VenuePlaceMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenuePlaceMutation) ResetVenueID() {
	m.venue = nil
	delete(m.clearedFields, venueplace.FieldVenueID)
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *VenuePlaceMutation) ClearVenue() {
	m.clearedvenue = true
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *VenuePlaceMutation) VenueCleared() bool {
	return m.VenueIDCleared() || m.clearedvenue
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *VenuePlaceMutation) VenueIDs() (ids []int64) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *VenuePlaceMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// Where appends a list predicates to the VenuePlaceMutation builder.
func (m *VenuePlaceMutation) Where(ps ...predicate.VenuePlace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenuePlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenuePlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VenuePlace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenuePlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenuePlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VenuePlace).
func (m *VenuePlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenuePlaceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, venueplace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venueplace.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, venueplace.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.venue != nil {
		fields = append(fields, venueplace.FieldVenueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenuePlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.CreatedAt()
	case venueplace.FieldUpdatedAt:
		return m.UpdatedAt()
	case venueplace.FieldStatus:
		return m.Status()
	case venueplace.FieldName:
		return m.Name()
	case venueplace.FieldPic:
		return m.Pic()
	case venueplace.FieldVenueID:
		return m.VenueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenuePlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venueplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venueplace.FieldStatus:
		return m.OldStatus(ctx)
	case venueplace.FieldName:
		return m.OldName(ctx)
	case venueplace.FieldPic:
		return m.OldPic(ctx)
	case venueplace.FieldVenueID:
		return m.OldVenueID(ctx)
	}
	return nil, fmt.Errorf("unknown VenuePlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venueplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case venueplace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venueplace.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venueplace.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenuePlaceMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenuePlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenuePlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venueplace.FieldStatus) {
		fields = append(fields, venueplace.FieldStatus)
	}
	if m.FieldCleared(venueplace.FieldName) {
		fields = append(fields, venueplace.FieldName)
	}
	if m.FieldCleared(venueplace.FieldPic) {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.FieldCleared(venueplace.FieldVenueID) {
		fields = append(fields, venueplace.FieldVenueID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenuePlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ClearField(name string) error {
	switch name {
	case venueplace.FieldStatus:
		m.ClearStatus()
		return nil
	case venueplace.FieldName:
		m.ClearName()
		return nil
	case venueplace.FieldPic:
		m.ClearPic()
		return nil
	case venueplace.FieldVenueID:
		m.ClearVenueID()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ResetField(name string) error {
	switch name {
	case venueplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venueplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venueplace.FieldStatus:
		m.ResetStatus()
		return nil
	case venueplace.FieldName:
		m.ResetName()
		return nil
	case venueplace.FieldPic:
		m.ResetPic()
		return nil
	case venueplace.FieldVenueID:
		m.ResetVenueID()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenuePlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.venue != nil {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenuePlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venueplace.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenuePlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenuePlaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenuePlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvenue {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenuePlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case venueplace.EdgeVenue:
		return m.clearedvenue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenuePlaceMutation) ClearEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenuePlaceMutation) ResetEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ResetVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace edge %s", name)
}
