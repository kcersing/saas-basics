// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"saas/pkg/db/ent/api"
	"saas/pkg/db/ent/courserecordcoach"
	"saas/pkg/db/ent/courserecordschedule"
	"saas/pkg/db/ent/courserecorduser"
	"saas/pkg/db/ent/dictionary"
	"saas/pkg/db/ent/dictionarydetail"
	"saas/pkg/db/ent/logs"
	"saas/pkg/db/ent/menu"
	"saas/pkg/db/ent/menuparam"
	"saas/pkg/db/ent/order"
	"saas/pkg/db/ent/orderamount"
	"saas/pkg/db/ent/orderitem"
	"saas/pkg/db/ent/orderpay"
	"saas/pkg/db/ent/ordersales"
	"saas/pkg/db/ent/predicate"
	"saas/pkg/db/ent/product"
	"saas/pkg/db/ent/productproperty"
	"saas/pkg/db/ent/role"
	"saas/pkg/db/ent/token"
	"saas/pkg/db/ent/user"
	"saas/pkg/db/ent/venue"
	"saas/pkg/db/ent/venueplace"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI                  = "API"
	TypeCourseRecordCoach    = "CourseRecordCoach"
	TypeCourseRecordSchedule = "CourseRecordSchedule"
	TypeCourseRecordUser     = "CourseRecordUser"
	TypeDictionary           = "Dictionary"
	TypeDictionaryDetail     = "DictionaryDetail"
	TypeLogs                 = "Logs"
	TypeMenu                 = "Menu"
	TypeMenuParam            = "MenuParam"
	TypeOrder                = "Order"
	TypeOrderAmount          = "OrderAmount"
	TypeOrderItem            = "OrderItem"
	TypeOrderPay             = "OrderPay"
	TypeOrderSales           = "OrderSales"
	TypeProduct              = "Product"
	TypeProductProperty      = "ProductProperty"
	TypeRole                 = "Role"
	TypeToken                = "Token"
	TypeUser                 = "User"
	TypeVenue                = "Venue"
	TypeVenuePlace           = "VenuePlace"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_path         *string
	description   *string
	api_group     *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldPath:
		return m.Path()
	case api.FieldDescription:
		return m.Description()
	case api.FieldAPIGroup:
		return m.APIGroup()
	case api.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// CourseRecordCoachMutation represents an operation that mutates the CourseRecordCoach nodes in the graph.
type CourseRecordCoachMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	venue_id        *int64
	addvenue_id     *int64
	coach_id        *int64
	addcoach_id     *int64
	_type           *string
	start_time      *time.Time
	end_time        *time.Time
	sign_start_time *time.Time
	sign_nd_time    *time.Time
	status          *int64
	addstatus       *int64
	clearedFields   map[string]struct{}
	schedule        *int64
	clearedschedule bool
	done            bool
	oldValue        func(context.Context) (*CourseRecordCoach, error)
	predicates      []predicate.CourseRecordCoach
}

var _ ent.Mutation = (*CourseRecordCoachMutation)(nil)

// courserecordcoachOption allows management of the mutation configuration using functional options.
type courserecordcoachOption func(*CourseRecordCoachMutation)

// newCourseRecordCoachMutation creates new mutation for the CourseRecordCoach entity.
func newCourseRecordCoachMutation(c config, op Op, opts ...courserecordcoachOption) *CourseRecordCoachMutation {
	m := &CourseRecordCoachMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseRecordCoach,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseRecordCoachID sets the ID field of the mutation.
func withCourseRecordCoachID(id int64) courserecordcoachOption {
	return func(m *CourseRecordCoachMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseRecordCoach
		)
		m.oldValue = func(ctx context.Context) (*CourseRecordCoach, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseRecordCoach.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseRecordCoach sets the old CourseRecordCoach of the mutation.
func withCourseRecordCoach(node *CourseRecordCoach) courserecordcoachOption {
	return func(m *CourseRecordCoachMutation) {
		m.oldValue = func(context.Context) (*CourseRecordCoach, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseRecordCoachMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseRecordCoachMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CourseRecordCoach entities.
func (m *CourseRecordCoachMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseRecordCoachMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseRecordCoachMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseRecordCoach.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseRecordCoachMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseRecordCoachMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseRecordCoachMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseRecordCoachMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseRecordCoachMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseRecordCoachMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVenueID sets the "venue_id" field.
func (m *CourseRecordCoachMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *CourseRecordCoachMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *CourseRecordCoachMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *CourseRecordCoachMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *CourseRecordCoachMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[courserecordcoach.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *CourseRecordCoachMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, courserecordcoach.FieldVenueID)
}

// SetCoachID sets the "coach_id" field.
func (m *CourseRecordCoachMutation) SetCoachID(i int64) {
	m.coach_id = &i
	m.addcoach_id = nil
}

// CoachID returns the value of the "coach_id" field in the mutation.
func (m *CourseRecordCoachMutation) CoachID() (r int64, exists bool) {
	v := m.coach_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoachID returns the old "coach_id" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldCoachID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoachID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoachID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoachID: %w", err)
	}
	return oldValue.CoachID, nil
}

// AddCoachID adds i to the "coach_id" field.
func (m *CourseRecordCoachMutation) AddCoachID(i int64) {
	if m.addcoach_id != nil {
		*m.addcoach_id += i
	} else {
		m.addcoach_id = &i
	}
}

// AddedCoachID returns the value that was added to the "coach_id" field in this mutation.
func (m *CourseRecordCoachMutation) AddedCoachID() (r int64, exists bool) {
	v := m.addcoach_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoachID clears the value of the "coach_id" field.
func (m *CourseRecordCoachMutation) ClearCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	m.clearedFields[courserecordcoach.FieldCoachID] = struct{}{}
}

// CoachIDCleared returns if the "coach_id" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) CoachIDCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldCoachID]
	return ok
}

// ResetCoachID resets all changes to the "coach_id" field.
func (m *CourseRecordCoachMutation) ResetCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	delete(m.clearedFields, courserecordcoach.FieldCoachID)
}

// SetCourseRecordScheduleID sets the "course_record_schedule_id" field.
func (m *CourseRecordCoachMutation) SetCourseRecordScheduleID(i int64) {
	m.schedule = &i
}

// CourseRecordScheduleID returns the value of the "course_record_schedule_id" field in the mutation.
func (m *CourseRecordCoachMutation) CourseRecordScheduleID() (r int64, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseRecordScheduleID returns the old "course_record_schedule_id" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldCourseRecordScheduleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseRecordScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseRecordScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseRecordScheduleID: %w", err)
	}
	return oldValue.CourseRecordScheduleID, nil
}

// ClearCourseRecordScheduleID clears the value of the "course_record_schedule_id" field.
func (m *CourseRecordCoachMutation) ClearCourseRecordScheduleID() {
	m.schedule = nil
	m.clearedFields[courserecordcoach.FieldCourseRecordScheduleID] = struct{}{}
}

// CourseRecordScheduleIDCleared returns if the "course_record_schedule_id" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) CourseRecordScheduleIDCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldCourseRecordScheduleID]
	return ok
}

// ResetCourseRecordScheduleID resets all changes to the "course_record_schedule_id" field.
func (m *CourseRecordCoachMutation) ResetCourseRecordScheduleID() {
	m.schedule = nil
	delete(m.clearedFields, courserecordcoach.FieldCourseRecordScheduleID)
}

// SetType sets the "type" field.
func (m *CourseRecordCoachMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CourseRecordCoachMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *CourseRecordCoachMutation) ClearType() {
	m._type = nil
	m.clearedFields[courserecordcoach.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) TypeCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CourseRecordCoachMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, courserecordcoach.FieldType)
}

// SetStartTime sets the "start_time" field.
func (m *CourseRecordCoachMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CourseRecordCoachMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *CourseRecordCoachMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[courserecordcoach.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CourseRecordCoachMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, courserecordcoach.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *CourseRecordCoachMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CourseRecordCoachMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *CourseRecordCoachMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[courserecordcoach.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CourseRecordCoachMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, courserecordcoach.FieldEndTime)
}

// SetSignStartTime sets the "sign_start_time" field.
func (m *CourseRecordCoachMutation) SetSignStartTime(t time.Time) {
	m.sign_start_time = &t
}

// SignStartTime returns the value of the "sign_start_time" field in the mutation.
func (m *CourseRecordCoachMutation) SignStartTime() (r time.Time, exists bool) {
	v := m.sign_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartTime returns the old "sign_start_time" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldSignStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartTime: %w", err)
	}
	return oldValue.SignStartTime, nil
}

// ClearSignStartTime clears the value of the "sign_start_time" field.
func (m *CourseRecordCoachMutation) ClearSignStartTime() {
	m.sign_start_time = nil
	m.clearedFields[courserecordcoach.FieldSignStartTime] = struct{}{}
}

// SignStartTimeCleared returns if the "sign_start_time" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) SignStartTimeCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldSignStartTime]
	return ok
}

// ResetSignStartTime resets all changes to the "sign_start_time" field.
func (m *CourseRecordCoachMutation) ResetSignStartTime() {
	m.sign_start_time = nil
	delete(m.clearedFields, courserecordcoach.FieldSignStartTime)
}

// SetSignNdTime sets the "sign_nd_time" field.
func (m *CourseRecordCoachMutation) SetSignNdTime(t time.Time) {
	m.sign_nd_time = &t
}

// SignNdTime returns the value of the "sign_nd_time" field in the mutation.
func (m *CourseRecordCoachMutation) SignNdTime() (r time.Time, exists bool) {
	v := m.sign_nd_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignNdTime returns the old "sign_nd_time" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldSignNdTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignNdTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignNdTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignNdTime: %w", err)
	}
	return oldValue.SignNdTime, nil
}

// ClearSignNdTime clears the value of the "sign_nd_time" field.
func (m *CourseRecordCoachMutation) ClearSignNdTime() {
	m.sign_nd_time = nil
	m.clearedFields[courserecordcoach.FieldSignNdTime] = struct{}{}
}

// SignNdTimeCleared returns if the "sign_nd_time" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) SignNdTimeCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldSignNdTime]
	return ok
}

// ResetSignNdTime resets all changes to the "sign_nd_time" field.
func (m *CourseRecordCoachMutation) ResetSignNdTime() {
	m.sign_nd_time = nil
	delete(m.clearedFields, courserecordcoach.FieldSignNdTime)
}

// SetStatus sets the "status" field.
func (m *CourseRecordCoachMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CourseRecordCoachMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CourseRecordCoach entity.
// If the CourseRecordCoach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordCoachMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CourseRecordCoachMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CourseRecordCoachMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CourseRecordCoachMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[courserecordcoach.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CourseRecordCoachMutation) StatusCleared() bool {
	_, ok := m.clearedFields[courserecordcoach.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CourseRecordCoachMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, courserecordcoach.FieldStatus)
}

// SetScheduleID sets the "schedule" edge to the CourseRecordSchedule entity by id.
func (m *CourseRecordCoachMutation) SetScheduleID(id int64) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the CourseRecordSchedule entity.
func (m *CourseRecordCoachMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[courserecordcoach.FieldCourseRecordScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the CourseRecordSchedule entity was cleared.
func (m *CourseRecordCoachMutation) ScheduleCleared() bool {
	return m.CourseRecordScheduleIDCleared() || m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *CourseRecordCoachMutation) ScheduleID() (id int64, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *CourseRecordCoachMutation) ScheduleIDs() (ids []int64) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *CourseRecordCoachMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the CourseRecordCoachMutation builder.
func (m *CourseRecordCoachMutation) Where(ps ...predicate.CourseRecordCoach) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseRecordCoachMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseRecordCoachMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CourseRecordCoach, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseRecordCoachMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseRecordCoachMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CourseRecordCoach).
func (m *CourseRecordCoachMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseRecordCoachMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, courserecordcoach.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courserecordcoach.FieldUpdatedAt)
	}
	if m.venue_id != nil {
		fields = append(fields, courserecordcoach.FieldVenueID)
	}
	if m.coach_id != nil {
		fields = append(fields, courserecordcoach.FieldCoachID)
	}
	if m.schedule != nil {
		fields = append(fields, courserecordcoach.FieldCourseRecordScheduleID)
	}
	if m._type != nil {
		fields = append(fields, courserecordcoach.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, courserecordcoach.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, courserecordcoach.FieldEndTime)
	}
	if m.sign_start_time != nil {
		fields = append(fields, courserecordcoach.FieldSignStartTime)
	}
	if m.sign_nd_time != nil {
		fields = append(fields, courserecordcoach.FieldSignNdTime)
	}
	if m.status != nil {
		fields = append(fields, courserecordcoach.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseRecordCoachMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courserecordcoach.FieldCreatedAt:
		return m.CreatedAt()
	case courserecordcoach.FieldUpdatedAt:
		return m.UpdatedAt()
	case courserecordcoach.FieldVenueID:
		return m.VenueID()
	case courserecordcoach.FieldCoachID:
		return m.CoachID()
	case courserecordcoach.FieldCourseRecordScheduleID:
		return m.CourseRecordScheduleID()
	case courserecordcoach.FieldType:
		return m.GetType()
	case courserecordcoach.FieldStartTime:
		return m.StartTime()
	case courserecordcoach.FieldEndTime:
		return m.EndTime()
	case courserecordcoach.FieldSignStartTime:
		return m.SignStartTime()
	case courserecordcoach.FieldSignNdTime:
		return m.SignNdTime()
	case courserecordcoach.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseRecordCoachMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courserecordcoach.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courserecordcoach.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case courserecordcoach.FieldVenueID:
		return m.OldVenueID(ctx)
	case courserecordcoach.FieldCoachID:
		return m.OldCoachID(ctx)
	case courserecordcoach.FieldCourseRecordScheduleID:
		return m.OldCourseRecordScheduleID(ctx)
	case courserecordcoach.FieldType:
		return m.OldType(ctx)
	case courserecordcoach.FieldStartTime:
		return m.OldStartTime(ctx)
	case courserecordcoach.FieldEndTime:
		return m.OldEndTime(ctx)
	case courserecordcoach.FieldSignStartTime:
		return m.OldSignStartTime(ctx)
	case courserecordcoach.FieldSignNdTime:
		return m.OldSignNdTime(ctx)
	case courserecordcoach.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CourseRecordCoach field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseRecordCoachMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courserecordcoach.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courserecordcoach.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case courserecordcoach.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case courserecordcoach.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoachID(v)
		return nil
	case courserecordcoach.FieldCourseRecordScheduleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseRecordScheduleID(v)
		return nil
	case courserecordcoach.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case courserecordcoach.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case courserecordcoach.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case courserecordcoach.FieldSignStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartTime(v)
		return nil
	case courserecordcoach.FieldSignNdTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignNdTime(v)
		return nil
	case courserecordcoach.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CourseRecordCoach field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseRecordCoachMutation) AddedFields() []string {
	var fields []string
	if m.addvenue_id != nil {
		fields = append(fields, courserecordcoach.FieldVenueID)
	}
	if m.addcoach_id != nil {
		fields = append(fields, courserecordcoach.FieldCoachID)
	}
	if m.addstatus != nil {
		fields = append(fields, courserecordcoach.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseRecordCoachMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case courserecordcoach.FieldVenueID:
		return m.AddedVenueID()
	case courserecordcoach.FieldCoachID:
		return m.AddedCoachID()
	case courserecordcoach.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseRecordCoachMutation) AddField(name string, value ent.Value) error {
	switch name {
	case courserecordcoach.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case courserecordcoach.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoachID(v)
		return nil
	case courserecordcoach.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CourseRecordCoach numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseRecordCoachMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(courserecordcoach.FieldVenueID) {
		fields = append(fields, courserecordcoach.FieldVenueID)
	}
	if m.FieldCleared(courserecordcoach.FieldCoachID) {
		fields = append(fields, courserecordcoach.FieldCoachID)
	}
	if m.FieldCleared(courserecordcoach.FieldCourseRecordScheduleID) {
		fields = append(fields, courserecordcoach.FieldCourseRecordScheduleID)
	}
	if m.FieldCleared(courserecordcoach.FieldType) {
		fields = append(fields, courserecordcoach.FieldType)
	}
	if m.FieldCleared(courserecordcoach.FieldStartTime) {
		fields = append(fields, courserecordcoach.FieldStartTime)
	}
	if m.FieldCleared(courserecordcoach.FieldEndTime) {
		fields = append(fields, courserecordcoach.FieldEndTime)
	}
	if m.FieldCleared(courserecordcoach.FieldSignStartTime) {
		fields = append(fields, courserecordcoach.FieldSignStartTime)
	}
	if m.FieldCleared(courserecordcoach.FieldSignNdTime) {
		fields = append(fields, courserecordcoach.FieldSignNdTime)
	}
	if m.FieldCleared(courserecordcoach.FieldStatus) {
		fields = append(fields, courserecordcoach.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseRecordCoachMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseRecordCoachMutation) ClearField(name string) error {
	switch name {
	case courserecordcoach.FieldVenueID:
		m.ClearVenueID()
		return nil
	case courserecordcoach.FieldCoachID:
		m.ClearCoachID()
		return nil
	case courserecordcoach.FieldCourseRecordScheduleID:
		m.ClearCourseRecordScheduleID()
		return nil
	case courserecordcoach.FieldType:
		m.ClearType()
		return nil
	case courserecordcoach.FieldStartTime:
		m.ClearStartTime()
		return nil
	case courserecordcoach.FieldEndTime:
		m.ClearEndTime()
		return nil
	case courserecordcoach.FieldSignStartTime:
		m.ClearSignStartTime()
		return nil
	case courserecordcoach.FieldSignNdTime:
		m.ClearSignNdTime()
		return nil
	case courserecordcoach.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordCoach nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseRecordCoachMutation) ResetField(name string) error {
	switch name {
	case courserecordcoach.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courserecordcoach.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case courserecordcoach.FieldVenueID:
		m.ResetVenueID()
		return nil
	case courserecordcoach.FieldCoachID:
		m.ResetCoachID()
		return nil
	case courserecordcoach.FieldCourseRecordScheduleID:
		m.ResetCourseRecordScheduleID()
		return nil
	case courserecordcoach.FieldType:
		m.ResetType()
		return nil
	case courserecordcoach.FieldStartTime:
		m.ResetStartTime()
		return nil
	case courserecordcoach.FieldEndTime:
		m.ResetEndTime()
		return nil
	case courserecordcoach.FieldSignStartTime:
		m.ResetSignStartTime()
		return nil
	case courserecordcoach.FieldSignNdTime:
		m.ResetSignNdTime()
		return nil
	case courserecordcoach.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordCoach field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseRecordCoachMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.schedule != nil {
		edges = append(edges, courserecordcoach.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseRecordCoachMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case courserecordcoach.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseRecordCoachMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseRecordCoachMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseRecordCoachMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedschedule {
		edges = append(edges, courserecordcoach.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseRecordCoachMutation) EdgeCleared(name string) bool {
	switch name {
	case courserecordcoach.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseRecordCoachMutation) ClearEdge(name string) error {
	switch name {
	case courserecordcoach.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordCoach unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseRecordCoachMutation) ResetEdge(name string) error {
	switch name {
	case courserecordcoach.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordCoach edge %s", name)
}

// CourseRecordScheduleMutation represents an operation that mutates the CourseRecordSchedule nodes in the graph.
type CourseRecordScheduleMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	venue_id      *int64
	addvenue_id   *int64
	place_id      *int64
	addplace_id   *int64
	coach_id      *int64
	addcoach_id   *int64
	num           *int64
	addnum        *int64
	start_time    *time.Time
	end_time      *time.Time
	price         *float64
	addprice      *float64
	status        *int64
	addstatus     *int64
	clearedFields map[string]struct{}
	users         map[int64]struct{}
	removedusers  map[int64]struct{}
	clearedusers  bool
	coach         map[int64]struct{}
	removedcoach  map[int64]struct{}
	clearedcoach  bool
	done          bool
	oldValue      func(context.Context) (*CourseRecordSchedule, error)
	predicates    []predicate.CourseRecordSchedule
}

var _ ent.Mutation = (*CourseRecordScheduleMutation)(nil)

// courserecordscheduleOption allows management of the mutation configuration using functional options.
type courserecordscheduleOption func(*CourseRecordScheduleMutation)

// newCourseRecordScheduleMutation creates new mutation for the CourseRecordSchedule entity.
func newCourseRecordScheduleMutation(c config, op Op, opts ...courserecordscheduleOption) *CourseRecordScheduleMutation {
	m := &CourseRecordScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseRecordSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseRecordScheduleID sets the ID field of the mutation.
func withCourseRecordScheduleID(id int64) courserecordscheduleOption {
	return func(m *CourseRecordScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseRecordSchedule
		)
		m.oldValue = func(ctx context.Context) (*CourseRecordSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseRecordSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseRecordSchedule sets the old CourseRecordSchedule of the mutation.
func withCourseRecordSchedule(node *CourseRecordSchedule) courserecordscheduleOption {
	return func(m *CourseRecordScheduleMutation) {
		m.oldValue = func(context.Context) (*CourseRecordSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseRecordScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseRecordScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CourseRecordSchedule entities.
func (m *CourseRecordScheduleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseRecordScheduleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseRecordScheduleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseRecordSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseRecordScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseRecordScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseRecordScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseRecordScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseRecordScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseRecordScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *CourseRecordScheduleMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CourseRecordScheduleMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *CourseRecordScheduleMutation) ClearType() {
	m._type = nil
	m.clearedFields[courserecordschedule.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) TypeCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CourseRecordScheduleMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, courserecordschedule.FieldType)
}

// SetVenueID sets the "venue_id" field.
func (m *CourseRecordScheduleMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *CourseRecordScheduleMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *CourseRecordScheduleMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *CourseRecordScheduleMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *CourseRecordScheduleMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[courserecordschedule.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *CourseRecordScheduleMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, courserecordschedule.FieldVenueID)
}

// SetPlaceID sets the "place_id" field.
func (m *CourseRecordScheduleMutation) SetPlaceID(i int64) {
	m.place_id = &i
	m.addplace_id = nil
}

// PlaceID returns the value of the "place_id" field in the mutation.
func (m *CourseRecordScheduleMutation) PlaceID() (r int64, exists bool) {
	v := m.place_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceID returns the old "place_id" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldPlaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceID: %w", err)
	}
	return oldValue.PlaceID, nil
}

// AddPlaceID adds i to the "place_id" field.
func (m *CourseRecordScheduleMutation) AddPlaceID(i int64) {
	if m.addplace_id != nil {
		*m.addplace_id += i
	} else {
		m.addplace_id = &i
	}
}

// AddedPlaceID returns the value that was added to the "place_id" field in this mutation.
func (m *CourseRecordScheduleMutation) AddedPlaceID() (r int64, exists bool) {
	v := m.addplace_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlaceID clears the value of the "place_id" field.
func (m *CourseRecordScheduleMutation) ClearPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	m.clearedFields[courserecordschedule.FieldPlaceID] = struct{}{}
}

// PlaceIDCleared returns if the "place_id" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) PlaceIDCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldPlaceID]
	return ok
}

// ResetPlaceID resets all changes to the "place_id" field.
func (m *CourseRecordScheduleMutation) ResetPlaceID() {
	m.place_id = nil
	m.addplace_id = nil
	delete(m.clearedFields, courserecordschedule.FieldPlaceID)
}

// SetCoachID sets the "coach_id" field.
func (m *CourseRecordScheduleMutation) SetCoachID(i int64) {
	m.coach_id = &i
	m.addcoach_id = nil
}

// CoachID returns the value of the "coach_id" field in the mutation.
func (m *CourseRecordScheduleMutation) CoachID() (r int64, exists bool) {
	v := m.coach_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoachID returns the old "coach_id" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldCoachID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoachID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoachID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoachID: %w", err)
	}
	return oldValue.CoachID, nil
}

// AddCoachID adds i to the "coach_id" field.
func (m *CourseRecordScheduleMutation) AddCoachID(i int64) {
	if m.addcoach_id != nil {
		*m.addcoach_id += i
	} else {
		m.addcoach_id = &i
	}
}

// AddedCoachID returns the value that was added to the "coach_id" field in this mutation.
func (m *CourseRecordScheduleMutation) AddedCoachID() (r int64, exists bool) {
	v := m.addcoach_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoachID clears the value of the "coach_id" field.
func (m *CourseRecordScheduleMutation) ClearCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	m.clearedFields[courserecordschedule.FieldCoachID] = struct{}{}
}

// CoachIDCleared returns if the "coach_id" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) CoachIDCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldCoachID]
	return ok
}

// ResetCoachID resets all changes to the "coach_id" field.
func (m *CourseRecordScheduleMutation) ResetCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	delete(m.clearedFields, courserecordschedule.FieldCoachID)
}

// SetNum sets the "num" field.
func (m *CourseRecordScheduleMutation) SetNum(i int64) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *CourseRecordScheduleMutation) Num() (r int64, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *CourseRecordScheduleMutation) AddNum(i int64) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *CourseRecordScheduleMutation) AddedNum() (r int64, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ClearNum clears the value of the "num" field.
func (m *CourseRecordScheduleMutation) ClearNum() {
	m.num = nil
	m.addnum = nil
	m.clearedFields[courserecordschedule.FieldNum] = struct{}{}
}

// NumCleared returns if the "num" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) NumCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldNum]
	return ok
}

// ResetNum resets all changes to the "num" field.
func (m *CourseRecordScheduleMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
	delete(m.clearedFields, courserecordschedule.FieldNum)
}

// SetStartTime sets the "start_time" field.
func (m *CourseRecordScheduleMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CourseRecordScheduleMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *CourseRecordScheduleMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[courserecordschedule.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CourseRecordScheduleMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, courserecordschedule.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *CourseRecordScheduleMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CourseRecordScheduleMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *CourseRecordScheduleMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[courserecordschedule.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CourseRecordScheduleMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, courserecordschedule.FieldEndTime)
}

// SetPrice sets the "price" field.
func (m *CourseRecordScheduleMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *CourseRecordScheduleMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *CourseRecordScheduleMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *CourseRecordScheduleMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *CourseRecordScheduleMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[courserecordschedule.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) PriceCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *CourseRecordScheduleMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, courserecordschedule.FieldPrice)
}

// SetStatus sets the "status" field.
func (m *CourseRecordScheduleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CourseRecordScheduleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CourseRecordSchedule entity.
// If the CourseRecordSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordScheduleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CourseRecordScheduleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CourseRecordScheduleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CourseRecordScheduleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[courserecordschedule.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CourseRecordScheduleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[courserecordschedule.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CourseRecordScheduleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, courserecordschedule.FieldStatus)
}

// AddUserIDs adds the "users" edge to the CourseRecordUser entity by ids.
func (m *CourseRecordScheduleMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the CourseRecordUser entity.
func (m *CourseRecordScheduleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the CourseRecordUser entity was cleared.
func (m *CourseRecordScheduleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the CourseRecordUser entity by IDs.
func (m *CourseRecordScheduleMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the CourseRecordUser entity.
func (m *CourseRecordScheduleMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *CourseRecordScheduleMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CourseRecordScheduleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddCoachIDs adds the "coach" edge to the CourseRecordCoach entity by ids.
func (m *CourseRecordScheduleMutation) AddCoachIDs(ids ...int64) {
	if m.coach == nil {
		m.coach = make(map[int64]struct{})
	}
	for i := range ids {
		m.coach[ids[i]] = struct{}{}
	}
}

// ClearCoach clears the "coach" edge to the CourseRecordCoach entity.
func (m *CourseRecordScheduleMutation) ClearCoach() {
	m.clearedcoach = true
}

// CoachCleared reports if the "coach" edge to the CourseRecordCoach entity was cleared.
func (m *CourseRecordScheduleMutation) CoachCleared() bool {
	return m.clearedcoach
}

// RemoveCoachIDs removes the "coach" edge to the CourseRecordCoach entity by IDs.
func (m *CourseRecordScheduleMutation) RemoveCoachIDs(ids ...int64) {
	if m.removedcoach == nil {
		m.removedcoach = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.coach, ids[i])
		m.removedcoach[ids[i]] = struct{}{}
	}
}

// RemovedCoach returns the removed IDs of the "coach" edge to the CourseRecordCoach entity.
func (m *CourseRecordScheduleMutation) RemovedCoachIDs() (ids []int64) {
	for id := range m.removedcoach {
		ids = append(ids, id)
	}
	return
}

// CoachIDs returns the "coach" edge IDs in the mutation.
func (m *CourseRecordScheduleMutation) CoachIDs() (ids []int64) {
	for id := range m.coach {
		ids = append(ids, id)
	}
	return
}

// ResetCoach resets all changes to the "coach" edge.
func (m *CourseRecordScheduleMutation) ResetCoach() {
	m.coach = nil
	m.clearedcoach = false
	m.removedcoach = nil
}

// Where appends a list predicates to the CourseRecordScheduleMutation builder.
func (m *CourseRecordScheduleMutation) Where(ps ...predicate.CourseRecordSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseRecordScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseRecordScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CourseRecordSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseRecordScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseRecordScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CourseRecordSchedule).
func (m *CourseRecordScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseRecordScheduleMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, courserecordschedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courserecordschedule.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, courserecordschedule.FieldType)
	}
	if m.venue_id != nil {
		fields = append(fields, courserecordschedule.FieldVenueID)
	}
	if m.place_id != nil {
		fields = append(fields, courserecordschedule.FieldPlaceID)
	}
	if m.coach_id != nil {
		fields = append(fields, courserecordschedule.FieldCoachID)
	}
	if m.num != nil {
		fields = append(fields, courserecordschedule.FieldNum)
	}
	if m.start_time != nil {
		fields = append(fields, courserecordschedule.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, courserecordschedule.FieldEndTime)
	}
	if m.price != nil {
		fields = append(fields, courserecordschedule.FieldPrice)
	}
	if m.status != nil {
		fields = append(fields, courserecordschedule.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseRecordScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courserecordschedule.FieldCreatedAt:
		return m.CreatedAt()
	case courserecordschedule.FieldUpdatedAt:
		return m.UpdatedAt()
	case courserecordschedule.FieldType:
		return m.GetType()
	case courserecordschedule.FieldVenueID:
		return m.VenueID()
	case courserecordschedule.FieldPlaceID:
		return m.PlaceID()
	case courserecordschedule.FieldCoachID:
		return m.CoachID()
	case courserecordschedule.FieldNum:
		return m.Num()
	case courserecordschedule.FieldStartTime:
		return m.StartTime()
	case courserecordschedule.FieldEndTime:
		return m.EndTime()
	case courserecordschedule.FieldPrice:
		return m.Price()
	case courserecordschedule.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseRecordScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courserecordschedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courserecordschedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case courserecordschedule.FieldType:
		return m.OldType(ctx)
	case courserecordschedule.FieldVenueID:
		return m.OldVenueID(ctx)
	case courserecordschedule.FieldPlaceID:
		return m.OldPlaceID(ctx)
	case courserecordschedule.FieldCoachID:
		return m.OldCoachID(ctx)
	case courserecordschedule.FieldNum:
		return m.OldNum(ctx)
	case courserecordschedule.FieldStartTime:
		return m.OldStartTime(ctx)
	case courserecordschedule.FieldEndTime:
		return m.OldEndTime(ctx)
	case courserecordschedule.FieldPrice:
		return m.OldPrice(ctx)
	case courserecordschedule.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CourseRecordSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseRecordScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courserecordschedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courserecordschedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case courserecordschedule.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case courserecordschedule.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case courserecordschedule.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceID(v)
		return nil
	case courserecordschedule.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoachID(v)
		return nil
	case courserecordschedule.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case courserecordschedule.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case courserecordschedule.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case courserecordschedule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case courserecordschedule.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CourseRecordSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseRecordScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addvenue_id != nil {
		fields = append(fields, courserecordschedule.FieldVenueID)
	}
	if m.addplace_id != nil {
		fields = append(fields, courserecordschedule.FieldPlaceID)
	}
	if m.addcoach_id != nil {
		fields = append(fields, courserecordschedule.FieldCoachID)
	}
	if m.addnum != nil {
		fields = append(fields, courserecordschedule.FieldNum)
	}
	if m.addprice != nil {
		fields = append(fields, courserecordschedule.FieldPrice)
	}
	if m.addstatus != nil {
		fields = append(fields, courserecordschedule.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseRecordScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case courserecordschedule.FieldVenueID:
		return m.AddedVenueID()
	case courserecordschedule.FieldPlaceID:
		return m.AddedPlaceID()
	case courserecordschedule.FieldCoachID:
		return m.AddedCoachID()
	case courserecordschedule.FieldNum:
		return m.AddedNum()
	case courserecordschedule.FieldPrice:
		return m.AddedPrice()
	case courserecordschedule.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseRecordScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case courserecordschedule.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case courserecordschedule.FieldPlaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlaceID(v)
		return nil
	case courserecordschedule.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoachID(v)
		return nil
	case courserecordschedule.FieldNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case courserecordschedule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case courserecordschedule.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CourseRecordSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseRecordScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(courserecordschedule.FieldType) {
		fields = append(fields, courserecordschedule.FieldType)
	}
	if m.FieldCleared(courserecordschedule.FieldVenueID) {
		fields = append(fields, courserecordschedule.FieldVenueID)
	}
	if m.FieldCleared(courserecordschedule.FieldPlaceID) {
		fields = append(fields, courserecordschedule.FieldPlaceID)
	}
	if m.FieldCleared(courserecordschedule.FieldCoachID) {
		fields = append(fields, courserecordschedule.FieldCoachID)
	}
	if m.FieldCleared(courserecordschedule.FieldNum) {
		fields = append(fields, courserecordschedule.FieldNum)
	}
	if m.FieldCleared(courserecordschedule.FieldStartTime) {
		fields = append(fields, courserecordschedule.FieldStartTime)
	}
	if m.FieldCleared(courserecordschedule.FieldEndTime) {
		fields = append(fields, courserecordschedule.FieldEndTime)
	}
	if m.FieldCleared(courserecordschedule.FieldPrice) {
		fields = append(fields, courserecordschedule.FieldPrice)
	}
	if m.FieldCleared(courserecordschedule.FieldStatus) {
		fields = append(fields, courserecordschedule.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseRecordScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseRecordScheduleMutation) ClearField(name string) error {
	switch name {
	case courserecordschedule.FieldType:
		m.ClearType()
		return nil
	case courserecordschedule.FieldVenueID:
		m.ClearVenueID()
		return nil
	case courserecordschedule.FieldPlaceID:
		m.ClearPlaceID()
		return nil
	case courserecordschedule.FieldCoachID:
		m.ClearCoachID()
		return nil
	case courserecordschedule.FieldNum:
		m.ClearNum()
		return nil
	case courserecordschedule.FieldStartTime:
		m.ClearStartTime()
		return nil
	case courserecordschedule.FieldEndTime:
		m.ClearEndTime()
		return nil
	case courserecordschedule.FieldPrice:
		m.ClearPrice()
		return nil
	case courserecordschedule.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseRecordScheduleMutation) ResetField(name string) error {
	switch name {
	case courserecordschedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courserecordschedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case courserecordschedule.FieldType:
		m.ResetType()
		return nil
	case courserecordschedule.FieldVenueID:
		m.ResetVenueID()
		return nil
	case courserecordschedule.FieldPlaceID:
		m.ResetPlaceID()
		return nil
	case courserecordschedule.FieldCoachID:
		m.ResetCoachID()
		return nil
	case courserecordschedule.FieldNum:
		m.ResetNum()
		return nil
	case courserecordschedule.FieldStartTime:
		m.ResetStartTime()
		return nil
	case courserecordschedule.FieldEndTime:
		m.ResetEndTime()
		return nil
	case courserecordschedule.FieldPrice:
		m.ResetPrice()
		return nil
	case courserecordschedule.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseRecordScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, courserecordschedule.EdgeUsers)
	}
	if m.coach != nil {
		edges = append(edges, courserecordschedule.EdgeCoach)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseRecordScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case courserecordschedule.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case courserecordschedule.EdgeCoach:
		ids := make([]ent.Value, 0, len(m.coach))
		for id := range m.coach {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseRecordScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, courserecordschedule.EdgeUsers)
	}
	if m.removedcoach != nil {
		edges = append(edges, courserecordschedule.EdgeCoach)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseRecordScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case courserecordschedule.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case courserecordschedule.EdgeCoach:
		ids := make([]ent.Value, 0, len(m.removedcoach))
		for id := range m.removedcoach {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseRecordScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, courserecordschedule.EdgeUsers)
	}
	if m.clearedcoach {
		edges = append(edges, courserecordschedule.EdgeCoach)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseRecordScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case courserecordschedule.EdgeUsers:
		return m.clearedusers
	case courserecordschedule.EdgeCoach:
		return m.clearedcoach
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseRecordScheduleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseRecordSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseRecordScheduleMutation) ResetEdge(name string) error {
	switch name {
	case courserecordschedule.EdgeUsers:
		m.ResetUsers()
		return nil
	case courserecordschedule.EdgeCoach:
		m.ResetCoach()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordSchedule edge %s", name)
}

// CourseRecordUserMutation represents an operation that mutates the CourseRecordUser nodes in the graph.
type CourseRecordUserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_at              *time.Time
	updated_at              *time.Time
	venue_id                *int64
	addvenue_id             *int64
	user_id                 *int64
	adduser_id              *int64
	_type                   *string
	start_time              *time.Time
	end_time                *time.Time
	sign_start_time         *time.Time
	sign_nd_time            *time.Time
	user_product_id         *int64
	adduser_product_id      *int64
	user_product_item_id    *int64
	adduser_product_item_id *int64
	coach_id                *int64
	addcoach_id             *int64
	status                  *int64
	addstatus               *int64
	clearedFields           map[string]struct{}
	schedule                *int64
	clearedschedule         bool
	done                    bool
	oldValue                func(context.Context) (*CourseRecordUser, error)
	predicates              []predicate.CourseRecordUser
}

var _ ent.Mutation = (*CourseRecordUserMutation)(nil)

// courserecorduserOption allows management of the mutation configuration using functional options.
type courserecorduserOption func(*CourseRecordUserMutation)

// newCourseRecordUserMutation creates new mutation for the CourseRecordUser entity.
func newCourseRecordUserMutation(c config, op Op, opts ...courserecorduserOption) *CourseRecordUserMutation {
	m := &CourseRecordUserMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseRecordUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseRecordUserID sets the ID field of the mutation.
func withCourseRecordUserID(id int64) courserecorduserOption {
	return func(m *CourseRecordUserMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseRecordUser
		)
		m.oldValue = func(ctx context.Context) (*CourseRecordUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseRecordUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseRecordUser sets the old CourseRecordUser of the mutation.
func withCourseRecordUser(node *CourseRecordUser) courserecorduserOption {
	return func(m *CourseRecordUserMutation) {
		m.oldValue = func(context.Context) (*CourseRecordUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseRecordUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseRecordUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CourseRecordUser entities.
func (m *CourseRecordUserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseRecordUserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseRecordUserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseRecordUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseRecordUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseRecordUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseRecordUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseRecordUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseRecordUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseRecordUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVenueID sets the "venue_id" field.
func (m *CourseRecordUserMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *CourseRecordUserMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *CourseRecordUserMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *CourseRecordUserMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *CourseRecordUserMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[courserecorduser.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *CourseRecordUserMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *CourseRecordUserMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, courserecorduser.FieldVenueID)
}

// SetUserID sets the "user_id" field.
func (m *CourseRecordUserMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CourseRecordUserMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CourseRecordUserMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CourseRecordUserMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *CourseRecordUserMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[courserecorduser.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CourseRecordUserMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CourseRecordUserMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, courserecorduser.FieldUserID)
}

// SetCourseRecordScheduleID sets the "course_record_schedule_id" field.
func (m *CourseRecordUserMutation) SetCourseRecordScheduleID(i int64) {
	m.schedule = &i
}

// CourseRecordScheduleID returns the value of the "course_record_schedule_id" field in the mutation.
func (m *CourseRecordUserMutation) CourseRecordScheduleID() (r int64, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseRecordScheduleID returns the old "course_record_schedule_id" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldCourseRecordScheduleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseRecordScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseRecordScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseRecordScheduleID: %w", err)
	}
	return oldValue.CourseRecordScheduleID, nil
}

// ClearCourseRecordScheduleID clears the value of the "course_record_schedule_id" field.
func (m *CourseRecordUserMutation) ClearCourseRecordScheduleID() {
	m.schedule = nil
	m.clearedFields[courserecorduser.FieldCourseRecordScheduleID] = struct{}{}
}

// CourseRecordScheduleIDCleared returns if the "course_record_schedule_id" field was cleared in this mutation.
func (m *CourseRecordUserMutation) CourseRecordScheduleIDCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldCourseRecordScheduleID]
	return ok
}

// ResetCourseRecordScheduleID resets all changes to the "course_record_schedule_id" field.
func (m *CourseRecordUserMutation) ResetCourseRecordScheduleID() {
	m.schedule = nil
	delete(m.clearedFields, courserecorduser.FieldCourseRecordScheduleID)
}

// SetType sets the "type" field.
func (m *CourseRecordUserMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CourseRecordUserMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *CourseRecordUserMutation) ClearType() {
	m._type = nil
	m.clearedFields[courserecorduser.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CourseRecordUserMutation) TypeCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CourseRecordUserMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, courserecorduser.FieldType)
}

// SetStartTime sets the "start_time" field.
func (m *CourseRecordUserMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CourseRecordUserMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *CourseRecordUserMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[courserecorduser.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *CourseRecordUserMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CourseRecordUserMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, courserecorduser.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *CourseRecordUserMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CourseRecordUserMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *CourseRecordUserMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[courserecorduser.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *CourseRecordUserMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CourseRecordUserMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, courserecorduser.FieldEndTime)
}

// SetSignStartTime sets the "sign_start_time" field.
func (m *CourseRecordUserMutation) SetSignStartTime(t time.Time) {
	m.sign_start_time = &t
}

// SignStartTime returns the value of the "sign_start_time" field in the mutation.
func (m *CourseRecordUserMutation) SignStartTime() (r time.Time, exists bool) {
	v := m.sign_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignStartTime returns the old "sign_start_time" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldSignStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignStartTime: %w", err)
	}
	return oldValue.SignStartTime, nil
}

// ClearSignStartTime clears the value of the "sign_start_time" field.
func (m *CourseRecordUserMutation) ClearSignStartTime() {
	m.sign_start_time = nil
	m.clearedFields[courserecorduser.FieldSignStartTime] = struct{}{}
}

// SignStartTimeCleared returns if the "sign_start_time" field was cleared in this mutation.
func (m *CourseRecordUserMutation) SignStartTimeCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldSignStartTime]
	return ok
}

// ResetSignStartTime resets all changes to the "sign_start_time" field.
func (m *CourseRecordUserMutation) ResetSignStartTime() {
	m.sign_start_time = nil
	delete(m.clearedFields, courserecorduser.FieldSignStartTime)
}

// SetSignNdTime sets the "sign_nd_time" field.
func (m *CourseRecordUserMutation) SetSignNdTime(t time.Time) {
	m.sign_nd_time = &t
}

// SignNdTime returns the value of the "sign_nd_time" field in the mutation.
func (m *CourseRecordUserMutation) SignNdTime() (r time.Time, exists bool) {
	v := m.sign_nd_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSignNdTime returns the old "sign_nd_time" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldSignNdTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignNdTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignNdTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignNdTime: %w", err)
	}
	return oldValue.SignNdTime, nil
}

// ClearSignNdTime clears the value of the "sign_nd_time" field.
func (m *CourseRecordUserMutation) ClearSignNdTime() {
	m.sign_nd_time = nil
	m.clearedFields[courserecorduser.FieldSignNdTime] = struct{}{}
}

// SignNdTimeCleared returns if the "sign_nd_time" field was cleared in this mutation.
func (m *CourseRecordUserMutation) SignNdTimeCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldSignNdTime]
	return ok
}

// ResetSignNdTime resets all changes to the "sign_nd_time" field.
func (m *CourseRecordUserMutation) ResetSignNdTime() {
	m.sign_nd_time = nil
	delete(m.clearedFields, courserecorduser.FieldSignNdTime)
}

// SetUserProductID sets the "user_product_id" field.
func (m *CourseRecordUserMutation) SetUserProductID(i int64) {
	m.user_product_id = &i
	m.adduser_product_id = nil
}

// UserProductID returns the value of the "user_product_id" field in the mutation.
func (m *CourseRecordUserMutation) UserProductID() (r int64, exists bool) {
	v := m.user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserProductID returns the old "user_product_id" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldUserProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserProductID: %w", err)
	}
	return oldValue.UserProductID, nil
}

// AddUserProductID adds i to the "user_product_id" field.
func (m *CourseRecordUserMutation) AddUserProductID(i int64) {
	if m.adduser_product_id != nil {
		*m.adduser_product_id += i
	} else {
		m.adduser_product_id = &i
	}
}

// AddedUserProductID returns the value that was added to the "user_product_id" field in this mutation.
func (m *CourseRecordUserMutation) AddedUserProductID() (r int64, exists bool) {
	v := m.adduser_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserProductID clears the value of the "user_product_id" field.
func (m *CourseRecordUserMutation) ClearUserProductID() {
	m.user_product_id = nil
	m.adduser_product_id = nil
	m.clearedFields[courserecorduser.FieldUserProductID] = struct{}{}
}

// UserProductIDCleared returns if the "user_product_id" field was cleared in this mutation.
func (m *CourseRecordUserMutation) UserProductIDCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldUserProductID]
	return ok
}

// ResetUserProductID resets all changes to the "user_product_id" field.
func (m *CourseRecordUserMutation) ResetUserProductID() {
	m.user_product_id = nil
	m.adduser_product_id = nil
	delete(m.clearedFields, courserecorduser.FieldUserProductID)
}

// SetUserProductItemID sets the "user_product_item_id" field.
func (m *CourseRecordUserMutation) SetUserProductItemID(i int64) {
	m.user_product_item_id = &i
	m.adduser_product_item_id = nil
}

// UserProductItemID returns the value of the "user_product_item_id" field in the mutation.
func (m *CourseRecordUserMutation) UserProductItemID() (r int64, exists bool) {
	v := m.user_product_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserProductItemID returns the old "user_product_item_id" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldUserProductItemID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserProductItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserProductItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserProductItemID: %w", err)
	}
	return oldValue.UserProductItemID, nil
}

// AddUserProductItemID adds i to the "user_product_item_id" field.
func (m *CourseRecordUserMutation) AddUserProductItemID(i int64) {
	if m.adduser_product_item_id != nil {
		*m.adduser_product_item_id += i
	} else {
		m.adduser_product_item_id = &i
	}
}

// AddedUserProductItemID returns the value that was added to the "user_product_item_id" field in this mutation.
func (m *CourseRecordUserMutation) AddedUserProductItemID() (r int64, exists bool) {
	v := m.adduser_product_item_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserProductItemID clears the value of the "user_product_item_id" field.
func (m *CourseRecordUserMutation) ClearUserProductItemID() {
	m.user_product_item_id = nil
	m.adduser_product_item_id = nil
	m.clearedFields[courserecorduser.FieldUserProductItemID] = struct{}{}
}

// UserProductItemIDCleared returns if the "user_product_item_id" field was cleared in this mutation.
func (m *CourseRecordUserMutation) UserProductItemIDCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldUserProductItemID]
	return ok
}

// ResetUserProductItemID resets all changes to the "user_product_item_id" field.
func (m *CourseRecordUserMutation) ResetUserProductItemID() {
	m.user_product_item_id = nil
	m.adduser_product_item_id = nil
	delete(m.clearedFields, courserecorduser.FieldUserProductItemID)
}

// SetCoachID sets the "coach_id" field.
func (m *CourseRecordUserMutation) SetCoachID(i int64) {
	m.coach_id = &i
	m.addcoach_id = nil
}

// CoachID returns the value of the "coach_id" field in the mutation.
func (m *CourseRecordUserMutation) CoachID() (r int64, exists bool) {
	v := m.coach_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoachID returns the old "coach_id" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldCoachID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoachID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoachID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoachID: %w", err)
	}
	return oldValue.CoachID, nil
}

// AddCoachID adds i to the "coach_id" field.
func (m *CourseRecordUserMutation) AddCoachID(i int64) {
	if m.addcoach_id != nil {
		*m.addcoach_id += i
	} else {
		m.addcoach_id = &i
	}
}

// AddedCoachID returns the value that was added to the "coach_id" field in this mutation.
func (m *CourseRecordUserMutation) AddedCoachID() (r int64, exists bool) {
	v := m.addcoach_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCoachID clears the value of the "coach_id" field.
func (m *CourseRecordUserMutation) ClearCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	m.clearedFields[courserecorduser.FieldCoachID] = struct{}{}
}

// CoachIDCleared returns if the "coach_id" field was cleared in this mutation.
func (m *CourseRecordUserMutation) CoachIDCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldCoachID]
	return ok
}

// ResetCoachID resets all changes to the "coach_id" field.
func (m *CourseRecordUserMutation) ResetCoachID() {
	m.coach_id = nil
	m.addcoach_id = nil
	delete(m.clearedFields, courserecorduser.FieldCoachID)
}

// SetStatus sets the "status" field.
func (m *CourseRecordUserMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CourseRecordUserMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CourseRecordUser entity.
// If the CourseRecordUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseRecordUserMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CourseRecordUserMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CourseRecordUserMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *CourseRecordUserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[courserecorduser.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CourseRecordUserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[courserecorduser.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CourseRecordUserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, courserecorduser.FieldStatus)
}

// SetScheduleID sets the "schedule" edge to the CourseRecordSchedule entity by id.
func (m *CourseRecordUserMutation) SetScheduleID(id int64) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the CourseRecordSchedule entity.
func (m *CourseRecordUserMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[courserecorduser.FieldCourseRecordScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the CourseRecordSchedule entity was cleared.
func (m *CourseRecordUserMutation) ScheduleCleared() bool {
	return m.CourseRecordScheduleIDCleared() || m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *CourseRecordUserMutation) ScheduleID() (id int64, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *CourseRecordUserMutation) ScheduleIDs() (ids []int64) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *CourseRecordUserMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the CourseRecordUserMutation builder.
func (m *CourseRecordUserMutation) Where(ps ...predicate.CourseRecordUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseRecordUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseRecordUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CourseRecordUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseRecordUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseRecordUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CourseRecordUser).
func (m *CourseRecordUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseRecordUserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, courserecorduser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courserecorduser.FieldUpdatedAt)
	}
	if m.venue_id != nil {
		fields = append(fields, courserecorduser.FieldVenueID)
	}
	if m.user_id != nil {
		fields = append(fields, courserecorduser.FieldUserID)
	}
	if m.schedule != nil {
		fields = append(fields, courserecorduser.FieldCourseRecordScheduleID)
	}
	if m._type != nil {
		fields = append(fields, courserecorduser.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, courserecorduser.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, courserecorduser.FieldEndTime)
	}
	if m.sign_start_time != nil {
		fields = append(fields, courserecorduser.FieldSignStartTime)
	}
	if m.sign_nd_time != nil {
		fields = append(fields, courserecorduser.FieldSignNdTime)
	}
	if m.user_product_id != nil {
		fields = append(fields, courserecorduser.FieldUserProductID)
	}
	if m.user_product_item_id != nil {
		fields = append(fields, courserecorduser.FieldUserProductItemID)
	}
	if m.coach_id != nil {
		fields = append(fields, courserecorduser.FieldCoachID)
	}
	if m.status != nil {
		fields = append(fields, courserecorduser.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseRecordUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courserecorduser.FieldCreatedAt:
		return m.CreatedAt()
	case courserecorduser.FieldUpdatedAt:
		return m.UpdatedAt()
	case courserecorduser.FieldVenueID:
		return m.VenueID()
	case courserecorduser.FieldUserID:
		return m.UserID()
	case courserecorduser.FieldCourseRecordScheduleID:
		return m.CourseRecordScheduleID()
	case courserecorduser.FieldType:
		return m.GetType()
	case courserecorduser.FieldStartTime:
		return m.StartTime()
	case courserecorduser.FieldEndTime:
		return m.EndTime()
	case courserecorduser.FieldSignStartTime:
		return m.SignStartTime()
	case courserecorduser.FieldSignNdTime:
		return m.SignNdTime()
	case courserecorduser.FieldUserProductID:
		return m.UserProductID()
	case courserecorduser.FieldUserProductItemID:
		return m.UserProductItemID()
	case courserecorduser.FieldCoachID:
		return m.CoachID()
	case courserecorduser.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseRecordUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courserecorduser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courserecorduser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case courserecorduser.FieldVenueID:
		return m.OldVenueID(ctx)
	case courserecorduser.FieldUserID:
		return m.OldUserID(ctx)
	case courserecorduser.FieldCourseRecordScheduleID:
		return m.OldCourseRecordScheduleID(ctx)
	case courserecorduser.FieldType:
		return m.OldType(ctx)
	case courserecorduser.FieldStartTime:
		return m.OldStartTime(ctx)
	case courserecorduser.FieldEndTime:
		return m.OldEndTime(ctx)
	case courserecorduser.FieldSignStartTime:
		return m.OldSignStartTime(ctx)
	case courserecorduser.FieldSignNdTime:
		return m.OldSignNdTime(ctx)
	case courserecorduser.FieldUserProductID:
		return m.OldUserProductID(ctx)
	case courserecorduser.FieldUserProductItemID:
		return m.OldUserProductItemID(ctx)
	case courserecorduser.FieldCoachID:
		return m.OldCoachID(ctx)
	case courserecorduser.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CourseRecordUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseRecordUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courserecorduser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courserecorduser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case courserecorduser.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case courserecorduser.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case courserecorduser.FieldCourseRecordScheduleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseRecordScheduleID(v)
		return nil
	case courserecorduser.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case courserecorduser.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case courserecorduser.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case courserecorduser.FieldSignStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignStartTime(v)
		return nil
	case courserecorduser.FieldSignNdTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignNdTime(v)
		return nil
	case courserecorduser.FieldUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserProductID(v)
		return nil
	case courserecorduser.FieldUserProductItemID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserProductItemID(v)
		return nil
	case courserecorduser.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoachID(v)
		return nil
	case courserecorduser.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CourseRecordUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseRecordUserMutation) AddedFields() []string {
	var fields []string
	if m.addvenue_id != nil {
		fields = append(fields, courserecorduser.FieldVenueID)
	}
	if m.adduser_id != nil {
		fields = append(fields, courserecorduser.FieldUserID)
	}
	if m.adduser_product_id != nil {
		fields = append(fields, courserecorduser.FieldUserProductID)
	}
	if m.adduser_product_item_id != nil {
		fields = append(fields, courserecorduser.FieldUserProductItemID)
	}
	if m.addcoach_id != nil {
		fields = append(fields, courserecorduser.FieldCoachID)
	}
	if m.addstatus != nil {
		fields = append(fields, courserecorduser.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseRecordUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case courserecorduser.FieldVenueID:
		return m.AddedVenueID()
	case courserecorduser.FieldUserID:
		return m.AddedUserID()
	case courserecorduser.FieldUserProductID:
		return m.AddedUserProductID()
	case courserecorduser.FieldUserProductItemID:
		return m.AddedUserProductItemID()
	case courserecorduser.FieldCoachID:
		return m.AddedCoachID()
	case courserecorduser.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseRecordUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case courserecorduser.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case courserecorduser.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case courserecorduser.FieldUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserProductID(v)
		return nil
	case courserecorduser.FieldUserProductItemID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserProductItemID(v)
		return nil
	case courserecorduser.FieldCoachID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoachID(v)
		return nil
	case courserecorduser.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CourseRecordUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseRecordUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(courserecorduser.FieldVenueID) {
		fields = append(fields, courserecorduser.FieldVenueID)
	}
	if m.FieldCleared(courserecorduser.FieldUserID) {
		fields = append(fields, courserecorduser.FieldUserID)
	}
	if m.FieldCleared(courserecorduser.FieldCourseRecordScheduleID) {
		fields = append(fields, courserecorduser.FieldCourseRecordScheduleID)
	}
	if m.FieldCleared(courserecorduser.FieldType) {
		fields = append(fields, courserecorduser.FieldType)
	}
	if m.FieldCleared(courserecorduser.FieldStartTime) {
		fields = append(fields, courserecorduser.FieldStartTime)
	}
	if m.FieldCleared(courserecorduser.FieldEndTime) {
		fields = append(fields, courserecorduser.FieldEndTime)
	}
	if m.FieldCleared(courserecorduser.FieldSignStartTime) {
		fields = append(fields, courserecorduser.FieldSignStartTime)
	}
	if m.FieldCleared(courserecorduser.FieldSignNdTime) {
		fields = append(fields, courserecorduser.FieldSignNdTime)
	}
	if m.FieldCleared(courserecorduser.FieldUserProductID) {
		fields = append(fields, courserecorduser.FieldUserProductID)
	}
	if m.FieldCleared(courserecorduser.FieldUserProductItemID) {
		fields = append(fields, courserecorduser.FieldUserProductItemID)
	}
	if m.FieldCleared(courserecorduser.FieldCoachID) {
		fields = append(fields, courserecorduser.FieldCoachID)
	}
	if m.FieldCleared(courserecorduser.FieldStatus) {
		fields = append(fields, courserecorduser.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseRecordUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseRecordUserMutation) ClearField(name string) error {
	switch name {
	case courserecorduser.FieldVenueID:
		m.ClearVenueID()
		return nil
	case courserecorduser.FieldUserID:
		m.ClearUserID()
		return nil
	case courserecorduser.FieldCourseRecordScheduleID:
		m.ClearCourseRecordScheduleID()
		return nil
	case courserecorduser.FieldType:
		m.ClearType()
		return nil
	case courserecorduser.FieldStartTime:
		m.ClearStartTime()
		return nil
	case courserecorduser.FieldEndTime:
		m.ClearEndTime()
		return nil
	case courserecorduser.FieldSignStartTime:
		m.ClearSignStartTime()
		return nil
	case courserecorduser.FieldSignNdTime:
		m.ClearSignNdTime()
		return nil
	case courserecorduser.FieldUserProductID:
		m.ClearUserProductID()
		return nil
	case courserecorduser.FieldUserProductItemID:
		m.ClearUserProductItemID()
		return nil
	case courserecorduser.FieldCoachID:
		m.ClearCoachID()
		return nil
	case courserecorduser.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseRecordUserMutation) ResetField(name string) error {
	switch name {
	case courserecorduser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courserecorduser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case courserecorduser.FieldVenueID:
		m.ResetVenueID()
		return nil
	case courserecorduser.FieldUserID:
		m.ResetUserID()
		return nil
	case courserecorduser.FieldCourseRecordScheduleID:
		m.ResetCourseRecordScheduleID()
		return nil
	case courserecorduser.FieldType:
		m.ResetType()
		return nil
	case courserecorduser.FieldStartTime:
		m.ResetStartTime()
		return nil
	case courserecorduser.FieldEndTime:
		m.ResetEndTime()
		return nil
	case courserecorduser.FieldSignStartTime:
		m.ResetSignStartTime()
		return nil
	case courserecorduser.FieldSignNdTime:
		m.ResetSignNdTime()
		return nil
	case courserecorduser.FieldUserProductID:
		m.ResetUserProductID()
		return nil
	case courserecorduser.FieldUserProductItemID:
		m.ResetUserProductItemID()
		return nil
	case courserecorduser.FieldCoachID:
		m.ResetCoachID()
		return nil
	case courserecorduser.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseRecordUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.schedule != nil {
		edges = append(edges, courserecorduser.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseRecordUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case courserecorduser.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseRecordUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseRecordUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseRecordUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedschedule {
		edges = append(edges, courserecorduser.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseRecordUserMutation) EdgeCleared(name string) bool {
	switch name {
	case courserecorduser.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseRecordUserMutation) ClearEdge(name string) error {
	switch name {
	case courserecorduser.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseRecordUserMutation) ResetEdge(name string) error {
	switch name {
	case courserecorduser.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown CourseRecordUser edge %s", name)
}

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	created_at                *time.Time
	updated_at                *time.Time
	status                    *int8
	addstatus                 *int8
	title                     *string
	name                      *string
	description               *string
	clearedFields             map[string]struct{}
	dictionary_details        map[int64]struct{}
	removeddictionary_details map[int64]struct{}
	cleareddictionary_details bool
	done                      bool
	oldValue                  func(context.Context) (*Dictionary, error)
	predicates                []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id int64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryMutation) ResetTitle() {
	m.title = nil
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DictionaryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictionaryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DictionaryMutation) ResetDescription() {
	m.description = nil
}

// AddDictionaryDetailIDs adds the "dictionary_details" edge to the DictionaryDetail entity by ids.
func (m *DictionaryMutation) AddDictionaryDetailIDs(ids ...int64) {
	if m.dictionary_details == nil {
		m.dictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		m.dictionary_details[ids[i]] = struct{}{}
	}
}

// ClearDictionaryDetails clears the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) ClearDictionaryDetails() {
	m.cleareddictionary_details = true
}

// DictionaryDetailsCleared reports if the "dictionary_details" edge to the DictionaryDetail entity was cleared.
func (m *DictionaryMutation) DictionaryDetailsCleared() bool {
	return m.cleareddictionary_details
}

// RemoveDictionaryDetailIDs removes the "dictionary_details" edge to the DictionaryDetail entity by IDs.
func (m *DictionaryMutation) RemoveDictionaryDetailIDs(ids ...int64) {
	if m.removeddictionary_details == nil {
		m.removeddictionary_details = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.dictionary_details, ids[i])
		m.removeddictionary_details[ids[i]] = struct{}{}
	}
}

// RemovedDictionaryDetails returns the removed IDs of the "dictionary_details" edge to the DictionaryDetail entity.
func (m *DictionaryMutation) RemovedDictionaryDetailsIDs() (ids []int64) {
	for id := range m.removeddictionary_details {
		ids = append(ids, id)
	}
	return
}

// DictionaryDetailsIDs returns the "dictionary_details" edge IDs in the mutation.
func (m *DictionaryMutation) DictionaryDetailsIDs() (ids []int64) {
	for id := range m.dictionary_details {
		ids = append(ids, id)
	}
	return
}

// ResetDictionaryDetails resets all changes to the "dictionary_details" edge.
func (m *DictionaryMutation) ResetDictionaryDetails() {
	m.dictionary_details = nil
	m.cleareddictionary_details = false
	m.removeddictionary_details = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionary.FieldTitle)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dictionary.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldTitle:
		return m.Title()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldTitle:
		return m.OldTitle(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.dictionary_details))
		for id := range m.dictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictionary_details != nil {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		ids := make([]ent.Value, 0, len(m.removeddictionary_details))
		for id := range m.removeddictionary_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary_details {
		edges = append(edges, dictionary.EdgeDictionaryDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		return m.cleareddictionary_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeDictionaryDetails:
		m.ResetDictionaryDetails()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryDetailMutation represents an operation that mutates the DictionaryDetail nodes in the graph.
type DictionaryDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	status            *int8
	addstatus         *int8
	title             *string
	key               *string
	value             *string
	clearedFields     map[string]struct{}
	dictionary        *int64
	cleareddictionary bool
	done              bool
	oldValue          func(context.Context) (*DictionaryDetail, error)
	predicates        []predicate.DictionaryDetail
}

var _ ent.Mutation = (*DictionaryDetailMutation)(nil)

// dictionarydetailOption allows management of the mutation configuration using functional options.
type dictionarydetailOption func(*DictionaryDetailMutation)

// newDictionaryDetailMutation creates new mutation for the DictionaryDetail entity.
func newDictionaryDetailMutation(c config, op Op, opts ...dictionarydetailOption) *DictionaryDetailMutation {
	m := &DictionaryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryDetailID sets the ID field of the mutation.
func withDictionaryDetailID(id int64) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DictionaryDetail
		)
		m.oldValue = func(ctx context.Context) (*DictionaryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictionaryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionaryDetail sets the old DictionaryDetail of the mutation.
func withDictionaryDetail(node *DictionaryDetail) dictionarydetailOption {
	return func(m *DictionaryDetailMutation) {
		m.oldValue = func(context.Context) (*DictionaryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictionaryDetail entities.
func (m *DictionaryDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictionaryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DictionaryDetailMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryDetailMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictionaryDetailMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictionaryDetailMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryDetailMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictionarydetail.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryDetailMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryDetailMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictionarydetail.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictionaryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictionaryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DictionaryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetKey sets the "key" field.
func (m *DictionaryDetailMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DictionaryDetailMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DictionaryDetailMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DictionaryDetailMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryDetailMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryDetailMutation) ResetValue() {
	m.value = nil
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryDetailMutation) SetDictionaryID(i int64) {
	m.dictionary = &i
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryDetailMutation) DictionaryID() (r int64, exists bool) {
	v := m.dictionary
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the DictionaryDetail entity.
// If the DictionaryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryDetailMutation) OldDictionaryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ClearDictionaryID clears the value of the "dictionary_id" field.
func (m *DictionaryDetailMutation) ClearDictionaryID() {
	m.dictionary = nil
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryIDCleared returns if the "dictionary_id" field was cleared in this mutation.
func (m *DictionaryDetailMutation) DictionaryIDCleared() bool {
	_, ok := m.clearedFields[dictionarydetail.FieldDictionaryID]
	return ok
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryDetailMutation) ResetDictionaryID() {
	m.dictionary = nil
	delete(m.clearedFields, dictionarydetail.FieldDictionaryID)
}

// ClearDictionary clears the "dictionary" edge to the Dictionary entity.
func (m *DictionaryDetailMutation) ClearDictionary() {
	m.cleareddictionary = true
	m.clearedFields[dictionarydetail.FieldDictionaryID] = struct{}{}
}

// DictionaryCleared reports if the "dictionary" edge to the Dictionary entity was cleared.
func (m *DictionaryDetailMutation) DictionaryCleared() bool {
	return m.DictionaryIDCleared() || m.cleareddictionary
}

// DictionaryIDs returns the "dictionary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionaryID instead. It exists only for internal usage by the builders.
func (m *DictionaryDetailMutation) DictionaryIDs() (ids []int64) {
	if id := m.dictionary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionary resets all changes to the "dictionary" edge.
func (m *DictionaryDetailMutation) ResetDictionary() {
	m.dictionary = nil
	m.cleareddictionary = false
}

// Where appends a list predicates to the DictionaryDetailMutation builder.
func (m *DictionaryDetailMutation) Where(ps ...predicate.DictionaryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictionaryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictionaryDetail).
func (m *DictionaryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryDetailMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, dictionarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionarydetail.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictionarydetail.FieldTitle)
	}
	if m.key != nil {
		fields = append(fields, dictionarydetail.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dictionarydetail.FieldValue)
	}
	if m.dictionary != nil {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case dictionarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionarydetail.FieldStatus:
		return m.Status()
	case dictionarydetail.FieldTitle:
		return m.Title()
	case dictionarydetail.FieldKey:
		return m.Key()
	case dictionarydetail.FieldValue:
		return m.Value()
	case dictionarydetail.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionarydetail.FieldStatus:
		return m.OldStatus(ctx)
	case dictionarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case dictionarydetail.FieldKey:
		return m.OldKey(ctx)
	case dictionarydetail.FieldValue:
		return m.OldValue(ctx)
	case dictionarydetail.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionarydetail.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictionarydetail.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dictionarydetail.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionarydetail.FieldDictionaryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryDetailMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionarydetail.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionarydetail.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionarydetail.FieldStatus) {
		fields = append(fields, dictionarydetail.FieldStatus)
	}
	if m.FieldCleared(dictionarydetail.FieldDictionaryID) {
		fields = append(fields, dictionarydetail.FieldDictionaryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ClearField(name string) error {
	switch name {
	case dictionarydetail.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ClearDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryDetailMutation) ResetField(name string) error {
	switch name {
	case dictionarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionarydetail.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case dictionarydetail.FieldKey:
		m.ResetKey()
		return nil
	case dictionarydetail.FieldValue:
		m.ResetValue()
		return nil
	case dictionarydetail.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary != nil {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionarydetail.EdgeDictionary:
		if id := m.dictionary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary {
		edges = append(edges, dictionarydetail.EdgeDictionary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionarydetail.EdgeDictionary:
		return m.cleareddictionary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryDetailMutation) ClearEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ClearDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryDetailMutation) ResetEdge(name string) error {
	switch name {
	case dictionarydetail.EdgeDictionary:
		m.ResetDictionary()
		return nil
	}
	return fmt.Errorf("unknown DictionaryDetail edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	method        *string
	api           *string
	success       *bool
	req_content   *string
	resp_content  *string
	ip            *string
	user_agent    *string
	operator      *string
	time          *int
	addtime       *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int64) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *LogsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LogsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LogsMutation) ResetType() {
	m._type = nil
}

// SetMethod sets the "method" field.
func (m *LogsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *LogsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *LogsMutation) ResetMethod() {
	m.method = nil
}

// SetAPI sets the "api" field.
func (m *LogsMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *LogsMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *LogsMutation) ResetAPI() {
	m.api = nil
}

// SetSuccess sets the "success" field.
func (m *LogsMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LogsMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LogsMutation) ResetSuccess() {
	m.success = nil
}

// SetReqContent sets the "req_content" field.
func (m *LogsMutation) SetReqContent(s string) {
	m.req_content = &s
}

// ReqContent returns the value of the "req_content" field in the mutation.
func (m *LogsMutation) ReqContent() (r string, exists bool) {
	v := m.req_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReqContent returns the old "req_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldReqContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqContent: %w", err)
	}
	return oldValue.ReqContent, nil
}

// ClearReqContent clears the value of the "req_content" field.
func (m *LogsMutation) ClearReqContent() {
	m.req_content = nil
	m.clearedFields[logs.FieldReqContent] = struct{}{}
}

// ReqContentCleared returns if the "req_content" field was cleared in this mutation.
func (m *LogsMutation) ReqContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldReqContent]
	return ok
}

// ResetReqContent resets all changes to the "req_content" field.
func (m *LogsMutation) ResetReqContent() {
	m.req_content = nil
	delete(m.clearedFields, logs.FieldReqContent)
}

// SetRespContent sets the "resp_content" field.
func (m *LogsMutation) SetRespContent(s string) {
	m.resp_content = &s
}

// RespContent returns the value of the "resp_content" field in the mutation.
func (m *LogsMutation) RespContent() (r string, exists bool) {
	v := m.resp_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRespContent returns the old "resp_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRespContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespContent: %w", err)
	}
	return oldValue.RespContent, nil
}

// ClearRespContent clears the value of the "resp_content" field.
func (m *LogsMutation) ClearRespContent() {
	m.resp_content = nil
	m.clearedFields[logs.FieldRespContent] = struct{}{}
}

// RespContentCleared returns if the "resp_content" field was cleared in this mutation.
func (m *LogsMutation) RespContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldRespContent]
	return ok
}

// ResetRespContent resets all changes to the "resp_content" field.
func (m *LogsMutation) ResetRespContent() {
	m.resp_content = nil
	delete(m.clearedFields, logs.FieldRespContent)
}

// SetIP sets the "ip" field.
func (m *LogsMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *LogsMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[logs.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *LogsMutation) IPCleared() bool {
	_, ok := m.clearedFields[logs.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *LogsMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, logs.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LogsMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LogsMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LogsMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[logs.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LogsMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LogsMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, logs.FieldUserAgent)
}

// SetOperator sets the "operator" field.
func (m *LogsMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the value of the "operator" field in the mutation.
func (m *LogsMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldOperator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ClearOperator clears the value of the "operator" field.
func (m *LogsMutation) ClearOperator() {
	m.operator = nil
	m.clearedFields[logs.FieldOperator] = struct{}{}
}

// OperatorCleared returns if the "operator" field was cleared in this mutation.
func (m *LogsMutation) OperatorCleared() bool {
	_, ok := m.clearedFields[logs.FieldOperator]
	return ok
}

// ResetOperator resets all changes to the "operator" field.
func (m *LogsMutation) ResetOperator() {
	m.operator = nil
	delete(m.clearedFields, logs.FieldOperator)
}

// SetTime sets the "time" field.
func (m *LogsMutation) SetTime(i int) {
	m.time = &i
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *LogsMutation) Time() (r int, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to the "time" field.
func (m *LogsMutation) AddTime(i int) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *LogsMutation) AddedTime() (r int, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *LogsMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[logs.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *LogsMutation) TimeCleared() bool {
	_, ok := m.clearedFields[logs.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *LogsMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, logs.FieldTime)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, logs.FieldType)
	}
	if m.method != nil {
		fields = append(fields, logs.FieldMethod)
	}
	if m.api != nil {
		fields = append(fields, logs.FieldAPI)
	}
	if m.success != nil {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.req_content != nil {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.resp_content != nil {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.ip != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.operator != nil {
		fields = append(fields, logs.FieldOperator)
	}
	if m.time != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldType:
		return m.GetType()
	case logs.FieldMethod:
		return m.Method()
	case logs.FieldAPI:
		return m.API()
	case logs.FieldSuccess:
		return m.Success()
	case logs.FieldReqContent:
		return m.ReqContent()
	case logs.FieldRespContent:
		return m.RespContent()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldUserAgent:
		return m.UserAgent()
	case logs.FieldOperator:
		return m.Operator()
	case logs.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldType:
		return m.OldType(ctx)
	case logs.FieldMethod:
		return m.OldMethod(ctx)
	case logs.FieldAPI:
		return m.OldAPI(ctx)
	case logs.FieldSuccess:
		return m.OldSuccess(ctx)
	case logs.FieldReqContent:
		return m.OldReqContent(ctx)
	case logs.FieldRespContent:
		return m.OldRespContent(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case logs.FieldOperator:
		return m.OldOperator(ctx)
	case logs.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case logs.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case logs.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case logs.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case logs.FieldReqContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqContent(v)
		return nil
	case logs.FieldRespContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespContent(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case logs.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.addtime != nil {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldReqContent) {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.FieldCleared(logs.FieldRespContent) {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.FieldCleared(logs.FieldIP) {
		fields = append(fields, logs.FieldIP)
	}
	if m.FieldCleared(logs.FieldUserAgent) {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.FieldCleared(logs.FieldOperator) {
		fields = append(fields, logs.FieldOperator)
	}
	if m.FieldCleared(logs.FieldTime) {
		fields = append(fields, logs.FieldTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldReqContent:
		m.ClearReqContent()
		return nil
	case logs.FieldRespContent:
		m.ClearRespContent()
		return nil
	case logs.FieldIP:
		m.ClearIP()
		return nil
	case logs.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case logs.FieldOperator:
		m.ClearOperator()
		return nil
	case logs.FieldTime:
		m.ClearTime()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldType:
		m.ResetType()
		return nil
	case logs.FieldMethod:
		m.ResetMethod()
		return nil
	case logs.FieldAPI:
		m.ResetAPI()
		return nil
	case logs.FieldSuccess:
		m.ResetSuccess()
		return nil
	case logs.FieldReqContent:
		m.ResetReqContent()
		return nil
	case logs.FieldRespContent:
		m.ResetRespContent()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case logs.FieldOperator:
		m.ResetOperator()
		return nil
	case logs.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	menu_level            *int32
	addmenu_level         *int32
	menu_type             *int32
	addmenu_type          *int32
	_path                 *string
	name                  *string
	redirect              *string
	component             *string
	order_no              *int32
	addorder_no           *int32
	disabled              *bool
	title                 *string
	icon                  *string
	hide_menu             *bool
	hide_breadcrumb       *bool
	current_active_menu   *string
	ignore_keep_alive     *bool
	hide_tab              *bool
	frame_src             *string
	carry_param           *bool
	hide_children_in_menu *bool
	affix                 *bool
	dynamic_level         *int32
	adddynamic_level      *int32
	real_path             *string
	clearedFields         map[string]struct{}
	roles                 map[int64]struct{}
	removedroles          map[int64]struct{}
	clearedroles          bool
	parent                *int64
	clearedparent         bool
	children              map[int64]struct{}
	removedchildren       map[int64]struct{}
	clearedchildren       bool
	params                map[int64]struct{}
	removedparams         map[int64]struct{}
	clearedparams         bool
	done                  bool
	oldValue              func(context.Context) (*Menu, error)
	predicates            []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetMenuLevel sets the "menu_level" field.
func (m *MenuMutation) SetMenuLevel(i int32) {
	m.menu_level = &i
	m.addmenu_level = nil
}

// MenuLevel returns the value of the "menu_level" field in the mutation.
func (m *MenuMutation) MenuLevel() (r int32, exists bool) {
	v := m.menu_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuLevel returns the old "menu_level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuLevel: %w", err)
	}
	return oldValue.MenuLevel, nil
}

// AddMenuLevel adds i to the "menu_level" field.
func (m *MenuMutation) AddMenuLevel(i int32) {
	if m.addmenu_level != nil {
		*m.addmenu_level += i
	} else {
		m.addmenu_level = &i
	}
}

// AddedMenuLevel returns the value that was added to the "menu_level" field in this mutation.
func (m *MenuMutation) AddedMenuLevel() (r int32, exists bool) {
	v := m.addmenu_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuLevel resets all changes to the "menu_level" field.
func (m *MenuMutation) ResetMenuLevel() {
	m.menu_level = nil
	m.addmenu_level = nil
}

// SetMenuType sets the "menu_type" field.
func (m *MenuMutation) SetMenuType(i int32) {
	m.menu_type = &i
	m.addmenu_type = nil
}

// MenuType returns the value of the "menu_type" field in the mutation.
func (m *MenuMutation) MenuType() (r int32, exists bool) {
	v := m.menu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuType returns the old "menu_type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuType: %w", err)
	}
	return oldValue.MenuType, nil
}

// AddMenuType adds i to the "menu_type" field.
func (m *MenuMutation) AddMenuType(i int32) {
	if m.addmenu_type != nil {
		*m.addmenu_type += i
	} else {
		m.addmenu_type = &i
	}
}

// AddedMenuType returns the value that was added to the "menu_type" field in this mutation.
func (m *MenuMutation) AddedMenuType() (r int32, exists bool) {
	v := m.addmenu_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuType resets all changes to the "menu_type" field.
func (m *MenuMutation) ResetMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetRedirect sets the "redirect" field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of the "redirect" field.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the "redirect" field was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetOrderNo sets the "order_no" field.
func (m *MenuMutation) SetOrderNo(i int32) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *MenuMutation) OrderNo() (r int32, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldOrderNo(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *MenuMutation) AddOrderNo(i int32) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *MenuMutation) AddedOrderNo() (r int32, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *MenuMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// SetDisabled sets the "disabled" field.
func (m *MenuMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *MenuMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *MenuMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[menu.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *MenuMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[menu.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *MenuMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, menu.FieldDisabled)
}

// SetTitle sets the "title" field.
func (m *MenuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MenuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *MenuMutation) ResetTitle() {
	m.title = nil
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
}

// SetHideMenu sets the "hide_menu" field.
func (m *MenuMutation) SetHideMenu(b bool) {
	m.hide_menu = &b
}

// HideMenu returns the value of the "hide_menu" field in the mutation.
func (m *MenuMutation) HideMenu() (r bool, exists bool) {
	v := m.hide_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldHideMenu returns the old "hide_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideMenu(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideMenu: %w", err)
	}
	return oldValue.HideMenu, nil
}

// ClearHideMenu clears the value of the "hide_menu" field.
func (m *MenuMutation) ClearHideMenu() {
	m.hide_menu = nil
	m.clearedFields[menu.FieldHideMenu] = struct{}{}
}

// HideMenuCleared returns if the "hide_menu" field was cleared in this mutation.
func (m *MenuMutation) HideMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideMenu]
	return ok
}

// ResetHideMenu resets all changes to the "hide_menu" field.
func (m *MenuMutation) ResetHideMenu() {
	m.hide_menu = nil
	delete(m.clearedFields, menu.FieldHideMenu)
}

// SetHideBreadcrumb sets the "hide_breadcrumb" field.
func (m *MenuMutation) SetHideBreadcrumb(b bool) {
	m.hide_breadcrumb = &b
}

// HideBreadcrumb returns the value of the "hide_breadcrumb" field in the mutation.
func (m *MenuMutation) HideBreadcrumb() (r bool, exists bool) {
	v := m.hide_breadcrumb
	if v == nil {
		return
	}
	return *v, true
}

// OldHideBreadcrumb returns the old "hide_breadcrumb" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideBreadcrumb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideBreadcrumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideBreadcrumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideBreadcrumb: %w", err)
	}
	return oldValue.HideBreadcrumb, nil
}

// ClearHideBreadcrumb clears the value of the "hide_breadcrumb" field.
func (m *MenuMutation) ClearHideBreadcrumb() {
	m.hide_breadcrumb = nil
	m.clearedFields[menu.FieldHideBreadcrumb] = struct{}{}
}

// HideBreadcrumbCleared returns if the "hide_breadcrumb" field was cleared in this mutation.
func (m *MenuMutation) HideBreadcrumbCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideBreadcrumb]
	return ok
}

// ResetHideBreadcrumb resets all changes to the "hide_breadcrumb" field.
func (m *MenuMutation) ResetHideBreadcrumb() {
	m.hide_breadcrumb = nil
	delete(m.clearedFields, menu.FieldHideBreadcrumb)
}

// SetCurrentActiveMenu sets the "current_active_menu" field.
func (m *MenuMutation) SetCurrentActiveMenu(s string) {
	m.current_active_menu = &s
}

// CurrentActiveMenu returns the value of the "current_active_menu" field in the mutation.
func (m *MenuMutation) CurrentActiveMenu() (r string, exists bool) {
	v := m.current_active_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentActiveMenu returns the old "current_active_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCurrentActiveMenu(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentActiveMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentActiveMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentActiveMenu: %w", err)
	}
	return oldValue.CurrentActiveMenu, nil
}

// ClearCurrentActiveMenu clears the value of the "current_active_menu" field.
func (m *MenuMutation) ClearCurrentActiveMenu() {
	m.current_active_menu = nil
	m.clearedFields[menu.FieldCurrentActiveMenu] = struct{}{}
}

// CurrentActiveMenuCleared returns if the "current_active_menu" field was cleared in this mutation.
func (m *MenuMutation) CurrentActiveMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldCurrentActiveMenu]
	return ok
}

// ResetCurrentActiveMenu resets all changes to the "current_active_menu" field.
func (m *MenuMutation) ResetCurrentActiveMenu() {
	m.current_active_menu = nil
	delete(m.clearedFields, menu.FieldCurrentActiveMenu)
}

// SetIgnoreKeepAlive sets the "ignore_keep_alive" field.
func (m *MenuMutation) SetIgnoreKeepAlive(b bool) {
	m.ignore_keep_alive = &b
}

// IgnoreKeepAlive returns the value of the "ignore_keep_alive" field in the mutation.
func (m *MenuMutation) IgnoreKeepAlive() (r bool, exists bool) {
	v := m.ignore_keep_alive
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreKeepAlive returns the old "ignore_keep_alive" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIgnoreKeepAlive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnoreKeepAlive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnoreKeepAlive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreKeepAlive: %w", err)
	}
	return oldValue.IgnoreKeepAlive, nil
}

// ClearIgnoreKeepAlive clears the value of the "ignore_keep_alive" field.
func (m *MenuMutation) ClearIgnoreKeepAlive() {
	m.ignore_keep_alive = nil
	m.clearedFields[menu.FieldIgnoreKeepAlive] = struct{}{}
}

// IgnoreKeepAliveCleared returns if the "ignore_keep_alive" field was cleared in this mutation.
func (m *MenuMutation) IgnoreKeepAliveCleared() bool {
	_, ok := m.clearedFields[menu.FieldIgnoreKeepAlive]
	return ok
}

// ResetIgnoreKeepAlive resets all changes to the "ignore_keep_alive" field.
func (m *MenuMutation) ResetIgnoreKeepAlive() {
	m.ignore_keep_alive = nil
	delete(m.clearedFields, menu.FieldIgnoreKeepAlive)
}

// SetHideTab sets the "hide_tab" field.
func (m *MenuMutation) SetHideTab(b bool) {
	m.hide_tab = &b
}

// HideTab returns the value of the "hide_tab" field in the mutation.
func (m *MenuMutation) HideTab() (r bool, exists bool) {
	v := m.hide_tab
	if v == nil {
		return
	}
	return *v, true
}

// OldHideTab returns the old "hide_tab" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideTab(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideTab is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideTab requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideTab: %w", err)
	}
	return oldValue.HideTab, nil
}

// ClearHideTab clears the value of the "hide_tab" field.
func (m *MenuMutation) ClearHideTab() {
	m.hide_tab = nil
	m.clearedFields[menu.FieldHideTab] = struct{}{}
}

// HideTabCleared returns if the "hide_tab" field was cleared in this mutation.
func (m *MenuMutation) HideTabCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideTab]
	return ok
}

// ResetHideTab resets all changes to the "hide_tab" field.
func (m *MenuMutation) ResetHideTab() {
	m.hide_tab = nil
	delete(m.clearedFields, menu.FieldHideTab)
}

// SetFrameSrc sets the "frame_src" field.
func (m *MenuMutation) SetFrameSrc(s string) {
	m.frame_src = &s
}

// FrameSrc returns the value of the "frame_src" field in the mutation.
func (m *MenuMutation) FrameSrc() (r string, exists bool) {
	v := m.frame_src
	if v == nil {
		return
	}
	return *v, true
}

// OldFrameSrc returns the old "frame_src" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldFrameSrc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrameSrc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrameSrc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrameSrc: %w", err)
	}
	return oldValue.FrameSrc, nil
}

// ClearFrameSrc clears the value of the "frame_src" field.
func (m *MenuMutation) ClearFrameSrc() {
	m.frame_src = nil
	m.clearedFields[menu.FieldFrameSrc] = struct{}{}
}

// FrameSrcCleared returns if the "frame_src" field was cleared in this mutation.
func (m *MenuMutation) FrameSrcCleared() bool {
	_, ok := m.clearedFields[menu.FieldFrameSrc]
	return ok
}

// ResetFrameSrc resets all changes to the "frame_src" field.
func (m *MenuMutation) ResetFrameSrc() {
	m.frame_src = nil
	delete(m.clearedFields, menu.FieldFrameSrc)
}

// SetCarryParam sets the "carry_param" field.
func (m *MenuMutation) SetCarryParam(b bool) {
	m.carry_param = &b
}

// CarryParam returns the value of the "carry_param" field in the mutation.
func (m *MenuMutation) CarryParam() (r bool, exists bool) {
	v := m.carry_param
	if v == nil {
		return
	}
	return *v, true
}

// OldCarryParam returns the old "carry_param" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCarryParam(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarryParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarryParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarryParam: %w", err)
	}
	return oldValue.CarryParam, nil
}

// ClearCarryParam clears the value of the "carry_param" field.
func (m *MenuMutation) ClearCarryParam() {
	m.carry_param = nil
	m.clearedFields[menu.FieldCarryParam] = struct{}{}
}

// CarryParamCleared returns if the "carry_param" field was cleared in this mutation.
func (m *MenuMutation) CarryParamCleared() bool {
	_, ok := m.clearedFields[menu.FieldCarryParam]
	return ok
}

// ResetCarryParam resets all changes to the "carry_param" field.
func (m *MenuMutation) ResetCarryParam() {
	m.carry_param = nil
	delete(m.clearedFields, menu.FieldCarryParam)
}

// SetHideChildrenInMenu sets the "hide_children_in_menu" field.
func (m *MenuMutation) SetHideChildrenInMenu(b bool) {
	m.hide_children_in_menu = &b
}

// HideChildrenInMenu returns the value of the "hide_children_in_menu" field in the mutation.
func (m *MenuMutation) HideChildrenInMenu() (r bool, exists bool) {
	v := m.hide_children_in_menu
	if v == nil {
		return
	}
	return *v, true
}

// OldHideChildrenInMenu returns the old "hide_children_in_menu" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldHideChildrenInMenu(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideChildrenInMenu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideChildrenInMenu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideChildrenInMenu: %w", err)
	}
	return oldValue.HideChildrenInMenu, nil
}

// ClearHideChildrenInMenu clears the value of the "hide_children_in_menu" field.
func (m *MenuMutation) ClearHideChildrenInMenu() {
	m.hide_children_in_menu = nil
	m.clearedFields[menu.FieldHideChildrenInMenu] = struct{}{}
}

// HideChildrenInMenuCleared returns if the "hide_children_in_menu" field was cleared in this mutation.
func (m *MenuMutation) HideChildrenInMenuCleared() bool {
	_, ok := m.clearedFields[menu.FieldHideChildrenInMenu]
	return ok
}

// ResetHideChildrenInMenu resets all changes to the "hide_children_in_menu" field.
func (m *MenuMutation) ResetHideChildrenInMenu() {
	m.hide_children_in_menu = nil
	delete(m.clearedFields, menu.FieldHideChildrenInMenu)
}

// SetAffix sets the "affix" field.
func (m *MenuMutation) SetAffix(b bool) {
	m.affix = &b
}

// Affix returns the value of the "affix" field in the mutation.
func (m *MenuMutation) Affix() (r bool, exists bool) {
	v := m.affix
	if v == nil {
		return
	}
	return *v, true
}

// OldAffix returns the old "affix" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldAffix(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffix: %w", err)
	}
	return oldValue.Affix, nil
}

// ClearAffix clears the value of the "affix" field.
func (m *MenuMutation) ClearAffix() {
	m.affix = nil
	m.clearedFields[menu.FieldAffix] = struct{}{}
}

// AffixCleared returns if the "affix" field was cleared in this mutation.
func (m *MenuMutation) AffixCleared() bool {
	_, ok := m.clearedFields[menu.FieldAffix]
	return ok
}

// ResetAffix resets all changes to the "affix" field.
func (m *MenuMutation) ResetAffix() {
	m.affix = nil
	delete(m.clearedFields, menu.FieldAffix)
}

// SetDynamicLevel sets the "dynamic_level" field.
func (m *MenuMutation) SetDynamicLevel(i int32) {
	m.dynamic_level = &i
	m.adddynamic_level = nil
}

// DynamicLevel returns the value of the "dynamic_level" field in the mutation.
func (m *MenuMutation) DynamicLevel() (r int32, exists bool) {
	v := m.dynamic_level
	if v == nil {
		return
	}
	return *v, true
}

// OldDynamicLevel returns the old "dynamic_level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDynamicLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDynamicLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDynamicLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDynamicLevel: %w", err)
	}
	return oldValue.DynamicLevel, nil
}

// AddDynamicLevel adds i to the "dynamic_level" field.
func (m *MenuMutation) AddDynamicLevel(i int32) {
	if m.adddynamic_level != nil {
		*m.adddynamic_level += i
	} else {
		m.adddynamic_level = &i
	}
}

// AddedDynamicLevel returns the value that was added to the "dynamic_level" field in this mutation.
func (m *MenuMutation) AddedDynamicLevel() (r int32, exists bool) {
	v := m.adddynamic_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearDynamicLevel clears the value of the "dynamic_level" field.
func (m *MenuMutation) ClearDynamicLevel() {
	m.dynamic_level = nil
	m.adddynamic_level = nil
	m.clearedFields[menu.FieldDynamicLevel] = struct{}{}
}

// DynamicLevelCleared returns if the "dynamic_level" field was cleared in this mutation.
func (m *MenuMutation) DynamicLevelCleared() bool {
	_, ok := m.clearedFields[menu.FieldDynamicLevel]
	return ok
}

// ResetDynamicLevel resets all changes to the "dynamic_level" field.
func (m *MenuMutation) ResetDynamicLevel() {
	m.dynamic_level = nil
	m.adddynamic_level = nil
	delete(m.clearedFields, menu.FieldDynamicLevel)
}

// SetRealPath sets the "real_path" field.
func (m *MenuMutation) SetRealPath(s string) {
	m.real_path = &s
}

// RealPath returns the value of the "real_path" field in the mutation.
func (m *MenuMutation) RealPath() (r string, exists bool) {
	v := m.real_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRealPath returns the old "real_path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRealPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealPath: %w", err)
	}
	return oldValue.RealPath, nil
}

// ClearRealPath clears the value of the "real_path" field.
func (m *MenuMutation) ClearRealPath() {
	m.real_path = nil
	m.clearedFields[menu.FieldRealPath] = struct{}{}
}

// RealPathCleared returns if the "real_path" field was cleared in this mutation.
func (m *MenuMutation) RealPathCleared() bool {
	_, ok := m.clearedFields[menu.FieldRealPath]
	return ok
}

// ResetRealPath resets all changes to the "real_path" field.
func (m *MenuMutation) ResetRealPath() {
	m.real_path = nil
	delete(m.clearedFields, menu.FieldRealPath)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddParamIDs adds the "params" edge to the MenuParam entity by ids.
func (m *MenuMutation) AddParamIDs(ids ...int64) {
	if m.params == nil {
		m.params = make(map[int64]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the MenuParam entity.
func (m *MenuMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the MenuParam entity was cleared.
func (m *MenuMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the MenuParam entity by IDs.
func (m *MenuMutation) RemoveParamIDs(ids ...int64) {
	if m.removedparams == nil {
		m.removedparams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the MenuParam entity.
func (m *MenuMutation) RemovedParamsIDs() (ids []int64) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *MenuMutation) ParamsIDs() (ids []int64) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *MenuMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.menu_level != nil {
		fields = append(fields, menu.FieldMenuLevel)
	}
	if m.menu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.order_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.disabled != nil {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.title != nil {
		fields = append(fields, menu.FieldTitle)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.hide_menu != nil {
		fields = append(fields, menu.FieldHideMenu)
	}
	if m.hide_breadcrumb != nil {
		fields = append(fields, menu.FieldHideBreadcrumb)
	}
	if m.current_active_menu != nil {
		fields = append(fields, menu.FieldCurrentActiveMenu)
	}
	if m.ignore_keep_alive != nil {
		fields = append(fields, menu.FieldIgnoreKeepAlive)
	}
	if m.hide_tab != nil {
		fields = append(fields, menu.FieldHideTab)
	}
	if m.frame_src != nil {
		fields = append(fields, menu.FieldFrameSrc)
	}
	if m.carry_param != nil {
		fields = append(fields, menu.FieldCarryParam)
	}
	if m.hide_children_in_menu != nil {
		fields = append(fields, menu.FieldHideChildrenInMenu)
	}
	if m.affix != nil {
		fields = append(fields, menu.FieldAffix)
	}
	if m.dynamic_level != nil {
		fields = append(fields, menu.FieldDynamicLevel)
	}
	if m.real_path != nil {
		fields = append(fields, menu.FieldRealPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldMenuLevel:
		return m.MenuLevel()
	case menu.FieldMenuType:
		return m.MenuType()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldOrderNo:
		return m.OrderNo()
	case menu.FieldDisabled:
		return m.Disabled()
	case menu.FieldTitle:
		return m.Title()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldHideMenu:
		return m.HideMenu()
	case menu.FieldHideBreadcrumb:
		return m.HideBreadcrumb()
	case menu.FieldCurrentActiveMenu:
		return m.CurrentActiveMenu()
	case menu.FieldIgnoreKeepAlive:
		return m.IgnoreKeepAlive()
	case menu.FieldHideTab:
		return m.HideTab()
	case menu.FieldFrameSrc:
		return m.FrameSrc()
	case menu.FieldCarryParam:
		return m.CarryParam()
	case menu.FieldHideChildrenInMenu:
		return m.HideChildrenInMenu()
	case menu.FieldAffix:
		return m.Affix()
	case menu.FieldDynamicLevel:
		return m.DynamicLevel()
	case menu.FieldRealPath:
		return m.RealPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldMenuLevel:
		return m.OldMenuLevel(ctx)
	case menu.FieldMenuType:
		return m.OldMenuType(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case menu.FieldDisabled:
		return m.OldDisabled(ctx)
	case menu.FieldTitle:
		return m.OldTitle(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldHideMenu:
		return m.OldHideMenu(ctx)
	case menu.FieldHideBreadcrumb:
		return m.OldHideBreadcrumb(ctx)
	case menu.FieldCurrentActiveMenu:
		return m.OldCurrentActiveMenu(ctx)
	case menu.FieldIgnoreKeepAlive:
		return m.OldIgnoreKeepAlive(ctx)
	case menu.FieldHideTab:
		return m.OldHideTab(ctx)
	case menu.FieldFrameSrc:
		return m.OldFrameSrc(ctx)
	case menu.FieldCarryParam:
		return m.OldCarryParam(ctx)
	case menu.FieldHideChildrenInMenu:
		return m.OldHideChildrenInMenu(ctx)
	case menu.FieldAffix:
		return m.OldAffix(ctx)
	case menu.FieldDynamicLevel:
		return m.OldDynamicLevel(ctx)
	case menu.FieldRealPath:
		return m.OldRealPath(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldMenuLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuType(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case menu.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case menu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldHideMenu:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideMenu(v)
		return nil
	case menu.FieldHideBreadcrumb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideBreadcrumb(v)
		return nil
	case menu.FieldCurrentActiveMenu:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentActiveMenu(v)
		return nil
	case menu.FieldIgnoreKeepAlive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreKeepAlive(v)
		return nil
	case menu.FieldHideTab:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideTab(v)
		return nil
	case menu.FieldFrameSrc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrameSrc(v)
		return nil
	case menu.FieldCarryParam:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarryParam(v)
		return nil
	case menu.FieldHideChildrenInMenu:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideChildrenInMenu(v)
		return nil
	case menu.FieldAffix:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffix(v)
		return nil
	case menu.FieldDynamicLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDynamicLevel(v)
		return nil
	case menu.FieldRealPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealPath(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addmenu_level != nil {
		fields = append(fields, menu.FieldMenuLevel)
	}
	if m.addmenu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.addorder_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.adddynamic_level != nil {
		fields = append(fields, menu.FieldDynamicLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldMenuLevel:
		return m.AddedMenuLevel()
	case menu.FieldMenuType:
		return m.AddedMenuType()
	case menu.FieldOrderNo:
		return m.AddedOrderNo()
	case menu.FieldDynamicLevel:
		return m.AddedDynamicLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldMenuLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuLevel(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuType(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	case menu.FieldDynamicLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDynamicLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldDisabled) {
		fields = append(fields, menu.FieldDisabled)
	}
	if m.FieldCleared(menu.FieldHideMenu) {
		fields = append(fields, menu.FieldHideMenu)
	}
	if m.FieldCleared(menu.FieldHideBreadcrumb) {
		fields = append(fields, menu.FieldHideBreadcrumb)
	}
	if m.FieldCleared(menu.FieldCurrentActiveMenu) {
		fields = append(fields, menu.FieldCurrentActiveMenu)
	}
	if m.FieldCleared(menu.FieldIgnoreKeepAlive) {
		fields = append(fields, menu.FieldIgnoreKeepAlive)
	}
	if m.FieldCleared(menu.FieldHideTab) {
		fields = append(fields, menu.FieldHideTab)
	}
	if m.FieldCleared(menu.FieldFrameSrc) {
		fields = append(fields, menu.FieldFrameSrc)
	}
	if m.FieldCleared(menu.FieldCarryParam) {
		fields = append(fields, menu.FieldCarryParam)
	}
	if m.FieldCleared(menu.FieldHideChildrenInMenu) {
		fields = append(fields, menu.FieldHideChildrenInMenu)
	}
	if m.FieldCleared(menu.FieldAffix) {
		fields = append(fields, menu.FieldAffix)
	}
	if m.FieldCleared(menu.FieldDynamicLevel) {
		fields = append(fields, menu.FieldDynamicLevel)
	}
	if m.FieldCleared(menu.FieldRealPath) {
		fields = append(fields, menu.FieldRealPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldDisabled:
		m.ClearDisabled()
		return nil
	case menu.FieldHideMenu:
		m.ClearHideMenu()
		return nil
	case menu.FieldHideBreadcrumb:
		m.ClearHideBreadcrumb()
		return nil
	case menu.FieldCurrentActiveMenu:
		m.ClearCurrentActiveMenu()
		return nil
	case menu.FieldIgnoreKeepAlive:
		m.ClearIgnoreKeepAlive()
		return nil
	case menu.FieldHideTab:
		m.ClearHideTab()
		return nil
	case menu.FieldFrameSrc:
		m.ClearFrameSrc()
		return nil
	case menu.FieldCarryParam:
		m.ClearCarryParam()
		return nil
	case menu.FieldHideChildrenInMenu:
		m.ClearHideChildrenInMenu()
		return nil
	case menu.FieldAffix:
		m.ClearAffix()
		return nil
	case menu.FieldDynamicLevel:
		m.ClearDynamicLevel()
		return nil
	case menu.FieldRealPath:
		m.ClearRealPath()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldMenuLevel:
		m.ResetMenuLevel()
		return nil
	case menu.FieldMenuType:
		m.ResetMenuType()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case menu.FieldDisabled:
		m.ResetDisabled()
		return nil
	case menu.FieldTitle:
		m.ResetTitle()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldHideMenu:
		m.ResetHideMenu()
		return nil
	case menu.FieldHideBreadcrumb:
		m.ResetHideBreadcrumb()
		return nil
	case menu.FieldCurrentActiveMenu:
		m.ResetCurrentActiveMenu()
		return nil
	case menu.FieldIgnoreKeepAlive:
		m.ResetIgnoreKeepAlive()
		return nil
	case menu.FieldHideTab:
		m.ResetHideTab()
		return nil
	case menu.FieldFrameSrc:
		m.ResetFrameSrc()
		return nil
	case menu.FieldCarryParam:
		m.ResetCarryParam()
		return nil
	case menu.FieldHideChildrenInMenu:
		m.ResetHideChildrenInMenu()
		return nil
	case menu.FieldAffix:
		m.ResetAffix()
		return nil
	case menu.FieldDynamicLevel:
		m.ResetDynamicLevel()
		return nil
	case menu.FieldRealPath:
		m.ResetRealPath()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.params != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedparams != nil {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedparams {
		edges = append(edges, menu.EdgeParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeParams:
		return m.clearedparams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuParamMutation represents an operation that mutates the MenuParam nodes in the graph.
type MenuParamMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	key           *string
	value         *string
	clearedFields map[string]struct{}
	menus         *int64
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*MenuParam, error)
	predicates    []predicate.MenuParam
}

var _ ent.Mutation = (*MenuParamMutation)(nil)

// menuparamOption allows management of the mutation configuration using functional options.
type menuparamOption func(*MenuParamMutation)

// newMenuParamMutation creates new mutation for the MenuParam entity.
func newMenuParamMutation(c config, op Op, opts ...menuparamOption) *MenuParamMutation {
	m := &MenuParamMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuParam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuParamID sets the ID field of the mutation.
func withMenuParamID(id int64) menuparamOption {
	return func(m *MenuParamMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuParam
		)
		m.oldValue = func(ctx context.Context) (*MenuParam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuParam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuParam sets the old MenuParam of the mutation.
func withMenuParam(node *MenuParam) menuparamOption {
	return func(m *MenuParamMutation) {
		m.oldValue = func(context.Context) (*MenuParam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuParamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuParamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MenuParam entities.
func (m *MenuParamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuParamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuParamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuParam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuParamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuParamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuParamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuParamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuParamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuParamMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *MenuParamMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuParamMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MenuParamMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *MenuParamMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *MenuParamMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *MenuParamMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *MenuParamMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MenuParamMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the MenuParam entity.
// If the MenuParam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuParamMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MenuParamMutation) ResetValue() {
	m.value = nil
}

// SetMenusID sets the "menus" edge to the Menu entity by id.
func (m *MenuParamMutation) SetMenusID(id int64) {
	m.menus = &id
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *MenuParamMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *MenuParamMutation) MenusCleared() bool {
	return m.clearedmenus
}

// MenusID returns the "menus" edge ID in the mutation.
func (m *MenuParamMutation) MenusID() (id int64, exists bool) {
	if m.menus != nil {
		return *m.menus, true
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenusID instead. It exists only for internal usage by the builders.
func (m *MenuParamMutation) MenusIDs() (ids []int64) {
	if id := m.menus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *MenuParamMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
}

// Where appends a list predicates to the MenuParamMutation builder.
func (m *MenuParamMutation) Where(ps ...predicate.MenuParam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuParamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuParamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuParam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuParamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuParamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuParam).
func (m *MenuParamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuParamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, menuparam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menuparam.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, menuparam.FieldType)
	}
	if m.key != nil {
		fields = append(fields, menuparam.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, menuparam.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuParamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.CreatedAt()
	case menuparam.FieldUpdatedAt:
		return m.UpdatedAt()
	case menuparam.FieldType:
		return m.GetType()
	case menuparam.FieldKey:
		return m.Key()
	case menuparam.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuParamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuparam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menuparam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menuparam.FieldType:
		return m.OldType(ctx)
	case menuparam.FieldKey:
		return m.OldKey(ctx)
	case menuparam.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown MenuParam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuparam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menuparam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menuparam.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menuparam.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case menuparam.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuParamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuParamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuParamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MenuParam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuParamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuParamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuParamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MenuParam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuParamMutation) ResetField(name string) error {
	switch name {
	case menuparam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menuparam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menuparam.FieldType:
		m.ResetType()
		return nil
	case menuparam.FieldKey:
		m.ResetKey()
		return nil
	case menuparam.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown MenuParam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuParamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuParamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuparam.EdgeMenus:
		if id := m.menus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuParamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuParamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuParamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, menuparam.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuParamMutation) EdgeCleared(name string) bool {
	switch name {
	case menuparam.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuParamMutation) ClearEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ClearMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuParamMutation) ResetEdge(name string) error {
	switch name {
	case menuparam.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown MenuParam edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	order_sn      *string
	venue_id      *int64
	addvenue_id   *int64
	user_id       *int64
	adduser_id    *int64
	status        *int64
	addstatus     *int64
	source        *string
	device        *string
	completion_at *time.Time
	create_id     *int64
	addcreate_id  *int64
	clearedFields map[string]struct{}
	amount        map[int64]struct{}
	removedamount map[int64]struct{}
	clearedamount bool
	item          map[int64]struct{}
	removeditem   map[int64]struct{}
	cleareditem   bool
	pay           map[int64]struct{}
	removedpay    map[int64]struct{}
	clearedpay    bool
	sales         map[int64]struct{}
	removedsales  map[int64]struct{}
	clearedsales  bool
	done          bool
	oldValue      func(context.Context) (*Order, error)
	predicates    []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderSn sets the "order_sn" field.
func (m *OrderMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *OrderMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ClearOrderSn clears the value of the "order_sn" field.
func (m *OrderMutation) ClearOrderSn() {
	m.order_sn = nil
	m.clearedFields[order.FieldOrderSn] = struct{}{}
}

// OrderSnCleared returns if the "order_sn" field was cleared in this mutation.
func (m *OrderMutation) OrderSnCleared() bool {
	_, ok := m.clearedFields[order.FieldOrderSn]
	return ok
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *OrderMutation) ResetOrderSn() {
	m.order_sn = nil
	delete(m.clearedFields, order.FieldOrderSn)
}

// SetVenueID sets the "venue_id" field.
func (m *OrderMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *OrderMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *OrderMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *OrderMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *OrderMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[order.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *OrderMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[order.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *OrderMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, order.FieldVenueID)
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrderMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrderMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *OrderMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OrderMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[order.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, order.FieldUserID)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[order.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[order.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, order.FieldStatus)
}

// SetSource sets the "source" field.
func (m *OrderMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *OrderMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *OrderMutation) ClearSource() {
	m.source = nil
	m.clearedFields[order.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *OrderMutation) SourceCleared() bool {
	_, ok := m.clearedFields[order.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *OrderMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, order.FieldSource)
}

// SetDevice sets the "device" field.
func (m *OrderMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *OrderMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *OrderMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[order.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *OrderMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[order.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *OrderMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, order.FieldDevice)
}

// SetCompletionAt sets the "completion_at" field.
func (m *OrderMutation) SetCompletionAt(t time.Time) {
	m.completion_at = &t
}

// CompletionAt returns the value of the "completion_at" field in the mutation.
func (m *OrderMutation) CompletionAt() (r time.Time, exists bool) {
	v := m.completion_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAt returns the old "completion_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCompletionAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAt: %w", err)
	}
	return oldValue.CompletionAt, nil
}

// ClearCompletionAt clears the value of the "completion_at" field.
func (m *OrderMutation) ClearCompletionAt() {
	m.completion_at = nil
	m.clearedFields[order.FieldCompletionAt] = struct{}{}
}

// CompletionAtCleared returns if the "completion_at" field was cleared in this mutation.
func (m *OrderMutation) CompletionAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCompletionAt]
	return ok
}

// ResetCompletionAt resets all changes to the "completion_at" field.
func (m *OrderMutation) ResetCompletionAt() {
	m.completion_at = nil
	delete(m.clearedFields, order.FieldCompletionAt)
}

// SetCreateID sets the "create_id" field.
func (m *OrderMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *OrderMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *OrderMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *OrderMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *OrderMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[order.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *OrderMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[order.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *OrderMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, order.FieldCreateID)
}

// AddAmountIDs adds the "amount" edge to the OrderAmount entity by ids.
func (m *OrderMutation) AddAmountIDs(ids ...int64) {
	if m.amount == nil {
		m.amount = make(map[int64]struct{})
	}
	for i := range ids {
		m.amount[ids[i]] = struct{}{}
	}
}

// ClearAmount clears the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) ClearAmount() {
	m.clearedamount = true
}

// AmountCleared reports if the "amount" edge to the OrderAmount entity was cleared.
func (m *OrderMutation) AmountCleared() bool {
	return m.clearedamount
}

// RemoveAmountIDs removes the "amount" edge to the OrderAmount entity by IDs.
func (m *OrderMutation) RemoveAmountIDs(ids ...int64) {
	if m.removedamount == nil {
		m.removedamount = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.amount, ids[i])
		m.removedamount[ids[i]] = struct{}{}
	}
}

// RemovedAmount returns the removed IDs of the "amount" edge to the OrderAmount entity.
func (m *OrderMutation) RemovedAmountIDs() (ids []int64) {
	for id := range m.removedamount {
		ids = append(ids, id)
	}
	return
}

// AmountIDs returns the "amount" edge IDs in the mutation.
func (m *OrderMutation) AmountIDs() (ids []int64) {
	for id := range m.amount {
		ids = append(ids, id)
	}
	return
}

// ResetAmount resets all changes to the "amount" edge.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.clearedamount = false
	m.removedamount = nil
}

// AddItemIDs adds the "item" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddItemIDs(ids ...int64) {
	if m.item == nil {
		m.item = make(map[int64]struct{})
	}
	for i := range ids {
		m.item[ids[i]] = struct{}{}
	}
}

// ClearItem clears the "item" edge to the OrderItem entity.
func (m *OrderMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the OrderItem entity was cleared.
func (m *OrderMutation) ItemCleared() bool {
	return m.cleareditem
}

// RemoveItemIDs removes the "item" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveItemIDs(ids ...int64) {
	if m.removeditem == nil {
		m.removeditem = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.item, ids[i])
		m.removeditem[ids[i]] = struct{}{}
	}
}

// RemovedItem returns the removed IDs of the "item" edge to the OrderItem entity.
func (m *OrderMutation) RemovedItemIDs() (ids []int64) {
	for id := range m.removeditem {
		ids = append(ids, id)
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
func (m *OrderMutation) ItemIDs() (ids []int64) {
	for id := range m.item {
		ids = append(ids, id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *OrderMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
	m.removeditem = nil
}

// AddPayIDs adds the "pay" edge to the OrderPay entity by ids.
func (m *OrderMutation) AddPayIDs(ids ...int64) {
	if m.pay == nil {
		m.pay = make(map[int64]struct{})
	}
	for i := range ids {
		m.pay[ids[i]] = struct{}{}
	}
}

// ClearPay clears the "pay" edge to the OrderPay entity.
func (m *OrderMutation) ClearPay() {
	m.clearedpay = true
}

// PayCleared reports if the "pay" edge to the OrderPay entity was cleared.
func (m *OrderMutation) PayCleared() bool {
	return m.clearedpay
}

// RemovePayIDs removes the "pay" edge to the OrderPay entity by IDs.
func (m *OrderMutation) RemovePayIDs(ids ...int64) {
	if m.removedpay == nil {
		m.removedpay = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.pay, ids[i])
		m.removedpay[ids[i]] = struct{}{}
	}
}

// RemovedPay returns the removed IDs of the "pay" edge to the OrderPay entity.
func (m *OrderMutation) RemovedPayIDs() (ids []int64) {
	for id := range m.removedpay {
		ids = append(ids, id)
	}
	return
}

// PayIDs returns the "pay" edge IDs in the mutation.
func (m *OrderMutation) PayIDs() (ids []int64) {
	for id := range m.pay {
		ids = append(ids, id)
	}
	return
}

// ResetPay resets all changes to the "pay" edge.
func (m *OrderMutation) ResetPay() {
	m.pay = nil
	m.clearedpay = false
	m.removedpay = nil
}

// AddSaleIDs adds the "sales" edge to the OrderSales entity by ids.
func (m *OrderMutation) AddSaleIDs(ids ...int64) {
	if m.sales == nil {
		m.sales = make(map[int64]struct{})
	}
	for i := range ids {
		m.sales[ids[i]] = struct{}{}
	}
}

// ClearSales clears the "sales" edge to the OrderSales entity.
func (m *OrderMutation) ClearSales() {
	m.clearedsales = true
}

// SalesCleared reports if the "sales" edge to the OrderSales entity was cleared.
func (m *OrderMutation) SalesCleared() bool {
	return m.clearedsales
}

// RemoveSaleIDs removes the "sales" edge to the OrderSales entity by IDs.
func (m *OrderMutation) RemoveSaleIDs(ids ...int64) {
	if m.removedsales == nil {
		m.removedsales = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sales, ids[i])
		m.removedsales[ids[i]] = struct{}{}
	}
}

// RemovedSales returns the removed IDs of the "sales" edge to the OrderSales entity.
func (m *OrderMutation) RemovedSalesIDs() (ids []int64) {
	for id := range m.removedsales {
		ids = append(ids, id)
	}
	return
}

// SalesIDs returns the "sales" edge IDs in the mutation.
func (m *OrderMutation) SalesIDs() (ids []int64) {
	for id := range m.sales {
		ids = append(ids, id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *OrderMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
	m.removedsales = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.order_sn != nil {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.venue_id != nil {
		fields = append(fields, order.FieldVenueID)
	}
	if m.user_id != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, order.FieldSource)
	}
	if m.device != nil {
		fields = append(fields, order.FieldDevice)
	}
	if m.completion_at != nil {
		fields = append(fields, order.FieldCompletionAt)
	}
	if m.create_id != nil {
		fields = append(fields, order.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldOrderSn:
		return m.OrderSn()
	case order.FieldVenueID:
		return m.VenueID()
	case order.FieldUserID:
		return m.UserID()
	case order.FieldStatus:
		return m.Status()
	case order.FieldSource:
		return m.Source()
	case order.FieldDevice:
		return m.Device()
	case order.FieldCompletionAt:
		return m.CompletionAt()
	case order.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case order.FieldVenueID:
		return m.OldVenueID(ctx)
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldSource:
		return m.OldSource(ctx)
	case order.FieldDevice:
		return m.OldDevice(ctx)
	case order.FieldCompletionAt:
		return m.OldCompletionAt(ctx)
	case order.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case order.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case order.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case order.FieldCompletionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAt(v)
		return nil
	case order.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addvenue_id != nil {
		fields = append(fields, order.FieldVenueID)
	}
	if m.adduser_id != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.addcreate_id != nil {
		fields = append(fields, order.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldVenueID:
		return m.AddedVenueID()
	case order.FieldUserID:
		return m.AddedUserID()
	case order.FieldStatus:
		return m.AddedStatus()
	case order.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case order.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldOrderSn) {
		fields = append(fields, order.FieldOrderSn)
	}
	if m.FieldCleared(order.FieldVenueID) {
		fields = append(fields, order.FieldVenueID)
	}
	if m.FieldCleared(order.FieldUserID) {
		fields = append(fields, order.FieldUserID)
	}
	if m.FieldCleared(order.FieldStatus) {
		fields = append(fields, order.FieldStatus)
	}
	if m.FieldCleared(order.FieldSource) {
		fields = append(fields, order.FieldSource)
	}
	if m.FieldCleared(order.FieldDevice) {
		fields = append(fields, order.FieldDevice)
	}
	if m.FieldCleared(order.FieldCompletionAt) {
		fields = append(fields, order.FieldCompletionAt)
	}
	if m.FieldCleared(order.FieldCreateID) {
		fields = append(fields, order.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldOrderSn:
		m.ClearOrderSn()
		return nil
	case order.FieldVenueID:
		m.ClearVenueID()
		return nil
	case order.FieldUserID:
		m.ClearUserID()
		return nil
	case order.FieldStatus:
		m.ClearStatus()
		return nil
	case order.FieldSource:
		m.ClearSource()
		return nil
	case order.FieldDevice:
		m.ClearDevice()
		return nil
	case order.FieldCompletionAt:
		m.ClearCompletionAt()
		return nil
	case order.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case order.FieldVenueID:
		m.ResetVenueID()
		return nil
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldSource:
		m.ResetSource()
		return nil
	case order.FieldDevice:
		m.ResetDevice()
		return nil
	case order.FieldCompletionAt:
		m.ResetCompletionAt()
		return nil
	case order.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.amount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.item != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.pay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.sales != nil {
		edges = append(edges, order.EdgeSales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.amount))
		for id := range m.amount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.item))
		for id := range m.item {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.pay))
		for id := range m.pay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.sales))
		for id := range m.sales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedamount != nil {
		edges = append(edges, order.EdgeAmount)
	}
	if m.removeditem != nil {
		edges = append(edges, order.EdgeItem)
	}
	if m.removedpay != nil {
		edges = append(edges, order.EdgePay)
	}
	if m.removedsales != nil {
		edges = append(edges, order.EdgeSales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeAmount:
		ids := make([]ent.Value, 0, len(m.removedamount))
		for id := range m.removedamount {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeItem:
		ids := make([]ent.Value, 0, len(m.removeditem))
		for id := range m.removeditem {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePay:
		ids := make([]ent.Value, 0, len(m.removedpay))
		for id := range m.removedpay {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSales:
		ids := make([]ent.Value, 0, len(m.removedsales))
		for id := range m.removedsales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedamount {
		edges = append(edges, order.EdgeAmount)
	}
	if m.cleareditem {
		edges = append(edges, order.EdgeItem)
	}
	if m.clearedpay {
		edges = append(edges, order.EdgePay)
	}
	if m.clearedsales {
		edges = append(edges, order.EdgeSales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeAmount:
		return m.clearedamount
	case order.EdgeItem:
		return m.cleareditem
	case order.EdgePay:
		return m.clearedpay
	case order.EdgeSales:
		return m.clearedsales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeAmount:
		m.ResetAmount()
		return nil
	case order.EdgeItem:
		m.ResetItem()
		return nil
	case order.EdgePay:
		m.ResetPay()
		return nil
	case order.EdgeSales:
		m.ResetSales()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderAmountMutation represents an operation that mutates the OrderAmount nodes in the graph.
type OrderAmountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	total         *float64
	addtotal      *float64
	remission     *float64
	addremission  *float64
	pay           *float64
	addpay        *float64
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*OrderAmount, error)
	predicates    []predicate.OrderAmount
}

var _ ent.Mutation = (*OrderAmountMutation)(nil)

// orderamountOption allows management of the mutation configuration using functional options.
type orderamountOption func(*OrderAmountMutation)

// newOrderAmountMutation creates new mutation for the OrderAmount entity.
func newOrderAmountMutation(c config, op Op, opts ...orderamountOption) *OrderAmountMutation {
	m := &OrderAmountMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAmount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAmountID sets the ID field of the mutation.
func withOrderAmountID(id int64) orderamountOption {
	return func(m *OrderAmountMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAmount
		)
		m.oldValue = func(ctx context.Context) (*OrderAmount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAmount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAmount sets the old OrderAmount of the mutation.
func withOrderAmount(node *OrderAmount) orderamountOption {
	return func(m *OrderAmountMutation) {
		m.oldValue = func(context.Context) (*OrderAmount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAmountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAmountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderAmount entities.
func (m *OrderAmountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAmountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderAmountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderAmount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderAmountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderAmountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderAmountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderAmountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderAmountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderAmountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderAmountMutation) SetOrderID(i int64) {
	m.owner = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderAmountMutation) OrderID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderAmountMutation) ClearOrderID() {
	m.owner = nil
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderAmountMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderAmountMutation) ResetOrderID() {
	m.owner = nil
	delete(m.clearedFields, orderamount.FieldOrderID)
}

// SetTotal sets the "total" field.
func (m *OrderAmountMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderAmountMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *OrderAmountMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *OrderAmountMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *OrderAmountMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[orderamount.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *OrderAmountMutation) TotalCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderAmountMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, orderamount.FieldTotal)
}

// SetRemission sets the "remission" field.
func (m *OrderAmountMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderAmountMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderAmountMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderAmountMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderAmountMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderamount.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderAmountMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderAmountMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderamount.FieldRemission)
}

// SetPay sets the "pay" field.
func (m *OrderAmountMutation) SetPay(f float64) {
	m.pay = &f
	m.addpay = nil
}

// Pay returns the value of the "pay" field in the mutation.
func (m *OrderAmountMutation) Pay() (r float64, exists bool) {
	v := m.pay
	if v == nil {
		return
	}
	return *v, true
}

// OldPay returns the old "pay" field's value of the OrderAmount entity.
// If the OrderAmount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAmountMutation) OldPay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPay: %w", err)
	}
	return oldValue.Pay, nil
}

// AddPay adds f to the "pay" field.
func (m *OrderAmountMutation) AddPay(f float64) {
	if m.addpay != nil {
		*m.addpay += f
	} else {
		m.addpay = &f
	}
}

// AddedPay returns the value that was added to the "pay" field in this mutation.
func (m *OrderAmountMutation) AddedPay() (r float64, exists bool) {
	v := m.addpay
	if v == nil {
		return
	}
	return *v, true
}

// ClearPay clears the value of the "pay" field.
func (m *OrderAmountMutation) ClearPay() {
	m.pay = nil
	m.addpay = nil
	m.clearedFields[orderamount.FieldPay] = struct{}{}
}

// PayCleared returns if the "pay" field was cleared in this mutation.
func (m *OrderAmountMutation) PayCleared() bool {
	_, ok := m.clearedFields[orderamount.FieldPay]
	return ok
}

// ResetPay resets all changes to the "pay" field.
func (m *OrderAmountMutation) ResetPay() {
	m.pay = nil
	m.addpay = nil
	delete(m.clearedFields, orderamount.FieldPay)
}

// SetOwnerID sets the "owner" edge to the Order entity by id.
func (m *OrderAmountMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Order entity.
func (m *OrderAmountMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[orderamount.FieldOrderID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Order entity was cleared.
func (m *OrderAmountMutation) OwnerCleared() bool {
	return m.OrderIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *OrderAmountMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrderAmountMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrderAmountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the OrderAmountMutation builder.
func (m *OrderAmountMutation) Where(ps ...predicate.OrderAmount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderAmountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderAmountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderAmount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderAmountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderAmountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderAmount).
func (m *OrderAmountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAmountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, orderamount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderamount.FieldUpdatedAt)
	}
	if m.owner != nil {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.total != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.remission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	if m.pay != nil {
		fields = append(fields, orderamount.FieldPay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAmountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.CreatedAt()
	case orderamount.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderamount.FieldOrderID:
		return m.OrderID()
	case orderamount.FieldTotal:
		return m.Total()
	case orderamount.FieldRemission:
		return m.Remission()
	case orderamount.FieldPay:
		return m.Pay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAmountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderamount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderamount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderamount.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderamount.FieldTotal:
		return m.OldTotal(ctx)
	case orderamount.FieldRemission:
		return m.OldRemission(ctx)
	case orderamount.FieldPay:
		return m.OldPay(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAmount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderamount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderamount.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	case orderamount.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPay(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAmountMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.addremission != nil {
		fields = append(fields, orderamount.FieldRemission)
	}
	if m.addpay != nil {
		fields = append(fields, orderamount.FieldPay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAmountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderamount.FieldTotal:
		return m.AddedTotal()
	case orderamount.FieldRemission:
		return m.AddedRemission()
	case orderamount.FieldPay:
		return m.AddedPay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAmountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderamount.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case orderamount.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	case orderamount.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPay(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAmount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAmountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderamount.FieldOrderID) {
		fields = append(fields, orderamount.FieldOrderID)
	}
	if m.FieldCleared(orderamount.FieldTotal) {
		fields = append(fields, orderamount.FieldTotal)
	}
	if m.FieldCleared(orderamount.FieldRemission) {
		fields = append(fields, orderamount.FieldRemission)
	}
	if m.FieldCleared(orderamount.FieldPay) {
		fields = append(fields, orderamount.FieldPay)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAmountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAmountMutation) ClearField(name string) error {
	switch name {
	case orderamount.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ClearTotal()
		return nil
	case orderamount.FieldRemission:
		m.ClearRemission()
		return nil
	case orderamount.FieldPay:
		m.ClearPay()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAmountMutation) ResetField(name string) error {
	switch name {
	case orderamount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderamount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderamount.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderamount.FieldTotal:
		m.ResetTotal()
		return nil
	case orderamount.FieldRemission:
		m.ResetRemission()
		return nil
	case orderamount.FieldPay:
		m.ResetPay()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAmountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, orderamount.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAmountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderamount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAmountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAmountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAmountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, orderamount.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAmountMutation) EdgeCleared(name string) bool {
	switch name {
	case orderamount.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAmountMutation) ClearEdge(name string) error {
	switch name {
	case orderamount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAmountMutation) ResetEdge(name string) error {
	switch name {
	case orderamount.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderAmount edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	created_at                 *time.Time
	updated_at                 *time.Time
	product_id                 *int64
	addproduct_id              *int64
	quantity                   *int64
	addquantity                *int64
	related_user_product_id    *int64
	addrelated_user_product_id *int64
	contract_id                *int64
	addcontract_id             *int64
	assign_at                  *time.Time
	clearedFields              map[string]struct{}
	owner                      *int64
	clearedowner               bool
	done                       bool
	oldValue                   func(context.Context) (*OrderItem, error)
	predicates                 []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int64) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(i int64) {
	m.owner = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderItemMutation) ClearOrderID() {
	m.owner = nil
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m.owner = nil
	delete(m.clearedFields, orderitem.FieldOrderID)
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, orderitem.FieldProductID)
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(i int64) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r int64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderItemMutation) AddQuantity(i int64) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemMutation) AddedQuantity() (r int64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *OrderItemMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[orderitem.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *OrderItemMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, orderitem.FieldQuantity)
}

// SetRelatedUserProductID sets the "related_user_product_id" field.
func (m *OrderItemMutation) SetRelatedUserProductID(i int64) {
	m.related_user_product_id = &i
	m.addrelated_user_product_id = nil
}

// RelatedUserProductID returns the value of the "related_user_product_id" field in the mutation.
func (m *OrderItemMutation) RelatedUserProductID() (r int64, exists bool) {
	v := m.related_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedUserProductID returns the old "related_user_product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRelatedUserProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedUserProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedUserProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedUserProductID: %w", err)
	}
	return oldValue.RelatedUserProductID, nil
}

// AddRelatedUserProductID adds i to the "related_user_product_id" field.
func (m *OrderItemMutation) AddRelatedUserProductID(i int64) {
	if m.addrelated_user_product_id != nil {
		*m.addrelated_user_product_id += i
	} else {
		m.addrelated_user_product_id = &i
	}
}

// AddedRelatedUserProductID returns the value that was added to the "related_user_product_id" field in this mutation.
func (m *OrderItemMutation) AddedRelatedUserProductID() (r int64, exists bool) {
	v := m.addrelated_user_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelatedUserProductID clears the value of the "related_user_product_id" field.
func (m *OrderItemMutation) ClearRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	m.clearedFields[orderitem.FieldRelatedUserProductID] = struct{}{}
}

// RelatedUserProductIDCleared returns if the "related_user_product_id" field was cleared in this mutation.
func (m *OrderItemMutation) RelatedUserProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldRelatedUserProductID]
	return ok
}

// ResetRelatedUserProductID resets all changes to the "related_user_product_id" field.
func (m *OrderItemMutation) ResetRelatedUserProductID() {
	m.related_user_product_id = nil
	m.addrelated_user_product_id = nil
	delete(m.clearedFields, orderitem.FieldRelatedUserProductID)
}

// SetContractID sets the "contract_id" field.
func (m *OrderItemMutation) SetContractID(i int64) {
	m.contract_id = &i
	m.addcontract_id = nil
}

// ContractID returns the value of the "contract_id" field in the mutation.
func (m *OrderItemMutation) ContractID() (r int64, exists bool) {
	v := m.contract_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContractID returns the old "contract_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractID: %w", err)
	}
	return oldValue.ContractID, nil
}

// AddContractID adds i to the "contract_id" field.
func (m *OrderItemMutation) AddContractID(i int64) {
	if m.addcontract_id != nil {
		*m.addcontract_id += i
	} else {
		m.addcontract_id = &i
	}
}

// AddedContractID returns the value that was added to the "contract_id" field in this mutation.
func (m *OrderItemMutation) AddedContractID() (r int64, exists bool) {
	v := m.addcontract_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContractID clears the value of the "contract_id" field.
func (m *OrderItemMutation) ClearContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	m.clearedFields[orderitem.FieldContractID] = struct{}{}
}

// ContractIDCleared returns if the "contract_id" field was cleared in this mutation.
func (m *OrderItemMutation) ContractIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldContractID]
	return ok
}

// ResetContractID resets all changes to the "contract_id" field.
func (m *OrderItemMutation) ResetContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	delete(m.clearedFields, orderitem.FieldContractID)
}

// SetAssignAt sets the "assign_at" field.
func (m *OrderItemMutation) SetAssignAt(t time.Time) {
	m.assign_at = &t
}

// AssignAt returns the value of the "assign_at" field in the mutation.
func (m *OrderItemMutation) AssignAt() (r time.Time, exists bool) {
	v := m.assign_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignAt returns the old "assign_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldAssignAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignAt: %w", err)
	}
	return oldValue.AssignAt, nil
}

// ClearAssignAt clears the value of the "assign_at" field.
func (m *OrderItemMutation) ClearAssignAt() {
	m.assign_at = nil
	m.clearedFields[orderitem.FieldAssignAt] = struct{}{}
}

// AssignAtCleared returns if the "assign_at" field was cleared in this mutation.
func (m *OrderItemMutation) AssignAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldAssignAt]
	return ok
}

// ResetAssignAt resets all changes to the "assign_at" field.
func (m *OrderItemMutation) ResetAssignAt() {
	m.assign_at = nil
	delete(m.clearedFields, orderitem.FieldAssignAt)
}

// SetOwnerID sets the "owner" edge to the Order entity by id.
func (m *OrderItemMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Order entity.
func (m *OrderItemMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Order entity was cleared.
func (m *OrderItemMutation) OwnerCleared() bool {
	return m.OrderIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *OrderItemMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrderItemMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.owner != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.related_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.contract_id != nil {
		fields = append(fields, orderitem.FieldContractID)
	}
	if m.assign_at != nil {
		fields = append(fields, orderitem.FieldAssignAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldRelatedUserProductID:
		return m.RelatedUserProductID()
	case orderitem.FieldContractID:
		return m.ContractID()
	case orderitem.FieldAssignAt:
		return m.AssignAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldRelatedUserProductID:
		return m.OldRelatedUserProductID(ctx)
	case orderitem.FieldContractID:
		return m.OldContractID(ctx)
	case orderitem.FieldAssignAt:
		return m.OldAssignAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedUserProductID(v)
		return nil
	case orderitem.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractID(v)
		return nil
	case orderitem.FieldAssignAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.addquantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.addrelated_user_product_id != nil {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.addcontract_id != nil {
		fields = append(fields, orderitem.FieldContractID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldProductID:
		return m.AddedProductID()
	case orderitem.FieldQuantity:
		return m.AddedQuantity()
	case orderitem.FieldRelatedUserProductID:
		return m.AddedRelatedUserProductID()
	case orderitem.FieldContractID:
		return m.AddedContractID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderitem.FieldRelatedUserProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedUserProductID(v)
		return nil
	case orderitem.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldOrderID) {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.FieldCleared(orderitem.FieldProductID) {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.FieldCleared(orderitem.FieldQuantity) {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.FieldCleared(orderitem.FieldRelatedUserProductID) {
		fields = append(fields, orderitem.FieldRelatedUserProductID)
	}
	if m.FieldCleared(orderitem.FieldContractID) {
		fields = append(fields, orderitem.FieldContractID)
	}
	if m.FieldCleared(orderitem.FieldAssignAt) {
		fields = append(fields, orderitem.FieldAssignAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ClearProductID()
		return nil
	case orderitem.FieldQuantity:
		m.ClearQuantity()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ClearRelatedUserProductID()
		return nil
	case orderitem.FieldContractID:
		m.ClearContractID()
		return nil
	case orderitem.FieldAssignAt:
		m.ClearAssignAt()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldRelatedUserProductID:
		m.ResetRelatedUserProductID()
		return nil
	case orderitem.FieldContractID:
		m.ResetContractID()
		return nil
	case orderitem.FieldAssignAt:
		m.ResetAssignAt()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, orderitem.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, orderitem.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderPayMutation represents an operation that mutates the OrderPay nodes in the graph.
type OrderPayMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	pay_sn        *string
	remission     *float64
	addremission  *float64
	pay           *float64
	addpay        *float64
	create_id     *int64
	addcreate_id  *int64
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*OrderPay, error)
	predicates    []predicate.OrderPay
}

var _ ent.Mutation = (*OrderPayMutation)(nil)

// orderpayOption allows management of the mutation configuration using functional options.
type orderpayOption func(*OrderPayMutation)

// newOrderPayMutation creates new mutation for the OrderPay entity.
func newOrderPayMutation(c config, op Op, opts ...orderpayOption) *OrderPayMutation {
	m := &OrderPayMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPayID sets the ID field of the mutation.
func withOrderPayID(id int64) orderpayOption {
	return func(m *OrderPayMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPay
		)
		m.oldValue = func(ctx context.Context) (*OrderPay, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPay sets the old OrderPay of the mutation.
func withOrderPay(node *OrderPay) orderpayOption {
	return func(m *OrderPayMutation) {
		m.oldValue = func(context.Context) (*OrderPay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderPay entities.
func (m *OrderPayMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPayMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderPayMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderPay.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderPayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderPayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderPayMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderPayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderPayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderPayMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderPayMutation) SetOrderID(i int64) {
	m.owner = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderPayMutation) OrderID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderPayMutation) ClearOrderID() {
	m.owner = nil
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderPayMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderPayMutation) ResetOrderID() {
	m.owner = nil
	delete(m.clearedFields, orderpay.FieldOrderID)
}

// SetPaySn sets the "pay_sn" field.
func (m *OrderPayMutation) SetPaySn(s string) {
	m.pay_sn = &s
}

// PaySn returns the value of the "pay_sn" field in the mutation.
func (m *OrderPayMutation) PaySn() (r string, exists bool) {
	v := m.pay_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldPaySn returns the old "pay_sn" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPaySn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaySn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaySn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaySn: %w", err)
	}
	return oldValue.PaySn, nil
}

// ClearPaySn clears the value of the "pay_sn" field.
func (m *OrderPayMutation) ClearPaySn() {
	m.pay_sn = nil
	m.clearedFields[orderpay.FieldPaySn] = struct{}{}
}

// PaySnCleared returns if the "pay_sn" field was cleared in this mutation.
func (m *OrderPayMutation) PaySnCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPaySn]
	return ok
}

// ResetPaySn resets all changes to the "pay_sn" field.
func (m *OrderPayMutation) ResetPaySn() {
	m.pay_sn = nil
	delete(m.clearedFields, orderpay.FieldPaySn)
}

// SetRemission sets the "remission" field.
func (m *OrderPayMutation) SetRemission(f float64) {
	m.remission = &f
	m.addremission = nil
}

// Remission returns the value of the "remission" field in the mutation.
func (m *OrderPayMutation) Remission() (r float64, exists bool) {
	v := m.remission
	if v == nil {
		return
	}
	return *v, true
}

// OldRemission returns the old "remission" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldRemission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemission: %w", err)
	}
	return oldValue.Remission, nil
}

// AddRemission adds f to the "remission" field.
func (m *OrderPayMutation) AddRemission(f float64) {
	if m.addremission != nil {
		*m.addremission += f
	} else {
		m.addremission = &f
	}
}

// AddedRemission returns the value that was added to the "remission" field in this mutation.
func (m *OrderPayMutation) AddedRemission() (r float64, exists bool) {
	v := m.addremission
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemission clears the value of the "remission" field.
func (m *OrderPayMutation) ClearRemission() {
	m.remission = nil
	m.addremission = nil
	m.clearedFields[orderpay.FieldRemission] = struct{}{}
}

// RemissionCleared returns if the "remission" field was cleared in this mutation.
func (m *OrderPayMutation) RemissionCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldRemission]
	return ok
}

// ResetRemission resets all changes to the "remission" field.
func (m *OrderPayMutation) ResetRemission() {
	m.remission = nil
	m.addremission = nil
	delete(m.clearedFields, orderpay.FieldRemission)
}

// SetPay sets the "pay" field.
func (m *OrderPayMutation) SetPay(f float64) {
	m.pay = &f
	m.addpay = nil
}

// Pay returns the value of the "pay" field in the mutation.
func (m *OrderPayMutation) Pay() (r float64, exists bool) {
	v := m.pay
	if v == nil {
		return
	}
	return *v, true
}

// OldPay returns the old "pay" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldPay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPay: %w", err)
	}
	return oldValue.Pay, nil
}

// AddPay adds f to the "pay" field.
func (m *OrderPayMutation) AddPay(f float64) {
	if m.addpay != nil {
		*m.addpay += f
	} else {
		m.addpay = &f
	}
}

// AddedPay returns the value that was added to the "pay" field in this mutation.
func (m *OrderPayMutation) AddedPay() (r float64, exists bool) {
	v := m.addpay
	if v == nil {
		return
	}
	return *v, true
}

// ClearPay clears the value of the "pay" field.
func (m *OrderPayMutation) ClearPay() {
	m.pay = nil
	m.addpay = nil
	m.clearedFields[orderpay.FieldPay] = struct{}{}
}

// PayCleared returns if the "pay" field was cleared in this mutation.
func (m *OrderPayMutation) PayCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldPay]
	return ok
}

// ResetPay resets all changes to the "pay" field.
func (m *OrderPayMutation) ResetPay() {
	m.pay = nil
	m.addpay = nil
	delete(m.clearedFields, orderpay.FieldPay)
}

// SetCreateID sets the "create_id" field.
func (m *OrderPayMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *OrderPayMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the OrderPay entity.
// If the OrderPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPayMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *OrderPayMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *OrderPayMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *OrderPayMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[orderpay.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *OrderPayMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[orderpay.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *OrderPayMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, orderpay.FieldCreateID)
}

// SetOwnerID sets the "owner" edge to the Order entity by id.
func (m *OrderPayMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Order entity.
func (m *OrderPayMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[orderpay.FieldOrderID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Order entity was cleared.
func (m *OrderPayMutation) OwnerCleared() bool {
	return m.OrderIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *OrderPayMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrderPayMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrderPayMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the OrderPayMutation builder.
func (m *OrderPayMutation) Where(ps ...predicate.OrderPay) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderPayMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderPayMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderPay, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderPayMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderPayMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderPay).
func (m *OrderPayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPayMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, orderpay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderpay.FieldUpdatedAt)
	}
	if m.owner != nil {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.pay_sn != nil {
		fields = append(fields, orderpay.FieldPaySn)
	}
	if m.remission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.pay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.create_id != nil {
		fields = append(fields, orderpay.FieldCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.CreatedAt()
	case orderpay.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderpay.FieldOrderID:
		return m.OrderID()
	case orderpay.FieldPaySn:
		return m.PaySn()
	case orderpay.FieldRemission:
		return m.Remission()
	case orderpay.FieldPay:
		return m.Pay()
	case orderpay.FieldCreateID:
		return m.CreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderpay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderpay.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderpay.FieldPaySn:
		return m.OldPaySn(ctx)
	case orderpay.FieldRemission:
		return m.OldRemission(ctx)
	case orderpay.FieldPay:
		return m.OldPay(ctx)
	case orderpay.FieldCreateID:
		return m.OldCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderpay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderpay.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderpay.FieldPaySn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaySn(v)
		return nil
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPay(v)
		return nil
	case orderpay.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPayMutation) AddedFields() []string {
	var fields []string
	if m.addremission != nil {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.addpay != nil {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.addcreate_id != nil {
		fields = append(fields, orderpay.FieldCreateID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpay.FieldRemission:
		return m.AddedRemission()
	case orderpay.FieldPay:
		return m.AddedPay()
	case orderpay.FieldCreateID:
		return m.AddedCreateID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpay.FieldRemission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemission(v)
		return nil
	case orderpay.FieldPay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPay(v)
		return nil
	case orderpay.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpay.FieldOrderID) {
		fields = append(fields, orderpay.FieldOrderID)
	}
	if m.FieldCleared(orderpay.FieldPaySn) {
		fields = append(fields, orderpay.FieldPaySn)
	}
	if m.FieldCleared(orderpay.FieldRemission) {
		fields = append(fields, orderpay.FieldRemission)
	}
	if m.FieldCleared(orderpay.FieldPay) {
		fields = append(fields, orderpay.FieldPay)
	}
	if m.FieldCleared(orderpay.FieldCreateID) {
		fields = append(fields, orderpay.FieldCreateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPayMutation) ClearField(name string) error {
	switch name {
	case orderpay.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderpay.FieldPaySn:
		m.ClearPaySn()
		return nil
	case orderpay.FieldRemission:
		m.ClearRemission()
		return nil
	case orderpay.FieldPay:
		m.ClearPay()
		return nil
	case orderpay.FieldCreateID:
		m.ClearCreateID()
		return nil
	}
	return fmt.Errorf("unknown OrderPay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPayMutation) ResetField(name string) error {
	switch name {
	case orderpay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderpay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderpay.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderpay.FieldPaySn:
		m.ResetPaySn()
		return nil
	case orderpay.FieldRemission:
		m.ResetRemission()
		return nil
	case orderpay.FieldPay:
		m.ResetPay()
		return nil
	case orderpay.FieldCreateID:
		m.ResetCreateID()
		return nil
	}
	return fmt.Errorf("unknown OrderPay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, orderpay.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderpay.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, orderpay.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPayMutation) EdgeCleared(name string) bool {
	switch name {
	case orderpay.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPayMutation) ClearEdge(name string) error {
	switch name {
	case orderpay.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderPay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPayMutation) ResetEdge(name string) error {
	switch name {
	case orderpay.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderPay edge %s", name)
}

// OrderSalesMutation represents an operation that mutates the OrderSales nodes in the graph.
type OrderSalesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	sales_id      *int64
	addsales_id   *int64
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*OrderSales, error)
	predicates    []predicate.OrderSales
}

var _ ent.Mutation = (*OrderSalesMutation)(nil)

// ordersalesOption allows management of the mutation configuration using functional options.
type ordersalesOption func(*OrderSalesMutation)

// newOrderSalesMutation creates new mutation for the OrderSales entity.
func newOrderSalesMutation(c config, op Op, opts ...ordersalesOption) *OrderSalesMutation {
	m := &OrderSalesMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSales,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSalesID sets the ID field of the mutation.
func withOrderSalesID(id int64) ordersalesOption {
	return func(m *OrderSalesMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSales
		)
		m.oldValue = func(ctx context.Context) (*OrderSales, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSales.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSales sets the old OrderSales of the mutation.
func withOrderSales(node *OrderSales) ordersalesOption {
	return func(m *OrderSalesMutation) {
		m.oldValue = func(context.Context) (*OrderSales, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSalesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSalesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderSales entities.
func (m *OrderSalesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSalesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderSalesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderSales.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderSalesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderSalesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderSalesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderSalesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderSalesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderSalesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderSalesMutation) SetOrderID(i int64) {
	m.owner = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderSalesMutation) OrderID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderSalesMutation) ClearOrderID() {
	m.owner = nil
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderSalesMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderSalesMutation) ResetOrderID() {
	m.owner = nil
	delete(m.clearedFields, ordersales.FieldOrderID)
}

// SetSalesID sets the "sales_id" field.
func (m *OrderSalesMutation) SetSalesID(i int64) {
	m.sales_id = &i
	m.addsales_id = nil
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *OrderSalesMutation) SalesID() (r int64, exists bool) {
	v := m.sales_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the OrderSales entity.
// If the OrderSales object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSalesMutation) OldSalesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// AddSalesID adds i to the "sales_id" field.
func (m *OrderSalesMutation) AddSalesID(i int64) {
	if m.addsales_id != nil {
		*m.addsales_id += i
	} else {
		m.addsales_id = &i
	}
}

// AddedSalesID returns the value that was added to the "sales_id" field in this mutation.
func (m *OrderSalesMutation) AddedSalesID() (r int64, exists bool) {
	v := m.addsales_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *OrderSalesMutation) ClearSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	m.clearedFields[ordersales.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *OrderSalesMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[ordersales.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *OrderSalesMutation) ResetSalesID() {
	m.sales_id = nil
	m.addsales_id = nil
	delete(m.clearedFields, ordersales.FieldSalesID)
}

// SetOwnerID sets the "owner" edge to the Order entity by id.
func (m *OrderSalesMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Order entity.
func (m *OrderSalesMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[ordersales.FieldOrderID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Order entity was cleared.
func (m *OrderSalesMutation) OwnerCleared() bool {
	return m.OrderIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *OrderSalesMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrderSalesMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrderSalesMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the OrderSalesMutation builder.
func (m *OrderSalesMutation) Where(ps ...predicate.OrderSales) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderSalesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderSalesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderSales, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderSalesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderSalesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderSales).
func (m *OrderSalesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSalesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, ordersales.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordersales.FieldUpdatedAt)
	}
	if m.owner != nil {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.sales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSalesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.CreatedAt()
	case ordersales.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordersales.FieldOrderID:
		return m.OrderID()
	case ordersales.FieldSalesID:
		return m.SalesID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSalesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersales.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordersales.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordersales.FieldOrderID:
		return m.OldOrderID(ctx)
	case ordersales.FieldSalesID:
		return m.OldSalesID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSales field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordersales.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordersales.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSalesMutation) AddedFields() []string {
	var fields []string
	if m.addsales_id != nil {
		fields = append(fields, ordersales.FieldSalesID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSalesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordersales.FieldSalesID:
		return m.AddedSalesID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSalesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordersales.FieldSalesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSales numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSalesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersales.FieldOrderID) {
		fields = append(fields, ordersales.FieldOrderID)
	}
	if m.FieldCleared(ordersales.FieldSalesID) {
		fields = append(fields, ordersales.FieldSalesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSalesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSalesMutation) ClearField(name string) error {
	switch name {
	case ordersales.FieldOrderID:
		m.ClearOrderID()
		return nil
	case ordersales.FieldSalesID:
		m.ClearSalesID()
		return nil
	}
	return fmt.Errorf("unknown OrderSales nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSalesMutation) ResetField(name string) error {
	switch name {
	case ordersales.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordersales.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordersales.FieldOrderID:
		m.ResetOrderID()
		return nil
	case ordersales.FieldSalesID:
		m.ResetSalesID()
		return nil
	}
	return fmt.Errorf("unknown OrderSales field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSalesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, ordersales.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSalesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersales.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSalesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSalesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSalesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, ordersales.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSalesMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersales.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSalesMutation) ClearEdge(name string) error {
	switch name {
	case ordersales.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderSales unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSalesMutation) ResetEdge(name string) error {
	switch name {
	case ordersales.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown OrderSales edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	sn               *string
	venue_id         *int64
	addvenue_id      *int64
	create_id        *int64
	addcreate_id     *int64
	name             *string
	pic              *int64
	addpic           *int64
	description      *string
	price            *string
	stock            *int64
	addstock         *int64
	status           *int64
	addstatus        *int64
	clearedFields    map[string]struct{}
	propertys        map[int64]struct{}
	removedpropertys map[int64]struct{}
	clearedpropertys bool
	done             bool
	oldValue         func(context.Context) (*Product, error)
	predicates       []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int64) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSn sets the "sn" field.
func (m *ProductMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *ProductMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *ProductMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[product.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *ProductMutation) SnCleared() bool {
	_, ok := m.clearedFields[product.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *ProductMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, product.FieldSn)
}

// SetVenueID sets the "venue_id" field.
func (m *ProductMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *ProductMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *ProductMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *ProductMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *ProductMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[product.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *ProductMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[product.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *ProductMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, product.FieldVenueID)
}

// SetCreateID sets the "create_id" field.
func (m *ProductMutation) SetCreateID(i int64) {
	m.create_id = &i
	m.addcreate_id = nil
}

// CreateID returns the value of the "create_id" field in the mutation.
func (m *ProductMutation) CreateID() (r int64, exists bool) {
	v := m.create_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateID returns the old "create_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateID: %w", err)
	}
	return oldValue.CreateID, nil
}

// AddCreateID adds i to the "create_id" field.
func (m *ProductMutation) AddCreateID(i int64) {
	if m.addcreate_id != nil {
		*m.addcreate_id += i
	} else {
		m.addcreate_id = &i
	}
}

// AddedCreateID returns the value that was added to the "create_id" field in this mutation.
func (m *ProductMutation) AddedCreateID() (r int64, exists bool) {
	v := m.addcreate_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateID clears the value of the "create_id" field.
func (m *ProductMutation) ClearCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	m.clearedFields[product.FieldCreateID] = struct{}{}
}

// CreateIDCleared returns if the "create_id" field was cleared in this mutation.
func (m *ProductMutation) CreateIDCleared() bool {
	_, ok := m.clearedFields[product.FieldCreateID]
	return ok
}

// ResetCreateID resets all changes to the "create_id" field.
func (m *ProductMutation) ResetCreateID() {
	m.create_id = nil
	m.addcreate_id = nil
	delete(m.clearedFields, product.FieldCreateID)
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[product.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[product.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, product.FieldName)
}

// SetPic sets the "pic" field.
func (m *ProductMutation) SetPic(i int64) {
	m.pic = &i
	m.addpic = nil
}

// Pic returns the value of the "pic" field in the mutation.
func (m *ProductMutation) Pic() (r int64, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPic(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// AddPic adds i to the "pic" field.
func (m *ProductMutation) AddPic(i int64) {
	if m.addpic != nil {
		*m.addpic += i
	} else {
		m.addpic = &i
	}
}

// AddedPic returns the value that was added to the "pic" field in this mutation.
func (m *ProductMutation) AddedPic() (r int64, exists bool) {
	v := m.addpic
	if v == nil {
		return
	}
	return *v, true
}

// ClearPic clears the value of the "pic" field.
func (m *ProductMutation) ClearPic() {
	m.pic = nil
	m.addpic = nil
	m.clearedFields[product.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *ProductMutation) PicCleared() bool {
	_, ok := m.clearedFields[product.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *ProductMutation) ResetPic() {
	m.pic = nil
	m.addpic = nil
	delete(m.clearedFields, product.FieldPic)
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *ProductMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[product.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[product.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, product.FieldPrice)
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(i int64) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r int64, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductMutation) AddStock(i int64) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r int64, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ClearStock clears the value of the "stock" field.
func (m *ProductMutation) ClearStock() {
	m.stock = nil
	m.addstock = nil
	m.clearedFields[product.FieldStock] = struct{}{}
}

// StockCleared returns if the "stock" field was cleared in this mutation.
func (m *ProductMutation) StockCleared() bool {
	_, ok := m.clearedFields[product.FieldStock]
	return ok
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
	delete(m.clearedFields, product.FieldStock)
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ProductMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[product.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProductMutation) StatusCleared() bool {
	_, ok := m.clearedFields[product.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, product.FieldStatus)
}

// AddPropertyIDs adds the "propertys" edge to the ProductProperty entity by ids.
func (m *ProductMutation) AddPropertyIDs(ids ...int64) {
	if m.propertys == nil {
		m.propertys = make(map[int64]struct{})
	}
	for i := range ids {
		m.propertys[ids[i]] = struct{}{}
	}
}

// ClearPropertys clears the "propertys" edge to the ProductProperty entity.
func (m *ProductMutation) ClearPropertys() {
	m.clearedpropertys = true
}

// PropertysCleared reports if the "propertys" edge to the ProductProperty entity was cleared.
func (m *ProductMutation) PropertysCleared() bool {
	return m.clearedpropertys
}

// RemovePropertyIDs removes the "propertys" edge to the ProductProperty entity by IDs.
func (m *ProductMutation) RemovePropertyIDs(ids ...int64) {
	if m.removedpropertys == nil {
		m.removedpropertys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.propertys, ids[i])
		m.removedpropertys[ids[i]] = struct{}{}
	}
}

// RemovedPropertys returns the removed IDs of the "propertys" edge to the ProductProperty entity.
func (m *ProductMutation) RemovedPropertysIDs() (ids []int64) {
	for id := range m.removedpropertys {
		ids = append(ids, id)
	}
	return
}

// PropertysIDs returns the "propertys" edge IDs in the mutation.
func (m *ProductMutation) PropertysIDs() (ids []int64) {
	for id := range m.propertys {
		ids = append(ids, id)
	}
	return
}

// ResetPropertys resets all changes to the "propertys" edge.
func (m *ProductMutation) ResetPropertys() {
	m.propertys = nil
	m.clearedpropertys = false
	m.removedpropertys = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.sn != nil {
		fields = append(fields, product.FieldSn)
	}
	if m.venue_id != nil {
		fields = append(fields, product.FieldVenueID)
	}
	if m.create_id != nil {
		fields = append(fields, product.FieldCreateID)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, product.FieldPic)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldSn:
		return m.Sn()
	case product.FieldVenueID:
		return m.VenueID()
	case product.FieldCreateID:
		return m.CreateID()
	case product.FieldName:
		return m.Name()
	case product.FieldPic:
		return m.Pic()
	case product.FieldDescription:
		return m.Description()
	case product.FieldPrice:
		return m.Price()
	case product.FieldStock:
		return m.Stock()
	case product.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldSn:
		return m.OldSn(ctx)
	case product.FieldVenueID:
		return m.OldVenueID(ctx)
	case product.FieldCreateID:
		return m.OldCreateID(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldPic:
		return m.OldPic(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case product.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case product.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateID(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldPic:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addvenue_id != nil {
		fields = append(fields, product.FieldVenueID)
	}
	if m.addcreate_id != nil {
		fields = append(fields, product.FieldCreateID)
	}
	if m.addpic != nil {
		fields = append(fields, product.FieldPic)
	}
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.addstatus != nil {
		fields = append(fields, product.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldVenueID:
		return m.AddedVenueID()
	case product.FieldCreateID:
		return m.AddedCreateID()
	case product.FieldPic:
		return m.AddedPic()
	case product.FieldStock:
		return m.AddedStock()
	case product.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case product.FieldCreateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateID(v)
		return nil
	case product.FieldPic:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPic(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldSn) {
		fields = append(fields, product.FieldSn)
	}
	if m.FieldCleared(product.FieldVenueID) {
		fields = append(fields, product.FieldVenueID)
	}
	if m.FieldCleared(product.FieldCreateID) {
		fields = append(fields, product.FieldCreateID)
	}
	if m.FieldCleared(product.FieldName) {
		fields = append(fields, product.FieldName)
	}
	if m.FieldCleared(product.FieldPic) {
		fields = append(fields, product.FieldPic)
	}
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldPrice) {
		fields = append(fields, product.FieldPrice)
	}
	if m.FieldCleared(product.FieldStock) {
		fields = append(fields, product.FieldStock)
	}
	if m.FieldCleared(product.FieldStatus) {
		fields = append(fields, product.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldSn:
		m.ClearSn()
		return nil
	case product.FieldVenueID:
		m.ClearVenueID()
		return nil
	case product.FieldCreateID:
		m.ClearCreateID()
		return nil
	case product.FieldName:
		m.ClearName()
		return nil
	case product.FieldPic:
		m.ClearPic()
		return nil
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldPrice:
		m.ClearPrice()
		return nil
	case product.FieldStock:
		m.ClearStock()
		return nil
	case product.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldSn:
		m.ResetSn()
		return nil
	case product.FieldVenueID:
		m.ResetVenueID()
		return nil
	case product.FieldCreateID:
		m.ResetCreateID()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldPic:
		m.ResetPic()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.propertys != nil {
		edges = append(edges, product.EdgePropertys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePropertys:
		ids := make([]ent.Value, 0, len(m.propertys))
		for id := range m.propertys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpropertys != nil {
		edges = append(edges, product.EdgePropertys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePropertys:
		ids := make([]ent.Value, 0, len(m.removedpropertys))
		for id := range m.removedpropertys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpropertys {
		edges = append(edges, product.EdgePropertys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgePropertys:
		return m.clearedpropertys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgePropertys:
		m.ResetPropertys()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductPropertyMutation represents an operation that mutates the ProductProperty nodes in the graph.
type ProductPropertyMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	_type          *string
	spu_name       *string
	duration       *int64
	addduration    *int64
	length         *int64
	addlength      *int64
	count          *int64
	addcount       *int64
	spu_price      *float64
	addspu_price   *float64
	clearedFields  map[string]struct{}
	product        map[int64]struct{}
	removedproduct map[int64]struct{}
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*ProductProperty, error)
	predicates     []predicate.ProductProperty
}

var _ ent.Mutation = (*ProductPropertyMutation)(nil)

// productpropertyOption allows management of the mutation configuration using functional options.
type productpropertyOption func(*ProductPropertyMutation)

// newProductPropertyMutation creates new mutation for the ProductProperty entity.
func newProductPropertyMutation(c config, op Op, opts ...productpropertyOption) *ProductPropertyMutation {
	m := &ProductPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProductProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPropertyID sets the ID field of the mutation.
func withProductPropertyID(id int64) productpropertyOption {
	return func(m *ProductPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductProperty
		)
		m.oldValue = func(ctx context.Context) (*ProductProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductProperty sets the old ProductProperty of the mutation.
func withProductProperty(node *ProductProperty) productpropertyOption {
	return func(m *ProductPropertyMutation) {
		m.oldValue = func(context.Context) (*ProductProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductProperty entities.
func (m *ProductPropertyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPropertyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductPropertyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductPropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductPropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductPropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductPropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductPropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductPropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ProductPropertyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductPropertyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ProductPropertyMutation) ClearType() {
	m._type = nil
	m.clearedFields[productproperty.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ProductPropertyMutation) TypeCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ProductPropertyMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, productproperty.FieldType)
}

// SetSpuName sets the "spu_name" field.
func (m *ProductPropertyMutation) SetSpuName(s string) {
	m.spu_name = &s
}

// SpuName returns the value of the "spu_name" field in the mutation.
func (m *ProductPropertyMutation) SpuName() (r string, exists bool) {
	v := m.spu_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuName returns the old "spu_name" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldSpuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuName: %w", err)
	}
	return oldValue.SpuName, nil
}

// ClearSpuName clears the value of the "spu_name" field.
func (m *ProductPropertyMutation) ClearSpuName() {
	m.spu_name = nil
	m.clearedFields[productproperty.FieldSpuName] = struct{}{}
}

// SpuNameCleared returns if the "spu_name" field was cleared in this mutation.
func (m *ProductPropertyMutation) SpuNameCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldSpuName]
	return ok
}

// ResetSpuName resets all changes to the "spu_name" field.
func (m *ProductPropertyMutation) ResetSpuName() {
	m.spu_name = nil
	delete(m.clearedFields, productproperty.FieldSpuName)
}

// SetDuration sets the "duration" field.
func (m *ProductPropertyMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProductPropertyMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ProductPropertyMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ProductPropertyMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ProductPropertyMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[productproperty.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ProductPropertyMutation) DurationCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProductPropertyMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, productproperty.FieldDuration)
}

// SetLength sets the "length" field.
func (m *ProductPropertyMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ProductPropertyMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *ProductPropertyMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ProductPropertyMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *ProductPropertyMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[productproperty.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *ProductPropertyMutation) LengthCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *ProductPropertyMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, productproperty.FieldLength)
}

// SetCount sets the "count" field.
func (m *ProductPropertyMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *ProductPropertyMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *ProductPropertyMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *ProductPropertyMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *ProductPropertyMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[productproperty.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *ProductPropertyMutation) CountCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *ProductPropertyMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, productproperty.FieldCount)
}

// SetSpuPrice sets the "spu_price" field.
func (m *ProductPropertyMutation) SetSpuPrice(f float64) {
	m.spu_price = &f
	m.addspu_price = nil
}

// SpuPrice returns the value of the "spu_price" field in the mutation.
func (m *ProductPropertyMutation) SpuPrice() (r float64, exists bool) {
	v := m.spu_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuPrice returns the old "spu_price" field's value of the ProductProperty entity.
// If the ProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPropertyMutation) OldSpuPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpuPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpuPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuPrice: %w", err)
	}
	return oldValue.SpuPrice, nil
}

// AddSpuPrice adds f to the "spu_price" field.
func (m *ProductPropertyMutation) AddSpuPrice(f float64) {
	if m.addspu_price != nil {
		*m.addspu_price += f
	} else {
		m.addspu_price = &f
	}
}

// AddedSpuPrice returns the value that was added to the "spu_price" field in this mutation.
func (m *ProductPropertyMutation) AddedSpuPrice() (r float64, exists bool) {
	v := m.addspu_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpuPrice clears the value of the "spu_price" field.
func (m *ProductPropertyMutation) ClearSpuPrice() {
	m.spu_price = nil
	m.addspu_price = nil
	m.clearedFields[productproperty.FieldSpuPrice] = struct{}{}
}

// SpuPriceCleared returns if the "spu_price" field was cleared in this mutation.
func (m *ProductPropertyMutation) SpuPriceCleared() bool {
	_, ok := m.clearedFields[productproperty.FieldSpuPrice]
	return ok
}

// ResetSpuPrice resets all changes to the "spu_price" field.
func (m *ProductPropertyMutation) ResetSpuPrice() {
	m.spu_price = nil
	m.addspu_price = nil
	delete(m.clearedFields, productproperty.FieldSpuPrice)
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *ProductPropertyMutation) AddProductIDs(ids ...int64) {
	if m.product == nil {
		m.product = make(map[int64]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductPropertyMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductPropertyMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *ProductPropertyMutation) RemoveProductIDs(ids ...int64) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *ProductPropertyMutation) RemovedProductIDs() (ids []int64) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *ProductPropertyMutation) ProductIDs() (ids []int64) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductPropertyMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// Where appends a list predicates to the ProductPropertyMutation builder.
func (m *ProductPropertyMutation) Where(ps ...predicate.ProductProperty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductPropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductPropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductProperty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductPropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductPropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductProperty).
func (m *ProductPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPropertyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, productproperty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productproperty.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, productproperty.FieldType)
	}
	if m.spu_name != nil {
		fields = append(fields, productproperty.FieldSpuName)
	}
	if m.duration != nil {
		fields = append(fields, productproperty.FieldDuration)
	}
	if m.length != nil {
		fields = append(fields, productproperty.FieldLength)
	}
	if m.count != nil {
		fields = append(fields, productproperty.FieldCount)
	}
	if m.spu_price != nil {
		fields = append(fields, productproperty.FieldSpuPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productproperty.FieldCreatedAt:
		return m.CreatedAt()
	case productproperty.FieldUpdatedAt:
		return m.UpdatedAt()
	case productproperty.FieldType:
		return m.GetType()
	case productproperty.FieldSpuName:
		return m.SpuName()
	case productproperty.FieldDuration:
		return m.Duration()
	case productproperty.FieldLength:
		return m.Length()
	case productproperty.FieldCount:
		return m.Count()
	case productproperty.FieldSpuPrice:
		return m.SpuPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productproperty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productproperty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productproperty.FieldType:
		return m.OldType(ctx)
	case productproperty.FieldSpuName:
		return m.OldSpuName(ctx)
	case productproperty.FieldDuration:
		return m.OldDuration(ctx)
	case productproperty.FieldLength:
		return m.OldLength(ctx)
	case productproperty.FieldCount:
		return m.OldCount(ctx)
	case productproperty.FieldSpuPrice:
		return m.OldSpuPrice(ctx)
	}
	return nil, fmt.Errorf("unknown ProductProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productproperty.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productproperty.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productproperty.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case productproperty.FieldSpuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuName(v)
		return nil
	case productproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case productproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case productproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case productproperty.FieldSpuPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ProductProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPropertyMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, productproperty.FieldDuration)
	}
	if m.addlength != nil {
		fields = append(fields, productproperty.FieldLength)
	}
	if m.addcount != nil {
		fields = append(fields, productproperty.FieldCount)
	}
	if m.addspu_price != nil {
		fields = append(fields, productproperty.FieldSpuPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productproperty.FieldDuration:
		return m.AddedDuration()
	case productproperty.FieldLength:
		return m.AddedLength()
	case productproperty.FieldCount:
		return m.AddedCount()
	case productproperty.FieldSpuPrice:
		return m.AddedSpuPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case productproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case productproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case productproperty.FieldSpuPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ProductProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productproperty.FieldType) {
		fields = append(fields, productproperty.FieldType)
	}
	if m.FieldCleared(productproperty.FieldSpuName) {
		fields = append(fields, productproperty.FieldSpuName)
	}
	if m.FieldCleared(productproperty.FieldDuration) {
		fields = append(fields, productproperty.FieldDuration)
	}
	if m.FieldCleared(productproperty.FieldLength) {
		fields = append(fields, productproperty.FieldLength)
	}
	if m.FieldCleared(productproperty.FieldCount) {
		fields = append(fields, productproperty.FieldCount)
	}
	if m.FieldCleared(productproperty.FieldSpuPrice) {
		fields = append(fields, productproperty.FieldSpuPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPropertyMutation) ClearField(name string) error {
	switch name {
	case productproperty.FieldType:
		m.ClearType()
		return nil
	case productproperty.FieldSpuName:
		m.ClearSpuName()
		return nil
	case productproperty.FieldDuration:
		m.ClearDuration()
		return nil
	case productproperty.FieldLength:
		m.ClearLength()
		return nil
	case productproperty.FieldCount:
		m.ClearCount()
		return nil
	case productproperty.FieldSpuPrice:
		m.ClearSpuPrice()
		return nil
	}
	return fmt.Errorf("unknown ProductProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPropertyMutation) ResetField(name string) error {
	switch name {
	case productproperty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productproperty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productproperty.FieldType:
		m.ResetType()
		return nil
	case productproperty.FieldSpuName:
		m.ResetSpuName()
		return nil
	case productproperty.FieldDuration:
		m.ResetDuration()
		return nil
	case productproperty.FieldLength:
		m.ResetLength()
		return nil
	case productproperty.FieldCount:
		m.ResetCount()
		return nil
	case productproperty.FieldSpuPrice:
		m.ResetSpuPrice()
		return nil
	}
	return fmt.Errorf("unknown ProductProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product != nil {
		edges = append(edges, productproperty.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productproperty.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct != nil {
		edges = append(edges, productproperty.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productproperty.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct {
		edges = append(edges, productproperty.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case productproperty.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPropertyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPropertyMutation) ResetEdge(name string) error {
	switch name {
	case productproperty.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductProperty edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	status         *int8
	addstatus      *int8
	name           *string
	value          *string
	default_router *string
	remark         *string
	order_no       *int32
	addorder_no    *int32
	clearedFields  map[string]struct{}
	menus          map[int64]struct{}
	removedmenus   map[int64]struct{}
	clearedmenus   bool
	done           bool
	oldValue       func(context.Context) (*Role, error)
	predicates     []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RoleMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RoleMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RoleMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RoleMutation) ResetValue() {
	m.value = nil
}

// SetDefaultRouter sets the "default_router" field.
func (m *RoleMutation) SetDefaultRouter(s string) {
	m.default_router = &s
}

// DefaultRouter returns the value of the "default_router" field in the mutation.
func (m *RoleMutation) DefaultRouter() (r string, exists bool) {
	v := m.default_router
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRouter returns the old "default_router" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDefaultRouter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRouter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRouter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRouter: %w", err)
	}
	return oldValue.DefaultRouter, nil
}

// ResetDefaultRouter resets all changes to the "default_router" field.
func (m *RoleMutation) ResetDefaultRouter() {
	m.default_router = nil
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
}

// SetOrderNo sets the "order_no" field.
func (m *RoleMutation) SetOrderNo(i int32) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RoleMutation) OrderNo() (r int32, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrderNo(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *RoleMutation) AddOrderNo(i int32) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *RoleMutation) AddedOrderNo() (r int32, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RoleMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.value != nil {
		fields = append(fields, role.FieldValue)
	}
	if m.default_router != nil {
		fields = append(fields, role.FieldDefaultRouter)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.order_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldValue:
		return m.Value()
	case role.FieldDefaultRouter:
		return m.DefaultRouter()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldOrderNo:
		return m.OrderNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldValue:
		return m.OldValue(ctx)
	case role.FieldDefaultRouter:
		return m.OldDefaultRouter(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldOrderNo:
		return m.OldOrderNo(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case role.FieldDefaultRouter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRouter(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldOrderNo:
		return m.AddedOrderNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldValue:
		m.ResetValue()
		return nil
	case role.FieldDefaultRouter:
		m.ResetDefaultRouter()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int64
	adduser_id    *int64
	token         *string
	source        *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int64) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TokenMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TokenMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetSource sets the "source" field.
func (m *TokenMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TokenMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TokenMutation) ResetSource() {
	m.source = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TokenMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TokenMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.source != nil {
		fields = append(fields, token.FieldSource)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldUserID:
		return m.UserID()
	case token.FieldToken:
		return m.Token()
	case token.FieldSource:
		return m.Source()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldSource:
		return m.OldSource(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, token.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldSource:
		m.ResetSource()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	status        *int8
	addstatus     *int8
	username      *string
	password      *string
	nickname      *string
	side_mode     *string
	base_color    *string
	active_color  *string
	role_id       *int64
	addrole_id    *int64
	mobile        *string
	email         *string
	wecom         *string
	avatar        *string
	clearedFields map[string]struct{}
	token         *int64
	clearedtoken  bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetSideMode sets the "side_mode" field.
func (m *UserMutation) SetSideMode(s string) {
	m.side_mode = &s
}

// SideMode returns the value of the "side_mode" field in the mutation.
func (m *UserMutation) SideMode() (r string, exists bool) {
	v := m.side_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSideMode returns the old "side_mode" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSideMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSideMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSideMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSideMode: %w", err)
	}
	return oldValue.SideMode, nil
}

// ClearSideMode clears the value of the "side_mode" field.
func (m *UserMutation) ClearSideMode() {
	m.side_mode = nil
	m.clearedFields[user.FieldSideMode] = struct{}{}
}

// SideModeCleared returns if the "side_mode" field was cleared in this mutation.
func (m *UserMutation) SideModeCleared() bool {
	_, ok := m.clearedFields[user.FieldSideMode]
	return ok
}

// ResetSideMode resets all changes to the "side_mode" field.
func (m *UserMutation) ResetSideMode() {
	m.side_mode = nil
	delete(m.clearedFields, user.FieldSideMode)
}

// SetBaseColor sets the "base_color" field.
func (m *UserMutation) SetBaseColor(s string) {
	m.base_color = &s
}

// BaseColor returns the value of the "base_color" field in the mutation.
func (m *UserMutation) BaseColor() (r string, exists bool) {
	v := m.base_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseColor returns the old "base_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBaseColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseColor: %w", err)
	}
	return oldValue.BaseColor, nil
}

// ClearBaseColor clears the value of the "base_color" field.
func (m *UserMutation) ClearBaseColor() {
	m.base_color = nil
	m.clearedFields[user.FieldBaseColor] = struct{}{}
}

// BaseColorCleared returns if the "base_color" field was cleared in this mutation.
func (m *UserMutation) BaseColorCleared() bool {
	_, ok := m.clearedFields[user.FieldBaseColor]
	return ok
}

// ResetBaseColor resets all changes to the "base_color" field.
func (m *UserMutation) ResetBaseColor() {
	m.base_color = nil
	delete(m.clearedFields, user.FieldBaseColor)
}

// SetActiveColor sets the "active_color" field.
func (m *UserMutation) SetActiveColor(s string) {
	m.active_color = &s
}

// ActiveColor returns the value of the "active_color" field in the mutation.
func (m *UserMutation) ActiveColor() (r string, exists bool) {
	v := m.active_color
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveColor returns the old "active_color" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActiveColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveColor: %w", err)
	}
	return oldValue.ActiveColor, nil
}

// ClearActiveColor clears the value of the "active_color" field.
func (m *UserMutation) ClearActiveColor() {
	m.active_color = nil
	m.clearedFields[user.FieldActiveColor] = struct{}{}
}

// ActiveColorCleared returns if the "active_color" field was cleared in this mutation.
func (m *UserMutation) ActiveColorCleared() bool {
	_, ok := m.clearedFields[user.FieldActiveColor]
	return ok
}

// ResetActiveColor resets all changes to the "active_color" field.
func (m *UserMutation) ResetActiveColor() {
	m.active_color = nil
	delete(m.clearedFields, user.FieldActiveColor)
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(i int64) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r int64, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *UserMutation) AddRoleID(i int64) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *UserMutation) AddedRoleID() (r int64, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, user.FieldRoleID)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *UserMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *UserMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *UserMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[user.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *UserMutation) WecomCleared() bool {
	_, ok := m.clearedFields[user.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *UserMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, user.FieldWecom)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetTokenID sets the "token" edge to the Token entity by id.
func (m *UserMutation) SetTokenID(id int64) {
	m.token = &id
}

// ClearToken clears the "token" edge to the Token entity.
func (m *UserMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the Token entity was cleared.
func (m *UserMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the "token" edge ID in the mutation.
func (m *UserMutation) TokenID() (id int64, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TokenIDs() (ids []int64) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *UserMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.side_mode != nil {
		fields = append(fields, user.FieldSideMode)
	}
	if m.base_color != nil {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.active_color != nil {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.role_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, user.FieldWecom)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldSideMode:
		return m.SideMode()
	case user.FieldBaseColor:
		return m.BaseColor()
	case user.FieldActiveColor:
		return m.ActiveColor()
	case user.FieldRoleID:
		return m.RoleID()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldEmail:
		return m.Email()
	case user.FieldWecom:
		return m.Wecom()
	case user.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldSideMode:
		return m.OldSideMode(ctx)
	case user.FieldBaseColor:
		return m.OldBaseColor(ctx)
	case user.FieldActiveColor:
		return m.OldActiveColor(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldWecom:
		return m.OldWecom(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldSideMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSideMode(v)
		return nil
	case user.FieldBaseColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseColor(v)
		return nil
	case user.FieldActiveColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveColor(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addrole_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldRoleID:
		return m.AddedRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldSideMode) {
		fields = append(fields, user.FieldSideMode)
	}
	if m.FieldCleared(user.FieldBaseColor) {
		fields = append(fields, user.FieldBaseColor)
	}
	if m.FieldCleared(user.FieldActiveColor) {
		fields = append(fields, user.FieldActiveColor)
	}
	if m.FieldCleared(user.FieldRoleID) {
		fields = append(fields, user.FieldRoleID)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldWecom) {
		fields = append(fields, user.FieldWecom)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldSideMode:
		m.ClearSideMode()
		return nil
	case user.FieldBaseColor:
		m.ClearBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ClearActiveColor()
		return nil
	case user.FieldRoleID:
		m.ClearRoleID()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldWecom:
		m.ClearWecom()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldSideMode:
		m.ResetSideMode()
		return nil
	case user.FieldBaseColor:
		m.ResetBaseColor()
		return nil
	case user.FieldActiveColor:
		m.ResetActiveColor()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldWecom:
		m.ResetWecom()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token != nil {
		edges = append(edges, user.EdgeToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken {
		edges = append(edges, user.EdgeToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeToken:
		return m.clearedtoken
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VenueMutation represents an operation that mutates the Venue nodes in the graph.
type VenueMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	address        *string
	address_detail *string
	latitude       *string
	longitude      *string
	mobile         *string
	pic            *string
	information    *string
	status         *int64
	addstatus      *int64
	clearedFields  map[string]struct{}
	places         map[int64]struct{}
	removedplaces  map[int64]struct{}
	clearedplaces  bool
	done           bool
	oldValue       func(context.Context) (*Venue, error)
	predicates     []predicate.Venue
}

var _ ent.Mutation = (*VenueMutation)(nil)

// venueOption allows management of the mutation configuration using functional options.
type venueOption func(*VenueMutation)

// newVenueMutation creates new mutation for the Venue entity.
func newVenueMutation(c config, op Op, opts ...venueOption) *VenueMutation {
	m := &VenueMutation{
		config:        c,
		op:            op,
		typ:           TypeVenue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueID sets the ID field of the mutation.
func withVenueID(id int64) venueOption {
	return func(m *VenueMutation) {
		var (
			err   error
			once  sync.Once
			value *Venue
		)
		m.oldValue = func(ctx context.Context) (*Venue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Venue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenue sets the old Venue of the mutation.
func withVenue(node *Venue) venueOption {
	return func(m *VenueMutation) {
		m.oldValue = func(context.Context) (*Venue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Venue entities.
func (m *VenueMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Venue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *VenueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenueMutation) ClearName() {
	m.name = nil
	m.clearedFields[venue.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenueMutation) NameCleared() bool {
	_, ok := m.clearedFields[venue.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenueMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venue.FieldName)
}

// SetAddress sets the "address" field.
func (m *VenueMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VenueMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VenueMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[venue.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VenueMutation) AddressCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VenueMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, venue.FieldAddress)
}

// SetAddressDetail sets the "address_detail" field.
func (m *VenueMutation) SetAddressDetail(s string) {
	m.address_detail = &s
}

// AddressDetail returns the value of the "address_detail" field in the mutation.
func (m *VenueMutation) AddressDetail() (r string, exists bool) {
	v := m.address_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "address_detail" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldAddressDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "address_detail" field.
func (m *VenueMutation) ClearAddressDetail() {
	m.address_detail = nil
	m.clearedFields[venue.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "address_detail" field was cleared in this mutation.
func (m *VenueMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[venue.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "address_detail" field.
func (m *VenueMutation) ResetAddressDetail() {
	m.address_detail = nil
	delete(m.clearedFields, venue.FieldAddressDetail)
}

// SetLatitude sets the "latitude" field.
func (m *VenueMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *VenueMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ClearLatitude clears the value of the "latitude" field.
func (m *VenueMutation) ClearLatitude() {
	m.latitude = nil
	m.clearedFields[venue.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *VenueMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *VenueMutation) ResetLatitude() {
	m.latitude = nil
	delete(m.clearedFields, venue.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *VenueMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *VenueMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ClearLongitude clears the value of the "longitude" field.
func (m *VenueMutation) ClearLongitude() {
	m.longitude = nil
	m.clearedFields[venue.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *VenueMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[venue.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *VenueMutation) ResetLongitude() {
	m.longitude = nil
	delete(m.clearedFields, venue.FieldLongitude)
}

// SetMobile sets the "mobile" field.
func (m *VenueMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *VenueMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *VenueMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[venue.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *VenueMutation) MobileCleared() bool {
	_, ok := m.clearedFields[venue.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *VenueMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, venue.FieldMobile)
}

// SetPic sets the "pic" field.
func (m *VenueMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenueMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenueMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venue.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenueMutation) PicCleared() bool {
	_, ok := m.clearedFields[venue.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenueMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venue.FieldPic)
}

// SetInformation sets the "information" field.
func (m *VenueMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the value of the "information" field in the mutation.
func (m *VenueMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old "information" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ClearInformation clears the value of the "information" field.
func (m *VenueMutation) ClearInformation() {
	m.information = nil
	m.clearedFields[venue.FieldInformation] = struct{}{}
}

// InformationCleared returns if the "information" field was cleared in this mutation.
func (m *VenueMutation) InformationCleared() bool {
	_, ok := m.clearedFields[venue.FieldInformation]
	return ok
}

// ResetInformation resets all changes to the "information" field.
func (m *VenueMutation) ResetInformation() {
	m.information = nil
	delete(m.clearedFields, venue.FieldInformation)
}

// SetStatus sets the "status" field.
func (m *VenueMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenueMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenueMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenueMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenueMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venue.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenueMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venue.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenueMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venue.FieldStatus)
}

// AddPlaceIDs adds the "places" edge to the VenuePlace entity by ids.
func (m *VenueMutation) AddPlaceIDs(ids ...int64) {
	if m.places == nil {
		m.places = make(map[int64]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the VenuePlace entity.
func (m *VenueMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the VenuePlace entity was cleared.
func (m *VenueMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the VenuePlace entity by IDs.
func (m *VenueMutation) RemovePlaceIDs(ids ...int64) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the VenuePlace entity.
func (m *VenueMutation) RemovedPlacesIDs() (ids []int64) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *VenueMutation) PlacesIDs() (ids []int64) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *VenueMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Where appends a list predicates to the VenueMutation builder.
func (m *VenueMutation) Where(ps ...predicate.Venue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Venue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Venue).
func (m *VenueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, venue.FieldName)
	}
	if m.address != nil {
		fields = append(fields, venue.FieldAddress)
	}
	if m.address_detail != nil {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.latitude != nil {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.mobile != nil {
		fields = append(fields, venue.FieldMobile)
	}
	if m.pic != nil {
		fields = append(fields, venue.FieldPic)
	}
	if m.information != nil {
		fields = append(fields, venue.FieldInformation)
	}
	if m.status != nil {
		fields = append(fields, venue.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldCreatedAt:
		return m.CreatedAt()
	case venue.FieldUpdatedAt:
		return m.UpdatedAt()
	case venue.FieldName:
		return m.Name()
	case venue.FieldAddress:
		return m.Address()
	case venue.FieldAddressDetail:
		return m.AddressDetail()
	case venue.FieldLatitude:
		return m.Latitude()
	case venue.FieldLongitude:
		return m.Longitude()
	case venue.FieldMobile:
		return m.Mobile()
	case venue.FieldPic:
		return m.Pic()
	case venue.FieldInformation:
		return m.Information()
	case venue.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venue.FieldName:
		return m.OldName(ctx)
	case venue.FieldAddress:
		return m.OldAddress(ctx)
	case venue.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case venue.FieldLatitude:
		return m.OldLatitude(ctx)
	case venue.FieldLongitude:
		return m.OldLongitude(ctx)
	case venue.FieldMobile:
		return m.OldMobile(ctx)
	case venue.FieldPic:
		return m.OldPic(ctx)
	case venue.FieldInformation:
		return m.OldInformation(ctx)
	case venue.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Venue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venue.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case venue.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case venue.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case venue.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case venue.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case venue.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venue.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, venue.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venue.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Venue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venue.FieldName) {
		fields = append(fields, venue.FieldName)
	}
	if m.FieldCleared(venue.FieldAddress) {
		fields = append(fields, venue.FieldAddress)
	}
	if m.FieldCleared(venue.FieldAddressDetail) {
		fields = append(fields, venue.FieldAddressDetail)
	}
	if m.FieldCleared(venue.FieldLatitude) {
		fields = append(fields, venue.FieldLatitude)
	}
	if m.FieldCleared(venue.FieldLongitude) {
		fields = append(fields, venue.FieldLongitude)
	}
	if m.FieldCleared(venue.FieldMobile) {
		fields = append(fields, venue.FieldMobile)
	}
	if m.FieldCleared(venue.FieldPic) {
		fields = append(fields, venue.FieldPic)
	}
	if m.FieldCleared(venue.FieldInformation) {
		fields = append(fields, venue.FieldInformation)
	}
	if m.FieldCleared(venue.FieldStatus) {
		fields = append(fields, venue.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueMutation) ClearField(name string) error {
	switch name {
	case venue.FieldName:
		m.ClearName()
		return nil
	case venue.FieldAddress:
		m.ClearAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ClearLatitude()
		return nil
	case venue.FieldLongitude:
		m.ClearLongitude()
		return nil
	case venue.FieldMobile:
		m.ClearMobile()
		return nil
	case venue.FieldPic:
		m.ClearPic()
		return nil
	case venue.FieldInformation:
		m.ClearInformation()
		return nil
	case venue.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Venue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueMutation) ResetField(name string) error {
	switch name {
	case venue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venue.FieldName:
		m.ResetName()
		return nil
	case venue.FieldAddress:
		m.ResetAddress()
		return nil
	case venue.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case venue.FieldLatitude:
		m.ResetLatitude()
		return nil
	case venue.FieldLongitude:
		m.ResetLongitude()
		return nil
	case venue.FieldMobile:
		m.ResetMobile()
		return nil
	case venue.FieldPic:
		m.ResetPic()
		return nil
	case venue.FieldInformation:
		m.ResetInformation()
		return nil
	case venue.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.places != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplaces != nil {
		edges = append(edges, venue.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplaces {
		edges = append(edges, venue.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueMutation) EdgeCleared(name string) bool {
	switch name {
	case venue.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Venue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueMutation) ResetEdge(name string) error {
	switch name {
	case venue.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown Venue edge %s", name)
}

// VenuePlaceMutation represents an operation that mutates the VenuePlace nodes in the graph.
type VenuePlaceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	pic           *string
	status        *int64
	addstatus     *int64
	clearedFields map[string]struct{}
	venue         *int64
	clearedvenue  bool
	done          bool
	oldValue      func(context.Context) (*VenuePlace, error)
	predicates    []predicate.VenuePlace
}

var _ ent.Mutation = (*VenuePlaceMutation)(nil)

// venueplaceOption allows management of the mutation configuration using functional options.
type venueplaceOption func(*VenuePlaceMutation)

// newVenuePlaceMutation creates new mutation for the VenuePlace entity.
func newVenuePlaceMutation(c config, op Op, opts ...venueplaceOption) *VenuePlaceMutation {
	m := &VenuePlaceMutation{
		config:        c,
		op:            op,
		typ:           TypeVenuePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenuePlaceID sets the ID field of the mutation.
func withVenuePlaceID(id int64) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *VenuePlace
		)
		m.oldValue = func(ctx context.Context) (*VenuePlace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VenuePlace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenuePlace sets the old VenuePlace of the mutation.
func withVenuePlace(node *VenuePlace) venueplaceOption {
	return func(m *VenuePlaceMutation) {
		m.oldValue = func(context.Context) (*VenuePlace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenuePlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenuePlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VenuePlace entities.
func (m *VenuePlaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenuePlaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenuePlaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VenuePlace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VenuePlaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenuePlaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenuePlaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenuePlaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenuePlaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenuePlaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *VenuePlaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenuePlaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VenuePlaceMutation) ClearName() {
	m.name = nil
	m.clearedFields[venueplace.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VenuePlaceMutation) NameCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VenuePlaceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, venueplace.FieldName)
}

// SetPic sets the "pic" field.
func (m *VenuePlaceMutation) SetPic(s string) {
	m.pic = &s
}

// Pic returns the value of the "pic" field in the mutation.
func (m *VenuePlaceMutation) Pic() (r string, exists bool) {
	v := m.pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPic returns the old "pic" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPic: %w", err)
	}
	return oldValue.Pic, nil
}

// ClearPic clears the value of the "pic" field.
func (m *VenuePlaceMutation) ClearPic() {
	m.pic = nil
	m.clearedFields[venueplace.FieldPic] = struct{}{}
}

// PicCleared returns if the "pic" field was cleared in this mutation.
func (m *VenuePlaceMutation) PicCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldPic]
	return ok
}

// ResetPic resets all changes to the "pic" field.
func (m *VenuePlaceMutation) ResetPic() {
	m.pic = nil
	delete(m.clearedFields, venueplace.FieldPic)
}

// SetVenueID sets the "venue_id" field.
func (m *VenuePlaceMutation) SetVenueID(i int64) {
	m.venue = &i
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenuePlaceMutation) VenueID() (r int64, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *VenuePlaceMutation) ClearVenueID() {
	m.venue = nil
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *VenuePlaceMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenuePlaceMutation) ResetVenueID() {
	m.venue = nil
	delete(m.clearedFields, venueplace.FieldVenueID)
}

// SetStatus sets the "status" field.
func (m *VenuePlaceMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VenuePlaceMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VenuePlace entity.
// If the VenuePlace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenuePlaceMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VenuePlaceMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VenuePlaceMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VenuePlaceMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[venueplace.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VenuePlaceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[venueplace.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VenuePlaceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, venueplace.FieldStatus)
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *VenuePlaceMutation) ClearVenue() {
	m.clearedvenue = true
	m.clearedFields[venueplace.FieldVenueID] = struct{}{}
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *VenuePlaceMutation) VenueCleared() bool {
	return m.VenueIDCleared() || m.clearedvenue
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *VenuePlaceMutation) VenueIDs() (ids []int64) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *VenuePlaceMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// Where appends a list predicates to the VenuePlaceMutation builder.
func (m *VenuePlaceMutation) Where(ps ...predicate.VenuePlace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenuePlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenuePlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VenuePlace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenuePlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenuePlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VenuePlace).
func (m *VenuePlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenuePlaceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, venueplace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venueplace.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, venueplace.FieldName)
	}
	if m.pic != nil {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.venue != nil {
		fields = append(fields, venueplace.FieldVenueID)
	}
	if m.status != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenuePlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.CreatedAt()
	case venueplace.FieldUpdatedAt:
		return m.UpdatedAt()
	case venueplace.FieldName:
		return m.Name()
	case venueplace.FieldPic:
		return m.Pic()
	case venueplace.FieldVenueID:
		return m.VenueID()
	case venueplace.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenuePlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venueplace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venueplace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venueplace.FieldName:
		return m.OldName(ctx)
	case venueplace.FieldPic:
		return m.OldPic(ctx)
	case venueplace.FieldVenueID:
		return m.OldVenueID(ctx)
	case venueplace.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown VenuePlace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venueplace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venueplace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venueplace.FieldPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPic(v)
		return nil
	case venueplace.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenuePlaceMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, venueplace.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenuePlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case venueplace.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenuePlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case venueplace.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown VenuePlace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenuePlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venueplace.FieldName) {
		fields = append(fields, venueplace.FieldName)
	}
	if m.FieldCleared(venueplace.FieldPic) {
		fields = append(fields, venueplace.FieldPic)
	}
	if m.FieldCleared(venueplace.FieldVenueID) {
		fields = append(fields, venueplace.FieldVenueID)
	}
	if m.FieldCleared(venueplace.FieldStatus) {
		fields = append(fields, venueplace.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenuePlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ClearField(name string) error {
	switch name {
	case venueplace.FieldName:
		m.ClearName()
		return nil
	case venueplace.FieldPic:
		m.ClearPic()
		return nil
	case venueplace.FieldVenueID:
		m.ClearVenueID()
		return nil
	case venueplace.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenuePlaceMutation) ResetField(name string) error {
	switch name {
	case venueplace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venueplace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venueplace.FieldName:
		m.ResetName()
		return nil
	case venueplace.FieldPic:
		m.ResetPic()
		return nil
	case venueplace.FieldVenueID:
		m.ResetVenueID()
		return nil
	case venueplace.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenuePlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.venue != nil {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenuePlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venueplace.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenuePlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenuePlaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenuePlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvenue {
		edges = append(edges, venueplace.EdgeVenue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenuePlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case venueplace.EdgeVenue:
		return m.clearedvenue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenuePlaceMutation) ClearEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenuePlaceMutation) ResetEdge(name string) error {
	switch name {
	case venueplace.EdgeVenue:
		m.ResetVenue()
		return nil
	}
	return fmt.Errorf("unknown VenuePlace edge %s", name)
}
